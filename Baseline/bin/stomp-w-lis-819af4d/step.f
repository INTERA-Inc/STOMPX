!----------------------Program-----------------------------------------!
!
      SUBROUTINE STEP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!----------------------Description-------------------------------------!
!
!     STOMP: Subsurface Transport Over Multiple Phases
!
!     This utility program reads STOMP input files and writes a
!     STOMP parameter file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 29 September 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TRNSPT
      USE SOLTN
      USE PORMED
      USE PLT_ATM
      USE PARM_BH
      USE LEAK_WELL
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE GEOM_BH
      USE GEO_MECH
      USE FILES
      USE DUAL_POR
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      LOGICAL FCHK
      EXTERNAL I_COUNT
!
!----------------------Executable Lines--------------------------------!
!
      ALLOCATE( SUB_LOG(1:32),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: SUB_LOG'
        CALL WRMSGP( INDX )
      ENDIF
      ISUB_LOG = 1
      SUB_LOG(1) = 'STEP'
!
!---  Initialize variables  ---
!
      IDMN(2) = 4
      IDMN(3) = 4
      IDMN(4) = 4
      IDMN(8) = 4
      IDMN(9) = 4
      IDMN(10) = 4
      SMALL = 1.D-20
      BIG = 1.D+20
      ZERO = 0.D+0
      THIRD = 1.D+0/3.D+0
      ONE = 1.D+0
      EPSL = 1.D-14
      GRAV = 9.81D+0
      GPI = 3.1415926536D+0
      TENTH = 1.D-1
      TOLN = LOG(1.D+1)
      ISMALL = -32000
      IBIG = 32000
      IEVPTRNS = 0
      NSFCA = 0
      NSFCN = 0
!
!---  No input file, program exited  ---
!
      INQUIRE( FILE='input', EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        WRITE(6,'(A)') 'ERROR: Nonexistent "input" file.'
        STOP
      ELSE
        IRD = 25
        OPEN(UNIT=IRD, FILE='input', STATUS='OLD', FORM='FORMATTED')
      ENDIF
!
!---  Write banner to screen  ---
!
      WRITE(ISC,'(A,//)')' Welcome to ...'
      WRITE(ISC,'(A,/)') '                       STEP'
      WRITE(ISC,'(A)')   ' A memory allocator for the STOMP ' //
     &  'simulator.  This'
      WRITE(ISC,'(A)')   ' routine, developed by the Pacific ' //
     &  'Northwest National'
      WRITE(ISC,'(A)')   ' Laboratory, reads a STOMP input ' //
     &  'file and determines memory'
      WRITE(ISC,'(A)')   ' requirements for an execution.  ' //
     &  'These requirements'
      WRITE(ISC,'(A)')   ' are either recorded to a file or ' //
     &  'used to dynamically'
      WRITE(ISC,'(A)')   ' allocate memory.'
      WRITE(ISC,'(A)')   ' For support:  Tel: 509.372.6070'
      WRITE(ISC,'(A,/)') '               E-mail:  mark.white@pnnl.gov'
      WRITE(ISC,'(A,/)') '                     ---  SCREEN ECHO  ---'
!
!---  Simulation Title Card Parameters  ---
!
  100 CONTINUE
  110 READ(IRD,'(A)', END=190) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 110
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'simulation').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Simulation Title Card'
        CALL WRMSGP( INDX )
        CALL RD_SIMU
        REWIND(IRD)
        GOTO 200
      ELSE
        GOTO 100
      ENDIF
  190 CONTINUE
      INDX = 18
      CHMSG = 'Missing Simulation Title Card'
      CALL WRMSGP( INDX )
!
!---  Solution Control Card Parameters  ---
!
  200 CONTINUE
  210 READ(IRD,'(A)', END=290) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 210
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'solution').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Solution Control Card'
        CALL WRMSGP( INDX )
        CALL RD_SOLU
        REWIND(IRD)
        GOTO 300
      ELSE
        GOTO 200
      ENDIF
  290 CONTINUE
      INDX = 18
      CHMSG = 'Missing Solution Control Card'
      CALL WRMSGP( INDX )
!
!---  Grid Card Parameters  ---
!
  300 CONTINUE
  310 READ(IRD,'(A)', END=390) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 310
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  INDEX(CHDUM(2:),'grid').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Grid Card'
        CALL WRMSGP( INDX )
        CALL RD_GRID
        REWIND(IRD)
        GOTO 400
      ELSE
        GOTO 300
      ENDIF
  390 CONTINUE
      INDX = 18
      CHMSG = 'Missing Grid Card'
      CALL WRMSGP( INDX )
!
!---  Rock/Soil Zonation Card Parameters  ---
!
  400 CONTINUE
  410 READ(IRD,'(A)', END=430) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 410
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  INDEX(CHDUM(2:),'rock/soil').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Rock/Soil Zonation Card'
        CALL WRMSGP( INDX )
        CALL RD_ROCK
        REWIND(IRD)
        GOTO 440
      ELSE
        GOTO 400
      ENDIF
  430 CONTINUE
      INDX = 18
      CHMSG = 'Missing Rock/Soil Zonation Card'
      CALL WRMSGP( INDX )
!
!---  Fracture/Fault Zonation Card Parameters  ---
!
  440 CONTINUE
  450 READ(IRD,'(A)', END=460) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 450
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  (INDEX(CHDUM(2:),'fracture').NE.0 .OR.
     &  INDEX(CHDUM(2:),'fault').NE.0) .AND.
     &  INDEX(CHDUM(2:),'zonation').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Fracture/Fault Zonation Card'
        CALL WRMSGP( INDX )
        CALL RD_ROCK_FRAC
        REWIND(IRD)
        GOTO 500
      ELSE
        GOTO 440
      ENDIF
  460 CONTINUE
      IF( ISLC(74).NE.0 ) THEN
        INDX = 18
        CHMSG = 'Missing Fracture/Fault Zonation Card'
        CALL WRMSGP( INDX )
        REWIND(IRD)
      ELSE
        INDX = 1
        CHMSG = 'Missing Fracture/Fault Zonation Card'
        CALL WRMSGP( INDX )
        REWIND(IRD)
      ENDIF
!
!---  Inactive Nodes Card Parameters  ---
!
  500 CONTINUE
  510 READ(IRD,'(A)', END=590) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 510
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  INDEX(CHDUM(2:),'inactive').NE.0 .AND.
     &  INDEX(CHDUM(2:),'triangle').EQ.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Inactive Nodes Card'
        CALL WRMSGP( INDX )
        CALL RD_INAC
        REWIND(IRD)
        GOTO 600
      ELSE
        GOTO 500
      ENDIF
  590 CONTINUE
      INDX = 1
      CHMSG = 'Missing Inactive Nodes Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Block Refinement Card Parameters  ---
!
  600 CONTINUE
  609 READ(IRD,'(A)', END=610) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 609
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  INDEX(CHDUM(2:),'block').NE.0 .AND.
     &  INDEX(CHDUM(2:),'refine').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Block Refinement Card'
        CALL WRMSGP( INDX )
        CALL RD_BR
        REWIND(IRD)
        GOTO 624
      ELSE
        GOTO 600
      ENDIF
  610 CONTINUE
      INDX = 1
      CHMSG = 'Missing Block Refinement Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for leaky well card --
!
  624 CONTINUE
  625 READ(IRD,'(A)', END= 626) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 625
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'leak').NE.0 .AND.
     &    INDEX(CHDUM(2:),'well').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Leaky Well Card'
        CALL WRMSGP( INDX )
        CALL RD_LW
        REWIND(IRD)
        GOTO 627
      ELSE
        GOTO 624
      ENDIF
 626  CONTINUE
      INDX = 1
      CHMSG = 'Missing Leaky Well Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 627  CONTINUE
!
!---  Search input file for fracture/fault geometry card --
!
  634 CONTINUE
  635 READ(IRD,'(A)', END= 636) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 635
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    (INDEX(CHDUM(2:),'fracture').NE.0 .OR.
     &    INDEX(CHDUM(2:),'fault').NE.0) .AND.
     &    INDEX(CHDUM(2:),'geometry').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Fracture/Fault Geometry Card'
        CALL WRMSGP( INDX )
        CALL RD_GEOM_FRC
        REWIND(IRD)
        GOTO 637
      ELSE
        GOTO 634
      ENDIF
  636 CONTINUE
      INDX = 1
      CHMSG = 'Missing Fracture/Fault Geometry Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
  637 CONTINUE
!
!---  Search input file for inactive fault/fracture triangle card --
!
  644 CONTINUE
  645 READ(IRD,'(A)', END= 646) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 645
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'inactive').NE.0 .AND.
     &    INDEX(CHDUM(2:),'triangle').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Inactive Fracture/Fault Triangle Card'
        CALL WRMSGP( INDX )
        CALL RD_INAC_FRC
        REWIND(IRD)
        GOTO 647
      ELSE
        GOTO 644
      ENDIF
  646 CONTINUE
      INDX = 1
      CHMSG = 'Missing Inactive Fracture/Fault Triangle Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
  647 CONTINUE
!
!---  Search input file for borehole card --
!
  654 CONTINUE
  655 READ(IRD,'(A)', END= 656) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 655
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'borehole').NE.0 .AND.
     &    INDEX(CHDUM(2:),'initial').EQ.0 ) THEN
        INDX = 1
        IRD_BH = 1
        CHMSG = 'Reading Borehole Card'
        CALL WRMSGP( INDX )
        CALL RD_BH
        REWIND(IRD)
        GOTO 657
      ELSE
        GOTO 654
      ENDIF
  656 CONTINUE
      IRD_BH = 0
      INDX = 1
      CHMSG = 'Missing Borehole Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
  657 CONTINUE
!
!---  Search input file for mechanical properties card  ---
!
  660 CONTINUE
  669 READ(IRD,'(A)', END=670) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 669
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'mechanical').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Mechanical Properties Card'
        CALL WRMSGP( INDX )
        REWIND(IRD)
        GOTO 700
      ELSE
        GOTO 660
      ENDIF
  670 CONTINUE
      INDX = 18
      CHMSG = 'Missing Mechanical Properties Card'
      CALL WRMSGP( INDX )
!
!---  Search input file for hydraulic properties card  ---
!
  700 CONTINUE
  709 READ(IRD,'(A)', END=710) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 709
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'hydraulic').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Hydraulic Properties Card'
        CALL WRMSGP( INDX )
        REWIND(IRD)
        GOTO 800
      ELSE
        GOTO 700
      ENDIF
  710 CONTINUE
      INDX = 18
      CHMSG = 'Missing Hydraulic Properties Card'
      CALL WRMSGP( INDX )
!
!---  Search input file for saturation function card  ---
!
  800 CONTINUE
  809 READ(IRD,'(A)', END=810) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 809
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'saturation').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Saturation Function Card'
        CALL WRMSGP( INDX )
        CALL RD_SP
        REWIND(IRD)
        GOTO 900
      ELSE
        GOTO 800
      ENDIF
  810 CONTINUE
      INDX = 18
      CHMSG = 'Missing Saturation Function Card'
      CALL WRMSGP( INDX )
!
!---  Search input file for aqueous relative permeability card  ---
!
  900 CONTINUE
      IF( LL.NE.0 ) THEN
  909   READ(IRD,'(A)', END=910) CHDUM
        IF( CHDUM(1:1).EQ.'#' ) GOTO 909
        CALL L_CASE( CHDUM )
        IF( CHDUM(1:1).EQ.'~' .AND.
     &    ( INDEX(CHDUM(2:),'aqueous').NE.0 .AND.
     &      INDEX(CHDUM(2:),'rel').NE.0 ) ) THEN
          INDX = 1
          CHMSG = 'Reading Aqueous Relative Permeability Card'
          CALL WRMSGP( INDX )
          CALL RD_LRP
          REWIND(IRD)
          GOTO 1100
        ELSEIF( CHDUM(1:1).EQ.'~' .AND.
     &    (INDEX(CHDUM(2:),'3').NE.0 .OR.
     &    INDEX(CHDUM(2:),'three').NE.0) .AND.
     &    INDEX(CHDUM(2:),'phase').NE.0 .AND.
     &    INDEX(CHDUM(2:),'relative').NE.0 .AND.
     &    INDEX(CHDUM(2:),'perm').NE.0 ) THEN
          INDX = 1
          CHMSG = 'Reading 3-Phase Relative Permeability Card for ' //
     &      'Aqueous Relative Permeability'
          CALL WRMSGP( INDX )
          REWIND(IRD)
          GOTO 1100
        ELSE
          GOTO 900
        ENDIF
  910   CONTINUE
        INDX = 18
        CHMSG = 'Missing Aqueous Relative Permeability Card'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search input file for gas relative permeability card  ---
!
 1100 CONTINUE
      IF( LG.NE.0 ) THEN
 1109   READ(IRD,'(A)', END=1110) CHDUM
        IF( CHDUM(1:1).EQ.'#' ) GOTO 1109
        CALL L_CASE( CHDUM )
        IF( CHDUM(1:1).EQ.'~' .AND.
     &    ( INDEX(CHDUM(2:),'gas').NE.0 .AND.
     &      INDEX(CHDUM(2:),'rel').NE.0  ) ) THEN
          INDX = 1
          CHMSG = 'Reading Gas Relative Permeability Card'
          CALL WRMSGP( INDX )
          CALL RD_GRP
          REWIND(IRD)
          GOTO 1200
        ELSEIF( CHDUM(1:1).EQ.'~' .AND.
     &    (INDEX(CHDUM(2:),'3').NE.0 .OR.
     &    INDEX(CHDUM(2:),'three').NE.0) .AND.
     &    INDEX(CHDUM(2:),'phase').NE.0 .AND.
     &    INDEX(CHDUM(2:),'relative').NE.0 .AND.
     &    INDEX(CHDUM(2:),'perm').NE.0 ) THEN
          INDX = 1
          CHMSG = 'Reading 3-Phase Relative Permeability Card for ' //
     &      'Gas Relative Permeability'
          CALL WRMSGP( INDX )
          REWIND(IRD)
          GOTO 1200
        ELSE
          GOTO 1109
        ENDIF
 1110   CONTINUE
        INDX = 18
        CHMSG = 'Missing Gas Relative Permeability Card'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search input file for a napl relative permeability card
!     for operational modes with nonaqueous liquid, but not
!     STOMP-SEQ  ---
!
 1200 CONTINUE
      IF( LN.NE.0 .AND. IOM.NE.34 ) THEN
 1209   READ(IRD,'(A)', END=1210) CHDUM
        IF( CHDUM(1:1).EQ.'#' ) GOTO 1209
        CALL L_CASE( CHDUM )
        IF( CHDUM(1:1).EQ.'~' .AND.
     &    (( INDEX(CHDUM(2:),'nonaqueous').NE.0 .AND.
     &      INDEX(CHDUM(2:),'rel').NE.0 ) .OR.
     &      ( INDEX(CHDUM(2:),'napl').NE.0 .AND.
     &      INDEX(CHDUM(2:),'rel').NE.0 ) .OR.
     &      ( INDEX(CHDUM(2:),'liquid').NE.0 .AND.
     &      INDEX(CHDUM(2:),'co2').NE.0 .AND.
     &      INDEX(CHDUM(2:),'rel').NE.0 ) ) ) THEN
          INDX = 1
          CHMSG = 'Reading NAPL Relative Permeability Card'
          CALL WRMSGP( INDX )
          CALL RD_NRP
          REWIND(IRD)
          GOTO 1300
        ELSEIF( CHDUM(1:1).EQ.'~' .AND.
     &    (INDEX(CHDUM(2:),'3').NE.0 .OR.
     &    INDEX(CHDUM(2:),'three').NE.0) .AND.
     &    INDEX(CHDUM(2:),'phase').NE.0 .AND.
     &    INDEX(CHDUM(2:),'relative').NE.0 .AND.
     &    INDEX(CHDUM(2:),'perm').NE.0 ) THEN
          INDX = 1
          CHMSG = 'Reading 3-Phase Relative Permeability Card for ' //
     &      'NAPL Relative Permeability'
          CALL WRMSGP( INDX )
          REWIND(IRD)
          GOTO 1300
        ELSE
          GOTO 1209
        ENDIF
 1210   CONTINUE
        INDX = 18
        CHMSG = 'Missing NAPL Relative Permeability Card'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search input file for NAPL components properties card  ---
!
 1300 CONTINUE
 1309 READ(IRD,'(A)', END=1310) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 1309
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'napl').NE.0 .AND.
     &    INDEX(CHDUM(2:),'comp').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading NAPL Components Properties Card'
        CALL WRMSGP( INDX )
        CALL RD_NCP
        REWIND(IRD)
        GOTO 1400
      ELSE
        GOTO 1309
      ENDIF
 1310 CONTINUE
      INDX = 1
      CHMSG = 'Missing NAPL Components Properties Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for gas component properties card  ---
!
 1400 CONTINUE
 1409 READ(IRD,'(A)', END=1410) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 1409
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'gas').NE.0 .AND.
     &    INDEX(CHDUM(2:),'component').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Gas Components Properties Card'
        CALL WRMSGP( INDX )
        CALL RD_GCP
        REWIND(IRD)
        GOTO 1500
      ELSE
        GOTO 1409
      ENDIF
 1410 CONTINUE
      INDX = 1
      CHMSG = 'Missing Gas Components Properties Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for geomechanics boundary condition card  ---
!
 1500 CONTINUE
 1509 READ(IRD,'(A)', END= 1510) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 1509
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'geomech').NE.0 .AND.
     &    INDEX(CHDUM(2:),'bound').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Geomechanics Boundary Conditions Card'
        CALL WRMSGP( INDX )
        CALL RD_GMBC
        REWIND(IRD)
        GOTO 1600
      ELSE
        GOTO 1509
      ENDIF
 1510 CONTINUE
      IF( LM.EQ.0 ) THEN
        REWIND(IRD)
      ELSE
        INDX = 18
        CHMSG = 'Missing Geomechanics Boundary Conditions Card'
        CALL WRMSGP( INDX )
        REWIND(IRD)
      ENDIF
!
!---  Search input file for petroleum components properties card  ---
!
 1600 CONTINUE
 1609 READ(IRD,'(A)', END=1610) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 1609
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'petrol').NE.0 .AND.
     &    INDEX(CHDUM(2:),'component').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Petroleum Components Properties Card'
        CALL WRMSGP( INDX )
        CALL RD_PCP
        REWIND(IRD)
        GOTO 1900
      ELSE
        GOTO 1609
      ENDIF
 1610 CONTINUE
      INDX = 1
      CHMSG = 'Missing Petroleum Components Properties Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for scaling card  ---
!
 1900 CONTINUE
      IF( ISLC(19).EQ.1 ) THEN
 1909   READ(IRD,'(A)', END=1910) CHDUM
        IF( CHDUM(1:1).EQ.'#' ) GOTO 1909
        CALL L_CASE( CHDUM )
        IF( CHDUM(1:1).EQ.'~' .AND.
     &      INDEX(CHDUM(2:),'scaling').NE.0 ) THEN
          INDX = 1
          CHMSG = 'Reading Scaling Factors Card'
          CALL WRMSGP( INDX )
          REWIND(IRD)
          GOTO 2000
        ELSE
          GOTO 1909
        ENDIF
 1910   CONTINUE
        INDX = 18
        CHMSG = 'Missing Scaling Factors Card'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search input file for solute/fluid interaction card --
!
 2000 CONTINUE
 2009 READ(IRD,'(A)', END=2010) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 2009
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'solute/fluid').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Solute/Fluid Interactions Card'
        CALL WRMSGP( INDX )
        CALL RD_TF
        REWIND(IRD)
        GOTO 2100
      ELSE
        GOTO 2000
      ENDIF
 2010 CONTINUE
      IF( LC.EQ.0 ) THEN
        REWIND(IRD)
      ELSE
        INDX = 18
        CHMSG = 'Missing Solute/Fluid Interactions Card'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search input file for solute/porous media interaction card --
!
 2100 CONTINUE
 2109 READ(IRD,'(A)', END=2110) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 2109
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'solute/porous').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Solute/Porous Media Interactions Card'
        CALL WRMSGP( INDX )
        REWIND(IRD)
        GOTO 3000
      ELSE
        GOTO 2100
      ENDIF
 2110 CONTINUE
      IF( LC.EQ.0 .AND. LR.EQ.0 ) THEN
        REWIND(IRD)
      ELSE
        INDX = 18
        CHMSG = 'Missing Solute/Porous Media Interactions Card'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search input file for surface cover card --
!
 3000 CONTINUE
 3010 READ(IRD,'(A)', END= 3020) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 3010
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  INDEX(CHDUM(2:),'cover').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Surface Cover Card'
        CALL WRMSGP( INDX )
        CALL RD_SFCOV
        IEVPTRNS = 1
        REWIND(IRD)
        GOTO 3030
      ELSE
        GOTO 3000
      ENDIF
 3020 CONTINUE
      INDX = 1
      CHMSG = 'Missing Surface Cover Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 3030 CONTINUE
!
!---  Search input file for plant card --
!
 3050 CONTINUE
 3060 READ(IRD,'(A)', END= 3070) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 3060
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'plant').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Plant Card'
        CALL WRMSGP( INDX )
        CALL RD_PLANT
        REWIND(IRD)
        GOTO 3080
      ELSE
        GOTO 3050
      ENDIF
 3070 CONTINUE
      IF( IEVPTRNS.EQ.0 ) THEN
        INDX = 1
        CHMSG = 'Missing Plant Card'
        CALL WRMSGP( INDX )
      ELSE
        INDX = 18
        CHMSG = 'Missing Plant Card'
        CALL WRMSGP( INDX )
      ENDIF
      REWIND(IRD)
 3080 CONTINUE
!
!---  Search input file for atmospheric conditions card --
!
 3100 CONTINUE
 3110 READ(IRD,'(A)', END= 3120) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 3110
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'atmospheric').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Atmospheric Conditions Card'
        CALL WRMSGP( INDX )
        CALL RD_ATMOS
        REWIND(IRD)
        GOTO 3130
      ELSE
        GOTO 3100
      ENDIF
 3120 CONTINUE
      IF( IEVPTRNS.EQ.0 ) THEN
        INDX = 1
        CHMSG = 'Missing Atmospheric Conditions Card'
        CALL WRMSGP( INDX )
      ELSE
        INDX = 18
        CHMSG = 'Missing Atmospheric Conditions Card'
        CALL WRMSGP( INDX )
      ENDIF
      REWIND(IRD)
 3130 CONTINUE
!
!---  Search input file for initial conditions card --
!
 4000 CONTINUE
 4009 READ(IRD,'(A)', END=4010) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4009
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'initial').NE.0 .AND.
     &    INDEX(CHDUM(2:),'boundary').EQ.0 .AND.
     &    INDEX(CHDUM(2:),'borehole').EQ.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Initial Conditions Card'
        CALL WRMSGP( INDX )
        CALL RD_IC
        REWIND(IRD)
        GOTO 4100
      ELSE
        GOTO 4000
      ENDIF
 4010 CONTINUE
      IF( IEO.EQ.2 ) THEN
        INDX = 1
        CHMSG = 'Missing Initial Conditions Card'
        CALL WRMSGP( INDX )
        REWIND(IRD)
      ELSE
        INDX = 18
        CHMSG = 'Missing Initial Conditions Card'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search input file for boundary conditions card --
!
 4100 CONTINUE
 4109 READ(IRD,'(A)', END=4110) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4109
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  INDEX(CHDUM(2:),'boundary').NE.0 .AND.
     &  INDEX(CHDUM(2:),'initial').EQ.0 .AND.
     &  INDEX(CHDUM(2:),'geomech').EQ.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Boundary Conditions Card'
        CALL WRMSGP( INDX )
        CALL RD_BC
        REWIND(IRD)
        GOTO 4200
      ELSE
        GOTO 4100
      ENDIF
 4110 CONTINUE
      INDX = 1
      CHMSG = 'Missing Boundary Conditions Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for source card --
!
 4200 CONTINUE
 4209 READ(IRD,'(A)', END= 4210) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4209
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'source').NE.0 .AND.
     &    INDEX(CHDUM(2:),'fracture').EQ.0 .AND.
     &    INDEX(CHDUM(2:),'fault').EQ.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Source Card'
        CALL WRMSGP( INDX )
        CALL RD_SR
        REWIND(IRD)
        GOTO 4300
      ELSE
        GOTO 4200
      ENDIF
 4210 CONTINUE
      INDX = 1
      CHMSG = 'Missing Source Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for output control card --
!
 4300 CONTINUE
 4309 READ(IRD,'(A)', END=4310) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4309
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'output').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Output Control Card'
        CALL WRMSGP( INDX )
        CALL RD_OU
        REWIND(IRD)
        GOTO 4400
      ELSE
        GOTO 4300
      ENDIF
 4310 CONTINUE
      INDX = 1
      CHMSG = 'Missing Output Control Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for surface flux card --
!
 4400 CONTINUE
 4409 READ(IRD,'(A)', END=4410) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4409
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'surface').NE.0 .AND.
     &    INDEX(CHDUM(2:),'cover').EQ.0 ) THEN
        CHMSG = 'Reading Surface Flux Card'
        CALL WRMSGP( INDX )
        CALL RD_SF
        REWIND(IRD)
        GOTO 4500
      ELSE
        GOTO 4400
      ENDIF
 4410 CONTINUE
      INDX = 1
      CHMSG = 'Missing Surface Flux Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
!
!---  Search input file for observed data card --
!
 4500 CONTINUE
      IF( ISLC(20).EQ.1 ) THEN
 4509   READ(IRD,'(A)', END=4510) CHDUM
        IF( CHDUM(1:1).EQ.'#' ) GOTO 4509
        CALL L_CASE( CHDUM )
        IF( CHDUM(1:1).EQ.'~' .AND.
     &      INDEX(CHDUM(2:),'observed').NE.0 ) THEN
          INDX = 1
          CHMSG = 'Reading Observed Data Card'
          CALL WRMSGP( INDX )
          CALL RD_OBDA
          REWIND(IRD)
          GOTO 4600
        ELSE
          GOTO 4500
        ENDIF
 4510   CONTINUE
        IF( ISLC(20).EQ.0 ) THEN
          REWIND(IRD)
        ELSE
          INDX = 18
          CHMSG = 'Missing Observed Data Card'
          CALL WRMSGP( INDX )
        ENDIF
!
!---  Search input file for UCode control Card --
!
 4600   CONTINUE
 4609   READ(IRD,'(A)', END=4610) CHDUM
        IF( CHDUM(1:1).EQ.'#' ) GOTO 4609
        CALL L_CASE( CHDUM )
        IF( CHDUM(1:1).EQ.'~' .AND.
     &      INDEX(CHDUM(2:),'ucode').NE.0 ) THEN
          INDX = 1
          CHMSG = 'Reading UCode Control Card'
          CALL WRMSGP( INDX )
          REWIND(IRD)
          GOTO 4620
        ELSE
          GOTO 4600
        ENDIF
 4610   CONTINUE
        IF( ISLC(20).EQ.0 ) THEN
          REWIND(IRD)
        ELSE
          INDX = 18
          CHMSG = 'Missing UCode Control Card'
          CALL WRMSGP( INDX )
        ENDIF
 4620   CONTINUE
      ENDIF
!
!---  Balance Card Parameters  ---
!
 4700 CONTINUE
 4710 READ(IRD,'(A)', END=4720) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4710
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'balance').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Balance Card'
        CALL WRMSGP( INDX )
        CALL RD_BALA
        REWIND(IRD)
        GOTO 4720
      ELSE
        GOTO 4700
      ENDIF
 4720 CONTINUE
      REWIND(IRD)
!
!---  SAC Remediate Card Parameters  ---
!
 4800 CONTINUE
 4810 READ(IRD,'(A)', END=4820) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4810
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'sac remediation').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading SAC Remediation Card'
        CALL WRMSGP( INDX )
        CALL RD_SREM
        REWIND(IRD)
        GOTO 4820
      ELSE
        GOTO 4800
      ENDIF
 4820 CONTINUE
      REWIND(IRD)
!
!---  SAC Release Card Parameters  ---
!
 4900 CONTINUE
 4910 READ(IRD,'(A)', END=4920) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 4910
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'sac release').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading SAC Release Card'
        CALL WRMSGP( INDX )
        CALL RD_SREL
        REWIND(IRD)
        GOTO 4920
      ELSE
        GOTO 4900
      ENDIF
 4920 CONTINUE
      REWIND(IRD)
!
!---  Search input file for reactive species link card --
!
 5200 CONTINUE
 5210 READ(IRD,'(A)', END= 5220) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5210
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  INDEX(CHDUM(2:),'link').NE.0 .AND.
     &  INDEX(CHDUM(2:),'specie').NE.0) THEN
        INDX = 1
        CHMSG = 'Reading Reactive Species Link Card'
        CALL WRMSGP( INDX )
        CALL RD_SPLK
        REWIND(IRD)
        GOTO 5230
      ELSE
        GOTO 5200
      ENDIF
 5220 CONTINUE
      INDX = 1
      CHMSG = 'Missing Reactive Species Link Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5230 CONTINUE
!
!---  Search input file for aqueous species card --
!
 5300 CONTINUE
 5310 READ(IRD,'(A)', END= 5320) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5310
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'aqueous').NE.0 .AND.
     &    INDEX(CHDUM(2:),'species').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Aqueous Species Card'
        CALL WRMSGP( INDX )
        CALL RD_AQSP
        REWIND(IRD)
        GOTO 5330
      ELSE
        GOTO 5300
      ENDIF
 5320 CONTINUE
      INDX = 1
      CHMSG = 'Missing Aqueous Species Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5330 CONTINUE
!
!---  Search input file for solid species card --
!
 5400 CONTINUE
 5410 READ(IRD,'(A)', END= 5420) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5410
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'solid').NE.0 .AND.
     &    INDEX(CHDUM(2:),'species').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Solid Species Card'
        CALL WRMSGP( INDX )
        CALL RD_SDSP
        REWIND(IRD)
        GOTO 5430
      ELSE
        GOTO 5400
      ENDIF
 5420 CONTINUE
      INDX = 1
      CHMSG = 'Missing Solid Species Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5430 CONTINUE
!
!---  Search input file for exchanged species card --
!
 5432 CONTINUE
 5434 READ(IRD,'(A)', END= 5436) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5434
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'exchange').NE.0 .AND.
     &    INDEX(CHDUM(2:),'species').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Exchanged Species Card'
        CALL WRMSGP( INDX )
        CALL RD_EXSP
        REWIND(IRD)
        GOTO 5438
      ELSE
        GOTO 5432
      ENDIF
 5436 CONTINUE
      INDX = 1
      CHMSG = 'Missing Exchanged Species Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5438 CONTINUE
!
!---  Search input file for gas species card --
!
 5450 CONTINUE
 5460 READ(IRD,'(A)', END= 5470) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5460
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'gas').NE.0 .AND.
     &    INDEX(CHDUM(2:),'species').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Gas Species Card'
        CALL WRMSGP( INDX )
        CALL RD_GSSP
        REWIND(IRD)
        GOTO 5480
      ELSE
        GOTO 5450
      ENDIF
 5470 CONTINUE
      INDX = 1
      CHMSG = 'Missing Gas Species Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5480 CONTINUE
!
!---  Search input file for equilibrium reactions card --
!
 5500 CONTINUE
 5510 READ(IRD,'(A)', END= 5520) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5510
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'equil').NE.0 .AND.
     &    INDEX(CHDUM(2:),'react').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Equilibrium Reactions Card'
        CALL WRMSGP( INDX )
        CALL RD_EQRC
        REWIND(IRD)
        GOTO 5530
      ELSE
        GOTO 5500
      ENDIF
 5520 CONTINUE
      INDX = 1
      CHMSG = 'Missing Equilibrium Reactions Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5530 CONTINUE
!
!---  Search input file for kinetic reactions card --
!
 5600 CONTINUE
 5610 READ(IRD,'(A)', END= 5620) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5610
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'kinetic').NE.0 .AND.
     &    INDEX(CHDUM(2:),'react').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Kinetic Reactions Card'
        CALL WRMSGP( INDX )
        CALL RD_KNRC
        REWIND(IRD)
        GOTO 5630
      ELSE
        GOTO 5600
      ENDIF
 5620 CONTINUE
      INDX = 1
      CHMSG = 'Missing Kinetic Reactions Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5630 CONTINUE
!
!---  Search input file for equilibrium equations card --
!
 5700 CONTINUE
 5710 READ(IRD,'(A)', END= 5720) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5710
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'equil').NE.0 .AND.
     &    INDEX(CHDUM(2:),'equat').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Equilibrium Equations Card'
        CALL WRMSGP( INDX )
        CALL RD_EQEQ
        REWIND(IRD)
        GOTO 5730
      ELSE
        GOTO 5700
      ENDIF
 5720 CONTINUE
      INDX = 1
      CHMSG = 'Missing Equilibrium Equations Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5730 CONTINUE
!
!---  Search input file for kinetic equations card --
!
 5800 CONTINUE
 5810 READ(IRD,'(A)', END= 5820) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5810
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'kinetic').NE.0 .AND.
     &    INDEX(CHDUM(2:),'equat').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Kinetic Equations Card'
        CALL WRMSGP( INDX )
        CALL RD_KNEQ
        REWIND(IRD)
        GOTO 5830
      ELSE
        GOTO 5800
      ENDIF
 5820 CONTINUE
      INDX = 1
      CHMSG = 'Missing Kinetic Equations Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5830 CONTINUE
!
!---  Search input file for conservation equations card --
!
 5900 CONTINUE
 5910 READ(IRD,'(A)', END= 5920) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 5910
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'conser').NE.0 .AND.
     &    INDEX(CHDUM(2:),'equat').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Conservation Equations Card'
        CALL WRMSGP( INDX )
        CALL RD_CNEQ
        REWIND(IRD)
        GOTO 5930
      ELSE
        GOTO 5900
      ENDIF
 5920 CONTINUE
      INDX = 1
      CHMSG = 'Missing Conservation Equations Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 5930 CONTINUE
!
!---  Search input file for STOMP-WO well card --
!
 6000 CONTINUE
 6010 READ(IRD,'(A)', END= 6020) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 6010
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'well').NE.0
     &    .AND. IOM.EQ.4 ) THEN
        INDX = 1
        CHMSG = 'Reading Well Card for STOMP-WO'
        CALL WRMSGP( INDX )
        CALL RD_WELL4
        REWIND(IRD)
        GOTO 6030
      ELSE
        GOTO 6000
      ENDIF
 6020 CONTINUE
      INDX = 1
      CHMSG = 'Missing STOMP-WO Well Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 6030 CONTINUE
!
!---  Search input file for coupled well or ground-loop-well card --
!
 6040 CONTINUE
 6050 READ(IRD,'(A)', END= 6060) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 6050
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &    (INDEX(CHDUM(2:),'coupled').NE.0 .OR.
     &    (INDEX(CHDUM(2:),'ground').NE.0 .AND.
     &    INDEX(CHDUM(2:),'loop').NE.0)) .AND.
     &    INDEX(CHDUM(2:),'well').NE.0 ) THEN
        IF( IRD_BH.EQ.1 ) THEN
          INDX = 18
          CHMSG = 'Both Ground-Loop Well and Borehole Cards'
          CALL WRMSGP( INDX )
        ENDIF
        INDX = 1
        IF( INDEX(CHDUM(2:),'coupled').NE.0 ) THEN
          CHMSG = 'Reading Coupled Well Card'
        ELSE
          CHMSG = 'Reading Ground-Loop Well Card'
        ENDIF
        CALL WRMSGP( INDX )
        CALL RD_CW
        REWIND(IRD)
        GOTO 6070
      ELSE
        GOTO 6040
      ENDIF
 6060 CONTINUE
      INDX = 1
      CHMSG = 'Missing Coupled Well Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 6070 CONTINUE
!
!---  Search input file for fracture/fault source card --
!
 6200 CONTINUE
 6210 READ(IRD,'(A)', END= 6220) CHDUM
      IF( CHDUM(1:1).EQ.'#' ) GOTO 6210
      CALL L_CASE( CHDUM )
      IF( CHDUM(1:1).EQ.'~' .AND.
     &  (INDEX(CHDUM(2:),'fracture').NE.0 .OR.
     &  INDEX(CHDUM(2:),'fault').NE.0) .AND.
     &  INDEX(CHDUM(2:),'source').NE.0 ) THEN
        INDX = 1
        CHMSG = 'Reading Fracture/Fault Source Card'
        CALL WRMSGP( INDX )
        CALL RD_SR_FRC
        REWIND(IRD)
        GOTO 6230
      ELSE
        GOTO 6200
      ENDIF
 6220 CONTINUE
      INDX = 1
      CHMSG = 'Missing Fracture/Fault Source Card'
      CALL WRMSGP( INDX )
      REWIND(IRD)
 6230 CONTINUE
!
!---  End of cards  ---
!
      CALL CONN_MAP
      CALL CONN_LST
      IF( NSFCN.GT.0 ) CALL CONN_MAP_SFC
!
!---  For geomechanics simulations create a finite-element node map  --
!
      IF( LM.EQ.1 ) CALL CONN_FEN
!
!---  Jacobian matrix half-band width with coupled well  ---
!
      IF( L_CW.GT.0 ) THEN
!
!---    Dual-porosity modeld for STOMP-EOR  ---
!
        IF( ISLC(11).EQ.1 ) THEN
          CALL JCB_CW_DP
!
!---    Coupled fractures/faults with coupled wells  ---
!
        ELSEIF( L_FRC.EQ.1 ) THEN
          CALL JCB_CW_FRC
        ELSE
          CALL JCB_CW
        ENDIF
!
!---  Jacobian matrix half-band width with surface cover ---
!
      ELSEIF( NSFCN.GT.0 ) THEN
        CALL JCB_SURF_COV
!
!---  Jacobian matrix half-band width without coupled well  ---
!
      ELSE
!
!---    Dual-porosity modeld for STOMP-EOR  ---
!
        IF( ISLC(11).EQ.1 ) THEN
          CALL JCB_NCW_DP
!
!---    Coupled fracture or boreholes  ---
!
        ELSEIF( L_FRC.EQ.1 .OR. L_BH.EQ.1 ) THEN
          CALL JCB_MFB
        ELSE
          CALL JCB_NCW
        ENDIF
      ENDIF
!
!---  For geomechanics simulations compute Jacobian matrix half-band
!     width  --
!
      IF( LM.EQ.1 ) CALL JCB_GM
      LWN_CW = MAX( LWN_CW,1 )
      LWF_CW = MAX( LWF_CW,1 )
      LBN_BH = MAX( LBN_BH,1 )
      LUK_CW = MAX( LUK_CW,1 )
!
!---  Deallocate memory for the scaling group index array  ---
!
      IF( ALLOCATED(ISCALE) ) THEN
        DEALLOCATE( ISCALE,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ISCALE'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the rock/soil zonation index array  ---
!
      IF( ALLOCATED(IZ) ) THEN
        DEALLOCATE( IZ,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IZ'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the Jacobian matrix pointer array  ---
!
      IF( ALLOCATED(IM) ) THEN
        DEALLOCATE( IM,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the geomechanics Jacobian matrix pointer 
!     array  ---
!
      IF( ALLOCATED(IM_GM) ) THEN
        DEALLOCATE( IM_GM,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM_GM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the matrix dual-porosity Jacobian matrix 
!     pointer array  ---
!
      IF( ALLOCATED(IM_M) ) THEN
        DEALLOCATE( IM_M,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM_M'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the inactive nodes array  ---
!
      IF( ALLOCATED(IXP) ) THEN
        DEALLOCATE( IXP,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IXP'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the node connection map  ---
!
      IF( ALLOCATED(ICM) ) THEN
        DEALLOCATE( ICM,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ICM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the i-index node array  ---
!
      IF( ALLOCATED(ID) ) THEN
        DEALLOCATE( ID,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ID'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the j-index node array  ---
!
      IF( ALLOCATED(JD) ) THEN
        DEALLOCATE( JD,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: JD'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the k-index node array  ---
!
      IF( ALLOCATED(KD) ) THEN
        DEALLOCATE( KD,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: KD'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the node index array  ---
!
      IF( ALLOCATED(ND) ) THEN
        DEALLOCATE( ND,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ND'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the x-dimension array  ---
!
      IF( ALLOCATED(XE) ) THEN
        DEALLOCATE( XE,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XE'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the y-dimension array  ---
!
      IF( ALLOCATED(YE) ) THEN
        DEALLOCATE( YE,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YE'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the z-dimension array  ---
!
      IF( ALLOCATED(ZE) ) THEN
        DEALLOCATE( ZE,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZE'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the xp-dimension array  ---
!
      IF( ALLOCATED(XP) ) THEN
        DEALLOCATE( XP,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XP'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the yp-dimension array  ---
!
      IF( ALLOCATED(YP) ) THEN
        DEALLOCATE( YP,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YP'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the zp-dimension array  ---
!
      IF( ALLOCATED(ZP) ) THEN
        DEALLOCATE( ZP,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZP'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole type array  ---
!
      IF( ALLOCATED(IT_BH) ) THEN
        DEALLOCATE( IT_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IT_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole well-interval
!     index array  ---
!
      IF( ALLOCATED(ID_BH) ) THEN
        DEALLOCATE( ID_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ID_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for borehole node to borehole node connection
!     pointer array
!
      IF( ALLOCATED(IPB_BH) ) THEN
        DEALLOCATE( IPB_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IPB_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for borehole node to borehole node connection
!     map  ---
!
      IF( ALLOCATED(IBCM_BH) ) THEN
        DEALLOCATE( IBCM_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IBCM_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole well-node index array  ---
!
      IF( ALLOCATED(IBN_BH) ) THEN
        DEALLOCATE( IBN_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IBN_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole x-transition 
!     point array  ---
!
      IF( ALLOCATED(XTP_BH) ) THEN
        DEALLOCATE( XTP_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XTP_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole y-transition 
!     point array  ---
!
      IF( ALLOCATED(YTP_BH) ) THEN
        DEALLOCATE( YTP_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YTP_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole z-transition 
!     point array  ---
!
      IF( ALLOCATED(ZTP_BH) ) THEN
        DEALLOCATE( ZTP_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZTP_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole x-projection array  ---
!
      IF( ALLOCATED(XP_BH) ) THEN
        DEALLOCATE( XP_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XP_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole y-projection array  ---
!
      IF( ALLOCATED(YP_BH) ) THEN
        DEALLOCATE( YP_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YP_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the borehole z-projection array  ---
!
      IF( ALLOCATED(ZP_BH) ) THEN
        DEALLOCATE( ZP_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZP_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for triangle of borehole-fracture/fault 
!     connection assuming fewer connections than borehole nodes   ---
!
      IF( ALLOCATED(IBHT_FRC) ) THEN
        DEALLOCATE( IBHT_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IBHT_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for borehole node of borehole-fracture/fault 
!     connection assuming fewer connections than borehole nodes   ---
!
      IF( ALLOCATED(IBHN_FRC) ) THEN
        DEALLOCATE( IBHN_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IBHN_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well well-interval
!     index array  ---
!
      IF( ALLOCATED(ID_CW) ) THEN
        DEALLOCATE( ID_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ID_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well well-node index array  ---
!
      IF( ALLOCATED(IWN_CW) ) THEN
        DEALLOCATE( IWN_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IWN_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the index array for field nodes that
!     contain coupled-well nodes ---
!
      IF( ALLOCATED(IWF_CW) ) THEN
        DEALLOCATE( IWF_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IWF_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well Jacobian matrix array  ---
!
      IF( ALLOCATED(JM_CW) ) THEN
        DEALLOCATE( JM_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: JM_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well x-transition 
!     point array  ---
!
      IF( ALLOCATED(XTP_CW) ) THEN
        DEALLOCATE( XTP_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XTP_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well y-transition 
!     point array  ---
!
      IF( ALLOCATED(YTP_CW) ) THEN
        DEALLOCATE( YTP_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YTP_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well z-transition 
!     point array  ---
!
      IF( ALLOCATED(ZTP_CW) ) THEN
        DEALLOCATE( ZTP_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZTP_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well x-projection array  ---
!
      IF( ALLOCATED(XP_CW) ) THEN
        DEALLOCATE( XP_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XP_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well y-projection array  ---
!
      IF( ALLOCATED(YP_CW) ) THEN
        DEALLOCATE( YP_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YP_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the coupled-well z-projection array  ---
!
      IF( ALLOCATED(ZP_CW) ) THEN
        DEALLOCATE( ZP_CW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZP_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well field-node index array  ---
!
      IF( ALLOCATED(ND_LW) ) THEN
        DEALLOCATE( ND_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ND_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well well-interval
!     index array  ---
!
      IF( ALLOCATED(ID_LW) ) THEN
        DEALLOCATE( ID_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ID_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well well-node index array  ---
!
      IF( ALLOCATED(NF_LW) ) THEN
        DEALLOCATE( NF_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: NF_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the index array for field nodes that
!     contain leaky well nodes ---
!
      IF( ALLOCATED(IWF_LW) ) THEN
        DEALLOCATE( IWF_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IWF_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well x-transition 
!     point array  ---
!
      IF( ALLOCATED(XTP_LW) ) THEN
        DEALLOCATE( XTP_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XTP_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well y-transition 
!     point array  ---
!
      IF( ALLOCATED(YTP_LW) ) THEN
        DEALLOCATE( YTP_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YTP_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well z-transition 
!     point array  ---
!
      IF( ALLOCATED(PAR_LW) ) THEN
        DEALLOCATE( PAR_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: PAR_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well z-transition 
!     point array  ---
!
      IF( ALLOCATED(ZTP_LW) ) THEN
        DEALLOCATE( ZTP_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZTP_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well x-projection array  ---
!
      IF( ALLOCATED(XP_LW) ) THEN
        DEALLOCATE( XP_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XP_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well y-projection array  ---
!
      IF( ALLOCATED(YP_LW) ) THEN
        DEALLOCATE( YP_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YP_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the leaky well z-projection array  ---
!
      IF( ALLOCATED(ZP_LW) ) THEN
        DEALLOCATE( ZP_LW,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZP_LW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the internal boundary surface array  ---
!
      IF( ALLOCATED(INBS) ) THEN
        DEALLOCATE( INBS,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: INBS'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the x vertices array  ---
!
      IF( ALLOCATED(XE) ) THEN
        DEALLOCATE( XE,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XE'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the y vertices array  ---
!
      IF( ALLOCATED(YE) ) THEN
        DEALLOCATE( YE,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YE'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the z vertices array  ---
!
      IF( ALLOCATED(ZE) ) THEN
        DEALLOCATE( ZE,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZE'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the grid refinement pointer array  ---
!
      IF( ALLOCATED(IBR) ) THEN
        DEALLOCATE( IBR,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IBR'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the plant parameters array  ---
!
      IF( ALLOCATED(PARMS_P) ) THEN
        DEALLOCATE( PARMS_P,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: PARMS_P'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for surface cover connection map array  ---
!
      IF( ALLOCATED(ICM_SFC) ) THEN
        DEALLOCATE( ICM_SFC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ICM_SFC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the finite-element node map  ---
!
      IF( ALLOCATED(ND_GM) ) THEN
        DEALLOCATE( ND_GM,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ND_GM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the inverse finite-element node map  ---
!
      IF( ALLOCATED(NE_GM) ) THEN
        DEALLOCATE( NE_GM,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: NE_GM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the fracture triangle zonation indices  ---
!
      IF( ALLOCATED(IZ_FRC) ) THEN
        DEALLOCATE( IZ_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IZ_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the number of triangles in a fracture
!     /fault  ---
!
      IF( ALLOCATED(NTP_FRC) ) THEN
        DEALLOCATE( NTP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: NTP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the fracture  ---
!
      IF( ALLOCATED(INCM_FRC) ) THEN
        DEALLOCATE( INCM_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: INCM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the fracture  ---
!
      IF( ALLOCATED(ITCM_FRC) ) THEN
        DEALLOCATE( ITCM_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ITCM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for fracture/fault vertices  ---
!
      IF( ALLOCATED(XE_FRC) ) THEN
        DEALLOCATE( XE_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XE_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(YE_FRC) ) THEN
        DEALLOCATE( YE_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YE_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(ZE_FRC) ) THEN
        DEALLOCATE( ZE_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZE_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(XP_FRC) ) THEN
        DEALLOCATE( XP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(YP_FRC) ) THEN
        DEALLOCATE( YP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(ZP_FRC) ) THEN
        DEALLOCATE( ZP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(AF_FRC) ) THEN
        DEALLOCATE( AF_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: AF_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for fracture triangle to grid cell pointer  ---
!
      IF( ALLOCATED(IP_FRC) ) THEN
        DEALLOCATE( IP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for resident grid cell number of fracture
!     /fault triangle vertex  ---
!
      IF( ALLOCATED(ND_FRC) ) THEN
        DEALLOCATE( ND_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ND_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for fracture/fault triangle to 
!     grid cell pointer  ---
!
      IF( ALLOCATED(IPN_FRC) ) THEN
        DEALLOCATE( IPN_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IPN_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for index for inactive fracture/fault 
!     triangles  ---
!
      IF( ALLOCATED(IXP_FRC) ) THEN
        DEALLOCATE( IXP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IXP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for fracture  ---
!
      IF( ALLOCATED(IPF_FRC) ) THEN
        DEALLOCATE( IPF_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IPF_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for solute aqueous diffusion option  ---
!
      IF( ALLOCATED(IEDL) ) THEN
        DEALLOCATE( IEDL,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IEDL'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Write "parameters" file  ---
!
      CALL CGLBP
!
!---  Close input and allocation file  ---
!
      CLOSE( UNIT=IRD )
!
!---  End of STEP program  ---
!
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CGLBP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Computed global parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNNL, 22 May 2003.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CGLBP'
!
!---  Computed Parameters  ---
!
      LANW = LAN+(LWELL*LFZ*LNW)+(LSPILL*LFXY)
      LPH = LL+LG+LN+LHYD
      LMPH = LL+LG+LN
      LCMP = LD+LL+LN+LS
!
!---  Banded solver  ---
!
      IF( LBD.EQ.1 ) THEN
!
!---    Half band with not computed via Jacobian routine  ---
!
        IF( LHBW.EQ.1 ) THEN
          LHBW = LUK*LMNP + LUK - 1
        ENDIF
!
!---  Non-banded solver  ---
!
      ELSE
        LHBW = 1
      ENDIF      
!     
!---  Linear system solver variable parameters  ---
!
      LSTCX = MAX( LSTC,7 )
      LJA = MAX( LANW*LUK + L_CW*LN_CW + L_SFC*5*LSFCN + L_DP*LANW*LUK,
     &  LM*LFEN*3 + (LT_FRC-LXP_FRC)*LUK + LBN_BH*LUK )
      LJA = (LSP+LIS+LPT)*LJA + LBD
      LJB = MAX( LSTC*LANW*LUK*LUK + 4*(LT_FRC-LXP_FRC)*LUK*LUK
     &   + LNC_FRC*LUK*LUK + 4*LBN_BH*LUK*LUK + L_DP*LANW*LUK*LUK*3
     &   + L_CW*(LN_CW + 2*LWF_CW*LUK),LM*LFEN*3 )
      LJB = MAX( LJB,LJO )
      LJB = (LSP+LIS+LPT)*LJB
     &   + L_SFC*(LUK_SFC*LSFCN) + LBD
      LJO = LJB
      LJO_GM = (LSP+LIS+LPT)*LJO_GM + LBD
      LJB = MAX( LJB,LJO_GM)
      LJC = (LSP+LIS+LPT)*(LANW*LUK + (LT_FRC-LXP_FRC)*LUK + LBN_BH*LUK 
     &  + L_CW*LN_CW + L_SFC*5*LSFCN + L_DP*LANW*LUK + 1) + LBD
      LJC_GM = (LSP+LIS+LPT)*((LFEN*3) + 1) + LBD
      LJD = LBD*(3*LHBW+1) + LSP + LPT + LIS
      LJE = LBD*(LANW*LUK + (LT_FRC-LXP_FRC)*LUK + LBN_BH*LUK  
     &  + L_CW*LN_CW + L_SFC*5*LSFCN + L_DP*LANW*LUK) + LSP + LPT + LIS
      LJE = MAX( LBD*LFEN*3,LJE )
      LJF = LANW*LUK + (LT_FRC-LXP_FRC)*LUK + LBN_BH*LUK + L_CW*LN_CW 
     &  + L_SFC*5*LSFCN + L_DP*LANW*LUK
      LJF = MAX( LFEN*3,LJF )
      LJG = (LSP+LIS+LPT)*((LAN+(LWELL*LFZ*LNW)+(LSPILL*LFXY))*LUK + 
     &  L_CW*LN_CW + L_DP*LANW*LUK) + LBD
      LJG_FRC = (LSP+LIS)*((LT_FRC-LXP_FRC)*LUK) + LBD
      LJG_MCF = (LSP+LIS)*(LNC_FRC*LUK) + LBD
      LJG_FCM = (LSP+LIS)*(LNC_FRC*LUK) + LBD
      LJG_FCB = (LSP+LIS)*(LBC_FRC*LUK) + LBD
      LJG_BCF = (LSP+LIS)*(LBC_FRC*LUK) + LBD
      LJG_BH = (LSP+LIS)*(LBN_BH*LUK) + LBD
      LJG_MCB = (LSP+LIS)*(LBN_BH*LUK) + LBD
      LJG_BCM = (LSP+LIS)*(LBN_BH*LUK) + LBD
      LJG_BCF = (LSP+LIS)*(LBC_FRC*LUK) + LBD
      LJG_GM = (LSP+LIS)*(27) + LBD
      LJH = (LSP+LIS+LPT)*(LSTCX*LUK + 3*LUK*LWELL + L_DP*LUK)
     &  + LBD
      LJH_FRC = (LSP+LIS)*((LTC_FRC+1)*LUK) + LBD
      LJH_MCF = (LSP+LIS)*LUK + LBD
      LJH_FCM = (LSP+LIS)*LUK + LBD
      LJH_FCB = (LSP+LIS)*LUK + LBD
      LJH_BCF = (LSP+LIS)*LUK + LBD
      LJH_BH = (LSP+LIS)*(3*LUK) + LBD
      LJH_MCB = (LSP+LIS)*LUK + LBD
      LJH_BCM = (LSP+LIS)*LUK + LBD
      LJH_BCF = (LSP+LIS)*LUK + LBD
      LJH_GM = (LSP+LIS)*(LFEN) + LBD
      LJI = LBD*(LANW*LUK + (LT_FRC-LXP_FRC)*LUK
     &  + LBN_BH*LUK + L_CW*LN_CW  
     &  + L_SFC*5*LSFCN + L_DP*LANW*LUK) + LSP + LPT*LJF + LIS*LJF
      LJI = MAX( LBD*LFEN*3,LJI) 
      LJJ = LBD*(LANW*LUK + (LT_FRC-LXP_FRC)*LUK
     &  + LBN_BH*LUK + L_CW*LN_CW 
     &  + L_SFC*5*LSFCN + L_DP*LANW*LUK) + LSP + LPT + LIS
      LJJ = MAX( LBD*LFEN*3,LJJ)
      LJK = (LSP+LIS+LPT)*LANW + LBD
      LJK_FRC = (LSP+LIS+LPT)*(LT_FRC-LXP_FRC) + LBD
      LJK_MCF = (LSP+LIS+LPT)*LNC_FRC + LBD
      LJK_FCM = (LSP+LIS+LPT)*LNC_FRC + LBD
      LJK_FCB = (LSP+LIS+LPT)*LBC_FRC + LBD
      LJK_BCF = (LSP+LIS+LPT)*LBC_FRC + LBD
      LJK_BH = (LSP+LIS+LPT)*LBN_BH + LBD
      LJK_MCB = (LSP+LIS+LPT)*LBN_BH + LBD
      LJK_BCM = (LSP+LIS+LPT)*LBN_BH + LBD
      LJK_BCF = (LSP+LIS+LPT)*LBC_FRC + LBD
      LJL = LSTCX
      LJL_FRC = (LTC_FRC+1)
      LJL_MCF = 1
      LJL_FCM = 1
      LJL_FCB = 1
      LJL_BCF = 1
      LJL_BH = 3
      LJL_MCB = 1
      LJL_BCM = 1
      LJMX = (LSP+LIS+LPT)*((LSTC*LANW) + 4*(LT_FRC-LXP_FRC) + LNC_FRC +
     &  4*LBN_BH) + LBD
      LJM = MAX( LJM,LJMX )
      LJN = (LSP+LIS+LPT)*(LANW+(LT_FRC-LXP_FRC)+LBN_BH+1) + LBD
      LSU = 2
      LSV = (LUK+2)
      LSFV = (2*LUK+1)
!
!---  Field Variable Parameters  ---
!
      IF( LT.EQ.0 ) THEN
        LFDT = 1
      ELSE
        LFDT = LFD
      ENDIF
      IF( LL.EQ.0 ) THEN
        LFDL = 1
      ELSE
        LFDL = LFD
      ENDIF
      IF( LG.EQ.0 ) THEN
        LFDG = 1
      ELSE
        LFDG = LFD
      ENDIF
      IF( LN.EQ.0 ) THEN
        LFDN = 1
      ELSE
        LFDN = LFD
      ENDIF
      IF( LN2.EQ.0 ) THEN
        LFDN2 = 1
      ELSE
        LFDN2 = LFD
      ENDIF
      LFDNH = LFD**((LN+LHYD)-(LN*LHYD))
      LFDC = LFD**LC
      LFDM = LFD**LM
      LFDR = LFD**LR
      LFDCR = LFD**((LC+LR)-(LC*LR))
      LFDRL = LFD**(LR*LL)
      LFDRG = LFD**(LR*LG)
      LFDRN = LFD**(LR*LN)
      LFDI = LFD**((LFW+LHYD)-(LFW*LHYD))
      IF( LS.EQ.1 .OR. LALC.EQ.1 ) THEN
        LFDS = LFD
      ELSE
        LFDS = 1
      ENDIF
      LFDD = LFD**((LD+LDCO2)-(LD*LDCO2))
      LFDA = LFD**LN
      LFDH = LFD**LHYD
      LFDGC = LFD**LGC
!
!---  Surface Variable Parameters  ---
!
      LSX = LSX + (LFX+1)*LFYZ + LSRX + (L_LW*(2*LWN_LW))
      LSY = LSY + LFX*(LFY+1)*LFZ + LSRY + (L_LW*(2*LWN_LW))
      LSZ = LSZ + LFXY*(LFZ+1) + LSRZ + (L_LW*(LWN_LW+1))
      LSXT = LSX**LT
      LSXL = LSX**LL
      LSXG = LSX**LG
      LSXN = LSX**((LN+LHYD)-(LN*LHYD))
      LSXN2 = LSX**LN2
      LSXC = LSX**((LC+LR)-(LC*LR))
      LSXS = LSX**((LS+LALC)-(LS*LALC))
      LSXGC = LSX**(LGC*LG)
      LSXLC = LSX**(LGC*LL)
      LSXNC = LSX**(LGC*LN)
      LSYT = LSY**LT
      LSYL = LSY**LL
      LSYG = LSY**LG
      LSYN = LSY**((LN+LHYD)-(LN*LHYD))
      LSYN2 = LSY**LN2
      LSYC = LSY**((LC+LR)-(LC*LR))
      LSYS = LSY**((LS+LALC)-(LS*LALC))
      LSYLC = LSY**(LGC*LG)
      LSYGC = LSY**(LGC*LL)
      LSYNC = LSY**(LGC*LN)
      LSZT = LSZ**LT
      LSZL = LSZ**LL
      LSZG = LSZ**LG
      LSZN = LSZ**((LN+LHYD)-(LN*LHYD))
      LSZN2 = LSZ**LN2
      LSZC = LSZ**((LC+LR)-(LC*LR))
      LSZS = LSZ**((LS+LALC)-(LS*LALC))
      LSZGC = LSZ**(LGC*LG)
      LSZLC = LSZ**(LGC*LL)
      LSZNC = LSZ**(LGC*LN)
!
!---  Rock/Soil Variable Parameters  ---
!
      LRCT = LRC**LT
      LRCL = LRC**LL
      LRCG = LRC**LG
      LRCN = LRC**LN
      LRCS = LRC**((LS+LALC)-(LS*LALC))
!
!---  Boundary Condition Parameters  ---
!
      LBCT = LBC**LT
      LBCL = LBC**LL
      LBCG = LBC**LG
      LBCN = LBC**LN
      LBCN2 = LBC**LN2
      LBCC = LBC**((LC+LR)-(LC*LR))
      LBCI = LBC**((LFW+LHYD)-(LFW*LHYD))
      LBCS = LBC**((LS+LALC)-(LS*LALC))
      LBCA = LBC**LN
      IF( IOM.EQ.32 .OR. IOM.EQ.33 ) THEN
        LBCU = 12
        LBCV = LBCU + (LSOLU*LC) + (LSPBC*LR)
      ELSEIF( IOM.EQ.34 ) THEN
        LBCU = 12
        LBCV = LBCU + (LSOLU*LC) + (LSPBC*LR)
      ELSEIF( IOM.EQ.36 .OR. IOM.EQ.37 .OR. IOM.EQ.38 ) THEN
        LBCU = 13
        LBCV = LBCU + (LSOLU*LC) + (LSPBC*LR)
      ELSEIF( IOM.EQ.43 ) THEN
        LBCU = 10 + 2*LNGC
        LBCV = LBCU + (LSOLU*LC) + (LSPBC*LR)
      ELSEIF( IOM.EQ.50 ) THEN
        LBCU = 11
        LBCV = LBCU+((LPH**LPC)*(LSOLU*LC))+(LSPBC*LR)
      ELSEIF( IOM.EQ.51 ) THEN
        LBCU = 13
        LBCV = LBCU+((LPH**LPC)*(LSOLU*LC))+(LSPBC*LR)
      ELSEIF( IOM.EQ.52 ) THEN
        LBCU = 11
        LBCV = LBCU+((LPH**LPC)*(LSOLU*LC))+(LSPBC*LR)
      ELSE
        LBCU = LUK+(LPH*LCN)+LT+((LPLANT-1)*LSW*2)+3+(LNGC-1)
        LBCV = LBCU+((LPH**LPC)*(LSOLU*LC))+(LSPBC*LR)
      ENDIF
      IF( LXYZG.EQ.1 ) LBCV = LBCV + 3
      LBCH = LBC**LHYD
      LBCGC = LBC**LGC
!
!---  Exchange species parameters  ---
!
      LSPE = MAX( LSPE,1 )
      LESITE = MAX( LESITE,1 )
!
!---  ECKEChem parameters  ---
!
      LSPR = MAX( LSPG+LSPL+LSPN+LSPS+LSPE,1 )
      LSPG = MAX( LSPG,1 )
      LSPL = MAX( LSPL,1 )
      LSPN = MAX( LSPN,1 )
      LSPS = MAX( LSPS,1 )
      LSPT = MAX( LSPT,1 )
!
!---  Output Variable Parameter
!     Number of Source Code Files Parameter  ---
!
      LOUPV = 400+33*((LSOLU**LC)+((LSPR+LSPT)**LR)+2-LC-LR)
      LFILES = 400
!
!---  Soil Moisture-Retention Characteristic Parameters  ---
!     Aqueous Relative Permeability Parameters
!     Gas Relative Permeability Parameters
!     NAPL Relative Permeability Parameters
!     Relative Permeability Tensor Parameters  ---
!
      LSCHR = 18
      LRPLC = 12
      LRPGC = 6
      LRPNC = 6
      LRPL = 4
!
!---  Coupled Multifluid Well Model Parameters  ---
!
      LNWN = LNW*LFZ
      LSZW = LNW*(LFZ+1)
      LNWV = 6
      LUKW = LUK+(LUK*LWELL)
!
!---  Noncondensible Gas Property Table Parameters  ---
!
      LP_TA = 72**LPTA
      LT_TA = 70**LPTA
      LT_TH = 100**LPTA
      LO_TH = 11**LPTA
      LT_PH = 155**LPTA
      LO_PH = 11**LPTA
      L_LV = 115**LPTA
      LINH = 15
!
!---  Ternary hydrate parameters  ---
!
      LHF_HT = 3**(LHYD*LN2)
      LCN_HT = 11**(LHYD*LN2)
      LCP_HT = 45**(LHYD*LN2)
      LCH_HT = 66**(LHYD*LN2)
      LPE_HT = 52**(LHYD*LN2)
      LHE_HT = 115**(LHYD*LN2)
      LTP_HT = 27**(LHYD*LN2)
      LPP_HT = 54**(LHYD*LN2)
!
!---  Dual Porosity and Equivalent Continuum Model parameters  ---
!
      LFD_DP = LFD**L_DP
      LFD_EC = LFD**(L_EC+L_DP)
      LBC_EC = LBC**L_EC
!
!---  Fracture/fault parameters  ---
!
      LT_FRCC = LT_FRC**LC
      LF_FRCC = LF_FRC**LC
      LVIC_FRC = MAX(1,4*(6+LNGC+LSOLU+LSPT))
!
!---  Borehole parameters  ---
!
      LN_BHC = LN_BH**LC
      LBN_BHC = LBN_BH**LC
!
!---  End of CGLBP group
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CHK_BH
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Define borehole nodes, determine trajectory points, and 
!     check for borehole trajectories within node surface planes
!     and crossing embedded fractures/faults
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 5 April 2019.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_BH
      USE GRID
      USE GEOM_FRC
      USE GEOM_BH
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 XPX(5),YPX(5),ZPX(5)
      REAL*8 XIX(2),YIX(2),ZIX(2)
      REAL*8 PAX(3),PBX(3),PCX(3),PBCX(3)
      REAL*8 AJ(3,3),BJ(3)
      INTEGER IJ(3)
      INTEGER MSX(4,6)
      INTEGER N1X(4),N2X(4)
      TYPE(LIST_WELL_NODE), POINTER :: WN_CURR_PTR,WN_TMP_PTR
!
!----------------------Data Statements---------------------------------!
!
      SAVE MSX,N1X,N2X
      DATA MSX / 1,2,4,3,1,5,6,2,1,3,7,5,2,6,8,4,3,4,8,7,5,7,8,6 /
      DATA N1X / 2,3,4,1 /
      DATA N2X / 1,2,3,4 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CHK_BH'
      NULLIFY( WN_BH_PTR )
      EPSLX = 1.D-12
!
!---  Loop over boreholes ---
!
      DO 600 NBH = 1,LN_BH
        ID_BH(3,NBH) = LBN_BH + 1
        NBN_BH = LBN_BH
!
!---    Loop over number of borehole intervals  ---
!
        DO 490 NIBH = ID_BH(1,NBH),ID_BH(2,NBH)
          IFNDX = 0
!
!---      Loop over active nodes to find borehole nodes and well
!         projections ---
!
          DO 480 N = 1,LFD-LBR-LWN_LW
            IF( IXP(N).EQ.0 ) GOTO 480
            I = ID(N)
            J = JD(N)
            K = KD(N)
            NC = 0
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO KX = 1,KRX
            DO JX = 1,JRX
            DO IX = 1,IRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NC = 0
!
!---          Determine whether the transition points are within
!             the hexahedron node volume or on the hexahedron
!             surfaces  ---
!
              DO 190 NPT = 1,2
!
!---            Cylindrical coordinates with azimuthal symmetry,
!               centrally located boreholes  ---
!
                IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1
     &            .AND. I.EQ.1 ) THEN
                  XPX(1) = 0.D+0
                  XPX(2) = 0.D+0
                  YPX(1) = 0.D+0
                  YPX(2) = 0.D+0
                  ZPX(1) = ZE(1,NX)
                  ZPX(2) = ZE(5,NX)
!
!---              Node height greater than EPSLX  ---
!
                  IF( ABS(ZPX(1)-ZPX(2)).GT.EPSLX ) THEN
                    DZPX1 = ZTP_BH(NPT,NIBH)-ZPX(1)
                    DZPX2 = ZPX(2)-ZTP_BH(NPT,NIBH)
                    IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                    IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
!
!---                Transition point within vertical limits of node  ---
!
                    IF( DZPX1.GE.0.D+0 .AND. DZPX2.GE.0.D+0 ) THEN
                      NC = NC+1
                      XIX(NC) = 0.D+0
                      YIX(NC) = 0.D+0
                      ZIX(NC) = ZTP_BH(NPT,NIBH)
                    ENDIF
                  ENDIF
                  GOTO 190
                ENDIF
!
!---            Loop over node surfaces,
!               (bottom,south,west,east,north,top)  ---
!
                IBHX = 0
                DO 180 NS = 1,6
!
!---              Define the five surface points, four corners
!                 and one centroid---
!
                  DO 110 NP = 1,4
                    MX = MSX(NP,NS)
!
!---                Cylindrical coordinates  ---
!
                    IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                      XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                      YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                      ZPX(NP) = ZE(MX,NX)
                    ELSE
                      XPX(NP) = XE(MX,NX)
                      YPX(NP) = YE(MX,NX)
                      ZPX(NP) = ZE(MX,NX)
                    ENDIF
  110             CONTINUE
                  NP = 4
                  CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &              XPX(5),YPX(5),ZPX(5) )
!
!---              Loop over the four triangular planes on the 
!                 surface face  ---
!
                  DO 130 NT = 1,4
!
!---                Built vectors between transition point
!                   and triangular plane points  ---
!
                    PAX(1) = XPX(5)-XTP_BH(NPT,NIBH)
                    PAX(2) = YPX(5)-YTP_BH(NPT,NIBH)
                    PAX(3) = ZPX(5)-ZTP_BH(NPT,NIBH)
                    PBX(1) = XPX(N1X(NT))-XTP_BH(NPT,NIBH)
                    PBX(2) = YPX(N1X(NT))-YTP_BH(NPT,NIBH)
                    PBX(3) = ZPX(N1X(NT))-ZTP_BH(NPT,NIBH)
                    PCX(1) = XPX(N2X(NT))-XTP_BH(NPT,NIBH)
                    PCX(2) = YPX(N2X(NT))-YTP_BH(NPT,NIBH)
                    PCX(3) = ZPX(N2X(NT))-ZTP_BH(NPT,NIBH)
                    CALL VCROSSP( PBX,PCX,PBCX )
                    SX = VDOTP( PAX,PBCX )
!
!---                Clockwise rotation  ---
!
                    IF( SX.GT.EPSL ) THEN
!
!---                  Opposing rotations found, point outside 
!                     hexaheron  ---
!
                      IF( IBHX.EQ.-1 ) THEN
                        GOTO 190
!
!---                  Similar rotations found, continue searching  ---
!
                      ELSE
                        IBHX = 1
                      ENDIF
!
!---                Counterclockwise rotation  ---
!
                    ELSEIF( SX.LT.-EPSL ) THEN
!
!---                  Opposing rotations found, point outside 
!                     hexaheron  ---
!
                      IF( IBHX.EQ.1 ) THEN
                        GOTO 190
!
!---                  Similar rotations found, continue searching  ---
!
                      ELSE
                        IBHX = -1
                      ENDIF
                    ENDIF
  130             CONTINUE
  180           CONTINUE            
!
!---            No opposing rotations found, point inside 
!               hexahedron  ---
!
                NC = NC+1
                XIX(NC) = XTP_BH(NPT,NIBH)
                YIX(NC) = YTP_BH(NPT,NIBH)
                ZIX(NC) = ZTP_BH(NPT,NIBH)
  190         CONTINUE
!
!---          Both transition points inside hexahedron, skip search 
!             for borehole path crossing hexahedron surfaces  ---
!
              IF( NC.EQ.2 ) GOTO 232
!
!---          Cylindrical coordinates with azimuthal symmetry,
!             centrally located boreholes  ---
!
              IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1
     &          .AND. I.EQ.1 ) THEN
!
!---            Interval crosses lower node surface  ---
!
                DZPX1 = ZPX(1)-ZTP_BH(1,NIBH)
                IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                DZPX2 = ZPX(1)-ZTP_BH(2,NIBH)
                IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
                IF( (DZPX1*DZPX2).LT.-EPSLX ) THEN
                  NC = NC+1
                  XIX(NC) = 0.D+0
                  YIX(NC) = 0.D+0
                  ZIX(NC) = ZPX(1)
                ENDIF
!
!---            Interval crosses upper node surface  ---
!
                DZPX1 = ZPX(2)-ZTP_BH(1,NIBH)
                IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                DZPX2 = ZPX(2)-ZTP_BH(2,NIBH)
                IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
                IF( (DZPX1*DZPX2).LT.-EPSLX ) THEN
                  NC = NC+1
                  XIX(NC) = 0.D+0
                  YIX(NC) = 0.D+0
                  ZIX(NC) = ZPX(2)
                ENDIF
                GOTO 232
              ENDIF
!
!---          Loop over node surfaces,
!             (bottom,south,west,east,north,top)  ---
!
              DO 230 NS = 1,6
!
!---            Define the five surface points, four corners
!               and one centroid---
!
                DO 200 NP = 1,4
                  MX = MSX(NP,NS)
!
!---              Cylindrical coordinates---
!
                  IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                    XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                    YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                    ZPX(NP) = ZE(MX,NX)
                  ELSE
                    XPX(NP) = XE(MX,NX)
                    YPX(NP) = YE(MX,NX)
                    ZPX(NP) = ZE(MX,NX)
                  ENDIF
  200           CONTINUE
                NP = 4
                CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &            XPX(5),YPX(5),ZPX(5) )
!
!
!---            Loop over the four triangular planes on the 
!               surface face  ---
!
                DO 220 NT = 1,4
!
!---              Load plane-line intersection matrix and 
!                 problem vector  ---
!
                  AJ(1,1) = XTP_BH(1,NIBH)-XTP_BH(2,NIBH)
                  AJ(2,1) = YTP_BH(1,NIBH)-YTP_BH(2,NIBH)
                  AJ(3,1) = ZTP_BH(1,NIBH)-ZTP_BH(2,NIBH)
                  AJ(1,2) = XPX(N1X(NT))-XPX(5)
                  AJ(2,2) = YPX(N1X(NT))-YPX(5)
                  AJ(3,2) = ZPX(N1X(NT))-ZPX(5)
                  AJ(1,3) = XPX(N2X(NT))-XPX(5)
                  AJ(2,3) = YPX(N2X(NT))-YPX(5)
                  AJ(3,3) = ZPX(N2X(NT))-ZPX(5)
                  BJ(1) = XTP_BH(1,NIBH)-XPX(5)
                  BJ(2) = YTP_BH(1,NIBH)-YPX(5)
                  BJ(3) = ZTP_BH(1,NIBH)-ZPX(5)
!
!---              Check for no intersection  ---
!
                  DO 210 IP = 1,3
                    AAMAX = 0.D+0
                    DO 202 JP = 1,3
                      IF( ABS(AJ(IP,JP)).GT.AAMAX ) 
     &                  AAMAX = ABS(AJ(IP,JP))
  202               CONTINUE
!
!---                No intersection go to next triangle on the 
!                   surface  ---
!
                    IF( ABS(AAMAX)/EPSL.LT.EPSL ) GOTO 220
  210             CONTINUE
!
!---              Find plane-line intersection matrix inverse  ---
!
                  JP = 3
                  KP = 3
                  CALL LU_DCMP( AJ,JP,KP,IJ,DJ )
                  CALL LU_BKSB( AJ,JP,KP,IJ,BJ )
!
!---              Find plane-line intersection point  ---
!
                  TX = BJ(1)
                  UX = BJ(2)
                  VX = BJ(3)
                  IF( ABS(TX).LT.EPSL ) TX = 0.D+0
                  IF( ABS(UX).LT.EPSL ) UX = 0.D+0
                  IF( ABS(VX).LT.EPSL ) VX = 0.D+0
!
!---              Line crosses surface, within the triangle  ---
!
                  IF( TX.GE.0.D+0 .AND. TX.LE.1.D+0 .AND.
     &              UX.GE.0.D+0 .AND. UX.LE.1.D+0 .AND. 
     &              VX.GE.0.D+0 .AND. VX.LE.1.D+0 .AND.
     &              (UX+VX).LE.1.D+0 ) THEN
                    XTX = XTP_BH(1,NIBH)
     &                + (XTP_BH(2,NIBH)-XTP_BH(1,NIBH))*TX
                    YTX = YTP_BH(1,NIBH)
     &                + (YTP_BH(2,NIBH)-YTP_BH(1,NIBH))*TX
                    ZTX = ZTP_BH(1,NIBH)
     &                + (ZTP_BH(2,NIBH)-ZTP_BH(1,NIBH))*TX
!
!---                Check for non-distinct points  ---
!
                    IF( NC.GE.1 ) THEN
                      DO 212 NDP = 1,NC
                        DPX = SQRT( ((XTX-XIX(NDP))**2) 
     &                    + ((YTX-YIX(NDP))**2) + ((ZTX-ZIX(NDP))**2) )
!
!---                    Duplicate point found  ---
!
                        IF( DPX.LT.EPSLX ) GOTO 214
  212                 CONTINUE
                    ENDIF
                    IF( NC.EQ.2 ) THEN
                      INDX = 7
                      CHMSG = 'Three Distinct Coupled Borehole Points'
     &                  //  ' at Node'
                      IMSG = NX
                      CALL WRMSGP( INDX )
                    ENDIF
                    NC = NC + 1
                    XIX(NC) = XTX
                    YIX(NC) = YTX
                    ZIX(NC) = ZTX
                  ENDIF
  214             CONTINUE
  220           CONTINUE
  230         CONTINUE
  232         CONTINUE
!
!---          Check that two borehole points are distinct  ---
!
              DPX = 0.D+0
              IF( NC.EQ.2 ) THEN
                DPX = SQRT( ((XIX(2)-XIX(1))**2) + ((YIX(2)-YIX(1))**2)
     &            + ((ZIX(2)-ZIX(1))**2) )
              ENDIF
!
!---          Two distinct borehole points  ---
!
              IF( NC.EQ.2 .AND. DPX.GT.EPSLX ) THEN
!
!---            Cylindrical coordinates with azimuthal symmetry  ---
!
                IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) GOTO 362
!
!---            Check if line between borehole points is contained in
!               a node surface plane, loop over node surfaces,
!               (bottom,south,west,east,north,top)  ---
!
                DO 360 NS = 1,6
!
!---              Define the five surface points, four corners
!                 and one centroid---
!
                  DO 352 NP = 1,4
                    MX = MSX(NP,NS)
!
!---                Cylindrical coordinates---
!
                    IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                      XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                      YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                      ZPX(NP) = ZE(MX,NX)
                    ELSE
                      XPX(NP) = XE(MX,NX)
                      YPX(NP) = YE(MX,NX)
                      ZPX(NP) = ZE(MX,NX)
                    ENDIF
  352             CONTINUE
                  NP = 4
                  CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &              XPX(5),YPX(5),ZPX(5) )
!
!---              Loop over the four triangular planes on the 
!                 surface face  ---
!
                  DO 358 NT = 1,4
!
!---                Loop over trajectory points  ---
!
                    DO 356 NPT = 1,2
!
!---                  Load point-plane matrix  ---
!
                      AJ(1,1) = XIX(NPT)-XPX(5)
                      AJ(2,1) = XIX(NPT)-XPX(N1X(NT))
                      AJ(3,1) = XIX(NPT)-XPX(N2X(NT))
                      AJ(1,2) = YIX(NPT)-YPX(5)
                      AJ(2,2) = YIX(NPT)-YPX(N1X(NT))
                      AJ(3,2) = YIX(NPT)-YPX(N2X(NT))
                      AJ(1,3) = ZIX(NPT)-ZPX(5)
                      AJ(2,3) = ZIX(NPT)-ZPX(N1X(NT))
                      AJ(3,3) = ZIX(NPT)-ZPX(N2X(NT))
!
!---                  Check for singular matrix  ---
!
                      DO 310 IP = 1,3
                        AAMAX = 0.D+0
                        DO 302 JP = 1,3
                          IF( ABS(AJ(IP,JP)).GT.AAMAX ) 
     &                    AAMAX = ABS(AJ(IP,JP))
  302                   CONTINUE
!
!---                    Singular matrix, trajectory point is within
!                       the surface plane  ---
!
                        IF( ABS(AAMAX)/EPSL.LT.EPSL ) GOTO 356
  310                 CONTINUE
!
!---                  Find matrix determinant  ---
!
                      JP = 3
                      KP = 3
                      CALL LU_DCMP( AJ,JP,KP,IJ,DJ )
                      DO 354 M = 1,JP
                        DJ = DJ*AJ(M,M)
  354                 CONTINUE
!
!---                  If determinant equals zero trajectory point
!                     is within the surface plane  ---
!
                      IF( ABS(DJ).GT.EPSL ) GOTO 358
  356               CONTINUE
                    INDX = 7
                    CHMSG = 'Both Borehole Trajectory Points within '
     &                //  'Surface Plane for Borehole Number'
                    IMSG = NBH
                    CALL WRMSGP( INDX )
  358             CONTINUE
  360           CONTINUE
  362           CONTINUE
!
!---            Loop over current borehole nodes, where the most recent
!               borehole node is first in the list order  ---
!
                WN_CURR_PTR => WN_BH_PTR
                DO 370 NWN = 1,LBN_BH-NBN_BH
!
!---              Borehole node previously counted  ---
!
                  IF( WN_CURR_PTR%IWN_CW.EQ.NX ) THEN
                    GOTO 372
                  ENDIF
                  WN_CURR_PTR => WN_CURR_PTR%NEXT
  370           CONTINUE
  372           CONTINUE
!
!---            Increment the number of borehole nodes  ---
!
                LBN_BH = LBN_BH + 1
!
!---            Double the number borehole nodes
!               for coaxial boreholes  ---
!
                IF( IT_BH(1,NBH).GE.10000 ) LBN_BH = LBN_BH + 1
                IFNDX = 1
!
!---            Allocate memory for new borehole node element  ---
!
                ALLOCATE( WN_TMP_PTR,STAT=ISTAT )
                IF( ISTAT.NE.0 ) THEN
                  INDX = 3
                  CHMSG = 'Allocation Error: WN_TMP_PTR'
                  CALL WRMSGP( INDX )
                ENDIF
                WN_TMP_PTR%IWN_CW = NX
                WN_TMP_PTR%XP1_CW = XIX(1)
                WN_TMP_PTR%YP1_CW = YIX(1)
                WN_TMP_PTR%ZP1_CW = ZIX(1)
                WN_TMP_PTR%XP2_CW = XIX(2)
                WN_TMP_PTR%YP2_CW = YIX(2)
                WN_TMP_PTR%ZP2_CW = ZIX(2)
                WN_TMP_PTR%NEXT => WN_BH_PTR
                WN_BH_PTR => WN_TMP_PTR
!
!---            Double the number borehole nodes
!               for coaxial boreholes  ---
!
                IF( IT_BH(1,NBH).GE.10000 ) THEN
!
!---              Allocate memory for new borehole node element  ---
!
                  ALLOCATE( WN_TMP_PTR,STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Allocation Error: WN_TMP_PTR'
                    CALL WRMSGP( INDX )
                  ENDIF
                  WN_TMP_PTR%IWN_CW = NX
                  WN_TMP_PTR%XP1_CW = XIX(1)
                  WN_TMP_PTR%YP1_CW = YIX(1)
                  WN_TMP_PTR%ZP1_CW = ZIX(1)
                  WN_TMP_PTR%XP2_CW = XIX(2)
                  WN_TMP_PTR%YP2_CW = YIX(2)
                  WN_TMP_PTR%ZP2_CW = ZIX(2)
                  WN_TMP_PTR%NEXT => WN_BH_PTR
                  WN_BH_PTR => WN_TMP_PTR
                ENDIF
              ENDIF
            ENDDO
            ENDDO
            ENDDO
  480     CONTINUE
  490   CONTINUE
        ID_BH(4,NBH) = LBN_BH
  600 CONTINUE
!
!---  Allocate memory for borehole node to borehole node connection
!     pointer array  ---
!
      ALLOCATE( IPB_BH(1:3,1:LBN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IPB_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for borehole node to borehole node connection
!     map  ---
!
      LBC_BH = 3*LBN_BH
      ALLOCATE( IBCM_BH(1:LBC_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IBCM_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for borehole-node index array  ---
!
      ALLOCATE( IBN_BH(1:LBN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IBN_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the borehole x-projection array  ---
!
      ALLOCATE( XP_BH(1:2,1:LBN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XP_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the borehole y-projection array  ---
!
      ALLOCATE( YP_BH(1:2,1:LBN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YP_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the borehole z-projection array  ---
!
      ALLOCATE( ZP_BH(1:2,1:LBN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZP_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for triangle of borehole-fracture/fault connection
!     assuming fewer connections than borehole nodes   ---
!
      ALLOCATE( IBHT_FRC(1:LBN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IBHT_FRC'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for borehole node of borehole-fracture
!      connection assuming fewer connections than borehole nodes   ---
!
      ALLOCATE( IBHN_FRC(1:LBN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IBHN_FRC'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load borehole-node index array  ---
!
      WN_CURR_PTR => WN_BH_PTR
      DO 620 NWN = 1,LBN_BH
        M = LBN_BH-NWN+1
        IBN_BH(M) = WN_CURR_PTR%IWN_CW
        XP_BH(1,M) = WN_CURR_PTR%XP1_CW
        XP_BH(2,M) = WN_CURR_PTR%XP2_CW
        YP_BH(1,M) = WN_CURR_PTR%YP1_CW
        YP_BH(2,M) = WN_CURR_PTR%YP2_CW
        ZP_BH(1,M) = WN_CURR_PTR%ZP1_CW
        ZP_BH(2,M) = WN_CURR_PTR%ZP2_CW
        WN_CURR_PTR => WN_CURR_PTR%NEXT
  620 CONTINUE
!
!---  Loop over boreholes ---
!
      NC = 0
      DO 700 NBH = 1,LN_BH
!
!---    Sequence borehole nodes according to their distance from
!       the previous borehole, beginning with the starting point 
!       of the borehole  ---
!
        I1X = ID_BH(1,NBH)
        I3X = ID_BH(3,NBH)
        I4X = ID_BH(4,NBH)
        XTP_BHX = XTP_BH(1,I1X)
        YTP_BHX = YTP_BH(1,I1X)
        ZTP_BHX = ZTP_BH(1,I1X)
  630   CONTINUE
        DMNX = 1.D+20
        DO 640 KBN = I3X,I4X
          XWPX = 5.D-1*(XP_BH(1,KBN)+XP_BH(2,KBN))
          YWPX = 5.D-1*(YP_BH(1,KBN)+YP_BH(2,KBN))
          ZWPX = 5.D-1*(ZP_BH(1,KBN)+ZP_BH(2,KBN))
          DISTX = SQRT( (XTP_BHX-XWPX)**2 +
     &      (YTP_BHX-YWPX)**2 + (ZTP_BHX-ZWPX)**2 )
          IF( DISTX.LT.DMNX ) THEN
            DMNX = DISTX
            IMNX = KBN
            IBNX = IBN_BH(KBN)
            XIX(1) = XP_BH(1,KBN)
            XIX(2) = XP_BH(2,KBN)
            YIX(1) = YP_BH(1,KBN)
            YIX(2) = YP_BH(2,KBN)
            ZIX(1) = ZP_BH(1,KBN)
            ZIX(2) = ZP_BH(2,KBN)
          ENDIF
  640   CONTINUE
        DO 650 JBN = I4X,I3X,-1
          IF( JBN.LT.IMNX ) THEN
            IBN_BH(JBN+1) = IBN_BH(JBN)
            XP_BH(1,JBN+1) = XP_BH(1,JBN)
            XP_BH(2,JBN+1) = XP_BH(2,JBN)
            YP_BH(1,JBN+1) = YP_BH(1,JBN)
            YP_BH(2,JBN+1) = YP_BH(2,JBN)
            ZP_BH(1,JBN+1) = ZP_BH(1,JBN)
            ZP_BH(2,JBN+1) = ZP_BH(2,JBN)
          ENDIF
  650   CONTINUE
        IBN_BH(I3X) = IBNX
        XP_BH(1,I3X) = XIX(1)
        XP_BH(2,I3X) = XIX(2)
        YP_BH(1,I3X) = YIX(1)
        YP_BH(2,I3X) = YIX(2)
        ZP_BH(1,I3X) = ZIX(1)
        ZP_BH(2,I3X) = ZIX(2)
        XTP_BHX = XP_BH(2,I3X)
        YTP_BHX = YP_BH(2,I3X)
        ZTP_BHX = ZP_BH(2,I3X)
        I3X = I3X+1
        IF( I3X.LT.I4X ) GOTO 630
!
!---    Sequence borehole nodes according to their distance from
!       the previous borehole, beginning with the starting point 
!       of the borehole  ---
!
        I1X = ID_BH(1,NBH)
        I3X = ID_BH(3,NBH)
        I4X = ID_BH(4,NBH)
        XTP_BHX = XTP_BH(1,I1X)
        YTP_BHX = YTP_BH(1,I1X)
        ZTP_BHX = ZTP_BH(1,I1X)
        DO 652 KBN = I3X,I4X
          DIST1X = SQRT( (XTP_BHX-XP_BH(1,KBN))**2 +
     &      (YTP_BHX-YP_BH(1,KBN))**2 + 
     &      (ZTP_BHX-ZP_BH(1,KBN))**2 )
          DIST2X = SQRT( (XTP_BHX-XP_BH(2,KBN))**2 +
     &      (YTP_BHX-YP_BH(2,KBN))**2 + 
     &      (ZTP_BHX-ZP_BH(2,KBN))**2 )
          IF( DIST1X.GT.DIST2X ) THEN
            XIX(2) = XP_BH(1,KBN)
            YIX(2) = YP_BH(1,KBN)
            ZIX(2) = ZP_BH(1,KBN)
            XP_BH(1,KBN) = XP_BH(2,KBN)
            YP_BH(1,KBN) = YP_BH(2,KBN)
            ZP_BH(1,KBN) = ZP_BH(2,KBN)
            XP_BH(2,KBN) = XIX(2)
            YP_BH(2,KBN) = YIX(2)
            ZP_BH(2,KBN) = ZIX(2)
          ENDIF
          XTP_BHX = XP_BH(2,KBN)
          YTP_BHX = YP_BH(2,KBN)
          ZTP_BHX = ZP_BH(2,KBN)       
  652   CONTINUE
  700 CONTINUE
!
!---  Loop over boreholes, re-numbering borehole nodes for coaxial
!     boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Coaxial borehole  ---
!
        IF( IT_BH(1,NBH).GE.10000 ) THEN
          I1X = ID_BH(3,NBH)
          I2X = (ID_BH(4,NBH)-ID_BH(3,NBH))/2 + ID_BH(3,NBH)
          DO NBN = I1X,I2X
            NBN1 = (NBN-ID_BH(3,NBH))*2 + 1
            XP_BH(1,NBN) = XP_BH(1,NBN1)
            XP_BH(2,NBN) = XP_BH(2,NBN1)
            YP_BH(1,NBN) = YP_BH(1,NBN1)
            YP_BH(2,NBN) = YP_BH(2,NBN1)
            ZP_BH(1,NBN) = ZP_BH(1,NBN1)
            ZP_BH(2,NBN) = ZP_BH(2,NBN1)
            IBN_BH(NBN) = IBN_BH(NBN1)
          ENDDO
          DO NBN = I1X,I2X
            NBN1 = ID_BH(4,NBH) - NBN + 1
            XP_BH(1,NBN1) = XP_BH(2,NBN)
            XP_BH(2,NBN1) = XP_BH(1,NBN)
            YP_BH(1,NBN1) = YP_BH(2,NBN)
            YP_BH(2,NBN1) = YP_BH(1,NBN)
            ZP_BH(1,NBN1) = ZP_BH(2,NBN)
            ZP_BH(2,NBN1) = ZP_BH(1,NBN)
            IBN_BH(NBN1) = IBN_BH(NBN)
            IBN_BH(NBN) = 0
          ENDDO
        ENDIF
      ENDDO
!
!---  Loop over boreholes, creating a borehole node to borehole node
!     connection map  ---
!
      NC = 0
      DO NBH = 1,N_BH
!
!---    Include inner to outer node connections for coaxial
!       boreholes  ---
!
        IF( IT_BH(1,NBH).GE.10000 ) THEN
          I1X = ID_BH(3,NBH)
          I2X = (ID_BH(4,NBH)-ID_BH(3,NBH))/2 + ID_BH(3,NBH)
          DO NBN = I1X,I2X
            NBN1 = NBN
            NBN2 = ID_BH(4,NBH) - NBN1 + 1
            IF( NBN.EQ.I1X .AND. NBN.EQ.I2X ) THEN
              NC = NC + 1
              IPB_BH(1,NBN1) = 0
              IPB_BH(2,NBN1) = NC
              IBCM_BH(NC) = NBN2
              IPB_BH(3,NBN1) = -2             
              NC = NC + 1
              IPB_BH(1,NBN2) = NC
              IPB_BH(2,NBN2) = 0
              IBCM_BH(NC) = NBN1
              IPB_BH(3,NBN2) = -1             
            ELSEIF( NBN.EQ.I1X ) THEN
              NC = NC + 1
              IPB_BH(1,NBN1) = 0
              IPB_BH(2,NBN1) = NC
              IBCM_BH(NC) = NBN1 + 1
              NC = NC + 1
              IPB_BH(3,NBN1) = NC
              IBCM_BH(NC) = NBN2
              NC = NC + 1
              IPB_BH(1,NBN2) = 0
              IPB_BH(2,NBN2) = NC
              IBCM_BH(NC) = NBN2 - 1
              NC = NC + 1
              IPB_BH(3,NBN2) = NC
              IBCM_BH(NC) = NBN1
            ELSEIF( NBN.EQ.I2X ) THEN
              NC = NC + 1
              IPB_BH(1,NBN1) = NC
              IBCM_BH(NC) = NBN1 - 1
              NC = NC + 1
              IPB_BH(2,NBN1) = NC
              IBCM_BH(NC) = NBN2
              IPB_BH(3,NBN1) = -2
              NC = NC + 1
              IPB_BH(1,NBN2) = NC
              IBCM_BH(NC) = NBN1
              NC = NC + 1
              IPB_BH(2,NBN2) = NC
              IBCM_BH(NC) = NBN2 + 1
              IPB_BH(3,NBN2) = -1
            ELSE
              NC = NC + 1
              IPB_BH(1,NBN1) = NC
              IBCM_BH(NC) = NBN1 - 1
              NC = NC + 1
              IPB_BH(2,NBN1) = NC
              IBCM_BH(NC) = NBN1 + 1
              NC = NC + 1
              IPB_BH(3,NBN1) = NC
              IBCM_BH(NC) = NBN2
              NC = NC + 1
              IPB_BH(1,NBN2) = NC
              IBCM_BH(NC) = NBN2 - 1
              NC = NC + 1
              IPB_BH(2,NBN2) = NC
              IBCM_BH(NC) = NBN2 + 1
              NC = NC + 1
              IPB_BH(3,NBN2) = NC
              IBCM_BH(NC) = NBN1
            ENDIF
          ENDDO
!
!---      Loop over number of borehole nodes  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
            IF( MOD(NBN,2).EQ.0 ) IBN_BH(NBN) = 0
          ENDDO
        ELSE
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
            IF( NBN.EQ.ID_BH(3,NBH) .AND. NBN.EQ.ID_BH(4,NBH) ) THEN
              NC = NC + 1
              IPB_BH(1,NBN) = NC
              IPB_BH(2,NBN) = NC
              IPB_BH(3,NBN) = 0
              IBCM_BH(NC) = 0
            ELSEIF( NBN.EQ.ID_BH(3,NBH) ) THEN
              NC = NC + 1
              IPB_BH(1,NBN) = NC
              IPB_BH(2,NBN) = NC
              IPB_BH(3,NBN) = 0
              IBCM_BH(NC) = NBN + 1
            ELSEIF( NBN.EQ.ID_BH(4,NBH) ) THEN
              NC = NC + 1
              IPB_BH(1,NBN) = NC
              IPB_BH(2,NBN) = NC
              IPB_BH(3,NBN) = 0
              IBCM_BH(NC) = NBN - 1
            ELSE
              NC = NC + 1
              IPB_BH(1,NBN) = NC
              IBCM_BH(NC) = NBN - 1
              NC = NC + 1
              IPB_BH(2,NBN) = NC
              IPB_BH(3,NBN) = 0
              IBCM_BH(NC) = NBN + 1
            ENDIF
          ENDDO
        ENDIF
      ENDDO
!
!---  Loop over boreholes, checking for intersections of the
!     borehole trajectory with fracture/fault triangle surfaces  ---
!
      NC = 0
      DO NBH = 1,N_BH
        ID_BH(5,NBH) = NC+1
!
!---    Skip for coaxial boreholes  ---
!
        IF( IT_BH(1,NBH).GE.10000 ) CYCLE
!
!---    Loop over number of borehole nodes  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Loop over fractures/faults  ---
!
          DO NFX = 1,NF_FRC
!
!---        Loop over fracture/fault triangles  ---
!
            DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---          Load plane-line intersection matrix and problem vector  ---
!
              AJ(1,1) = XP_BH(1,NBN)-XP_BH(2,NBN)
              AJ(2,1) = YP_BH(1,NBN)-YP_BH(2,NBN)
              AJ(3,1) = ZP_BH(1,NBN)-ZP_BH(2,NBN)
              AJ(1,2) = XE_FRC(2,NTX)-XE_FRC(1,NTX)
              AJ(2,2) = YE_FRC(2,NTX)-YE_FRC(1,NTX)
              AJ(3,2) = ZE_FRC(2,NTX)-ZE_FRC(1,NTX)
              AJ(1,3) = XE_FRC(3,NTX)-XE_FRC(1,NTX)
              AJ(2,3) = YE_FRC(3,NTX)-YE_FRC(1,NTX)
              AJ(3,3) = ZE_FRC(3,NTX)-ZE_FRC(1,NTX)
              BJ(1) = XP_BH(1,NBN)-XE_FRC(1,NTX)
              BJ(2) = YP_BH(1,NBN)-YE_FRC(1,NTX)
              BJ(3) = ZP_BH(1,NBN)-ZE_FRC(1,NTX)
!
!---          Check for no intersection  ---
!
              DO IP = 1,3
                AAMAX = 0.D+0
                DO JP = 1,3
                  IF( ABS(AJ(IP,JP)).GT.AAMAX ) AAMAX = ABS(AJ(IP,JP))
                ENDDO
!
!---            No intersection go to next triangle on the 
!               surface  ---
!
                IF( ABS(AAMAX)/EPSL.LT.EPSL ) GOTO 800
              ENDDO
!
!---          Find plane-line intersection matrix inverse  ---
!
              JP = 3
              KP = 3
              CALL LU_DCMP( AJ,JP,KP,IJ,DJ )
              CALL LU_BKSB( AJ,JP,KP,IJ,BJ )
!
!---          Find plane-line intersection point  ---
!
              TX = BJ(1)
              UX = BJ(2)
              VX = BJ(3)
              IF( ABS(TX).LT.EPSL ) TX = 0.D+0
              IF( ABS(UX).LT.EPSL ) UX = 0.D+0
              IF( ABS(VX).LT.EPSL ) VX = 0.D+0
!
!---          Line crosses surface, within the triangle  ---
!
              IF( TX.GE.0.D+0 .AND. TX.LE.1.D+0 .AND.
     &          UX.GE.0.D+0 .AND. UX.LE.1.D+0 .AND. 
     &          VX.GE.0.D+0 .AND. VX.LE.1.D+0 .AND.
     &          (UX+VX).LE.1.D+0 ) THEN
                NC = NC + 1
                IF( NC.GT.LBN_BH ) THEN
                  INDX = 3
                  CHMSG = 'Number of Borehole to Fracture/Fault ' //
     &              ' Connections > Parameter LBN_BH: Check Coding'
                  CALL WRMSGP( INDX )
                ENDIF
                IBHT_FRC(NC) = NTX
                IBHN_FRC(NC) = NBN
              ENDIF
  800         CONTINUE
            ENDDO
          ENDDO
        ENDDO
        ID_BH(6,NBH) = NC
      ENDDO
      LBC_FRC = MAX( NC,LBC_FRC )
      LFC_BH = MAX( NC,LFC_BH )
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CHK_BH group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Check to see if a character-string input exists.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNNL, November 2000.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CHK_CHR'
      ICD = INDEX( CARD,'  ')-1
      IVR = INDEX( VARB,'  ')-1
      ISX = ISTART
      ICX = ICOMMA
      INDX = 0
!
!---  End of card record error ---
!
      IF( CHDUM(1:1) .EQ. '~' ) THEN
        INDX = 4
        CHMSG = 'End of Card Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Find next comma  ---
!
      ICOMMA = INDEX (CHDUM(ISTART:), ',') + ISTART - 1
      ISTOP = ICOMMA
  100 CONTINUE
!
!---  Comma not found, missing real data  ---
!
      IF( ISTOP.LT.ISTART ) THEN
        GOTO 200
!
!---  Null entry  ---
!
      ELSEIF( ISTOP.EQ.ISTART ) THEN
        INDX = 1
        GOTO 200
!
!---  Characters between commas  ---
!
      ELSE
!
!---  Eliminate leading blank spaces  ---
!
        IF( ICHAR(CHDUM(ISTART:ISTART)).EQ.32 ) THEN
          ISTART = ISTART+1
          GOTO 100
        ENDIF
!
!---  Eliminate trailing blank spaces  ---
!
        ISTOP = ISTOP-1
  110   CONTINUE
        IF( ICHAR(CHDUM(ISTOP:ISTOP)).EQ.32 ) THEN
          ISTOP = ISTOP-1
          GOTO 110
        ENDIF
!
!---  Character string recognized as a character string  ---
!
        INDX = 1
      ENDIF
  200 CONTINUE
      ISTART = ISX
      ICOMMA = ICX
!
!---  End of CHK_CHR group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CHK_CW
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!
!     STOMP-CO2
!
!     Define well nodes, determine trajectory points, and 
!     check for well trajectories within node surface planes
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 31 March 2011.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 XPX(5),YPX(5),ZPX(5)
      REAL*8 XIX(2),YIX(2),ZIX(2)
      REAL*8 PAX(3),PBX(3),PCX(3),PBCX(3)
      REAL*8 AJ(3,3),BJ(3)
      INTEGER IJ(3)
      INTEGER MSX(4,6)
      INTEGER N1X(4),N2X(4)
      TYPE(LIST_WELL_NODE), POINTER :: WN_CURR_PTR,WN_TMP_PTR
!
!----------------------Data Statements---------------------------------!
!
      SAVE MSX,N1X,N2X
      DATA MSX / 1,2,4,3,1,5,6,2,1,3,7,5,2,6,8,4,3,4,8,7,5,7,8,6 /
      DATA N1X / 2,3,4,1 /
      DATA N2X / 1,2,3,4 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CHK_CW'
      NULLIFY( WN_CW_PTR )
      EPSLX = 1.D-12
!
!---  Loop over coupled wells ---
!
      DO 600 NCW = 1,LN_CW
        ID_CW(3,NCW) = LWN_CW + 1
        ID_CW(5,NCW) = LWF_CW + 1
        NWN_CW = LWN_CW
        NWF_CW = LWF_CW
!
!---    Loop over number of well intervals  ---
!
        DO 490 NICW = ID_CW(1,NCW),ID_CW(2,NCW)
          IFNDX = 0
!
!---      Loop over active nodes to find well nodes and well
!         projections ---
!
          DO 480 N = 1,LFD-LBR-LWN_LW
            IF( IXP(N).EQ.0 ) GOTO 480
            I = ID(N)
            J = JD(N)
            K = KD(N)
            NC = 0
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO KX = 1,KRX
            DO JX = 1,JRX
            DO IX = 1,IRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NC = 0
!
!---          Determine whether the transition points are within
!             the hexahedron node volume or on the hexahedron
!             surfaces  ---
!
              DO 190 NPT = 1,2
!
!---            Cylindrical coordinates with azimuthal symmetry,
!               centrally located wells  ---
!
                IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1
     &            .AND. I.EQ.1 ) THEN
                  XPX(1) = 0.D+0
                  XPX(2) = 0.D+0
                  YPX(1) = 0.D+0
                  YPX(2) = 0.D+0
                  ZPX(1) = ZE(1,NX)
                  ZPX(2) = ZE(5,NX)
!
!---              Node height greater than EPSLX  ---
!
                  IF( ABS(ZPX(1)-ZPX(2)).GT.EPSLX ) THEN
                    DZPX1 = ZTP_CW(NPT,NICW)-ZPX(1)
                    DZPX2 = ZPX(2)-ZTP_CW(NPT,NICW)
                    IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                    IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
!
!---                Transition point within vertical limits of node  ---
!
                    IF( DZPX1.GE.0.D+0 .AND. DZPX2.GE.0.D+0 ) THEN
                      NC = NC+1
                      XIX(NC) = 0.D+0
                      YIX(NC) = 0.D+0
                      ZIX(NC) = ZTP_CW(NPT,NICW)
                    ENDIF
                  ENDIF
                  GOTO 190
                ENDIF
!
!---            Loop over node surfaces,
!               (bottom,south,west,east,north,top)  ---
!
                ICWX = 0
                DO 180 NS = 1,6
!
!---              Define the five surface points, four corners
!                 and one centroid---
!
                  DO 110 NP = 1,4
                    MX = MSX(NP,NS)
!
!---                Cylindrical coordinates  ---
!
                    IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                      XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                      YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                      ZPX(NP) = ZE(MX,NX)
                    ELSE
                      XPX(NP) = XE(MX,NX)
                      YPX(NP) = YE(MX,NX)
                      ZPX(NP) = ZE(MX,NX)
                    ENDIF
  110             CONTINUE
                  NP = 4
                  CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &              XPX(5),YPX(5),ZPX(5) )
!
!---              Loop over the four triangular planes on the 
!                 surface face  ---
!
                  DO 130 NT = 1,4
!
!---                Built vectors between transition point
!                   and triangular plane points  ---
!
                    PAX(1) = XPX(5)-XTP_CW(NPT,NICW)
                    PAX(2) = YPX(5)-YTP_CW(NPT,NICW)
                    PAX(3) = ZPX(5)-ZTP_CW(NPT,NICW)
                    PBX(1) = XPX(N1X(NT))-XTP_CW(NPT,NICW)
                    PBX(2) = YPX(N1X(NT))-YTP_CW(NPT,NICW)
                    PBX(3) = ZPX(N1X(NT))-ZTP_CW(NPT,NICW)
                    PCX(1) = XPX(N2X(NT))-XTP_CW(NPT,NICW)
                    PCX(2) = YPX(N2X(NT))-YTP_CW(NPT,NICW)
                    PCX(3) = ZPX(N2X(NT))-ZTP_CW(NPT,NICW)
                    CALL VCROSSP( PBX,PCX,PBCX )
                    SX = VDOTP( PAX,PBCX )
!
!---                Clockwise rotation  ---
!
                    IF( SX.GT.EPSL ) THEN
!
!---                  Opposing rotations found, point outside 
!                     hexaheron  ---
!
                      IF( ICWX.EQ.-1 ) THEN
                        GOTO 190
!
!---                  Similar rotations found, continue searching  ---
!
                      ELSE
                        ICWX = 1
                      ENDIF
!
!---                Counterclockwise rotation  ---
!
                    ELSEIF( SX.LT.-EPSL ) THEN
!
!---                  Opposing rotations found, point outside 
!                     hexaheron  ---
!
                      IF( ICWX.EQ.1 ) THEN
                        GOTO 190
!
!---                  Similar rotations found, continue searching  ---
!
                      ELSE
                        ICWX = -1
                      ENDIF
                    ENDIF
  130             CONTINUE
  180           CONTINUE            
!
!---            No opposing rotations found, point inside 
!               hexahedron  ---
!
                NC = NC+1
                XIX(NC) = XTP_CW(NPT,NICW)
                YIX(NC) = YTP_CW(NPT,NICW)
                ZIX(NC) = ZTP_CW(NPT,NICW)
  190         CONTINUE
!
!---          Both transition points inside hexahedron, skip
!             search for well path crossing hexahedron surfaces  ---
!
              IF( NC.EQ.2 ) GOTO 232
!
!---          Cylindrical coordinates with azimuthal symmetry,
!             centrally located wells  ---
!
              IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1
     &          .AND. I.EQ.1 ) THEN
!
!---            Interval crosses lower node surface  ---
!
                DZPX1 = ZPX(1)-ZTP_CW(1,NICW)
                IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                DZPX2 = ZPX(1)-ZTP_CW(2,NICW)
                IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
                IF( (DZPX1*DZPX2).LT.-EPSLX ) THEN
                  NC = NC+1
                  XIX(NC) = 0.D+0
                  YIX(NC) = 0.D+0
                  ZIX(NC) = ZPX(1)
                ENDIF
!
!---            Interval crosses upper node surface  ---
!
                DZPX1 = ZPX(2)-ZTP_CW(1,NICW)
                IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                DZPX2 = ZPX(2)-ZTP_CW(2,NICW)
                IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
                IF( (DZPX1*DZPX2).LT.-EPSLX ) THEN
                  NC = NC+1
                  XIX(NC) = 0.D+0
                  YIX(NC) = 0.D+0
                  ZIX(NC) = ZPX(2)
                ENDIF
                GOTO 232
              ENDIF
!
!---          Loop over node surfaces,
!             (bottom,south,west,east,north,top)  ---
!
              DO 230 NS = 1,6
!
!---            Define the five surface points, four corners
!               and one centroid---
!
                DO 200 NP = 1,4
                  MX = MSX(NP,NS)
!
!---              Cylindrical coordinates---
!
                  IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                    XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                    YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                    ZPX(NP) = ZE(MX,NX)
                  ELSE
                    XPX(NP) = XE(MX,NX)
                    YPX(NP) = YE(MX,NX)
                    ZPX(NP) = ZE(MX,NX)
                  ENDIF
  200           CONTINUE
                NP = 4
                CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &            XPX(5),YPX(5),ZPX(5) )
!
!
!---            Loop over the four triangular planes on the 
!               surface face  ---
!
                DO 220 NT = 1,4
!
!---              Load plane-line intersection matrix and 
!                 problem vector  ---
!
                  AJ(1,1) = XTP_CW(1,NICW)-XTP_CW(2,NICW)
                  AJ(2,1) = YTP_CW(1,NICW)-YTP_CW(2,NICW)
                  AJ(3,1) = ZTP_CW(1,NICW)-ZTP_CW(2,NICW)
                  AJ(1,2) = XPX(N1X(NT))-XPX(5)
                  AJ(2,2) = YPX(N1X(NT))-YPX(5)
                  AJ(3,2) = ZPX(N1X(NT))-ZPX(5)
                  AJ(1,3) = XPX(N2X(NT))-XPX(5)
                  AJ(2,3) = YPX(N2X(NT))-YPX(5)
                  AJ(3,3) = ZPX(N2X(NT))-ZPX(5)
                  BJ(1) = XTP_CW(1,NICW)-XPX(5)
                  BJ(2) = YTP_CW(1,NICW)-YPX(5)
                  BJ(3) = ZTP_CW(1,NICW)-ZPX(5)
!
!---              Check for no intersection  ---
!
                  DO 210 IP = 1,3
                    AAMAX = 0.D+0
                    DO 202 JP = 1,3
                      IF( ABS(AJ(IP,JP)).GT.AAMAX ) 
     &                  AAMAX = ABS(AJ(IP,JP))
  202               CONTINUE
!
!---                No intersection go to next triangle on the 
!                   surface  ---
!
                    IF( ABS(AAMAX)/EPSL.LT.EPSL ) GOTO 220
  210             CONTINUE
!
!---              Find plane-line intersection matrix inverse  ---
!
                  JP = 3
                  KP = 3
                  CALL LU_DCMP( AJ,JP,KP,IJ,DJ )
                  CALL LU_BKSB( AJ,JP,KP,IJ,BJ )
!
!---              Find plane-line intersection point  ---
!
                  TX = BJ(1)
                  UX = BJ(2)
                  VX = BJ(3)
                  IF( ABS(TX).LT.EPSL ) TX = 0.D+0
                  IF( ABS(UX).LT.EPSL ) UX = 0.D+0
                  IF( ABS(VX).LT.EPSL ) VX = 0.D+0
!
!---              Line crosses surface, within the triangle  ---
!
                  IF( TX.GE.0.D+0 .AND. TX.LE.1.D+0 .AND.
     &              UX.GE.0.D+0 .AND. UX.LE.1.D+0 .AND. 
     &              VX.GE.0.D+0 .AND. VX.LE.1.D+0 .AND.
     &              (UX+VX).LE.1.D+0 ) THEN
                    XTX = XTP_CW(1,NICW)
     &                + (XTP_CW(2,NICW)-XTP_CW(1,NICW))*TX
                    YTX = YTP_CW(1,NICW)
     &                + (YTP_CW(2,NICW)-YTP_CW(1,NICW))*TX
                    ZTX = ZTP_CW(1,NICW)
     &                + (ZTP_CW(2,NICW)-ZTP_CW(1,NICW))*TX
!
!---                Check for non-distinct points  ---
!
                    IF( NC.GE.1 ) THEN
                      DO 212 NDP = 1,NC
                        DPX = SQRT( ((XTX-XIX(NDP))**2) 
     &                    + ((YTX-YIX(NDP))**2) + ((ZTX-ZIX(NDP))**2) )
!
!---                    Duplicate point found  ---
!
                        IF( DPX.LT.EPSLX ) GOTO 214
  212                 CONTINUE
                    ENDIF
                    IF( NC.EQ.2 ) THEN
                      INDX = 7
                      CHMSG = 'Three Distinct Coupled Well Points'
     &                  //  ' at Node'
                      IMSG = NX
                      CALL WRMSGP( INDX )
                    ENDIF
                    NC = NC + 1
                    XIX(NC) = XTX
                    YIX(NC) = YTX
                    ZIX(NC) = ZTX
                  ENDIF
  214             CONTINUE
  220           CONTINUE
  230         CONTINUE
  232         CONTINUE
!
!---          Check that two well points are distinct  ---
!
              DPX = 0.D+0
              IF( NC.EQ.2 ) THEN
                DPX = SQRT( ((XIX(2)-XIX(1))**2) + ((YIX(2)-YIX(1))**2)
     &            + ((ZIX(2)-ZIX(1))**2) )
              ENDIF
!
!---          Two distinct well points  ---
!
              IF( NC.EQ.2 .AND. DPX.GT.EPSLX ) THEN
!
!---            Cylindrical coordinates with azimuthal symmetry  ---
!
                IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) GOTO 362
!
!---            Check if line between well points is contained in
!               a node surface plane, loop over node surfaces,
!               (bottom,south,west,east,north,top)  ---
!
                DO 360 NS = 1,6
!
!---              Define the five surface points, four corners
!                 and one centroid---
!
                  DO 352 NP = 1,4
                    MX = MSX(NP,NS)
!
!---                Cylindrical coordinates---
!
                    IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                      XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                      YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                      ZPX(NP) = ZE(MX,NX)
                    ELSE
                      XPX(NP) = XE(MX,NX)
                      YPX(NP) = YE(MX,NX)
                      ZPX(NP) = ZE(MX,NX)
                    ENDIF
  352             CONTINUE
                  NP = 4
                  CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &              XPX(5),YPX(5),ZPX(5) )
!
!---              Loop over the four triangular planes on the 
!                 surface face  ---
!
                  DO 358 NT = 1,4
!
!---                Loop over trajectory points  ---
!
                    DO 356 NPT = 1,2
!
!---                  Load point-plane matrix  ---
!
                      AJ(1,1) = XIX(NPT)-XPX(5)
                      AJ(2,1) = XIX(NPT)-XPX(N1X(NT))
                      AJ(3,1) = XIX(NPT)-XPX(N2X(NT))
                      AJ(1,2) = YIX(NPT)-YPX(5)
                      AJ(2,2) = YIX(NPT)-YPX(N1X(NT))
                      AJ(3,2) = YIX(NPT)-YPX(N2X(NT))
                      AJ(1,3) = ZIX(NPT)-ZPX(5)
                      AJ(2,3) = ZIX(NPT)-ZPX(N1X(NT))
                      AJ(3,3) = ZIX(NPT)-ZPX(N2X(NT))
!
!---                  Check for singular matrix  ---
!
                      DO 310 IP = 1,3
                        AAMAX = 0.D+0
                        DO 302 JP = 1,3
                          IF( ABS(AJ(IP,JP)).GT.AAMAX ) 
     &                    AAMAX = ABS(AJ(IP,JP))
  302                   CONTINUE
!
!---                    Singular matrix, trajectory point is within
!                       the surface plane  ---
!
                        IF( ABS(AAMAX)/EPSL.LT.EPSL ) GOTO 356
  310                 CONTINUE
!
!---                  Find matrix determinant  ---
!
                      JP = 3
                      KP = 3
                      CALL LU_DCMP( AJ,JP,KP,IJ,DJ )
                      DO 354 M = 1,JP
                        DJ = DJ*AJ(M,M)
  354                 CONTINUE
!
!---                  If determinant equals zero trajectory point
!                     is within the surface plane  ---
!
                      IF( ABS(DJ).GT.EPSL ) GOTO 358
  356               CONTINUE
                    INDX = 7
                    CHMSG = 'Both Well Trajectory Points within '
     &                //  'Surface Plane for Well Number'
                    IMSG = NCW
                    CALL WRMSGP( INDX )
  358             CONTINUE
  360           CONTINUE
  362           CONTINUE
!
!---            Loop over current well nodes, where the most recent
!               well node is first in the list order  ---
!
                WN_CURR_PTR => WN_CW_PTR
                DO 370 NWN = 1,LWN_CW-NWN_CW
!                DO 370 NWN = 1,LWN_CW
!
!---              Well node previously counted  ---
!
                  IF( WN_CURR_PTR%IWN_CW.EQ.NX ) THEN
                    GOTO 372
                  ENDIF
                  WN_CURR_PTR => WN_CURR_PTR%NEXT
  370           CONTINUE
!
!---            Increment the number of field nodes with
!               coupled-well nodes  ---
!
                LWF_CW = LWF_CW + 1
  372           CONTINUE
!
!---            Increment the number of well nodes  ---
!
                LWN_CW = LWN_CW + 1
                IFNDX = 1
!
!---            Allocate memory for new well node element  ---
!
                ALLOCATE( WN_TMP_PTR,STAT=ISTAT )
                IF( ISTAT.NE.0 ) THEN
                  INDX = 3
                  CHMSG = 'Allocation Error: WN_TMP_PTR'
                  CALL WRMSGP( INDX )
                ENDIF
                WN_TMP_PTR%IWN_CW = NX
                WN_TMP_PTR%XP1_CW = XIX(1)
                WN_TMP_PTR%YP1_CW = YIX(1)
                WN_TMP_PTR%ZP1_CW = ZIX(1)
                WN_TMP_PTR%XP2_CW = XIX(2)
                WN_TMP_PTR%YP2_CW = YIX(2)
                WN_TMP_PTR%ZP2_CW = ZIX(2)
                WN_TMP_PTR%NEXT => WN_CW_PTR
                WN_CW_PTR => WN_TMP_PTR
              ENDIF
            ENDDO
            ENDDO
            ENDDO
  480     CONTINUE
          IF( IFNDX.EQ.0 ) THEN
            INDX = 7
            CHMSG = 'Well Interval not Found within Domain: ' //
     &        'Well Interval = '
            IMSG = NICW
            CALL WRMSGP( INDX )
          ENDIF
  490   CONTINUE
        ID_CW(4,NCW) = LWN_CW
        ID_CW(6,NCW) = LWF_CW
  600 CONTINUE
!
!---  Allocate memory for coupled-well well-node index array  ---
!
      ALLOCATE( IWN_CW(1:LWN_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IWN_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for field-node with coupled-well nodes
!     index array  ---
!
      ALLOCATE( IWF_CW(1:LWF_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IWF_CW'
        CALL WRMSGP( INDX )
      ENDIF
      DO 610 NWF = 1,LWF_CW
        IWF_CW(NWF) = 0
  610 CONTINUE
!
!---  Allocate memory for the coupled-well x-projection array  ---
!
      ALLOCATE( XP_CW(1:2,1:LWN_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XP_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the coupled-well y-projection array  ---
!
      ALLOCATE( YP_CW(1:2,1:LWN_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YP_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the coupled-well z-projection array  ---
!
      ALLOCATE( ZP_CW(1:2,1:LWN_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZP_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load coupled-well well-node index array  ---
!
      WN_CURR_PTR => WN_CW_PTR
      DO 620 NWN = 1,LWN_CW
        M = LWN_CW-NWN+1
        IWN_CW(M) = WN_CURR_PTR%IWN_CW
        XP_CW(1,M) = WN_CURR_PTR%XP1_CW
        XP_CW(2,M) = WN_CURR_PTR%XP2_CW
        YP_CW(1,M) = WN_CURR_PTR%YP1_CW
        YP_CW(2,M) = WN_CURR_PTR%YP2_CW
        ZP_CW(1,M) = WN_CURR_PTR%ZP1_CW
        ZP_CW(2,M) = WN_CURR_PTR%ZP2_CW
        WN_CURR_PTR => WN_CURR_PTR%NEXT
  620 CONTINUE
!
!---  Loop over coupled wells ---
!
      NC = 0
      DO 700 NCW = 1,LN_CW
!
!---    Sequence well nodes according to their distance from
!       the starting point of the well  ---
!
        I1X = ID_CW(1,NCW)
        I3X = ID_CW(3,NCW)
        I4X = ID_CW(4,NCW)
  630   CONTINUE
        DMNX = 1.D+20
        DO 640 KCW = I3X,I4X
          XWPX = 5.D-1*(XP_CW(1,KCW)+XP_CW(2,KCW))
          YWPX = 5.D-1*(YP_CW(1,KCW)+YP_CW(2,KCW))
          ZWPX = 5.D-1*(ZP_CW(1,KCW)+ZP_CW(2,KCW))
          DISTX = SQRT( (XTP_CW(1,I1X)-XWPX)**2 +
     &      (YTP_CW(1,I1X)-YWPX)**2 + (ZTP_CW(1,I1X)-ZWPX)**2 )
          IF( DISTX.LT.DMNX ) THEN
            DMNX = DISTX
            IMNX = KCW
            IWNX = IWN_CW(KCW)
            XIX(1) = XP_CW(1,KCW)
            XIX(2) = XP_CW(2,KCW)
            YIX(1) = YP_CW(1,KCW)
            YIX(2) = YP_CW(2,KCW)
            ZIX(1) = ZP_CW(1,KCW)
            ZIX(2) = ZP_CW(2,KCW)
          ENDIF
  640   CONTINUE
        DO 650 JCW = I4X,I3X,-1
          IF( JCW.LT.IMNX ) THEN
            IWN_CW(JCW+1) = IWN_CW(JCW)
            XP_CW(1,JCW+1) = XP_CW(1,JCW)
            XP_CW(2,JCW+1) = XP_CW(2,JCW)
            YP_CW(1,JCW+1) = YP_CW(1,JCW)
            YP_CW(2,JCW+1) = YP_CW(2,JCW)
            ZP_CW(1,JCW+1) = ZP_CW(1,JCW)
            ZP_CW(2,JCW+1) = ZP_CW(2,JCW)
          ENDIF
  650   CONTINUE
        IWN_CW(I3X) = IWNX
        XP_CW(1,I3X) = XIX(1)
        XP_CW(2,I3X) = XIX(2)
        YP_CW(1,I3X) = YIX(1)
        YP_CW(2,I3X) = YIX(2)
        ZP_CW(1,I3X) = ZIX(1)
        ZP_CW(2,I3X) = ZIX(2)
        I3X = I3X+1
        IF( I3X.LT.I4X ) GOTO 630
!
!---    Sequence well node points according to their distance from
!       the starting point of the well  ---
!
        I1X = ID_CW(1,NCW)
        I3X = ID_CW(3,NCW)
        I4X = ID_CW(4,NCW)
        DO 652 KCW = I3X,I4X
          DIST1X = SQRT( (XTP_CW(1,I1X)-XP_CW(1,KCW))**2 +
     &      (YTP_CW(1,I1X)-YP_CW(1,KCW))**2 + 
     &      (ZTP_CW(1,I1X)-ZP_CW(1,KCW))**2 )
          DIST2X = SQRT( (XTP_CW(1,I1X)-XP_CW(2,KCW))**2 +
     &      (YTP_CW(1,I1X)-YP_CW(2,KCW))**2 + 
     &      (ZTP_CW(1,I1X)-ZP_CW(2,KCW))**2 )
          IF( DIST1X.GT.DIST2X ) THEN
            XIX(2) = XP_CW(1,KCW)
            YIX(2) = YP_CW(1,KCW)
            ZIX(2) = ZP_CW(1,KCW)
            XP_CW(1,KCW) = XP_CW(2,KCW)
            YP_CW(1,KCW) = YP_CW(2,KCW)
            ZP_CW(1,KCW) = ZP_CW(2,KCW)
            XP_CW(2,KCW) = XIX(2)
            YP_CW(2,KCW) = YIX(2)
            ZP_CW(2,KCW) = ZIX(2)
          ENDIF
  652   CONTINUE
!
!---    Load array for field nodes that contain coupled-well nodes  ---
!
        MC = 0
        DO 670 KCW = ID_CW(3,NCW),ID_CW(4,NCW)
          N = IWN_CW(KCW)
          DO 660 JCW = ID_CW(5,NCW),ID_CW(5,NCW)-1+MC
            IF( IWF_CW(JCW).EQ.N ) GOTO 662
  660     CONTINUE
          MC = MC + 1
          NC = NC + 1
          IWF_CW(NC) = N
  662     CONTINUE
  670   CONTINUE
  700 CONTINUE
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CHK_CW group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CHK_LW
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!
!     STOMP-CO2
!
!     Define well nodes, determine trajectory points, and 
!     check for well trajectories within node surface planes
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 31 March 2011.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE LEAK_WELL
      USE GRID
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 XPX(5),YPX(5),ZPX(5)
      REAL*8 XIX(2),YIX(2),ZIX(2)
      REAL*8 PAX(3),PBX(3),PCX(3),PBCX(3)
      REAL*8 AJ(3,3),BJ(3)
      INTEGER IJ(3)
      INTEGER MSX(4,6)
      INTEGER N1X(4),N2X(4)
      TYPE(LIST_WELL_NODE), POINTER :: WN_CURR_PTR,WN_TMP_PTR
!
!----------------------Data Statements---------------------------------!
!
      SAVE MSX,N1X,N2X
      DATA MSX / 1,2,4,3,1,5,6,2,1,3,7,5,2,6,8,4,3,4,8,7,5,7,8,6 /
      DATA N1X / 2,3,4,1 /
      DATA N2X / 1,2,3,4 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CHK_LW'
      NULLIFY( WN_LW_PTR )
      EPSLX = 1.D-12
!
!---  Loop over leaky wells ---
!
      DO 600 NLW = 1,LN_LW
        ID_LW(3,NLW) = LWN_LW + 1
        ID_LW(5,NLW) = LWF_LW + 1
        NWN_LW = LWN_LW
        NWF_LW = LWF_LW
!
!---    Loop over number of well intervals  ---
!
        DO 490 NICW = ID_LW(1,NLW),ID_LW(2,NLW)
          IFNDX = 0
!
!---      Loop over active nodes to find well nodes and well
!         projections ---
!
          DO 480 N = 1,LFD-LBR-LWN_LW
            IF( IXP(N).EQ.0 ) GOTO 480
            I = ID(N)
            J = JD(N)
            K = KD(N)
            NC = 0
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO KX = 1,KRX
            DO JX = 1,JRX
            DO IX = 1,IRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NC = 0
!
!---          Determine whether the transition points are within
!             the hexahedron node volume or on the hexahedron
!             surfaces  ---
!
              DO 190 NPT = 1,2
!
!---            Cylindrical coordinates with azimuthal symmetry,
!               centrally located wells  ---
!
                IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1
     &            .AND. I.EQ.1 ) THEN
                  XPX(1) = 0.D+0
                  XPX(2) = 0.D+0
                  YPX(1) = 0.D+0
                  YPX(2) = 0.D+0
                  ZPX(1) = ZE(1,NX)
                  ZPX(2) = ZE(5,NX)
!
!---              Node height greater than EPSLX  ---
!
                  IF( ABS(ZPX(1)-ZPX(2)).GT.EPSLX ) THEN
                    DZPX1 = ZTP_LW(NPT,NICW)-ZPX(1)
                    DZPX2 = ZPX(2)-ZTP_LW(NPT,NICW)
                    IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                    IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
!
!---                Transition point within vertical limits of node  ---
!
                    IF( DZPX1.GE.0.D+0 .AND. DZPX2.GE.0.D+0 ) THEN
                      NC = NC+1
                      XIX(NC) = 0.D+0
                      YIX(NC) = 0.D+0
                      ZIX(NC) = ZTP_LW(NPT,NICW)
                    ENDIF
                  ENDIF
                  GOTO 190
                ENDIF
!
!---            Loop over node surfaces,
!               (bottom,south,west,east,north,top)  ---
!
                ICWX = 0
                DO 180 NS = 1,6
!
!---              Define the five surface points, four corners
!                 and one centroid---
!
                  DO 110 NP = 1,4
                    MX = MSX(NP,NS)
!
!---                Cylindrical coordinates  ---
!
                    IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                      XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                      YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                      ZPX(NP) = ZE(MX,NX)
                    ELSE
                      XPX(NP) = XE(MX,NX)
                      YPX(NP) = YE(MX,NX)
                      ZPX(NP) = ZE(MX,NX)
                    ENDIF
  110             CONTINUE
                  NP = 4
                  CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &              XPX(5),YPX(5),ZPX(5) )
!
!---              Loop over the four triangular planes on the 
!                 surface face  ---
!
                  DO 130 NT = 1,4
!
!---                Built vectors between transition point
!                   and triangular plane points  ---
!
                    PAX(1) = XPX(5)-XTP_LW(NPT,NICW)
                    PAX(2) = YPX(5)-YTP_LW(NPT,NICW)
                    PAX(3) = ZPX(5)-ZTP_LW(NPT,NICW)
                    PBX(1) = XPX(N1X(NT))-XTP_LW(NPT,NICW)
                    PBX(2) = YPX(N1X(NT))-YTP_LW(NPT,NICW)
                    PBX(3) = ZPX(N1X(NT))-ZTP_LW(NPT,NICW)
                    PCX(1) = XPX(N2X(NT))-XTP_LW(NPT,NICW)
                    PCX(2) = YPX(N2X(NT))-YTP_LW(NPT,NICW)
                    PCX(3) = ZPX(N2X(NT))-ZTP_LW(NPT,NICW)
                    CALL VCROSSP( PBX,PCX,PBCX )
                    SX = VDOTP( PAX,PBCX )
!
!---                Clockwise rotation  ---
!
                    IF( SX.GT.EPSL ) THEN
!
!---                  Opposing rotations found, point outside 
!                     hexaheron  ---
!
                      IF( ICWX.EQ.-1 ) THEN
                        GOTO 190
!
!---                  Similar rotations found, continue searching  ---
!
                      ELSE
                        ICWX = 1
                      ENDIF
!
!---                Counterclockwise rotation  ---
!
                    ELSEIF( SX.LT.-EPSL ) THEN
!
!---                  Opposing rotations found, point outside 
!                     hexaheron  ---
!
                      IF( ICWX.EQ.1 ) THEN
                        GOTO 190
!
!---                  Similar rotations found, continue searching  ---
!
                      ELSE
                        ICWX = -1
                      ENDIF
                    ENDIF
  130             CONTINUE
  180           CONTINUE            
!
!---            No opposing rotations found, point inside 
!               hexahedron  ---
!
                NC = NC+1
                XIX(NC) = XTP_LW(NPT,NICW)
                YIX(NC) = YTP_LW(NPT,NICW)
                ZIX(NC) = ZTP_LW(NPT,NICW)
  190         CONTINUE
!
!---          Both transition points inside hexahedron, skip
!             search for well path crossing hexahedron surfaces  ---
!
              IF( NC.EQ.2 ) GOTO 232
!
!---          Cylindrical coordinates with azimuthal symmetry,
!             centrally located wells  ---
!
              IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1
     &          .AND. I.EQ.1 ) THEN
!
!---            Interval crosses lower node surface  ---
!
                DZPX1 = ZPX(1)-ZTP_LW(1,NICW)
                IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                DZPX2 = ZPX(1)-ZTP_LW(2,NICW)
                IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
                IF( (DZPX1*DZPX2).LT.-EPSLX ) THEN
                  NC = NC+1
                  XIX(NC) = 0.D+0
                  YIX(NC) = 0.D+0
                  ZIX(NC) = ZPX(1)
                ENDIF
!
!---            Interval crosses upper node surface  ---
!
                DZPX1 = ZPX(2)-ZTP_LW(1,NICW)
                IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                DZPX2 = ZPX(2)-ZTP_LW(2,NICW)
                IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
                IF( (DZPX1*DZPX2).LT.-EPSLX ) THEN
                  NC = NC+1
                  XIX(NC) = 0.D+0
                  YIX(NC) = 0.D+0
                  ZIX(NC) = ZPX(2)
                ENDIF
                GOTO 232
              ENDIF
!
!---          Loop over node surfaces,
!             (bottom,south,west,east,north,top)  ---
!
              DO 230 NS = 1,6
!
!---            Define the five surface points, four corners
!               and one centroid---
!
                DO 200 NP = 1,4
                  MX = MSX(NP,NS)
!
!---              Cylindrical coordinates---
!
                  IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                    XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                    YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                    ZPX(NP) = ZE(MX,NX)
                  ELSE
                    XPX(NP) = XE(MX,NX)
                    YPX(NP) = YE(MX,NX)
                    ZPX(NP) = ZE(MX,NX)
                  ENDIF
  200           CONTINUE
                NP = 4
                CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &            XPX(5),YPX(5),ZPX(5) )
!
!
!---            Loop over the four triangular planes on the 
!               surface face  ---
!
                DO 220 NT = 1,4
!
!---              Load plane-line intersection matrix and 
!                 problem vector  ---
!
                  AJ(1,1) = XTP_LW(1,NICW)-XTP_LW(2,NICW)
                  AJ(2,1) = YTP_LW(1,NICW)-YTP_LW(2,NICW)
                  AJ(3,1) = ZTP_LW(1,NICW)-ZTP_LW(2,NICW)
                  AJ(1,2) = XPX(N1X(NT))-XPX(5)
                  AJ(2,2) = YPX(N1X(NT))-YPX(5)
                  AJ(3,2) = ZPX(N1X(NT))-ZPX(5)
                  AJ(1,3) = XPX(N2X(NT))-XPX(5)
                  AJ(2,3) = YPX(N2X(NT))-YPX(5)
                  AJ(3,3) = ZPX(N2X(NT))-ZPX(5)
                  BJ(1) = XTP_LW(1,NICW)-XPX(5)
                  BJ(2) = YTP_LW(1,NICW)-YPX(5)
                  BJ(3) = ZTP_LW(1,NICW)-ZPX(5)
!
!---              Check for no intersection  ---
!
                  DO 210 IP = 1,3
                    AAMAX = 0.D+0
                    DO 202 JP = 1,3
                      IF( ABS(AJ(IP,JP)).GT.AAMAX ) 
     &                  AAMAX = ABS(AJ(IP,JP))
  202               CONTINUE
!
!---                No intersection go to next triangle on the 
!                   surface  ---
!
                    IF( ABS(AAMAX)/EPSL.LT.EPSL ) GOTO 220
  210             CONTINUE
!
!---              Find plane-line intersection matrix inverse  ---
!
                  JP = 3
                  KP = 3
                  CALL LU_DCMP( AJ,JP,KP,IJ,DJ )
                  CALL LU_BKSB( AJ,JP,KP,IJ,BJ )
!
!---              Find plane-line intersection point  ---
!
                  TX = BJ(1)
                  UX = BJ(2)
                  VX = BJ(3)
                  IF( ABS(TX).LT.EPSL ) TX = 0.D+0
                  IF( ABS(UX).LT.EPSL ) UX = 0.D+0
                  IF( ABS(VX).LT.EPSL ) VX = 0.D+0
!
!---              Line crosses surface, within the triangle  ---
!
                  IF( TX.GE.0.D+0 .AND. TX.LE.1.D+0 .AND.
     &              UX.GE.0.D+0 .AND. UX.LE.1.D+0 .AND. 
     &              VX.GE.0.D+0 .AND. VX.LE.1.D+0 .AND.
     &              (UX+VX).LE.1.D+0 ) THEN
                    XTX = XTP_LW(1,NICW)
     &                + (XTP_LW(2,NICW)-XTP_LW(1,NICW))*TX
                    YTX = YTP_LW(1,NICW)
     &                + (YTP_LW(2,NICW)-YTP_LW(1,NICW))*TX
                    ZTX = ZTP_LW(1,NICW)
     &                + (ZTP_LW(2,NICW)-ZTP_LW(1,NICW))*TX
!
!---                Check for non-distinct points  ---
!
                    IF( NC.GE.1 ) THEN
                      DO 212 NDP = 1,NC
                        DPX = SQRT( ((XTX-XIX(NDP))**2) 
     &                    + ((YTX-YIX(NDP))**2) + ((ZTX-ZIX(NDP))**2) )
!
!---                    Duplicate point found  ---
!
                        IF( DPX.LT.EPSLX ) GOTO 214
  212                 CONTINUE
                    ENDIF
                    IF( NC.EQ.2 ) THEN
                      INDX = 7
                      CHMSG = 'Three Distinct Coupled Well Points'
     &                  //  ' at Node'
                      IMSG = NX
                      CALL WRMSGP( INDX )
                    ENDIF
                    NC = NC + 1
                    XIX(NC) = XTX
                    YIX(NC) = YTX
                    ZIX(NC) = ZTX
                  ENDIF
  214             CONTINUE
  220           CONTINUE
  230         CONTINUE
  232         CONTINUE
!
!---          Check that two well points are distinct  ---
!
              DPX = 0.D+0
              IF( NC.EQ.2 ) THEN
                DPX = SQRT( ((XIX(2)-XIX(1))**2) + ((YIX(2)-YIX(1))**2)
     &            + ((ZIX(2)-ZIX(1))**2) )
              ENDIF
!
!---          Two distinct well points  ---
!
              IF( NC.EQ.2 .AND. DPX.GT.EPSLX ) THEN
!
!---            Cylindrical coordinates with azimuthal symmetry  ---
!
                IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) GOTO 362
!
!---            Check if line between well points is contained in
!               a node surface plane, loop over node surfaces,
!               (bottom,south,west,east,north,top)  ---
!
                DO 360 NS = 1,6
!
!---              Define the five surface points, four corners
!                 and one centroid---
!
                  DO 352 NP = 1,4
                    MX = MSX(NP,NS)
!
!---                Cylindrical coordinates---
!
                    IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                      XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
                      YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
                      ZPX(NP) = ZE(MX,NX)
                    ELSE
                      XPX(NP) = XE(MX,NX)
                      YPX(NP) = YE(MX,NX)
                      ZPX(NP) = ZE(MX,NX)
                    ENDIF
  352             CONTINUE
                  NP = 4
                  CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &              XPX(5),YPX(5),ZPX(5) )
!
!---              Loop over the four triangular planes on the 
!                 surface face  ---
!
                  DO 358 NT = 1,4
!
!---                Loop over trajectory points  ---
!
                    DO 356 NPT = 1,2
!
!---                  Load point-plane matrix  ---
!
                      AJ(1,1) = XIX(NPT)-XPX(5)
                      AJ(2,1) = XIX(NPT)-XPX(N1X(NT))
                      AJ(3,1) = XIX(NPT)-XPX(N2X(NT))
                      AJ(1,2) = YIX(NPT)-YPX(5)
                      AJ(2,2) = YIX(NPT)-YPX(N1X(NT))
                      AJ(3,2) = YIX(NPT)-YPX(N2X(NT))
                      AJ(1,3) = ZIX(NPT)-ZPX(5)
                      AJ(2,3) = ZIX(NPT)-ZPX(N1X(NT))
                      AJ(3,3) = ZIX(NPT)-ZPX(N2X(NT))
!
!---                  Check for singular matrix  ---
!
                      DO 310 IP = 1,3
                        AAMAX = 0.D+0
                        DO 302 JP = 1,3
                          IF( ABS(AJ(IP,JP)).GT.AAMAX ) 
     &                    AAMAX = ABS(AJ(IP,JP))
  302                   CONTINUE
!
!---                    Singular matrix, trajectory point is within
!                       the surface plane  ---
!
                        IF( ABS(AAMAX)/EPSL.LT.EPSL ) GOTO 356
  310                 CONTINUE
!
!---                  Find matrix determinant  ---
!
                      JP = 3
                      KP = 3
                      CALL LU_DCMP( AJ,JP,KP,IJ,DJ )
                      DO 354 M = 1,JP
                        DJ = DJ*AJ(M,M)
  354                 CONTINUE
!
!---                  If determinant equals zero trajectory point
!                     is within the surface plane  ---
!
                      IF( ABS(DJ).GT.EPSL ) GOTO 358
  356               CONTINUE
                    INDX = 7
                    CHMSG = 'Both Well Trajectory Points within '
     &                //  'Surface Plane for Well Number'
                    IMSG = NLW
                    CALL WRMSGP( INDX )
  358             CONTINUE
  360           CONTINUE
  362           CONTINUE
!
!---            Loop over current well nodes, where the most recent
!               well node is first in the list order  ---
!
                WN_CURR_PTR => WN_LW_PTR
                DO 370 NWN = 1,LWN_LW-NWN_LW
!                DO 370 NWN = 1,LWN_LW
!
!---              Well node previously counted  ---
!
                  IF( WN_CURR_PTR%IWN_CW.EQ.NX ) THEN
                    GOTO 372
                  ENDIF
                  WN_CURR_PTR => WN_CURR_PTR%NEXT
  370           CONTINUE
!
!---            Increment the number of field nodes with
!               leaky well nodes  ---
!
                LWF_LW = LWF_LW + 1
  372           CONTINUE
!
!---            Increment the number of well nodes  ---
!
                LWN_LW = LWN_LW + 1
                IFNDX = 1
!
!---            Allocate memory for new well node element  ---
!
                ALLOCATE( WN_TMP_PTR,STAT=ISTAT )
                IF( ISTAT.NE.0 ) THEN
                  INDX = 3
                  CHMSG = 'Allocation Error: WN_TMP_PTR'
                  CALL WRMSGP( INDX )
                ENDIF
                WN_TMP_PTR%IWN_CW = NX
                WN_TMP_PTR%XP1_CW = XIX(1)
                WN_TMP_PTR%YP1_CW = YIX(1)
                WN_TMP_PTR%ZP1_CW = ZIX(1)
                WN_TMP_PTR%XP2_CW = XIX(2)
                WN_TMP_PTR%YP2_CW = YIX(2)
                WN_TMP_PTR%ZP2_CW = ZIX(2)
                WN_TMP_PTR%NEXT => WN_LW_PTR
                WN_LW_PTR => WN_TMP_PTR
              ENDIF
            ENDDO
            ENDDO
            ENDDO
  480     CONTINUE
          IF( IFNDX.EQ.0 ) THEN
            INDX = 7
            CHMSG = 'Well Interval not Found within Domain: ' //
     &        'Well Interval = '
            IMSG = NICW
            CALL WRMSGP( INDX )
          ENDIF
  490   CONTINUE
        ID_LW(4,NLW) = LWN_LW
        ID_LW(6,NLW) = LWF_LW
  600 CONTINUE
!
!---  Allocate memory for leaky well field-node index array  ---
!
      ALLOCATE( ND_LW(1:LWN_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ND_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for leaky well well-node index array  ---
!
      ALLOCATE( NF_LW(1:LWN_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: NF_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for field-node with leaky well nodes
!     index array  ---
!
      ALLOCATE( IWF_LW(1:LWF_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IWF_LW'
        CALL WRMSGP( INDX )
      ENDIF
      DO 610 NWF = 1,LWF_LW
        IWF_LW(NWF) = 0
  610 CONTINUE
!
!---  Allocate memory for the leaky well x-projection array  ---
!
      ALLOCATE( XP_LW(1:2,1:LWN_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XP_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the leaky well y-projection array  ---
!
      ALLOCATE( YP_LW(1:2,1:LWN_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YP_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the leaky well z-projection array  ---
!
      ALLOCATE( ZP_LW(1:2,1:LWN_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZP_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load leaky well well-node index array  ---
!
      WN_CURR_PTR => WN_LW_PTR
      DO 620 NWN = 1,LWN_LW
        M = LWN_LW-NWN+1
        NF_LW(M) = WN_CURR_PTR%IWN_CW
        XP_LW(1,M) = WN_CURR_PTR%XP1_CW
        XP_LW(2,M) = WN_CURR_PTR%XP2_CW
        YP_LW(1,M) = WN_CURR_PTR%YP1_CW
        YP_LW(2,M) = WN_CURR_PTR%YP2_CW
        ZP_LW(1,M) = WN_CURR_PTR%ZP1_CW
        ZP_LW(2,M) = WN_CURR_PTR%ZP2_CW
        WN_CURR_PTR => WN_CURR_PTR%NEXT
  620 CONTINUE
!
!---  Loop over leaky wells ---
!
      NC = 0
      DO 700 NLW = 1,LN_LW
!
!---    Sequence well nodes according to their distance from
!       the starting point of the well  ---
!
        I1X = ID_LW(1,NLW)
        I3X = ID_LW(3,NLW)
        I4X = ID_LW(4,NLW)
  630   CONTINUE
        DMNX = 1.D+20
        DO 640 KLW = I3X,I4X
          XWPX = 5.D-1*(XP_LW(1,KLW)+XP_LW(2,KLW))
          YWPX = 5.D-1*(YP_LW(1,KLW)+YP_LW(2,KLW))
          ZWPX = 5.D-1*(ZP_LW(1,KLW)+ZP_LW(2,KLW))
          DISTX = SQRT( (XTP_LW(1,I1X)-XWPX)**2 +
     &      (YTP_LW(1,I1X)-YWPX)**2 + (ZTP_LW(1,I1X)-ZWPX)**2 )
          IF( DISTX.LT.DMNX ) THEN
            DMNX = DISTX
            IMNX = KLW
            IWNX = NF_LW(KLW)
            XIX(1) = XP_LW(1,KLW)
            XIX(2) = XP_LW(2,KLW)
            YIX(1) = YP_LW(1,KLW)
            YIX(2) = YP_LW(2,KLW)
            ZIX(1) = ZP_LW(1,KLW)
            ZIX(2) = ZP_LW(2,KLW)
          ENDIF
  640   CONTINUE
        DO 650 JLW = I4X,I3X,-1
          IF( JLW.LT.IMNX ) THEN
            NF_LW(JLW+1) = NF_LW(JLW)
            XP_LW(1,JLW+1) = XP_LW(1,JLW)
            XP_LW(2,JLW+1) = XP_LW(2,JLW)
            YP_LW(1,JLW+1) = YP_LW(1,JLW)
            YP_LW(2,JLW+1) = YP_LW(2,JLW)
            ZP_LW(1,JLW+1) = ZP_LW(1,JLW)
            ZP_LW(2,JLW+1) = ZP_LW(2,JLW)
          ENDIF
  650   CONTINUE
        NF_LW(I3X) = IWNX
        XP_LW(1,I3X) = XIX(1)
        XP_LW(2,I3X) = XIX(2)
        YP_LW(1,I3X) = YIX(1)
        YP_LW(2,I3X) = YIX(2)
        ZP_LW(1,I3X) = ZIX(1)
        ZP_LW(2,I3X) = ZIX(2)
        I3X = I3X+1
        IF( I3X.LT.I4X ) GOTO 630
!
!---    Sequence well node points according to their distance from
!       the starting point of the well  ---
!
        I1X = ID_LW(1,NLW)
        I3X = ID_LW(3,NLW)
        I4X = ID_LW(4,NLW)
        DO 652 KLW = I3X,I4X
          DIST1X = SQRT( (XTP_LW(1,I1X)-XP_LW(1,KLW))**2 +
     &      (YTP_LW(1,I1X)-YP_LW(1,KLW))**2 + 
     &      (ZTP_LW(1,I1X)-ZP_LW(1,KLW))**2 )
          DIST2X = SQRT( (XTP_LW(1,I1X)-XP_LW(2,KLW))**2 +
     &      (YTP_LW(1,I1X)-YP_LW(2,KLW))**2 + 
     &      (ZTP_LW(1,I1X)-ZP_LW(2,KLW))**2 )
          IF( DIST1X.GT.DIST2X ) THEN
            XIX(2) = XP_LW(1,KLW)
            YIX(2) = YP_LW(1,KLW)
            ZIX(2) = ZP_LW(1,KLW)
            XP_LW(1,KLW) = XP_LW(2,KLW)
            YP_LW(1,KLW) = YP_LW(2,KLW)
            ZP_LW(1,KLW) = ZP_LW(2,KLW)
            XP_LW(2,KLW) = XIX(2)
            YP_LW(2,KLW) = YIX(2)
            ZP_LW(2,KLW) = ZIX(2)
          ENDIF
  652   CONTINUE
!
!---    Load array for field nodes that contain leaky well nodes  ---
!
        MC = 0
        DO 670 KLW = ID_LW(3,NLW),ID_LW(4,NLW)
          N = NF_LW(KLW)
          DO 660 JLW = ID_LW(5,NLW),ID_LW(5,NLW)-1+MC
            IF( IWF_LW(JLW).EQ.N ) GOTO 662
  660     CONTINUE
          MC = MC + 1
          NC = NC + 1
          IWF_LW(NC) = N
  662     CONTINUE
  670   CONTINUE
  700 CONTINUE
!
!---  Create intermediate leaky well nodes, loop over leaky wells ---
!
      DO NLW = 1,N_LW
!
!---    Loop over well nodes  ---
!
        DO KLW = ID_LW(3,NLW)+1,ID_LW(4,NLW)
!
!---    Identify discontinuous well node sections  ---
!
          DLX = SQRT( (XP_LW(1,KLW)-XP_LW(2,KLW-1))**2 + 
     &      (YP_LW(1,KLW)-YP_LW(2,KLW-1))**2 + 
     &      (ZP_LW(1,KLW)-ZP_LW(2,KLW-1))**2 )
          IF( DLX.GT.1.D-9 ) THEN
!
!---        Determine the well intervals of the two points  ---
!
            INV1X = 0
            INV2X = 0
            DO NILW = ID_LW(1,NLW),ID_LW(2,NLW)
              XMAX = MAX(XTP_LW(1,NILW),XTP_LW(2,NILW))
              XMIN = MIN(XTP_LW(1,NILW),XTP_LW(2,NILW))
              YMAX = MAX(YTP_LW(1,NILW),YTP_LW(2,NILW))
              YMIN = MIN(YTP_LW(1,NILW),YTP_LW(2,NILW))
              ZMAX = MAX(ZTP_LW(1,NILW),ZTP_LW(2,NILW))
              ZMIN = MIN(ZTP_LW(1,NILW),ZTP_LW(2,NILW))
              IF( XP_LW(1,KLW).GE.XMIN .AND. 
     &          XP_LW(1,KLW).LE.XMAX .AND.
     &          YP_LW(1,KLW).GE.YMIN .AND. 
     &          YP_LW(1,KLW).LE.YMAX .AND.
     &          ZP_LW(1,KLW).GE.ZMIN .AND. 
     &          ZP_LW(1,KLW).LE.ZMAX ) INV1X = NILW
              IF( XP_LW(2,KLW-1).GE.XMIN .AND. 
     &          XP_LW(2,KLW-1).LE.XMAX .AND.
     &          YP_LW(2,KLW-1).GE.YMIN .AND. 
     &          YP_LW(2,KLW-1).LE.YMAX .AND.
     &          ZP_LW(2,KLW-1).GE.ZMIN .AND. 
     &          ZP_LW(2,KLW-1).LE.ZMAX ) INV2X = NILW
            ENDDO
!
!---        Discontinuity found within an interval  ---
!
            IF( INV1X.EQ.INV2X ) THEN
              LWN_LW = LWN_LW + INT(DLX/PAR_LW(3,INV1X)) + 1
!
!---        Discontinuity between intervals  ---
!
            ELSE
              DL1X = SQRT( (XTP_LW(2,INV2X)-XP_LW(2,KLW-1))**2 + 
     &          (YTP_LW(2,INV2X)-YP_LW(2,KLW-1))**2 + 
     &          (ZTP_LW(2,INV2X)-ZP_LW(2,KLW-1))**2 )
              DL2X = SQRT( (XTP_LW(1,INV1X)-XP_LW(1,KLW))**2 + 
     &          (YTP_LW(1,INV1X)-YP_LW(1,KLW))**2 + 
     &          (ZTP_LW(1,INV1X)-ZP_LW(1,KLW))**2 )
              IF( DL1X.GT.1.D-9 ) LWN_LW = LWN_LW + 
     &          INT(DL1X/PAR_LW(3,INV1X)) + 1
              IF( DL2X.GT.1.D-9 ) LWN_LW = LWN_LW + 
     &          INT(DL2X/PAR_LW(3,INV2X)) + 1
            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
!---  Leaky well nodes occur after field nodes  ---
!
      N = LFX*LFY*LFZ
!
!---  Loop over number of leaky wells  ---
!
      DO NLW = 1,N_LW
!
!---    Loop over number of leaky well nodes in the leaky well  ---
!
        DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
          N = N + 1
          ND_LW(NWN) = N
        ENDDO
      ENDDO
!
!---  Include leaky well nodes in field node parameter  ---
!
      LFD = LFD + LWN_LW
      LAN = LAN + LWN_LW
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CHK_LW group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Fill double precision variable VAR with data between commas.
!     Return default value or zero for null entries.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, November 1992.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) CHDUM
      CHARACTER*6 FORM1
      CHARACTER*7 FORM2
!
!----------------------Data Statements---------------------------------!
!
      SAVE FORM1,FORM2
      DATA FORM1 /'(D .0)'/
      DATA FORM2 /'(D  .0)'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CHK_DPR'
      IDFLTD = 0
      ICD = INDEX( CARD,'  ')-1
      IVR = INDEX( VARB,'  ')-1
      ISX = ISTART
      ICX = ICOMMA
      INDX = 0
!
!---  End of card record error ---
!
      IF( CHDUM(1:1) .EQ. '~' ) THEN
        INDX = 4
        CHMSG = 'End of Card Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Find next comma  ---
!
      ICOMMA = INDEX (CHDUM(ISTART:), ',') + ISTART - 1
      ISTOP = ICOMMA
  100 CONTINUE
!
!---  Comma not found, missing real data  ---
!
      IF( ISTOP.LT.ISTART ) THEN
        GOTO 200
!
!---  Null entry  ---
!
      ELSEIF( ISTOP.EQ.ISTART ) THEN
        INDX = 1
        GOTO 200
!
!---  Characters between commas  ---
!
      ELSE
!
!---  Eliminate leading blank spaces  ---
!
        IF( ICHAR(CHDUM(ISTART:ISTART)).EQ.32 ) THEN
          ISTART = ISTART+1
          GOTO 100
        ENDIF
!
!---  Eliminate trailing blank spaces  ---
!
        ISTOP = ISTOP-1
  110   CONTINUE
        IF( ICHAR(CHDUM(ISTOP:ISTOP)).EQ.32 ) THEN
          ISTOP = ISTOP-1
          GOTO 110
        ENDIF
!
!---  Check for scientific notation  ---
!
        IEXP = ISTART-1
        IF( INDEX( CHDUM(ISTART:ISTOP),'e' ).NE.0 ) THEN
          IEXP = INDEX( CHDUM(ISTART:ISTOP),'e' )+ISTART-1
        ELSEIF( INDEX( CHDUM(ISTART:ISTOP),'d' ).NE.0 ) THEN
          IEXP = INDEX( CHDUM(ISTART:ISTOP),'d' )+ISTART-1
        ENDIF
        IPER = INDEX( CHDUM(ISTART:ISTOP),'.' )+ISTART-1
!
!---  Check for non-numerical characters  ---
!
        DO 120 N = ISTART,ISTOP
          IF( N.EQ.IEXP .OR. N.EQ.IPER ) GOTO 120
          NC = ICHAR(CHDUM(N:N))
          IF( ( N.EQ.ISTART .OR. N.EQ.IEXP+1 ) .AND.
     &      ( NC.EQ.43 .OR. NC.EQ.45 ) ) GOTO 120
          IF( NC.LT.48 .OR. NC.GT.57 ) GOTO 200
  120   CONTINUE
!
!---  Character string recognized as a double precision real  ---
!
        INDX = 1
      ENDIF
  200 CONTINUE
      ISTART = ISX
      ICOMMA = ICX
!
!---  End of CHK_DPR group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CHK_INT( ISTART,ICOMMA,CHDUM,INDX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Fill integer variable IVAR with data between commas.
!     Return default value or zero for null entries.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNNL, November 2000.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) CHDUM
      CHARACTER*4 FORM1
!
!----------------------Data Statements---------------------------------!
!
      SAVE FORM1
      DATA FORM1 /'(I )'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CHK_INT'
      ICD = INDEX( CARD,'  ')-1
      IVR = INDEX( VARB,'  ')-1
      ISX = ISTART
      ICX = ICOMMA
      INDX = 0
!
!---  End of card record error ---
!
      IF( CHDUM(1:1) .EQ. '~' ) THEN
        INDX = 4
        CHMSG = 'End of Card Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read numbers between commas  ---
!
      ICOMMA = INDEX (CHDUM(ISTART:), ',') + ISTART - 1
      ISTOP = ICOMMA
  100 CONTINUE
!
!---  Comma not found, missing integer data  ---
!
      IF( ISTOP.LT.ISTART ) THEN
        GOTO 200
!
!---  Null entry  ---
!
      ELSEIF( ISTOP.EQ.ISTART ) THEN
        INDX = 1
        GOTO 200
!
!---  Characters between commas  ---
!
      ELSE
!
!---  Eliminate leading blank spaces  ---
!
        IF( ICHAR(CHDUM(ISTART:ISTART)).EQ.32 ) THEN
          ISTART = ISTART+1
          GOTO 100
        ENDIF
!
!---  Eliminate trailing blank spaces  ---
!
        ISTOP = ISTOP-1
  110   CONTINUE
        IF( ICHAR(CHDUM(ISTOP:ISTOP)).EQ.32 ) THEN
          ISTOP = ISTOP-1
          GOTO 110
        ENDIF
!
!---  Check for non-numerical characters  ---
!
        DO 120 N = ISTART,ISTOP
          NC = ICHAR(CHDUM(N:N))
          IF( N.EQ.ISTART .AND. ( NC.EQ.43 .OR. NC.EQ.45 ) ) GOTO 120
          IF( NC.LT.48 .OR. NC.GT.57 ) GOTO 200
  120   CONTINUE
!
!---  Character string recognized as an integer  ---
!
        INDX = 1
      ENDIF
  200 CONTINUE
      ISTART = ISX
      ICOMMA = ICX
!
!---  End of CHK_INT group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CONN_LST
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Search grid for internal boundary surfaces
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNNL, February 2012.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CONN_LST'
!
!---  Search grid for internal boundary surfaces  ---
!
      DO 100 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        NPX = (K-1)*LFY*(LFX+1) + (J-1)*(LFX+1) + I
        NPY = (K-1)*(LFY+1)*LFX + (J-1)*LFX + I
        NPZ = N
        NQX = NPX + 1
        NQY = NPY + LFX
        NQZ = NPZ + LFXY
!
!---    Bottom surface  ---
!
        IF( K.NE.1 ) THEN
          NB = N-LFXY
          IF( ABS(XE(1,N)-XE(5,NB)).GT.EPSL .OR. 
     &        ABS(YE(1,N)-YE(5,NB)).GT.EPSL .OR.
     &        ABS(ZE(1,N)-ZE(5,NB)).GT.EPSL .OR.
     &        ABS(XE(2,N)-XE(6,NB)).GT.EPSL .OR. 
     &        ABS(YE(2,N)-YE(6,NB)).GT.EPSL .OR.
     &        ABS(ZE(2,N)-ZE(6,NB)).GT.EPSL .OR.
     &        ABS(XE(3,N)-XE(7,NB)).GT.EPSL .OR. 
     &        ABS(YE(3,N)-YE(7,NB)).GT.EPSL .OR.
     &        ABS(ZE(3,N)-ZE(7,NB)).GT.EPSL .OR.
     &        ABS(XE(4,N)-XE(8,NB)).GT.EPSL .OR. 
     &        ABS(YE(4,N)-YE(8,NB)).GT.EPSL .OR.
     &        ABS(ZE(4,N)-ZE(8,NB)).GT.EPSL ) THEN
            INBS(1,N) = NPZ
            INBS(6,NB) = NQZ
          ENDIF
        ENDIF
!
!---    South surface  ---
!
        IF( J.NE.1 ) THEN
          NS = N-LFX
          IF( ABS(XE(1,N)-XE(3,NS)).GT.EPSL .OR. 
     &        ABS(YE(1,N)-YE(3,NS)).GT.EPSL .OR.
     &        ABS(ZE(1,N)-ZE(3,NS)).GT.EPSL .OR.
     &        ABS(XE(2,N)-XE(4,NS)).GT.EPSL .OR. 
     &        ABS(YE(2,N)-YE(4,NS)).GT.EPSL .OR.
     &        ABS(ZE(2,N)-ZE(4,NS)).GT.EPSL .OR.
     &        ABS(XE(5,N)-XE(7,NS)).GT.EPSL .OR. 
     &        ABS(YE(5,N)-YE(7,NS)).GT.EPSL .OR.
     &        ABS(ZE(5,N)-ZE(7,NS)).GT.EPSL .OR.
     &        ABS(XE(6,N)-XE(8,NS)).GT.EPSL .OR. 
     &        ABS(YE(6,N)-YE(8,NS)).GT.EPSL .OR.
     &        ABS(ZE(6,N)-ZE(8,NS)).GT.EPSL ) THEN
            INBS(2,N) = NPY
            INBS(5,NS) = NQY
          ENDIF
        ENDIF
!
!---    West surface  ---
!
        IF( I.NE.1 ) THEN
          NW = N-1
          IF( ABS(XE(1,N)-XE(2,NW)).GT.EPSL .OR. 
     &        ABS(YE(1,N)-YE(2,NW)).GT.EPSL .OR.
     &        ABS(ZE(1,N)-ZE(2,NW)).GT.EPSL .OR.
     &        ABS(XE(3,N)-XE(4,NW)).GT.EPSL .OR. 
     &        ABS(YE(3,N)-YE(4,NW)).GT.EPSL .OR.
     &        ABS(ZE(3,N)-ZE(4,NW)).GT.EPSL .OR.
     &        ABS(XE(5,N)-XE(6,NW)).GT.EPSL .OR. 
     &        ABS(YE(5,N)-YE(6,NW)).GT.EPSL .OR.
     &        ABS(ZE(5,N)-ZE(6,NW)).GT.EPSL .OR.
     &        ABS(XE(7,N)-XE(8,NW)).GT.EPSL .OR. 
     &        ABS(YE(7,N)-YE(8,NW)).GT.EPSL .OR.
     &        ABS(ZE(7,N)-ZE(8,NW)).GT.EPSL ) THEN
            INBS(3,N) = NPX
            INBS(4,NW) = NQX
          ENDIF
        ENDIF
!
!---    East surface  ---
!
        IF( I.NE.LFX ) THEN
          NE = N+1
          IF( ABS(XE(1,NE)-XE(2,N)).GT.EPSL .OR. 
     &        ABS(YE(1,NE)-YE(2,N)).GT.EPSL .OR.
     &        ABS(ZE(1,NE)-ZE(2,N)).GT.EPSL .OR.
     &        ABS(XE(3,NE)-XE(4,N)).GT.EPSL .OR. 
     &        ABS(YE(3,NE)-YE(4,N)).GT.EPSL .OR.
     &        ABS(ZE(3,NE)-ZE(4,N)).GT.EPSL .OR.
     &        ABS(XE(5,NE)-XE(6,N)).GT.EPSL .OR. 
     &        ABS(YE(5,NE)-YE(6,N)).GT.EPSL .OR.
     &        ABS(ZE(5,NE)-ZE(6,N)).GT.EPSL .OR.
     &        ABS(XE(7,NE)-XE(8,N)).GT.EPSL .OR. 
     &        ABS(YE(7,NE)-YE(8,N)).GT.EPSL .OR.
     &        ABS(ZE(7,NE)-ZE(8,N)).GT.EPSL ) THEN
            INBS(3,NE) = NPX
            LSX = LSX + 1
            INBS(4,N) = LSX
          ENDIF
        ENDIF
!
!---    North surface  ---
!
        IF( J.NE.LFY ) THEN
          NN = N+LFX
          IF( ABS(XE(1,NN)-XE(3,N)).GT.EPSL .OR. 
     &        ABS(YE(1,NN)-YE(3,N)).GT.EPSL .OR.
     &        ABS(ZE(1,NN)-ZE(3,N)).GT.EPSL .OR.
     &        ABS(XE(2,NN)-XE(4,N)).GT.EPSL .OR. 
     &        ABS(YE(2,NN)-YE(4,N)).GT.EPSL .OR.
     &        ABS(ZE(2,NN)-ZE(4,N)).GT.EPSL .OR.
     &        ABS(XE(5,NN)-XE(7,N)).GT.EPSL .OR. 
     &        ABS(YE(5,NN)-YE(7,N)).GT.EPSL .OR.
     &        ABS(ZE(5,NN)-ZE(7,N)).GT.EPSL .OR.
     &        ABS(XE(6,NN)-XE(8,N)).GT.EPSL .OR. 
     &        ABS(YE(6,NN)-YE(8,N)).GT.EPSL .OR.
     &        ABS(ZE(6,NN)-ZE(8,N)).GT.EPSL ) THEN
            INBS(2,NN) = NPY
            LSY = LSY + 1
            INBS(5,N) = LSY
          ENDIF
        ENDIF
!
!---    Top surface  ---
!
        IF( K.NE.LFZ ) THEN
          NT = N+LFXY
          IF( ABS(XE(1,NT)-XE(5,N)).GT.EPSL .OR. 
     &        ABS(YE(1,NT)-YE(5,N)).GT.EPSL .OR.
     &        ABS(ZE(1,NT)-ZE(5,N)).GT.EPSL .OR.
     &        ABS(XE(2,NT)-XE(6,N)).GT.EPSL .OR. 
     &        ABS(YE(2,NT)-YE(6,N)).GT.EPSL .OR.
     &        ABS(ZE(2,NT)-ZE(6,N)).GT.EPSL .OR.
     &        ABS(XE(3,NT)-XE(7,N)).GT.EPSL .OR. 
     &        ABS(YE(3,NT)-YE(7,N)).GT.EPSL .OR.
     &        ABS(ZE(3,NT)-ZE(7,N)).GT.EPSL .OR.
     &        ABS(XE(4,NT)-XE(8,N)).GT.EPSL .OR. 
     &        ABS(YE(4,NT)-YE(8,N)).GT.EPSL .OR.
     &        ABS(ZE(4,NT)-ZE(8,N)).GT.EPSL ) THEN
            INBS(1,NT) = NPZ
            LSZ = LSZ + 1
            INBS(6,N) = LSZ
          ENDIF
        ENDIF
  100 CONTINUE
!
!---  End of CONN_LST group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CONN_MAP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Create a node connection map and determine the maximum
!     number of connections
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNNL, January 2014.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CONN_MAP'
!
!---  Allocate memory for coupled-well Jacobian index array  ---
!
      IF( .NOT.ALLOCATED(ICM) ) THEN
        ALLOCATE( ICM(1:5,1:6,1:LFD),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ICM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Initialize memory for coupled-well Jacobian index array  ---
!
      DO K = 1,LFD
      DO J = 1,6
      DO I = 1,5
        ICM(I,J,K) = 0
      ENDDO
      ENDDO
      ENDDO
!
!---  Bottom connections  ---
!
      DO 100 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        NB = N-LFXY
!
!---    Bottom surface is an external boundary surface  ---
!
        IBX = 0
        IF( K.EQ.1 ) THEN
          IBX = 1
        ELSE
!
!---      Bottom surface is an internal boundary surface  ---
!
          IF( IXP(N).EQ.0 .OR. IXP(NB).EQ.0 .OR.
     &      INBS(1,N).GT.0 .OR. INBS(6,NB).GT.0 ) IBX = 1
          IF( IBX.EQ.0 ) ICM(5,1,N) = NB
        ENDIF
!
!---    Node refinement  ---
!
        IRX = 2**IBR(1,N)
        JRX = 2**IBR(2,N)
        KRX = 2**IBR(3,N)
        DO 90 KX = 1,KRX
        IF( KX.EQ.1 .AND. IBX.EQ.1 ) CYCLE
        DO 80 JX = 1,JRX
        DO 70 IX = 1,IRX
          NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
          IF( IRX*JRX.GT.1 ) INBS(1,NX) = -1 
          NC = 0
          IF( KX.EQ.1 ) THEN
!
!---        Bottom node refinement, in the x- and y-directions  ---
!
            IRBX = 2**IBR(1,NB)
            JRBX = 2**IBR(2,NB)
            KRBX = 2**IBR(3,NB)
            KBX = KRBX
            IF( JRBX.GT.JRX ) THEN
              J1X = 2*JX - 1
              J2X = 2*JX
            ELSEIF( JRBX.LT.JRX ) THEN
              J1X = (JX+1)/2
              J2X = (JX+1)/2
            ELSE
              J1X = JX
              J2X = JX
            ENDIF
            IF( IRBX.GT.IRX ) THEN
              I1X = 2*IX - 1
              I2X = 2*IX
            ELSEIF( IRBX.LT.IRX ) THEN
              I1X = (IX+1)/2
              I2X = (IX+1)/2
            ELSE
              I1X = IX
              I2X = IX
            ENDIF
            DO 60 JBX = J1X,J2X
            DO 50 IBX = I1X,I2X
              NRBX = IBR(4,NB) + ND_BR(IBX,IRBX,JBX,JRBX,KBX)
              NC = NC+1
              ICM(NC,1,NX) = NRBX
   50       CONTINUE
   60       CONTINUE
          ELSE
            KBX = KX-1
            NRBX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KBX)
            NC = NC+1
            ICM(NC,1,NX) = NRBX
          ENDIF
   70   CONTINUE
   80   CONTINUE
   90   CONTINUE
  100 CONTINUE
!
!---  South connections  ---
!
      DO 200 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        NS = N-LFX
!
!---    South surface is an external boundary surface  ---
!
        IBX = 0
        IF( J.EQ.1 ) THEN
          IBX = 1
        ELSE
!
!---      South surface is an internal boundary surface  ---
!
          IF( IXP(N).EQ.0 .OR. IXP(NS).EQ.0 .OR.
     &      INBS(2,N).GT.0 .OR. INBS(5,NS).GT.0 ) IBX = 1
        ENDIF
        IF( IBX.EQ.0 ) ICM(5,2,N) = NS
!
!---    Node refinement  ---
!
        IRX = 2**IBR(1,N)
        JRX = 2**IBR(2,N)
        KRX = 2**IBR(3,N)
        DO 190 KX = 1,KRX
        DO 180 JX = 1,JRX
        IF( JX.EQ.1 .AND. IBX.EQ.1 ) CYCLE
        DO 170 IX = 1,IRX
          NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
          IF( IRX*KRX.GT.1 ) INBS(2,NX) = -1 
          NC = 0
          IF( JX.EQ.1 ) THEN
!
!---        South node refinement, in the x- and y-directions  ---
!
            IRSX = 2**IBR(1,NS)
            JRSX = 2**IBR(2,NS)
            KRSX = 2**IBR(3,NS)
            JSX = JRSX
            IF( KRSX.GT.KRX ) THEN
              K1X = 2*KX - 1
              K2X = 2*KX
            ELSEIF( KRSX.LT.KRX ) THEN
              K1X = (KX+1)/2
              K2X = (KX+1)/2
            ELSE
              K1X = KX
              K2X = KX
            ENDIF
            IF( IRSX.GT.IRX ) THEN
              I1X = 2*IX - 1
              I2X = 2*IX
            ELSEIF( IRSX.LT.IRX ) THEN
              I1X = (IX+1)/2
              I2X = (IX+1)/2
            ELSE
              I1X = IX
              I2X = IX
            ENDIF
            DO 160 KSX = K1X,K2X
            DO 150 ISX = I1X,I2X
              NRSX = IBR(4,NS) + ND_BR(ISX,IRSX,JSX,JRSX,KSX)
              NC = NC+1
              ICM(NC,2,NX) = NRSX
  150       CONTINUE
  160       CONTINUE
          ELSE
            JSX = JX-1
            NRSX = IBR(4,N) + ND_BR(IX,IRX,JSX,JRX,KX)
            NC = NC+1
            ICM(NC,2,NX) = NRSX
          ENDIF
  170   CONTINUE
  180   CONTINUE
  190   CONTINUE
  200 CONTINUE
!
!---  West connections  ---
!
      DO 300 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        NW = N-1
!
!---    West surface is an external boundary surface  ---
!
        IBX = 0
        IF( I.EQ.1 ) THEN
          IBX = 1
        ELSE
!
!---      West surface is an internal boundary surface  ---
!
          IF( IXP(N).EQ.0 .OR. IXP(NW).EQ.0 .OR.
     &      INBS(3,N).GT.0 .OR. INBS(4,NW).GT.0 ) IBX = 1
        ENDIF
        IF( IBX.EQ.0 ) ICM(5,3,N) = NW
!
!---    Node refinement  ---
!
        IRX = 2**IBR(1,N)
        JRX = 2**IBR(2,N)
        KRX = 2**IBR(3,N)
        DO KX = 1,KRX
        DO JX = 1,JRX
        DO IX = 1,IRX
        IF( IX.EQ.1 .AND. IBX.EQ.1 ) CYCLE
          NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
          IF( JRX*KRX.GT.1 ) INBS(3,NX) = -1 
          NC = 0
          IF( IX.EQ.1 ) THEN
!
!---        West node refinement, in the y- and z-directions  ---
!
            IRWX = 2**IBR(1,NW)
            JRWX = 2**IBR(2,NW)
            KRWX = 2**IBR(3,NW)
            IWX = IRWX
            IF( KRWX.GT.KRX ) THEN
              K1X = 2*KX - 1
              K2X = 2*KX
            ELSEIF( KRWX.LT.KRX ) THEN
              K1X = (KX+1)/2
              K2X = (KX+1)/2
            ELSE
              K1X = KX
              K2X = KX
            ENDIF
            IF( JRWX.GT.JRX ) THEN
              J1X = 2*JX - 1
              J2X = 2*JX
            ELSEIF( JRWX.LT.JRX ) THEN
              J1X = (JX+1)/2
              J2X = (JX+1)/2
            ELSE
              J1X = JX
              J2X = JX
            ENDIF
            DO 260 KWX = K1X,K2X
            DO 250 JWX = J1X,J2X
              NRWX = IBR(4,NW) + ND_BR(IWX,IRWX,JWX,JRWX,KWX)
              NC = NC+1
              ICM(NC,3,NX) = NRWX
  250       CONTINUE
  260       CONTINUE
          ELSE
            IWX = IX-1
            NRWX = IBR(4,N) + ND_BR(IWX,IRX,JX,JRX,KX)
            NC = NC+1
            ICM(NC,3,NX) = NRWX
          ENDIF
        ENDDO
        ENDDO
        ENDDO
  300 CONTINUE
!
!---  East connections  ---
!
      DO 400 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        NE = N+1
!
!---    East surface is an external boundary surface  ---
!
        IBX = 0
        IF( I.EQ.LFX ) THEN
          IBX = 1
        ELSE
!
!---      East surface is an internal boundary surface  ---
!
          IF( IXP(N).EQ.0 .OR. IXP(NE).EQ.0 .OR.
     &      INBS(4,N).GT.0 .OR. INBS(3,NE).GT.0 ) IBX = 1
        ENDIF
        IF( IBX.EQ.0 ) ICM(5,4,N) = NE
!
!---    Node refinement  ---
!
        IRX = 2**IBR(1,N)
        JRX = 2**IBR(2,N)
        KRX = 2**IBR(3,N)
        DO KX = 1,KRX
        DO JX = 1,JRX
        DO IX = 1,IRX
        IF( IX.EQ.IRX .AND. IBX.EQ.1 ) CYCLE
          NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
          IF( JRX*KRX.GT.1 ) INBS(4,NX) = -1 
          NC = 0
          IF( IX.EQ.IRX ) THEN
!
!---        East node refinement, in the y- and z-directions  ---
!
            IREX = 2**IBR(1,NE)
            JREX = 2**IBR(2,NE)
            KREX = 2**IBR(3,NE)
            IEX = 1
            IF( KREX.GT.KRX ) THEN
              K1X = 2*KX - 1
              K2X = 2*KX
            ELSEIF( KREX.LT.KRX ) THEN
              K1X = (KX+1)/2
              K2X = (KX+1)/2
            ELSE
              K1X = KX
              K2X = KX
            ENDIF
            IF( JREX.GT.JRX ) THEN
              J1X = 2*JX - 1
              J2X = 2*JX
            ELSEIF( JREX.LT.JRX ) THEN
              J1X = (JX+1)/2
              J2X = (JX+1)/2
            ELSE
              J1X = JX
              J2X = JX
            ENDIF
            DO 360 KEX = K1X,K2X
            DO 350 JEX = J1X,J2X
              NREX = IBR(4,NE) + ND_BR(IEX,IREX,JEX,JREX,KEX)
              NC = NC+1
              ICM(NC,4,NX) = NREX
  350       CONTINUE
  360       CONTINUE
          ELSE
            IEX = IX+1
            NREX = IBR(4,N) + ND_BR(IEX,IRX,JX,JRX,KX)
            NC = NC+1
            ICM(NC,4,NX) = NREX
          ENDIF
        ENDDO
        ENDDO
        ENDDO
  400 CONTINUE
!
!---  North connections  ---
!
      DO 500 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        NN = N+LFX
!
!---    North surface is an external boundary surface  ---
!
        IBX = 0
        IF( J.EQ.LFY ) THEN
          IBX = 1
        ELSE
!
!---      North surface is an internal boundary surface  ---
!
          IF( IXP(N).EQ.0 .OR. IXP(NN).EQ.0 .OR.
     &      INBS(5,N).GT.0 .OR. INBS(2,NN).GT.0 ) IBX = 1
        ENDIF
        IF( IBX.EQ.0 ) ICM(5,5,N) = NN
!
!---    Node refinement  ---
!
        IRX = 2**IBR(1,N)
        JRX = 2**IBR(2,N)
        KRX = 2**IBR(3,N)
        DO 490 KX = 1,KRX
        DO 480 JX = 1,JRX
        IF( JX.EQ.JRX .AND. IBX.EQ.1 ) CYCLE
        DO 470 IX = 1,IRX
          NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
          IF( IRX*KRX.GT.1 ) INBS(5,NX) = -1 
          NC = 0
          IF( JX.EQ.JRX ) THEN
!
!---        North node refinement, in the x- and y-directions  ---
!
            IRNX = 2**IBR(1,NN)
            JRNX = 2**IBR(2,NN)
            KRNX = 2**IBR(3,NN)
            JNX = 1
            IF( KRNX.GT.KRX ) THEN
              K1X = 2*KX - 1
              K2X = 2*KX
            ELSEIF( KRNX.LT.KRX ) THEN
              K1X = (KX+1)/2
              K2X = (KX+1)/2
            ELSE
              K1X = KX
              K2X = KX
            ENDIF
            IF( IRNX.GT.IRX ) THEN
              I1X = 2*IX - 1
              I2X = 2*IX
            ELSEIF( IRNX.LT.IRX ) THEN
              I1X = (IX+1)/2
              I2X = (IX+1)/2
            ELSE
              I1X = IX
              I2X = IX
            ENDIF
            DO 460 KNX = K1X,K2X
            DO 450 INX = I1X,I2X
              NRNX = IBR(4,NN) + ND_BR(INX,IRNX,JNX,JRNX,KNX)
              NC = NC+1
              ICM(NC,5,NX) = NRNX
  450       CONTINUE
  460       CONTINUE
          ELSE
            JNX = JX+1
            NRNX = IBR(4,N) + ND_BR(IX,IRX,JNX,JRX,KX)
            NC = NC+1
            ICM(NC,5,NX) = NRNX
          ENDIF
  470   CONTINUE
  480   CONTINUE
  490   CONTINUE
  500 CONTINUE
!
!---  Top connections  ---
!
      DO 600 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        NT = N+LFXY
!
!---    Top surface is an external boundary surface  ---
!
        IBX = 0
        IF( K.EQ.LFZ ) THEN
          IBX = 1
        ELSE
!
!---      Top surface is an internal boundary surface  ---
!
          IF( IXP(N).EQ.0 .OR. IXP(NT).EQ.0 .OR.
     &      INBS(6,N).GT.0 .OR. INBS(1,NT).GT.0 ) IBX = 1
        ENDIF
        IF( IBX.EQ.0 ) ICM(5,6,N) = NT
!
!---    Node refinement  ---
!
        IRX = 2**IBR(1,N)
        JRX = 2**IBR(2,N)
        KRX = 2**IBR(3,N)
        DO 590 KX = 1,KRX
        IF( KX.EQ.KRX .AND. IBX.EQ.1 ) CYCLE
        DO 580 JX = 1,JRX
        DO 570 IX = 1,IRX
          NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
          IF( IRX*JRX.GT.1 ) INBS(6,NX) = -1 
          NC = 0
          IF( KX.EQ.KRX ) THEN
!
!---        Top node refinement, in the x- and y-directions  ---
!
            IRTX = 2**IBR(1,NT)
            JRTX = 2**IBR(2,NT)
            KRTX = 2**IBR(3,NT)
            KTX = 1
            NC = 0
            IF( JRTX.GT.JRX ) THEN
              J1X = 2*JX - 1
              J2X = 2*JX
            ELSEIF( JRTX.LT.JRX ) THEN
              J1X = (JX+1)/2
              J2X = (JX+1)/2
            ELSE
              J1X = JX
              J2X = JX
            ENDIF
            IF( IRTX.GT.IRX ) THEN
              I1X = 2*IX - 1
              I2X = 2*IX
            ELSEIF( IRTX.LT.IRX ) THEN
              I1X = (IX+1)/2
              I2X = (IX+1)/2
            ELSE
              I1X = IX
              I2X = IX
            ENDIF
            DO 560 JTX = J1X,J2X
            DO 550 ITX = I1X,I2X
              NRTX = IBR(4,NT) + ND_BR(ITX,IRTX,JTX,JRTX,KTX)
              NC = NC+1
              ICM(NC,6,NX) = NRTX
  550       CONTINUE
  560       CONTINUE
          ELSE
            KTX = KX+1
            NRTX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KTX)
            NC = NC+1
            ICM(NC,6,NX) = NRTX
          ENDIF
  570   CONTINUE
  580   CONTINUE
  590   CONTINUE
  600 CONTINUE
!
!---  Maximum number of connections  ---
!
      NCMX = 0
      DO 800 N = 1,LFD-LBR-LWN_LW
        I = ID(N)
        J = JD(N)
        K = KD(N)
        IRX = 2**IBR(1,N)
        JRX = 2**IBR(2,N)
        KRX = 2**IBR(3,N)
        DO KX = 1,KRX
        DO JX = 1,JRX
        DO IX = 1,IRX
          NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
          NCX = 0
          DO 760 NR = 1,4
            DO 750 NS = 1,6
              IF( ICM(NR,NS,NX).NE.0 ) NCX = NCX + 1
  750       CONTINUE
  760     CONTINUE
          NCMX = MAX( NCMX,NCX )
        ENDDO
        ENDDO
        ENDDO
  800 CONTINUE
      LSTC = MAX( LSTC,NCMX+1 )
!
!---  End of CONN_MAP group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CONN_MAP_SFC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the maximum number of field nodes connected
!     to a surface cover node via plant roots
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 12 November 2015.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PLT_ATM
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 XPX(4),YPX(4),ZPX(4)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CONN_MAP_SFC'
!
!---  Find maximum plant root depth  ---
!
      PRDMX = 0.D+0
      DO IP = 1,NPLANT
        PRDMX = MAX( PRDMX,PARMS_P(1,IP) )
      ENDDO
!
!---  Loop over number of surface cover areas  ---
!
      DO NSCA = 1,NSFCA
!
!---    Loop over surface cover nodes  ---
!
        DO NSCN = 1,NSFCN
          NC = 1
          PRDX = PRDMX
          N = ICM_SFC(1,NSCN)
!
!---      Continuous loop from surface cover node down field nodes  ---
!
          DO
!
!---        Inactive node, exit  ---
!
            IF( IXP(N).EQ.0 ) EXIT
!
!---        Top surface centroid  ---
!
            XPX(1) = XE(5,N)
            XPX(2) = XE(6,N)
            XPX(3) = XE(8,N)
            XPX(4) = XE(7,N)
            YPX(1) = YE(5,N)
            YPX(2) = YE(6,N)
            YPX(3) = YE(8,N)
            YPX(4) = YE(7,N)
            ZPX(1) = ZE(5,N)
            ZPX(2) = ZE(6,N)
            ZPX(3) = ZE(8,N)
            ZPX(4) = ZE(7,N)
            NP = 4
            CALL PGCNTRD( NP,XPX,YPX,ZPX,XFTX,YFTX,ZFTX )
!
!---        Bottom surface vertices  ---
!
            XPX(1) = XE(1,N)
            XPX(2) = XE(2,N)
            XPX(3) = XE(4,N)
            XPX(4) = XE(3,N)
            YPX(1) = YE(1,N)
            YPX(2) = YE(2,N)
            YPX(3) = YE(4,N)
            YPX(4) = YE(3,N)
            ZPX(1) = ZE(1,N)
            ZPX(2) = ZE(2,N)
            ZPX(3) = ZE(4,N)
            ZPX(4) = ZE(3,N)
            NP = 4
            CALL PGCNTRD( NP,XPX,YPX,ZPX,XFBX,YFBX,ZFBX )
            DZGFX = SQRT((XFTX-XFBX)**2 + (YFTX-YFBX)**2 + 
     &        (ZFTX-ZFBX)**2)
!
!---        Roots continue through to next deeper field node  ---
!
            IF( PRDX.GT.DZGFX ) THEN
              NC = NC + 1
              PRDX = PRDX - DZGFX
              N = N - LFX*LFY
!
!---          Bottom of domain, exit  ---
!
              IF( N.LE.0 ) EXIT
!
!---          Inactive node, exit  ---
!
              IF( IXP(N).EQ.0 ) EXIT
            ELSE
!
!---          Maximum root depth ends within node  ---
!
              EXIT
            ENDIF
          ENDDO
          LSFCC = MAX( LSFCC,NC )
        ENDDO
      ENDDO
!
!---  Maximum number of surface cover equation unknowns  ---
!
      LUK_SFC = 2*(2*LUK + 3*LUK*LSFCC) + 13
!
!---  End of CONN_MAP_SFC group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!!----------------------Subroutine--------------------------------------!
!!
!      SUBROUTINE CONN_FEN
!!
!!-------------------------Disclaimer-----------------------------------!
!!
!!     This material was prepared as an account of work sponsored by
!!     an agency of the United States Government. Neither the
!!     United States Government nor the United States Department of
!!     Energy, nor Battelle, nor any of their employees, makes any
!!     warranty, express or implied, or assumes any legal liability or
!!     responsibility for the accuracy, completeness, or usefulness
!!     of any information, apparatus, product, software or process
!!     disclosed, or represents that its use would not infringe
!!     privately owned rights.
!!
!!----------------------Acknowledgement---------------------------------!
!!
!!     This software and its documentation were produced with Government
!!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!!     United Department of Energy. The Government retains a paid-up
!!     non-exclusive, irrevocable worldwide license to reproduce,
!!     prepare derivative works, perform publicly and display publicly
!!     by or for the Government, including the right to distribute to
!!     other Government contractors.
!!
!!---------------------Copyright Notices--------------------------------!
!!
!!            Copyright Battelle Memorial Institute, 1996
!!                    All Rights Reserved.
!!
!!----------------------Description-------------------------------------!
!!
!!     Create a map of finite-element nodes for geomechanics.
!!
!!----------------------Authors-----------------------------------------!
!!
!!     Written by MD White, PNNL, 28 October 2016.
!!
!!----------------------Fortran 90 Modules------------------------------!
!!
!      USE GLB_PAR
!      USE SOLTN
!      USE GRID
!      USE GEO_MECH
!!
!!----------------------Implicit Double Precision-----------------------!
!!
!      IMPLICIT REAL*8 (A-H,O-Z)
!      IMPLICIT INTEGER (I-N)
!!
!!----------------------Type Declarations-------------------------------!
!!
!      INTEGER JNDX(4,15,8)
!!
!!----------------------Data Statements---------------------------------!
!!
!      DATA JNDX / 1,0,0,5,1,2,0,7,1,2,3,8,1,3,0,6,
!     &            1,3,2,8,2,0,0,3,2,3,0,4,2,3,1,8,
!     &            2,1,0,7,2,1,3,8,3,0,0,2,3,1,0,6,
!     &            3,1,2,8,3,2,0,4,3,2,1,8,1,0,0,6,
!     &            1,2,0,8,1,2,4,7,1,4,0,5,1,4,2,7,
!     &            2,0,0,4,2,4,0,3,2,4,1,7,2,1,0,8,
!     &            2,1,4,7,4,0,0,1,4,1,0,5,4,1,2,7,
!     &            4,2,0,3,4,2,1,7,1,0,0,7,1,5,0,5,
!     &            1,5,3,6,1,3,0,8,1,3,5,6,5,0,0,1,
!     &            5,3,0,2,5,3,1,6,5,1,0,5,5,1,3,6,
!     &            3,0,0,4,3,1,0,8,3,1,5,6,3,5,0,2,
!     &            3,5,1,6,1,0,0,8,1,5,0,6,1,5,4,5,
!     &            1,4,0,7,1,4,5,5,5,0,0,2,5,4,0,1,
!     &            5,4,1,5,5,1,0,6,5,1,4,5,4,0,0,3,
!     &            4,1,0,7,4,1,5,5,4,5,0,1,4,5,1,5,
!     &            6,0,0,1,6,2,0,3,6,2,3,4,6,3,0,2,
!     &            6,3,2,4,2,0,0,7,2,3,0,8,2,3,6,4,
!     &            2,6,0,3,2,6,3,4,3,0,0,6,3,6,0,2,
!     &            3,6,2,4,3,2,0,8,3,2,6,4,6,0,0,2,
!     &            6,2,0,4,6,2,4,3,6,4,0,1,6,4,2,3,
!     &            2,0,0,8,2,4,0,7,2,4,6,3,2,6,0,4,
!     &            2,6,4,3,4,0,0,5,4,6,0,1,4,6,2,3,
!     &            4,2,0,7,4,2,6,3,6,0,0,3,6,5,0,1,
!     &            6,5,3,2,6,3,0,4,6,3,5,2,5,0,0,5,
!     &            5,3,0,6,5,3,6,2,5,6,0,1,5,6,3,2,
!     &            3,0,0,8,3,6,0,4,3,6,5,2,3,5,0,6,
!     &            3,5,6,2,6,0,0,4,6,5,0,2,6,5,4,1,
!     &            6,4,0,3,6,4,5,1,5,0,0,6,5,4,0,5,
!     &            5,4,6,1,5,6,0,2,5,6,4,1,4,0,0,7,
!     &            4,6,0,3,4,6,5,1,4,5,0,5,4,5,6,1 /
!!
!!----------------------Executable Lines--------------------------------!
!!
!      ISUB_LOG = ISUB_LOG+1
!      SUB_LOG(ISUB_LOG) = '/CONN_FEN'
!!
!!---  Allocate memory for the finite-element node map  ---
!!
!      IF( .NOT.ALLOCATED(ND_GM) ) THEN
!        ALLOCATE( ND_GM(1:8,1:LFD),STAT=ISTAT )
!        IF( ISTAT.NE.0 ) THEN
!          INDX = 3
!          CHMSG = 'Allocation Error: ND_GM'
!          CALL WRMSGP( INDX )
!        ENDIF
!        DO M1 = 1,8
!          DO M2 = 1,LFD
!            ND_GM(M1,M2) = 0
!          ENDDO
!        ENDDO
!      ENDIF
!!
!!---  Loop over all nodes create a map of finite element nodes,
!!     where nodes are numbered in the order around the hexahedron
!!     grid cells as
!!
!!     1 i,j,k
!!     2 i+1,j,k
!!     3 i,j+1,k
!!     4 i+1,j+1,k
!!     5 i,j,k+1
!!     6 i+1,j,k+1
!!     7 i,j+1,k+1
!!     8 i+1,j+1,k+1  ---
!!
!      NC = 0
!      DO N = 1,LFD
!        IF( IXP(N).EQ.0 ) CYCLE
!!
!!---    Loop over FE Nodes  ---
!!
!        DO NFE = 1,8
!          IF( ND_GM(NFE,N).EQ.0 ) THEN
!            NC = NC + 1
!            ND_GM(NFE,N) = NC
!!
!!---        Loop over number of connection paths  ---
!!
!            DO NCP = 1,15
!!
!!---          Loop over number of connection tiers  ---
!!
!              NX = N
!              DO NCT = 1,3
!                IX = JNDX(NCT,NCP,NFE)
!                IF( JNDX(NCT,NCP,NFE).EQ.0 ) EXIT
!!
!!---            Connection to neighboring element found  ---
!!
!                IF( ICM(5,IX,NX).NE.0 ) THEN
!                  NX = ICM(5,IX,NX)
!!
!!---            Connection string broken  ---
!!
!                ELSE
!                  NX = 0
!                  EXIT
!                ENDIF
!              ENDDO
!!
!!---         Connection string completed  ---
!!
!              IF( NX.NE.0 ) THEN
!                JX = JNDX(4,NCP,NFE)
!                ND_GM(JX,NX) = NC
!              ENDIF
!            ENDDO
!          ENDIF
!        ENDDO
!      ENDDO
!!
!!---  Number of finite element nodes  ---
!!
!      LFEN = MAX( NC,1 )
!!
!!---  Allocate memory for the inverse FE node map  ---
!!
!      IF( .NOT.ALLOCATED(NE_GM) ) THEN
!        ALLOCATE( NE_GM(1:8,1:LFEN),STAT=ISTAT )
!        IF( ISTAT.NE.0 ) THEN
!          INDX = 3
!          CHMSG = 'Allocation Error: NE_GM'
!          CALL WRMSGP( INDX )
!        ENDIF
!        DO M1 = 1,8
!          DO M2 = 1,LFEN
!            NE_GM(M1,M2) = 0
!          ENDDO
!        ENDDO
!      ENDIF
!!
!!---  Loop over all nodes, creating an inverse map of FE nodes  ---
!!
!      DO N = 1,LFD
!        IF( IXP(N).EQ.0 ) CYCLE
!!
!!---    Loop over FE Nodes  ---
!!
!        DO NFE = 1,8
!          IF( ND_GM(NFE,N).EQ.0 ) CYCLE
!          NC = ND_GM(NFE,N)
!          NE_GM(NFE,NC) = N
!        ENDDO
!      ENDDO
!!
!!---  End of CONN_FEN group  ---
!!
!      ISUB_LOG = ISUB_LOG-1
!      RETURN
!      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CONN_FEN
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Create a map of finite-element nodes for geomechanics.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 28 October 2016.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE GEO_MECH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER JNDX(4,15,8)
      INTEGER IDX(8),JDX(8),KDX(8)
!
!----------------------Data Statements---------------------------------!
!
      DATA JNDX / 1,0,0,5,1,2,0,7,1,2,3,8,1,3,0,6,
     &            1,3,2,8,2,0,0,3,2,3,0,4,2,3,1,8,
     &            2,1,0,7,2,1,3,8,3,0,0,2,3,1,0,6,
     &            3,1,2,8,3,2,0,4,3,2,1,8,1,0,0,6,
     &            1,2,0,8,1,2,4,7,1,4,0,5,1,4,2,7,
     &            2,0,0,4,2,4,0,3,2,4,1,7,2,1,0,8,
     &            2,1,4,7,4,0,0,1,4,1,0,5,4,1,2,7,
     &            4,2,0,3,4,2,1,7,1,0,0,7,1,5,0,5,
     &            1,5,3,6,1,3,0,8,1,3,5,6,5,0,0,1,
     &            5,3,0,2,5,3,1,6,5,1,0,5,5,1,3,6,
     &            3,0,0,4,3,1,0,8,3,1,5,6,3,5,0,2,
     &            3,5,1,6,1,0,0,8,1,5,0,6,1,5,4,5,
     &            1,4,0,7,1,4,5,5,5,0,0,2,5,4,0,1,
     &            5,4,1,5,5,1,0,6,5,1,4,5,4,0,0,3,
     &            4,1,0,7,4,1,5,5,4,5,0,1,4,5,1,5,
     &            6,0,0,1,6,2,0,3,6,2,3,4,6,3,0,2,
     &            6,3,2,4,2,0,0,7,2,3,0,8,2,3,6,4,
     &            2,6,0,3,2,6,3,4,3,0,0,6,3,6,0,2,
     &            3,6,2,4,3,2,0,8,3,2,6,4,6,0,0,2,
     &            6,2,0,4,6,2,4,3,6,4,0,1,6,4,2,3,
     &            2,0,0,8,2,4,0,7,2,4,6,3,2,6,0,4,
     &            2,6,4,3,4,0,0,5,4,6,0,1,4,6,2,3,
     &            4,2,0,7,4,2,6,3,6,0,0,3,6,5,0,1,
     &            6,5,3,2,6,3,0,4,6,3,5,2,5,0,0,5,
     &            5,3,0,6,5,3,6,2,5,6,0,1,5,6,3,2,
     &            3,0,0,8,3,6,0,4,3,6,5,2,3,5,0,6,
     &            3,5,6,2,6,0,0,4,6,5,0,2,6,5,4,1,
     &            6,4,0,3,6,4,5,1,5,0,0,6,5,4,0,5,
     &            5,4,6,1,5,6,0,2,5,6,4,1,4,0,0,7,
     &            4,6,0,3,4,6,5,1,4,5,0,5,4,5,6,1 /
      DATA IDX / 0,1,0,1,0,1,0,1 /
      DATA JDX / 0,0,1,1,0,0,1,1 /
      DATA KDX / 0,0,0,0,1,1,1,1 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CONN_FEN'
!
!---  Allocate memory for the finite-element node map  ---
!
      IF( .NOT.ALLOCATED(ND_GM) ) THEN
        ALLOCATE( ND_GM(1:8,1:LFD),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ND_GM'
          CALL WRMSGP( INDX )
        ENDIF
        DO M1 = 1,8
          DO M2 = 1,LFD
            ND_GM(M1,M2) = 0
          ENDDO
        ENDDO
      ENDIF
!
!---  Loop over all nodes create a map of finite element nodes,
!     where nodes are numbered in the order around the hexahedron
!     grid cells as
!
!     1 i,j,k
!     2 i+1,j,k
!     3 i,j+1,k
!     4 i+1,j+1,k
!     5 i,j,k+1
!     6 i+1,j,k+1
!     7 i,j+1,k+1
!     8 i+1,j+1,k+1  ---
!
      DO N = 1,LFX*LFY*LFZ
!
!---    Loop over FE Nodes  ---
!
        DO NFE = 1,8
          IX = ID(N) + IDX(NFE)
          JX = JD(N) + JDX(NFE)
          KX = KD(N) + KDX(NFE)
          NC = (KX-1)*(LFY+1)*(LFX+1) + (JX-1)*(LFX+1) + IX
          ND_GM(NFE,N) = NC
!
!---      Loop over number of connection paths  ---
!
          DO NCP = 1,15
!
!---        Loop over number of connection tiers  ---
!
            NX = N
            DO NCT = 1,3
              IX = JNDX(NCT,NCP,NFE)
              IF( JNDX(NCT,NCP,NFE).EQ.0 ) EXIT
!
!---          Connection to neighboring element found  ---
!
              IF( ICM(5,IX,NX).NE.0 ) THEN
                NX = ICM(5,IX,NX)
!
!---          Connection string broken  ---
!
              ELSE
                NX = 0
                EXIT
              ENDIF
            ENDDO
!
!---       Connection string completed  ---
!
            IF( NX.NE.0 ) THEN
              JX = JNDX(4,NCP,NFE)
              ND_GM(JX,NX) = NC
            ENDIF
          ENDDO
        ENDDO
      ENDDO
!
!---  Number of finite element nodes  ---
!
      LFEN = MAX( (LFX+1)*(LFY+1)*(LFZ+1),1 )
!
!---  Allocate memory for the inverse FE node map  ---
!
      IF( .NOT.ALLOCATED(NE_GM) ) THEN
        ALLOCATE( NE_GM(1:8,1:LFEN),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: NE_GM'
          CALL WRMSGP( INDX )
        ENDIF
        DO M1 = 1,8
          DO M2 = 1,LFEN
            NE_GM(M1,M2) = 0
          ENDDO
        ENDDO
      ENDIF
!
!---  Loop over all nodes, creating an inverse map of FE nodes  ---
!
      DO N = 1,LFD
!
!---    Loop over FE Nodes  ---
!
        DO NFE = 1,8
          IF( ND_GM(NFE,N).EQ.0 ) CYCLE
          NC = ND_GM(NFE,N)
          NE_GM(NFE,NC) = N
        ENDDO
      ENDDO
!
!---  End of CONN_FEN group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CP_TRI( PN1X,V1X,V2X,PTX,NPTX,ITX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     PN1X - normal vector to triangle V
!     V1X - x,y,z coordinates of vertices of triangle V
!     V2X - x,y,z coordinates of vertices of triangle U
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 28 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 PN1X(3)
      REAL*8 V1X(3,3),V2X(3,3)
      REAL*8 AX(3)
      REAL*8, DIMENSION(3,24) :: PTX
      INTEGER MX(3,2)
!
!----------------------Data Statements---------------------------------!
!
      DATA MX /1,2,3,2,3,1/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CP_TRI'
!
!---  First project onto an axis aligned plane that maximizes the
!     areas of the triangles, computing indices I1X and I2X  ---
!
      DO M = 1,3
        AX(M) = ABS(PN1X(M))
      ENDDO
      IF( AX(1).GT.AX(2) ) THEN
!
!---    AX(1) is the greatest  ---
!
        IF( AX(1).GT.AX(3) ) THEN
          I0X = 2
          I1X = 3
!
!---    AX(3) is the greatest  ---
!
        ELSE
          I0X = 1
          I1X = 2
        ENDIF
      ELSE
!
!---    AX(3) is the greatest  ---
!
        IF( AX(3).GT.AX(2) ) THEN
          I0X = 1
          I1X = 2
!
!---    AX(2) is the greatest  ---
!
        ELSE
          I0X = 1
          I1X = 3
        ENDIF
      ENDIF
!
!---  Check if vertices of triangle 1 are within triangle 2  ---
!
      NC1X = 0
      DO M = 1,3
        CALL PNT_TRI_C( V1X(1,M),V2X,I0X,I1X,ITX )
        IF( ITX.EQ.1 ) THEN
          NC1X = NC1X + 1
!
!---      Skip duplicate points  ---
!
          ISKPX = 0
          DO N = 1,NPTX
            IF( ABS(V1X(1,M)-PTX(1,N)).LT.EPSL .AND. 
     &        ABS(V1X(2,M)-PTX(2,N)).LT.EPSL .AND.
     &        ABS(V1X(3,M)-PTX(3,N)).LT.EPSL ) THEN
              ISKPX = 1
              EXIT
            ENDIF
          ENDDO
          IF( ISKPX.EQ.0 ) THEN
            NPTX = NPTX + 1
            PTX(1,NPTX) = V1X(1,M)
            PTX(2,NPTX) = V1X(2,M)
            PTX(3,NPTX) = V1X(3,M)
          ENDIF
        ENDIF
      ENDDO
!
!---  Check if vertices of triangle 2 are within triangle 1  ---
!
      NC2X = 0
      DO M = 1,3
        CALL PNT_TRI_C( V2X(1,M),V1X,I0X,I1X,ITX )
        IF( ITX.EQ.1 ) THEN
          NC2X = NC2X + 1
!
!---      Skip duplicate points  ---
!
          ISKPX = 0
          DO N = 1,NPTX
            IF( ABS(V2X(1,M)-PTX(1,N)).LT.EPSL .AND. 
     &        ABS(V2X(2,M)-PTX(2,N)).LT.EPSL .AND.
     &        ABS(V2X(3,M)-PTX(3,N)).LT.EPSL ) THEN
              ISKPX = 1
              EXIT
            ENDIF
          ENDDO
          IF( ISKPX.EQ.0 ) THEN
            NPTX = NPTX + 1
            PTX(1,NPTX) = V2X(1,M)
            PTX(2,NPTX) = V2X(2,M)
            PTX(3,NPTX) = V2X(3,M)
          ENDIF
        ENDIF
      ENDDO
!
!---  Check for singlet or doublet, indicating triangle-triangle
!     intersection  ---
!
      ITX = 0
      IF( NC1X.EQ.1.OR.NC1X.EQ.2 .OR. NC2X.EQ.1.OR.NC2X.EQ.2 ) THEN
        ITX = 1
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Check for intersections of line segments of triangle 1 with
!     line segments of triangle 2  ---
!
      DO M1X = 1,3
        DO M2X = 1,3
          CALL LSEG_C( V1X(1,MX(M1X,1)),V1X(1,MX(M1X,2)),
     &      V2X(1,MX(M2X,1)),V2X(1,MX(M2X,2)),I0X,I1X,ITX )
          IF( ITX.EQ.1 ) THEN
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CP_TRI group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CP_INT( PN1X,V1X,V2X,PTX,NPTX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Find the x,y,z coordinates of the four intersection points of 
!     two triangles along the intersection line.
!
!     PN1X - normal vector to triangle 1 or plane Pi1
!     V1X - x,y,z coordinates of vertices of triangle 1
!     V2X - x,y,z coordinates of vertices of triangle 2
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 15 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(3,24) :: PTX
      REAL*8 PN1X(3)
      REAL*8 XPNCX(3),YPNCX(3),ZPNCX(3)
      REAL*8 XNCX(3),YNCX(3),ZNCX(3)
      REAL*8 PIX(2,6)
      REAL*8 V1X(3,3),V2X(3,3)
      REAL*8 V1PX(2,3),V2PX(2,3)
      REAL*8 VCX(3),VDX(3)
      REAL*8 TRNSMX(3,3)
      INTEGER MX(3,2)
!
!----------------------Data Statements---------------------------------!
!
      DATA MX /1,2,3,2,3,1/
      DATA XNCX /1,0,0/
      DATA YNCX /0,1,0/
      DATA ZNCX /0,0,1/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CP_INT'
!
!---  Create a x'y' coordinate system in the plane with vertex 1 of
!     triangle 1 as the center, and the vector between vertex 1 and 2
!     of triangle 1 as the x' coordinate direction. The y' coordinate 
!     direction will be normal to the plane surface normal, and the 
!     x' coordinate direction  ---
!
      CALL VSUB( V1X(1,2),V1X(1,1),XPNCX )
      DXPCX = SQRT( (V1X(1,2)-V1X(1,1))**2 + (V1X(2,2)-V1X(2,1))**2
     &  + (V1X(3,2)-V1X(3,1))**2 )
      DZPCX = SQRT( PN1X(1)**2 + PN1X(2)**2 + PN1X(3)**2 )
      DO M = 1,3
        XPNCX(M) = XPNCX(M)/DXPCX
        ZPNCX(M) = PN1X(M)/DZPCX
      ENDDO
      CALL VCROSSP( ZPNCX,XPNCX,YPNCX )
!
!---  Convert triangles to the x'y' coordinate system  ---
!
      DO M = 1,3
        CALL VSUB( V1X(1,M),V1X(1,1),VDX )
        V1PX(1,M) = VDOTP(VDX,XPNCX)
        V1PX(2,M) = VDOTP(VDX,YPNCX)
        CALL VSUB( V2X(1,M),V1X(1,1),VDX )
        V2PX(1,M) = VDOTP(VDX,XPNCX)
        V2PX(2,M) = VDOTP(VDX,YPNCX)
      ENDDO
!
!---  Check for intersections of the triangle lines  ---
!
      NPIX = 0
      DO M1X = 1,3
        DO M2X = 1,3
          CALL LSEG_I( V1PX(1,MX(M1X,1)),V1PX(1,MX(M1X,2)),
     &      V2PX(1,MX(M2X,1)),V2PX(1,MX(M2X,2)),PIX,NPIX )
        ENDDO
      ENDDO
!
!---  Convert intersection points to x,y,z coordinate system  ---
!
      TRNSMX(1,1) = VDOTP( XNCX,XPNCX )
      TRNSMX(1,2) = VDOTP( XNCX,YPNCX )
      TRNSMX(1,3) = VDOTP( XNCX,ZPNCX )
      TRNSMX(2,1) = VDOTP( YNCX,XPNCX )
      TRNSMX(2,2) = VDOTP( YNCX,YPNCX )
      TRNSMX(2,3) = VDOTP( YNCX,ZPNCX )
      TRNSMX(3,1) = VDOTP( ZNCX,XPNCX )
      TRNSMX(3,2) = VDOTP( ZNCX,YPNCX )
      TRNSMX(3,3) = VDOTP( ZNCX,ZPNCX )
      DO N = 1,NPIX
        VDX(1) = PIX(1,N)
        VDX(2) = PIX(2,N)
        VDX(3) = 0.D+0
!
!---    Rotation between x',y',z' and x,y,z  ---
!
        CALL MAT_MUL( TRNSMX,VDX,VCX,3,3,1 )
!
!---    Translation from origin of x',y',z'  ---
!
        DO M = 1,3
          VCX(M) = VCX(M) + V1X(M,1)
        ENDDO
!
!---    Skip duplicate points  ---
!
        ISKPX = 0
        DO M = 1,NPTX
          IF( ABS(VCX(1)-PTX(1,M)).LT.EPSL .AND. 
     &      ABS(VCX(2)-PTX(2,M)).LT.EPSL .AND.
     &      ABS(VCX(3)-PTX(3,M)).LT.EPSL ) THEN
            ISKPX = 1
            EXIT
          ENDIF
        ENDDO
        IF( ISKPX.EQ.0 ) THEN
          NPTX = NPTX + 1
          PTX(1,NPTX) = VCX(1)
          PTX(2,NPTX) = VCX(2)
          PTX(3,NPTX) = VCX(3)
        ENDIF
      ENDDO
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CP_INT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE FTT_IT( V1X,V2X,P1X,P2X,PN1X,PN2X,ICPX,ITX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     FTT_IT A fast triangle-triangle intersection test.
!
!     Tomas Moller "A fast triangle-triangle intersection test."
!
!     V1X - vertices of the first triangle (fracture/fault)
!       1,n x-coordinate of n vertex
!       2,n y-coordinate of n vertex
!       3,n z-coordinate of n vertex
!     V2X - vertices of the second triangle (grid surface)
!       1,n x-coordinate of n vertex
!       2,n y-coordinate of n vertex
!       3,n z-coordinate of n vertex
!     PN1X - normal vector to fracture/fault triangle
!     PN2X - normal vector to grid surface triangle
!     ITX - itersection test
!       0 - no intersection
!       1 - intersection
!     ICPX - coplanar index
!       0 - triangles are not coplanar
!       1 - triangles are coplanar
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 14 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 V1X(3,3),V2X(3,3)
      REAL*8 VP1X(3),VP2X(3)
      REAL*8 AX(3),BX(3),DX(3)
      REAL*8 PN1X(3),PN2X(3)
      REAL*8 P1X(3),P2X(3)
      REAL*8 DV1X(3),DV2X(3)
      REAL*8 SECT1(2),SECT2(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/FTT_IT'
!
!---  Initialize points  ---
!
      DO N = 1,3
        P1X(N) = 0.D+0
        P2X(N) = 0.D+0
      ENDDO
!
!---  Plane equation Pi1 : N1 dot X + D1 = 0, where X is any point
!     on the plane is computed
!     N1 = (V1(2)-V1(1)) cross (V1(3)-V1(1)) 
!     D1 = -N1 dot V1(1) ---
!
      CALL VSUB( V1X(1,2),V1X(1,1),AX )
      CALL VSUB( V1X(1,3),V1X(1,1),BX )
      DO N = 1,3
        IF( ABS(AX(N)).LT.1.D-12 ) AX(N) = 0.D+0 
        IF( ABS(BX(N)).LT.1.D-12 ) BX(N) = 0.D+0 
      ENDDO
      CALL VCROSSP( AX,BX,PN1X )
      DO N = 1,3
        IF( ABS(PN1X(N)).LT.1.D-12 ) PN1X(N) = 0.D+0
      ENDDO
      PD1X = -VDOTP( PN1X,V1X(1,1) )
!
!---  Put V2 into plane equation Pi1 to compute signed distances
!     to plane  ---
!
      DO N = 1,3
        DV2X(N) = VDOTP( PN1X,V2X(1,N) )
        DV2X(N) = DV2X(N) + PD1X
      ENDDO
!
!---  Coplanarity robustness check  ---
!
      DO N = 1,3
        IF( ABS(DV2X(N)).LT.1.D-12 ) DV2X(N) = 0.D+0
      ENDDO
      DV2AX = DV2X(1)*DV2X(2)
      DV2BX = DV2X(1)*DV2X(3)
!
!---  Same sign on all of them, plus not equal to zero, therefore
!     no intersecion occurs  ---
!
      IF( DV2AX.GT.0.D+0 .AND. DV2BX.GT.0.D+0 ) THEN
        ITX = 0
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Plane equation Pi2 : N2 dot X + D2 = 0, where X is any point
!     on the plane is computed
!     N2 = (V2(2)-V2(1)) cross (V2(3)-V2(1)) 
!     D2 = -N2 dot V2(1) ---
!
      CALL VSUB( V2X(1,2),V2X(1,1),AX )
      CALL VSUB( V2X(1,3),V2X(1,1),BX )
      DO N = 1,3
        IF( ABS(AX(N)).LT.1.D-12 ) AX(N) = 0.D+0 
        IF( ABS(BX(N)).LT.1.D-12 ) BX(N) = 0.D+0 
      ENDDO
      CALL VCROSSP( AX,BX,PN2X )
      DO N = 1,3
        IF( ABS(PN2X(N)).LT.1.D-12 ) PN2X(N) = 0.D+0
      ENDDO
      PD2X = -VDOTP( PN2X,V2X(1,1) )
!
!---  Put V1 into plane equation Pi2 to compute signed distances
!     to plane  ---
!
      DO N = 1,3
        DV1X(N) = VDOTP( PN2X,V1X(1,N) )
        DV1X(N) = DV1X(N) + PD2X
      ENDDO
!
!---  Coplanarity robustness check  ---
!
      DO N = 1,3
        IF( ABS(DV1X(N)).LT.1.D-12 ) DV1X(N) = 0.D+0
      ENDDO
      DV1AX = DV1X(1)*DV1X(2)
      DV1BX = DV1X(1)*DV1X(3)
!
!---  Same sign on all of them, plus not equal to zero, therefore
!     no intersecion occurs  ---
!
      IF( DV1AX.GT.0.D+0 .AND. DV1BX.GT.0.D+0 ) THEN
        ITX = 0
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Compute direction of intersection line, L  ---
!
      CALL VCROSSP( PN1X,PN2X,DX )
!
!---  Compute and index to the largest component of DX  ---
!
      DMAX = ABS(DX(1))
      INDX = 1
      DO N = 2,3
        IF( ABS(DX(N)).GT.DMAX ) THEN
          DMAX = DX(N)
          INDX = N
        ENDIF
      ENDDO
!
!---  This is the simplified projection onto L  ---
!
      DO N = 1,3
        VP1X(N) = V1X(INDX,N)
        VP2X(N) = V2X(INDX,N)
      ENDDO
!
!---  Compute interval for triangle 1  ---
!
      CALL INT_V( VP1X,DV1X,DV1AX,DV1BX,A1X,B1X,C1X,X10X,X11X,ICPX )
!
!---  Triangles are coplanar  ---
!
      IF( ICPX.NE.0 ) THEN
        ITX = 0
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Compute interval for triangle 2  ---
!
      CALL INT_V( VP2X,DV2X,DV2AX,DV2BX,A2X,B2X,C2X,X20X,X21X,ICPX )
!
!---  Triangles are coplanar  ---
!
      IF( ICPX.NE.0 ) THEN
        ITX = 0
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Check for overlap of triangle intervals  ---
!
      X1X = X10X*X11X
      X2X = X20X*X21X
      X12X = X1X*X2X
      VARX = A1X*X12X
      SECT1(1) = VARX + B1X*X11X*X2X
      SECT1(2) = VARX + C1X*X10X*X2X
      VARX = A2X*X12X
      SECT2(1) = VARX + B2X*X21X*X1X
      SECT2(2) = VARX + C2X*X20X*X1X
      CALL SORT_V( SECT1(1),SECT1(2) )
      CALL SORT_V( SECT2(1),SECT2(2) )
!
!---  No intersection occurs  ---
!
!      IF( SECT1(2).LT.SECT2(1) .OR. SECT2(2).LT.SECT1(1) ) THEN
      IF( (SECT2(1)-SECT1(2)).GT.EPSL .OR. 
     &  (SECT1(1)-SECT2(2)).GT.EPSL ) THEN
        ITX = 0
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Intersection occurs, find four points along intersection line  ---
!
      CALL LINE_I( DX,DV1X,DV2X,P1X,P2X,PN1X,PN2X,V1X,V2X )
      ITX = 1
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of FTT_IT group  ---
!
      RETURN
      END

!----------------------Function----------------------------------------!
!
      FUNCTION I_COUNT( I )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Count the number of digits in an integer variable.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNL, March, 1993.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/I_COUNT'
      IC = I
      I_COUNT = 0
   10 CONTINUE
      I_COUNT = I_COUNT + 1
      IC = IC/10
      IF( IC.GT.0 ) GOTO 10
!
!---  End of I_COUNT group
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE IMAT_MUL( IAX,IBX,ICX,IX,JX,KX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Multiple the integer matrix IAX (IX X JX) and IBX (JX X KX), 
!     returning the result in integer matrix ICX (IX X KX).
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 7 November 2016 (Ensisheim meteorite).
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER IAX(IX,JX),IBX(JX,KX),ICX(IX,KX)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/IMAT_MUL'
!
!---  Initialize CX  ---
!
      DO K = 1,KX
        DO I = 1,IX
          ICX(I,K) = 0
        ENDDO
      ENDDO
!
!---  Matrix multiply  ---
!
      DO I = 1,IX
        DO K = 1,KX
          DO J = 1,JX
            ICX(I,K) = ICX(I,K) + IAX(I,J)*IBX(J,K)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of IMAT_MUL group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE INT_V( VPX,DVX,DVAX,DVBX,AX,BX,CX,X0X,X1X,ICPX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Identify triangle intersection intervals.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 15 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 VPX(3),DVX(3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/INT_V'
!
!---  Here we know that DVBX <= 0.0, that is DVX(1) and DVX(2)
!     are on the same side, DVX(3) is on the other side or on
!     the plane  ---
!
      IF( DVAX.GT.0.D+0 ) THEN
        AX = VPX(3)
        BX = (VPX(1)-VPX(3))*DVX(3)
        CX = (VPX(2)-VPX(3))*DVX(3)
        X0X = DVX(3)-DVX(1)
        X1X = DVX(3)-DVX(2)
!
!---  Here we know that DVAX <= 0.0  ---
!
      ELSEIF( DVBX.GT.0.D+0 ) THEN
        AX = VPX(2)
        BX = (VPX(1)-VPX(2))*DVX(2)
        CX = (VPX(3)-VPX(2))*DVX(2)
        X0X = DVX(2)-DVX(1)
        X1X = DVX(2)-DVX(3)
!
!---  Here we know that DVX(2)*DVX(3) > 0.0 || DVX(1) /= 0.0  ---
!
      ELSEIF( DVX(2)*DVX(3).GT.0.D+0 .OR. 
     &  ABS(DVX(1))/EPSL.GT.EPSL ) THEN
        AX = VPX(1)
        BX = (VPX(2)-VPX(1))*DVX(1)
        CX = (VPX(3)-VPX(1))*DVX(1)
        X0X = DVX(1)-DVX(2)
        X1X = DVX(1)-DVX(3)
!
!---  Here we know that DVX(2) /= 0.0  ---
!
      ELSEIF( ABS(DVX(2))/EPSL.GT.EPSL ) THEN
        AX = VPX(2)
        BX = (VPX(1)-VPX(2))*DVX(2)
        CX = (VPX(3)-VPX(2))*DVX(2)
        X0X = DVX(2)-DVX(1)
        X1X = DVX(2)-DVX(3)
!
!---  Here we know that DVX(3) /= 0.0  ---
!
      ELSEIF( ABS(DVX(3))/EPSL.GT.EPSL ) THEN
        AX = VPX(3)
        BX = (VPX(1)-VPX(3))*DVX(3)
        CX = (VPX(2)-VPX(3))*DVX(3)
        X0X = DVX(3)-DVX(1)
        X1X = DVX(3)-DVX(2)
!
!---  Triangles are coplanar  ---
!
      ELSE
        ICPX = ICPX + 1
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of INT_V group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_CW
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for the coupled
!     well model
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 03 February 2014.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE LEAK_WELL
      USE JACOB
      USE GRID
      USE COUP_WELL
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: M_IJK,M_JKI,M_KIJ
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_CW'

!
!---  Deallocate memory for the IJK half-band width array  ---
!
      IF( ALLOCATED(M_IJK) ) THEN
        DEALLOCATE( M_IJK,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_IJK'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the JKI half-band width array  ---
!
      IF( ALLOCATED(M_JKI) ) THEN
        DEALLOCATE( M_JKI,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_JKI'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the KIJ half-band width array  ---
!
      IF( ALLOCATED(M_KIJ) ) THEN
        DEALLOCATE( M_KIJ,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_KIJ'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_CW group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_CW_DP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for the coupled
!     well model and dual porosity
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 24 November 2015.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE DUAL_POR
      USE COUP_WELL
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: M_IJK,M_JKI,M_KIJ
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_CW_DP'

!
!---  Deallocate memory for the IJK half-band width array  ---
!
      IF( ALLOCATED(M_IJK) ) THEN
        DEALLOCATE( M_IJK,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_IJK'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the JKI half-band width array  ---
!
      IF( ALLOCATED(M_JKI) ) THEN
        DEALLOCATE( M_JKI,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_JKI'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the KIJ half-band width array  ---
!
      IF( ALLOCATED(M_KIJ) ) THEN
        DEALLOCATE( M_KIJ,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_KIJ'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_CW_DP group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_CW_FRC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for the coupled
!     well model with coupled fracture/faults
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 27 May 2020.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_FRC
      USE LEAK_WELL
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE COUP_WELL
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: M_IJK,M_JKI,M_KIJ
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_CW_FRC'
!
!---  Allocate memory for fracture/fault Jacobian matrix 
!     equation index  ---
!
      IF( .NOT.ALLOCATED(IM_FRC) ) THEN
        ALLOCATE( IM_FRC(1:LUK,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Allocate memory for Jacobian matrix equation index  ---
!
      IF( .NOT.ALLOCATED(IM) ) THEN
        ALLOCATE( IM(1:LUK,1:LFD+LBR),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Allocate memory for coupled-well Jacobian index array  ---
!
      IF( .NOT.ALLOCATED(JM_CW) ) THEN
        ALLOCATE( JM_CW(1:LN_CW),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: JM_CW'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Allocate memory for half-band width count array 
!     for IJK index ordering  ---
!
      IF( .NOT.ALLOCATED(M_IJK) ) THEN
        ALLOCATE( M_IJK(1:2,1:LN_CW),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: M_IJK'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Allocate memory for half-band width count array 
!     for JKI index ordering  ---
!
      IF( .NOT.ALLOCATED(M_JKI) ) THEN
        ALLOCATE( M_JKI(1:2,1:LN_CW),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: M_JKI'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Allocate memory for half-band width count array 
!     for KIJ index ordering  ---
!
      IF( .NOT.ALLOCATED(M_KIJ) ) THEN
        ALLOCATE( M_KIJ(1:2,1:LN_CW),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: M_KIJ'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Initialize number of unknowns  ---
!
      ISVC = LUK
      ILIMIT = 2**30
!
!---  Coupled equations half band width using I,J,K ordering  ---
!
      NC = 0
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        IF( IXP(N).EQ.0 ) CYCLE
        IF( IBR(4,N).GT.N ) THEN
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          IXP(N) = -(IRX*JRX*KRX)
          DO KX = 1,KRX
          DO JX = 1,JRX
          DO IX = 1,IRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NC = NC + 1
            IXP(NX) = NC
          ENDDO
          ENDDO
          ENDDO
        ELSE
          NC = NC + 1
          IXP(N) = NC
        ENDIF
      ENDDO
      ENDDO
      ENDDO
!
!---  Leaky well nodes  ---
!
      DO NLW = 1,N_LW
!
!---    Loop over number of leaky well nodes in the leaky well  ---
!
        DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
          N = ND_LW(NWN)
          NC = NC + 1
          IXP(N) = NC
        ENDDO
      ENDDO
!
!---  Loop over coupled wells  ---
!
      DO 60 NCW = 1,LN_CW
        M_IJK(1,NCW) = ILIMIT
!
!---    Locate coupled well equation at the mid-point of the string
!       of field nodes that contain the well  ---
!
        IDCW = (ID_CW(5,NCW)+ID_CW(6,NCW))/2
        NC = 0
        NWF = IWF_CW(IDCW)
        MHBC_IJK = 0
        DO K = 1,LFZ
        DO J = 1,LFY
        DO I = 1,LFX
          N = ND(I,J,K)
!
!---      Loop over block refined nodes  ---
!
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO KX = 1,KRX
            DO JX = 1,JRX
            DO IX = 1,IRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NMD = IXP(NX)
              DO 12 M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
   12         CONTINUE
              IF( NWF.EQ.NX ) THEN
                NC = NC+1
                JM_CWX = NC
              ENDIF
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NMD = IXP(N)
!
!---        Skip to next active node  ---
!
            IF( IXP(N).EQ.0 ) CYCLE
            DO 16 M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
   16       CONTINUE
            IF( NWF.EQ.N ) THEN
              NC = NC+1
              JM_CWX = NC
            ENDIF
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NMD = ABS(IXP(N))
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths, using I,J,K ordering  ---
!
        DO K = 1,LFZ
        DO J = 1,LFY
        DO I = 1,LFX
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          DO KX = 1,KRX
          DO JX = 1,JRX
          DO IX = 1,IRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NP = IXP(NX)
!
!---        Node  ---
!
            MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                DO 21 MX = 1,4
                  NB = ICM(MX,1,NX)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
   21           CONTINUE
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                DO 22 MX = 1,4
                  NS = ICM(MX,2,NX)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
   22           CONTINUE
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                DO 23 MX = 1,4
                  NW = ICM(MX,3,NX)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
   23           CONTINUE
             ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                DO 24 MX = 1,4
                  NE = ICM(MX,4,NX)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
   24           CONTINUE
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                DO 25 MX = 1,4
                  NN = ICM(MX,5,NX)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NN)),
     &              ABS(IM(ISVC,NP)-IM(1,NN)))
   25           CONTINUE
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                DO 26 MX = 1,4
                  NT = ICM(MX,6,NX)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
   26           CONTINUE
              ENDIF
            ENDIF
!
!---        Coupled well nodes  ---
!
            DO 30 JDCW = ID_CW(5,NCW),ID_CW(6,NCW)
              IF( IWF_CW(JDCW).EQ.NX ) THEN
                MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-JM_CWX),
     &            ABS(IM(ISVC,NP)-JM_CWX))
              ENDIF
   30       CONTINUE
          ENDDO
          ENDDO
          ENDDO
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NP = ABS(IXP(N))
!
!---        Bottom leaky well node  ---
!
            IF( ICM(1,1,N).NE.0 ) THEN
              NB = ABS(IXP(ICM(1,1,N)))
              MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NB)),
     &          ABS(IM(ISVC,NP)-IM(1,NB)))
            ENDIF
!
!---        Connected field node  ---
!
            IF( NF_LW(NWN).NE.0 ) THEN
              NW = ABS(IXP(NF_LW(NWN)))
              MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NW)),
     &          ABS(IM(ISVC,NP)-IM(1,NW)))
            ENDIF
!
!---        Top leaky well node  ---
!
            IF( ICM(1,6,N).NE.0 ) THEN
              NT = ABS(IXP(ICM(1,6,N)))
              MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NT)),
     &          ABS(IM(ISVC,NP)-IM(1,NT)))
            ENDIF
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        Fracture/fault triangle unknowns  ---
!
            MHBC_IJK = MAX( MHBC_IJK,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC_IJK = MAX( MHBC_IJK,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to matrix node 
!       connections, first looping over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to grid cell 
!           connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC_IJK = MAX( MHBC_IJK,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
            ENDDO
          ENDDO
        ENDDO
        IF( MHBC_IJK.LT.M_IJK(1,NCW) ) THEN
          M_IJK(1,NCW) = MHBC_IJK
          M_IJK(2,NCW) = IDCW
        ENDIF
   60 CONTINUE
!
!---  Coupled equations half band width using J,K,I ordering  ---
!
      NC = 0
      DO I = 1,LFX
      DO K = 1,LFZ
      DO J = 1,LFY
        N = ND(I,J,K)
        IF( IXP(N).EQ.0 ) CYCLE
        IF( IBR(4,N).GT.N ) THEN
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          IXP(N) = -(IRX*JRX*KRX)
          DO IX = 1,IRX
          DO KX = 1,KRX
          DO JX = 1,JRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NC = NC + 1
            IXP(NX) = NC
          ENDDO
          ENDDO
          ENDDO
        ELSE
          NC = NC + 1
          IXP(N) = NC
        ENDIF
      ENDDO
      ENDDO
      ENDDO
!
!---  Leaky well nodes  ---
!
      DO NLW = 1,N_LW
!
!---    Loop over number of leaky well nodes in the leaky well  ---
!
        DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
          N = ND_LW(NWN)
          NC = NC + 1
          IXP(N) = NC
        ENDDO
      ENDDO
!
!---  Loop over coupled wells  ---
!
      DO 120 NCW = 1,LN_CW
        M_JKI(1,NCW) = ILIMIT
!
!---    Locate coupled well equation at the mid-point of the string
!       of field nodes that contain the well  ---
!
        IDCW = (ID_CW(5,NCW)+ID_CW(6,NCW))/2
        NC = 0
        NWF = IWF_CW(IDCW)
        MHBC_JKI = 0
        DO I = 1,LFX
        DO K = 1,LFZ
        DO J = 1,LFY
          N = ND(I,J,K)
!
!---       Loop over block refined nodes  ---
!
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO IX = 1,IRX
            DO KX = 1,KRX
            DO JX = 1,JRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NMD = IXP(NX)
              DO 72 M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
   72         CONTINUE
              IF( NWF.EQ.NX ) THEN
                NC = NC+1
                JM_CWX = NC
              ENDIF
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NMD = IXP(N)
!
!---        Skip to next active node  ---
!
            IF( IXP(N).EQ.0 ) CYCLE
            DO 76 M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
   76       CONTINUE
            IF( NWF.EQ.N ) THEN
              NC = NC+1
              JM_CWX = NC
            ENDIF
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NMD = ABS(IXP(N))
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths, using J,K,I ordering  ---
!
        DO I = 1,LFX
        DO K = 1,LFZ
        DO J = 1,LFY
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          DO IX = 1,IRX
          DO KX = 1,KRX
          DO JX = 1,JRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NP = IXP(NX)
!
!---        Node  ---
!
            MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                DO 81 MX = 1,4
                  NB = ICM(MX,1,NX)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
   81           CONTINUE
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                DO 82 MX = 1,4
                  NS = ICM(MX,2,NX)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
   82           CONTINUE
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                DO 83 MX = 1,4
                  NW = ICM(MX,3,NX)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
   83           CONTINUE
             ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                DO 84 MX = 1,4
                  NE = ICM(MX,4,NX)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
   84           CONTINUE
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                DO 85 MX = 1,4
                  NN = ICM(MX,5,NX)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NN)),
     &              ABS(IM(ISVC,NP)-IM(1,NN)))
   85           CONTINUE
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                DO 86 MX = 1,4
                  NT = ICM(MX,6,NX)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
   86           CONTINUE
              ENDIF
            ENDIF
!
!---        Coupled well nodes  ---
!
            DO 90 JDCW = ID_CW(5,NCW),ID_CW(6,NCW)
              IF( IWF_CW(JDCW).EQ.NX ) THEN
                MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-JM_CWX),
     &            ABS(IM(ISVC,NP)-JM_CWX))
              ENDIF
   90       CONTINUE
          ENDDO
          ENDDO
          ENDDO
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NP = ABS(IXP(N))
!
!---        Bottom leaky well node  ---
!
            IF( ICM(1,1,N).NE.0 ) THEN
              NB = ABS(IXP(ICM(1,1,N)))
              MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NB)),
     &          ABS(IM(ISVC,NP)-IM(1,NB)))
            ENDIF
!
!---        Connected field node  ---
!
            IF( NF_LW(NWN).NE.0 ) THEN
              NW = ABS(IXP(NF_LW(NWN)))
              MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NW)),
     &          ABS(IM(ISVC,NP)-IM(1,NW)))
            ENDIF
!
!---        Top leaky well node  ---
!
            IF( ICM(1,6,N).NE.0 ) THEN
              NT = ABS(IXP(ICM(1,6,N)))
              MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NT)),
     &          ABS(IM(ISVC,NP)-IM(1,NT)))
            ENDIF
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        Fracture/fault triangle unknowns  ---
!
            MHBC_JKI = MAX( MHBC_JKI,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC_JKI = MAX( MHBC_JKI,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to 
!       matrix node connections, first looping over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to grid cell 
!           connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC_JKI = MAX( MHBC_JKI,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
            ENDDO
          ENDDO
        ENDDO
        IF( MHBC_JKI.LT.M_JKI(1,NCW) ) THEN
          M_JKI(1,NCW) = MHBC_JKI
          M_JKI(2,NCW) = IDCW
        ENDIF
  120 CONTINUE
!
!---  Coupled equations half band width using K,I,J ordering  ---
!
      NC = 0
      DO J = 1,LFY
      DO I = 1,LFX
      DO K = 1,LFZ
        N = ND(I,J,K)
        IF( IXP(N).EQ.0 ) CYCLE
        IF( IBR(4,N).GT.N ) THEN
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          IXP(N) = -(IRX*JRX*KRX)
          DO JX = 1,JRX
          DO IX = 1,IRX
          DO KX = 1,KRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NC = NC + 1
            IXP(NX) = NC
          ENDDO
          ENDDO
          ENDDO
        ELSE
          NC = NC + 1
          IXP(N) = NC
        ENDIF
      ENDDO
      ENDDO
      ENDDO
!
!---  Leaky well nodes  ---
!
      DO NLW = 1,N_LW
!
!---    Loop over number of leaky well nodes in the leaky well  ---
!
        DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
          N = ND_LW(NWN)
          NC = NC + 1
          IXP(N) = NC
        ENDDO
      ENDDO
!
!---  Loop over coupled wells  ---
!
      DO 180 NCW = 1,LN_CW
        M_KIJ(1,NCW) = ILIMIT
!
!---    Locate coupled well equation at the mid-point of the string
!       of field nodes that contain the well  ---
!
        IDCW = (ID_CW(5,NCW)+ID_CW(6,NCW))/2
        NC = 0
        NWF = IWF_CW(IDCW)
        MHBC_KIJ = 0
        DO J = 1,LFY
        DO I = 1,LFX
        DO K = 1,LFZ
          N = ND(I,J,K)
!
!---       Loop over block refined nodes  ---
!
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO JX = 1,JRX
            DO IX = 1,IRX
            DO KX = 1,KRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NMD = IXP(NX)
              DO 132 M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
  132         CONTINUE
              IF( NWF.EQ.NX ) THEN
                NC = NC+1
                JM_CWX = NC
              ENDIF
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NMD = IXP(N)
!
!---        Skip to next active node  ---
!
            IF( IXP(N).EQ.0 ) CYCLE
            DO 136 M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
  136       CONTINUE
            IF( NWF.EQ.N ) THEN
              NC = NC+1
              JM_CWX = NC
            ENDIF
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NMD = ABS(IXP(N))
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths, using K,I,J ordering  ---
!
        DO J = 1,LFY
        DO I = 1,LFX
        DO K = 1,LFZ
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          DO IX = 1,IRX
          DO KX = 1,KRX
          DO JX = 1,JRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NP = IXP(NX)
!
!---        Node  ---
!
            MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                DO 141 MX = 1,4
                  NB = ICM(MX,1,NX)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
  141           CONTINUE
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                DO 142 MX = 1,4
                  NS = ICM(MX,2,NX)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
  142           CONTINUE
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                DO 143 MX = 1,4
                  NW = ICM(MX,3,NX)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
  143           CONTINUE
             ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                DO 144 MX = 1,4
                  NE = ICM(MX,4,NX)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
  144           CONTINUE
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                DO 145 MX = 1,4
                  NN = ICM(MX,5,NX)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NN)),
     &              ABS(IM(ISVC,NP)-IM(1,NN)))
  145           CONTINUE
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                DO 146 MX = 1,4
                  NT = ICM(MX,6,NX)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
  146           CONTINUE
              ENDIF
            ENDIF
!
!---        Coupled well nodes  ---
!
            DO 150 JDCW = ID_CW(5,NCW),ID_CW(6,NCW)
              IF( IWF_CW(JDCW).EQ.NX ) THEN
                MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-JM_CWX),
     &            ABS(IM(ISVC,NP)-JM_CWX))
              ENDIF
  150       CONTINUE
          ENDDO
          ENDDO
          ENDDO
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NP = ABS(IXP(N))
!
!---        Bottom leaky well node  ---
!
            IF( ICM(1,1,N).NE.0 ) THEN
              NB = ABS(IXP(ICM(1,1,N)))
              MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NB)),
     &          ABS(IM(ISVC,NP)-IM(1,NB)))
            ENDIF
!
!---        Connected field node  ---
!
            IF( NF_LW(NWN).NE.0 ) THEN
              NW = ABS(IXP(NF_LW(NWN)))
              MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NW)),
     &          ABS(IM(ISVC,NP)-IM(1,NW)))
            ENDIF
!
!---        Top leaky well node  ---
!
            IF( ICM(1,6,N).NE.0 ) THEN
              NT = ABS(IXP(ICM(1,6,N)))
              MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NT)),
     &          ABS(IM(ISVC,NP)-IM(1,NT)))
            ENDIF
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        Fracture/fault triangle unknowns  ---
!
            MHBC_KIJ = MAX( MHBC_KIJ,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC_KIJ = MAX( MHBC_KIJ,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to 
!       matrix node connections, first looping over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to grid cell 
!           connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC_KIJ = MAX( MHBC_KIJ,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
            ENDDO
          ENDDO
        ENDDO
        IF( MHBC_KIJ.LT.M_KIJ(1,NCW) ) THEN
          M_KIJ(1,NCW) = MHBC_KIJ
          M_KIJ(2,NCW) = IDCW
        ENDIF
  180 CONTINUE
!
!---  Loop over wells searching for the maximum half band width   ---
!
      MHBC_IJK = 0
      MHBC_JKI = 0
      MHBC_KIJ = 0
      DO 190 NCW = 1,N_CW
        IF( M_IJK(1,NCW).GT.MHBC_IJK ) MHBC_IJK = M_IJK(1,NCW)
        IF( M_JKI(1,NCW).GT.MHBC_JKI ) MHBC_JKI = M_JKI(1,NCW)
        IF( M_KIJ(1,NCW).GT.MHBC_KIJ ) MHBC_KIJ = M_KIJ(1,NCW)
  190 CONTINUE
!
!---  IJK ordering yields the lowest half band width   ---
!
      IF( MHBC_IJK.LE.MHBC_JKI .AND. MHBC_IJK.LE.MHBC_KIJ ) THEN
!
!---    Loop over coupled wells  ---
!
        DO 200 NCW = 1,LN_CW
          ID_CW(7,NCW) = M_IJK(2,NCW)
  200   CONTINUE
!
!---    Equation ordering using I,J,K ordering, skipping inactive
!       nodes  ---
!
        NC = 0
        DO K = 1,LFZ
        DO J = 1,LFY
        DO I = 1,LFX
          N = ND(I,J,K)
          IF( IXP(N).EQ.0 ) CYCLE
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            IXP(N) = -(IRX*JRX*KRX)
            DO KX = 1,KRX
            DO JX = 1,JRX
            DO IX = 1,IRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NC = NC + 1
              IXP(NX) = NC
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NC = NC + 1
            IXP(N) = NC
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NC = NC + 1
            IXP(N) = NC
          ENDDO
        ENDDO
!
!---    Initialize counter  ---
!
        NC = 0
        MHBC = 0
!
!---    Coupled equations half band width using I,J,K ordering  ---
!
        DO K = 1,LFZ
        DO J = 1,LFY
        DO I = 1,LFX
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
!
!---      Loop over block refined nodes  ---
!
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO KX = 1,KRX
            DO JX = 1,JRX
            DO IX = 1,IRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NMD = IXP(NX)
              DO 212 M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
  212         CONTINUE
!
!---          Loop over coupled wells, placing well equation
!             in the principal node of the well  ---
!
              DO 214 NCW = 1,N_CW
                IF( IWF_CW(ID_CW(7,NCW)).EQ.NX ) THEN
                  NC = NC+1
                  JM_CW(NCW) = NC
                ENDIF
  214         CONTINUE
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NMD = IXP(N)
            DO 218 M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
  218       CONTINUE
!
!---        Loop over coupled wells, placing well equation
!           in the principal node of the well  ---
!
            DO 220 NCW = 1,N_CW
              IF( IWF_CW(ID_CW(7,NCW)).EQ.N ) THEN
                NC = NC+1
                JM_CW(NCW) = NC
              ENDIF
  220       CONTINUE
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NMD = ABS(IXP(N))
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths, using I,J,K ordering  ---
!
        DO K = 1,LFZ
        DO J = 1,LFY
        DO I = 1,LFX
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          DO KX = 1,KRX
          DO JX = 1,JRX
          DO IX = 1,IRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NP = IXP(NX)
!
!---        Node  ---
!
            MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                DO 241 MX = 1,4
                  NB = ICM(MX,1,NX)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
  241           CONTINUE
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                DO 242 MX = 1,4
                  NS = ICM(MX,2,NX)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
  242           CONTINUE
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                DO 243 MX = 1,4
                  NW = ICM(MX,3,NX)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
  243           CONTINUE
              ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                DO 244 MX = 1,4
                  NE = ICM(MX,4,NX)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
  244           CONTINUE
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                DO 245 MX = 1,4
                  NN = ICM(MX,5,NX)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NN)),
     &               ABS(IM(ISVC,NP)-IM(1,NN)))
  245           CONTINUE
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                DO 246 MX = 1,4
                  NT = ICM(MX,6,NX)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
  246           CONTINUE
              ENDIF
            ENDIF
!
!---        Coupled well nodes  ---
!
            DO 250 NCW = 1,N_CW
              DO 248 NWF = ID_CW(5,NCW),ID_CW(6,NCW)
                IF( IWF_CW(NWF).EQ.NX ) THEN
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-JM_CW(NCW)),
     &              ABS(IM(ISVC,NP)-JM_CW(NCW)))
                ENDIF
  248         CONTINUE
  250       CONTINUE
          ENDDO
          ENDDO
          ENDDO
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NP = ABS(IXP(N))
!
!---        Bottom leaky well node  ---
!
            IF( ICM(1,1,N).NE.0 ) THEN
              NB = ABS(IXP(ICM(1,1,N)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &          ABS(IM(ISVC,NP)-IM(1,NB)))
            ENDIF
!
!---        Connected field node  ---
!
            IF( NF_LW(NWN).NE.0 ) THEN
              NW = ABS(IXP(NF_LW(NWN)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &          ABS(IM(ISVC,NP)-IM(1,NW)))
            ENDIF
!
!---        Top leaky well node  ---
!
            IF( ICM(1,6,N).NE.0 ) THEN
              NT = ABS(IXP(ICM(1,6,N)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &          ABS(IM(ISVC,NP)-IM(1,NT)))
            ENDIF
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        fracture/fault triangle unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to 
!       matrix node connections, first looping over fractures/faults, 
!       counting double for fracture/fault triangle and matrix 
!       grid cell equations  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to grid cell 
!           connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
              NC = NC + 2*(ISVC**2)
              NCC = NCC + 2
            ENDDO
          ENDDO
        ENDDO
!
!---  JKI ordering yields the lowest half band width   ---
!
      ELSEIF( MHBC_JKI.LE.MHBC_KIJ ) THEN
!
!---    Loop over coupled wells  ---
!
        DO 300 NCW = 1,LN_CW
          ID_CW(7,NCW) = M_JKI(2,NCW)
  300   CONTINUE
!
!---    Equation ordering using J,K,I ordering, skipping inactive
!       nodes  ---
!
        NC = 0
        DO I = 1,LFX
        DO K = 1,LFZ
        DO J = 1,LFY
          N = ND(I,J,K)
          IF( IXP(N).EQ.0 ) CYCLE
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            IXP(N) = -(IRX*JRX*KRX)
            DO IX = 1,IRX
            DO KX = 1,KRX
            DO JX = 1,JRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NC = NC + 1
              IXP(NX) = NC
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NC = NC + 1
            IXP(N) = NC
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NC = NC + 1
            IXP(N) = NC
          ENDDO
        ENDDO
!
!---    Initialize counter  ---
!
        NC = 0
        MHBC = 0
!
!---    Coupled equations half band width using J,K,I ordering  ---
!
        DO I = 1,LFX
        DO K = 1,LFZ
        DO J = 1,LFY
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
!
!---      Loop over block refined nodes  ---
!
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO IX = 1,IRX
            DO KX = 1,KRX
            DO JX = 1,JRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NMD = IXP(NX)
              DO 312 M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
  312         CONTINUE
!
!---          Loop over coupled wells, placing well equation
!             in the principal node of the well  ---
!
              DO 314 NCW = 1,N_CW
                IF( IWF_CW(ID_CW(7,NCW)).EQ.NX ) THEN
                  NC = NC+1
                  JM_CW(NCW) = NC
                ENDIF
  314         CONTINUE
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NMD = IXP(N)
            DO 318 M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
  318       CONTINUE
!
!---        Loop over coupled wells, placing well equation
!           in the principal node of the well  ---
!
            DO 320 NCW = 1,N_CW
              IF( IWF_CW(ID_CW(7,NCW)).EQ.N ) THEN
                NC = NC+1
                JM_CW(NCW) = NC
              ENDIF
  320       CONTINUE
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NMD = ABS(IXP(N))
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths using J,K,I ordering  ---
!
        DO I = 1,LFX
        DO K = 1,LFZ
        DO J = 1,LFY
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          DO KX = 1,KRX
          DO JX = 1,JRX
          DO IX = 1,IRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NP = IXP(NX)
!
!---        Node  ---
!
            MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                DO 341 MX = 1,4
                  NB = ICM(MX,1,NX)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
  341           CONTINUE
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                DO 342 MX = 1,4
                  NS = ICM(MX,2,NX)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
  342           CONTINUE
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                DO 343 MX = 1,4
                  NW = ICM(MX,3,NX)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
  343           CONTINUE
              ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                DO 344 MX = 1,4
                  NE = ICM(MX,4,NX)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
  344           CONTINUE
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                DO 345 MX = 1,4
                  NN = ICM(MX,5,NX)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NN)),
     &               ABS(IM(ISVC,NP)-IM(1,NN)))
  345           CONTINUE
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                DO 346 MX = 1,4
                  NT = ICM(MX,6,NX)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
  346           CONTINUE
              ENDIF
            ENDIF
!
!---        Coupled well nodes  ---
!
            DO 350 NCW = 1,N_CW
              DO 348 NWF = ID_CW(5,NCW),ID_CW(6,NCW)
                IF( IWF_CW(NWF).EQ.NX ) THEN
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-JM_CW(NCW)),
     &              ABS(IM(ISVC,NP)-JM_CW(NCW)))
                ENDIF
  348         CONTINUE
  350       CONTINUE
          ENDDO
          ENDDO
          ENDDO
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NP = ABS(IXP(N))
!
!---        Bottom leaky well node  ---
!
            IF( ICM(1,1,N).NE.0 ) THEN
              NB = ABS(IXP(ICM(1,1,N)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &          ABS(IM(ISVC,NP)-IM(1,NB)))
            ENDIF
!
!---        Connected field node  ---
!
            IF( NF_LW(NWN).NE.0 ) THEN
              NW = ABS(IXP(NF_LW(NWN)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &          ABS(IM(ISVC,NP)-IM(1,NW)))
            ENDIF
!
!---        Top leaky well node  ---
!
            IF( ICM(1,6,N).NE.0 ) THEN
              NT = ABS(IXP(ICM(1,6,N)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &          ABS(IM(ISVC,NP)-IM(1,NT)))
            ENDIF
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        Fracture/fault triangle unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to matrix node connections, 
!       first looping over fractures/faults, counting double for 
!       fracture/fault triangle and matrix grid cell equations  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to grid cell 
!           connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
              NC = NC + 2*(ISVC**2)
              NCC = NCC + 2
            ENDDO
          ENDDO
        ENDDO
!
!---  KIJ ordering yields the lowest half band width   ---
!
      ELSE
!
!---    Loop over coupled wells  ---
!
        DO 400 NCW = 1,LN_CW
          ID_CW(7,NCW) = M_KIJ(2,NCW)
  400   CONTINUE
!
!---    Equation ordering using K,I,J ordering, skipping inactive
!       nodes  ---
!
        NC = 0
        DO J = 1,LFY
        DO I = 1,LFX
        DO K = 1,LFZ
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            IXP(N) = -(IRX*JRX*KRX)
            DO JX = 1,JRX
            DO IX = 1,IRX
            DO KX = 1,KRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NC = NC + 1
              IXP(NX) = NC
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NC = NC + 1
            IXP(N) = NC
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NC = NC + 1
            IXP(N) = NC
          ENDDO
        ENDDO
!
!---    Initialize counter  ---
!
        NC = 0
        MHBC = 0
!
!---    Coupled equations half band width using K,I,J ordering  ---
!
        DO J = 1,LFY
        DO I = 1,LFX
        DO K = 1,LFZ
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
!
!---      Loop over block refined nodes  ---
!
          IF( IBR(4,N).GT.N ) THEN
            IRX = 2**IBR(1,N)
            JRX = 2**IBR(2,N)
            KRX = 2**IBR(3,N)
            DO IX = 1,IRX
            DO KX = 1,KRX
            DO JX = 1,JRX
              NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
              NMD = IXP(NX)
              DO 412 M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
  412         CONTINUE
!
!---          Loop over coupled wells, placing well equation
!             in the principal node of the well  ---
!
              DO 414 NCW = 1,N_CW
                IF( IWF_CW(ID_CW(7,NCW)).EQ.NX ) THEN
                  NC = NC+1
                  JM_CW(NCW) = NC
                ENDIF
  414         CONTINUE
            ENDDO
            ENDDO
            ENDDO
          ELSE
            NMD = IXP(N)
            DO 418 M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
  418       CONTINUE
            DO 420 NCW = 1,N_CW
              IF( IWF_CW(ID_CW(7,NCW)).EQ.N ) THEN
                NC = NC+1
                JM_CW(NCW) = NC
              ENDIF
  420       CONTINUE
          ENDIF
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NMD = ABS(IXP(N))
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths using K,I,J ordering  ---
!
        DO J = 1,LFY
        DO I = 1,LFX
        DO K = 1,LFZ
          N = ND(I,J,K)
!
!---      Skip to next active node  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IRX = 2**IBR(1,N)
          JRX = 2**IBR(2,N)
          KRX = 2**IBR(3,N)
          DO KX = 1,KRX
          DO JX = 1,JRX
          DO IX = 1,IRX
            NX = IBR(4,N) + ND_BR(IX,IRX,JX,JRX,KX)
            NP = IXP(NX)
!
!---        Node  ---
!
            MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                DO 441 MX = 1,4
                  NB = ICM(MX,1,NX)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
  441           CONTINUE
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                DO 442 MX = 1,4
                  NS = ICM(MX,2,NX)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
  442           CONTINUE
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                DO 443 MX = 1,4
                  NW = ICM(MX,3,NX)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
  443           CONTINUE
              ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                DO 444 MX = 1,4
                  NE = ICM(MX,4,NX)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
  444           CONTINUE
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                DO 445 MX = 1,4
                  NN = ICM(MX,5,NX)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NN)),
     &               ABS(IM(ISVC,NP)-IM(1,NN)))
  445           CONTINUE
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                DO 446 MX = 1,4
                  NT = ICM(MX,6,NX)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
  446           CONTINUE
              ENDIF
            ENDIF
!
!---        Coupled well nodes  ---
!
            DO 450 NCW = 1,N_CW
              DO 440 NWF = ID_CW(5,NCW),ID_CW(6,NCW)
                IF( IWF_CW(NWF).EQ.NX ) THEN
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-JM_CW(NCW)),
     &              ABS(IM(ISVC,NP)-JM_CW(NCW)))
                ENDIF
  440         CONTINUE
  450       CONTINUE
          ENDDO
          ENDDO
          ENDDO
        ENDDO
        ENDDO
        ENDDO
!
!---    Leaky well nodes  ---
!
        DO NLW = 1,N_LW
!
!---      Loop over number of leaky well nodes in the leaky well  ---
!
          DO NWN = ID_LW(3,NLW),ID_LW(4,NLW)
            N = ND_LW(NWN)
            NP = ABS(IXP(N))
!
!---        Bottom leaky well node  ---
!
            IF( ICM(1,1,N).NE.0 ) THEN
              NB = ABS(IXP(ICM(1,1,N)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &          ABS(IM(ISVC,NP)-IM(1,NB)))
            ENDIF
!
!---        Connected field node  ---
!
            IF( NF_LW(NWN).NE.0 ) THEN
              NW = ABS(IXP(NF_LW(NWN)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &          ABS(IM(ISVC,NP)-IM(1,NW)))
            ENDIF
!
!---        Top leaky well node  ---
!
            IF( ICM(1,6,N).NE.0 ) THEN
              NT = ABS(IXP(ICM(1,6,N)))
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &          ABS(IM(ISVC,NP)-IM(1,NT)))
            ENDIF
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        Fracture/fault triangle unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to matrix node connections, 
!       first looping over fractures/faults, counting double for 
!       fracture/fault triangle and matrix grid cell equations  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to 
!           grid cell connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
              NC = NC + 2*(ISVC**2)
              NCC = NCC + 2
            ENDDO
          ENDDO
        ENDDO
      ENDIF



!
!---  SPLIB .or. Lis .or. PETSc Solver  ---
!
      LJO = NC
      LJM = NCC
!
!---  Deallocate memory for fracture/fault Jacobian matrix 
!     equation index  ---
!
      IF( ALLOCATED(IM_FRC) ) THEN
        DEALLOCATE( IM_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the IJK half-band width array  ---
!
      IF( ALLOCATED(M_IJK) ) THEN
        DEALLOCATE( M_IJK,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_IJK'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the JKI half-band width array  ---
!
      IF( ALLOCATED(M_JKI) ) THEN
        DEALLOCATE( M_JKI,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_JKI'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Deallocate memory for the KIJ half-band width array  ---
!
      IF( ALLOCATED(M_KIJ) ) THEN
        DEALLOCATE( M_KIJ,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: M_KIJ'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_CW_FRC group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_FRC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for fracture/fault and
!     borehole flow
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 18 April 2019.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_FRC
      USE PARM_BH
      USE JACOB
      USE GEOM_FRC
      USE GEOM_BH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_FRC'
!
!---  Allocate memory for fracture/fault Jacobian matrix 
!     equation index  ---
!
      IF( .NOT.ALLOCATED(IM_FRC) ) THEN
        ALLOCATE( IM_FRC(1:LUK,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( .NOT.ALLOCATED(IM_BH) ) THEN
        ALLOCATE( IM_BH(1:LUK,1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Initialize number of unknowns  ---
!
      ISVC = LUK
      NC = 0
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_FRC(M,NTX) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Loop over number of borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_BH(M,NBN) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Determine matrix half-band widths  ---
!
      MHBC_FRC = 0
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
          IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---      Fracture/fault triangle unknowns  ---
!
          MHBC_FRC = MAX( MHBC_FRC,
     &      ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
!
!---      Loop over fracture/fault triangle to
!         fracture/fault triangle connections  ---
!
          DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
            NT2X = ITCM_FRC(NCX)
            IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
            MHBC_FRC = MAX( MHBC_FRC,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &        ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Loop over borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
          NT1X = NBN + NT_FRC - NXP_FRC
!
!---      Borehole node unknowns  ---
!
          MHBC_FRC = MAX( MHBC_FRC,
     &      ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN)) )
!
!---      Loop over borehole node to borehole node connections,
!         where borehole nodes are only connected to adjacent 
!         borehole nodes  ---
!
          NC1X = MAX( NBN-1,ID_BH(3,NBH) )
          NC2X = MIN( NBN+1,ID_BH(4,NBH) )
          DO NCX = NC1X,NC2X
            NT2X = NCX + NT_FRC - NXP_FRC
            MHBC_FRC = MAX( MHBC_FRC,
     &        ABS(IM_BH(1,NBN)-IM_BH(ISVC,NCX)),
     &        ABS(IM_BH(ISVC,NBN)-IM_BH(1,NCX)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fracture/fault triangle to 
!     borehole node connections  ---
!
      DO NBH = 1,N_BH
        DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
          NT1X = IBHT_FRC(NBTC)
          NBN = IBHN_FRC(NBTC)
          NT2X = IBHN_FRC(NBTC) + NT_FRC - NXP_FRC
          MHBC_FRC = MAX( MHBC_FRC,
     &      ABS(IM_FRC(1,NT1X)-IM_BH(ISVC,NBN)),
     &      ABS(IM_FRC(ISVC,NT1X)-IM_BH(1,NBN)) )
         ENDDO
      ENDDO



!
!---  SPLIB .or. Lis .or. PETSc Solver  ---
!
      NC = 0
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
          IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
          DO L = 1,ISVC
            MA = 0
!
!---        Fracture/fault triangle  ---
!
            NC = NC + ISVC
            MA = MA + ISVC
!
!---        Loop over fracture/fault triangle to  
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
!
!---          Fracture/fault triangle to fracture/fault
!             triangle connections  ---
!
              NC = NC + ISVC
              MA = MA + ISVC
            ENDDO
!
!---        Loop over fracture/fault triangle to
!           borehole node connections  ---
!
            DO NBH = 1,N_BH
              DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
!
!---            Check if fracture/fault triangle is connected to
!               borehole node  ---
!
                IF( NT1X.EQ.IBHT_FRC(NBTC) ) THEN
                  NT2X = IBHN_FRC(NBTC) + NT_FRC - NXP_FRC
!
!---              fracture/fault triangle to borehole node 
!                 connections  ---
!
                  NC = NC + ISVC
                  MA = MA + ISVC
                ENDIF
              ENDDO
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Loop over borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
          NT1X = NBN + NT_FRC - NXP_FRC
          DO L = 1,ISVC
            MA = 0
!
!---        Borehole node  ---
!
            NC = NC + ISVC
            MA = MA + ISVC
!
!---        Loop over borehole node to borehole node connections,
!           where borehole nodes are only connected to adjacent 
!           borehole nodes  ---
!
            NC1X = MAX( NBN-1,ID_BH(3,NBH) )
            NC2X = MIN( NBN+1,ID_BH(4,NBH) )
            DO NCX = NC1X,NC2X
!
!---          Borehole node to borehole node connections  ---
!
              NC = NC + ISVC
              MA = MA + ISVC
            ENDDO
!
!---        Loop over borehole node to 
!           fracture/fault triangle connections  ---
!
            DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
!
!---          Check if borehole node is connected to
!             fracture/fault triangle  ---
!
              IF( NBN.EQ.IBHN_FRC(NBTC) ) THEN
                NT2X = IBHT_FRC(NBTC)
!
!---            Borehole node to fracture/fault triangle 
!               connections  ---
!
                NC = NC + ISVC
                MA = MA + ISVC
              ENDIF
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
!---  Deallocate memory for fracture/fault Jacobian matrix 
!     equation index  ---
!
      IF( ALLOCATED(IM_FRC) ) THEN
        DEALLOCATE( IM_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(IM_BH) ) THEN
        DEALLOCATE( IM_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(IP_FRC) ) THEN
        DEALLOCATE( IP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(ITCM_FRC) ) THEN
        DEALLOCATE( ITCM_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ITCM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(IPF_FRC) ) THEN
        DEALLOCATE( IPF_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IPF_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_FRC group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_GM
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for geomechanics
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 22 November 2016.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE GEO_MECH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER ISTCX(27)
      INTEGER NKX(8,8)
!
!----------------------Data Statements---------------------------------!
!
      DATA NKX /14,13,11,10,5,4,2,1,
     &          15,14,12,11,6,5,3,2,
     &          17,16,14,13,8,7,5,4,
     &          18,17,15,14,9,8,6,5,
     &          23,22,20,19,14,13,11,10,
     &          24,23,21,20,15,14,12,11,
     &          26,25,23,22,17,16,14,13,
     &          27,26,24,23,18,17,15,14 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_GM'
!
!---  Allocate memory for Jacobian matrix equation index  ---
!
      IF( .NOT.ALLOCATED(IM_GM) ) THEN
        ALLOCATE( IM_GM(1:LFEN),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM_GM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Geomechanics equations half band width  ---
!
      MHB_GM = 0
      NC = 0
!
!---  Loop over number of finite-element nodes to load
!     the Jacobian matrix pointer array  ---
!
      DO NFEN = 1,LFEN
!
!---    Finite-element node is inactive, only if all elements
!       that contain the FE node are inactive grid cells  ---
!
        IFX = 0
        DO M = 1,8
          N = NE_GM(M,NFEN)
          IF( N.EQ.0 ) CYCLE
          IF( IXP(N).NE.0 ) THEN
            IFX = 1
            EXIT
          ENDIF
        ENDDO
        IF( IFX.EQ.1 ) THEN
          NC = NC + 1
          IM_GM(NFEN) = NC
        ENDIF
      ENDDO
!
!---  Loop over number of finite-element nodes to compute the minimum
!     half band width  ---
!
      DO NFEN = 1,LFEN
!
!---    Loop over the connections to adjacent finite elements  ---
!
        DO M1 = 1,8
          N = NE_GM(M1,NFEN)
          IF( N.EQ.0 ) CYCLE
!
!---      Loop over the FE nodes in the adjacent finite element  ---
!
          DO M2 = 1,8
            MFEN = ND_GM(M2,N)
            IF( MFEN.EQ.0 ) CYCLE
!
!---        Compute differences in displacement equations for FE nodes
!           connected through adjacent finite elements  ---
!
            IM1X = (IM_GM(NFEN)-1)*3 + 1
            IM2X = (IM_GM(MFEN)-1)*3 + 3
            IM3X = (IM_GM(NFEN)-1)*3 + 3
            IM4X = (IM_GM(MFEN)-1)*3 + 1
            MHB_GM = MAX( MHB_GM,ABS(IM1X-IM2X),ABS(IM3X-IM4X) )
          ENDDO
        ENDDO
      ENDDO



!
!---  SPLIB .or. Lis .or. PETSc Solver  ---
!
      NC = 0
!
!---  Loop over number of finite-element nodes  ---
!
      DO NFEN = 1,LFEN
!
!---    Determine the connection stencil for the finite-element
!       node  ---
!
        DO M1 = 1,27
          ISTCX(M1) = 0
        ENDDO
!
!---    Loop over the connections to adjacent finite elements  ---
!
        DO M2 = 1,8
          N = NE_GM(M2,NFEN)
          IF( N.EQ.0 ) CYCLE
!
!---      Loop over the FE nodes in the adjacent finite element  ---
!
          DO M3 = 1,8
            MFEN = ND_GM(M3,N)
            IF( MFEN.EQ.0 ) CYCLE
            ISTCX(NKX(M2,M3)) = MFEN
          ENDDO
        ENDDO
!
!---    Loop over displacement equations  ---
!
        DO M4 = 1,3
          NMD = (IM_GM(NFEN)-1)*3 + M4
!
!---      Loop over the active connections  ---
!
          DO M5 = 1,27
            IF( ISTCX(M5).EQ.0 ) CYCLE
            MFEN = ISTCX(M5)
!
!---        Loop over displacement equations  ---
!
            DO M6 = 1,3
              NC = NC + 1
            ENDDO
          ENDDO
        ENDDO
      ENDDO
      LJO_GM = MAX( NC,LJO_GM )
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_GM group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_MFB
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for fully coupled matrix,
!     fracture/fault, and borehole flow and transport
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 26 August 2019.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_FRC
      USE PARM_BH
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE GEOM_BH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_MFB'
!
!---  Allocate memory for matrix Jacobian matrix equation index  ---
!
      IF( .NOT.ALLOCATED(IM) ) THEN
        ALLOCATE( IM(1:LUK,1:LFD+LBR),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Allocate memory for fracture/fault Jacobian matrix 
!     equation index  ---
!
      IF( .NOT.ALLOCATED(IM_FRC) ) THEN
        ALLOCATE( IM_FRC(1:LUK,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Allocate memory for borehole Jacobian matrix equation index  ---
!
      IF( .NOT.ALLOCATED(IM_BH) ) THEN
        ALLOCATE( IM_BH(1:LUK,1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IM_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Initialize number of unknowns  ---
!
      ISVC = LUK
!
!---  Coupled equations half band width using I,J,K ordering for
!     matrix nodes, assuming no block refinement  ---
!
      NC = 0
      DO K = 1,LFZ
        DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            IF( IXP(N).EQ.0 ) CYCLE
            NC = NC + 1
            IXP(N) = NC
          ENDDO
        ENDDO
      ENDDO
      NC = 0
      MHBC_IJK = 0
!
!---  Loop over matrix nodes using I,J,K ordering  ---
!
      DO K = 1,LFZ
        DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            IF( IXP(N).EQ.0 ) CYCLE
            NMD = IXP(N)
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_FRC(M,NTX) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over number of borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_BH(M,NBN) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Determine matrix half-band widths, using I,J,K ordering  ---
!
      DO K = 1,LFZ
        DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
!
!---        Skip to next active node  ---
!
            IF( IXP(N).EQ.0 ) CYCLE
            NP = IXP(N)
!
!---        Node  ---
!
            MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                NB = ICM(1,1,N)
                IF( NB.EQ.0 ) EXIT
                NB = IXP(NB)
                MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                NS = ICM(1,2,N)
                IF( NS.EQ.0 ) EXIT
                NS = IXP(NS)
                MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NS)),
     &            ABS(IM(ISVC,NP)-IM(1,NS)))
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                NW = ICM(1,3,N)
                IF( NW.EQ.0 ) EXIT
                NW = IXP(NW)
                MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NW)),
     &            ABS(IM(ISVC,NP)-IM(1,NW)))
              ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                NE = ICM(1,4,N)
                IF( NE.EQ.0 ) EXIT
                NE = IXP(NE)
                MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NE)),
     &            ABS(IM(ISVC,NP)-IM(1,NE)))
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                NN = ICM(1,5,N)
                IF( NN.EQ.0 ) EXIT
                NN = IXP(NN)
                MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NN)),
     &            ABS(IM(ISVC,NP)-IM(1,NN)))
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                NT = ICM(1,6,N)
                IF( NT.EQ.0 ) EXIT
                NT = IXP(NT)
                MHBC_IJK = MAX(MHBC_IJK,ABS(IM(1,NP)-IM(ISVC,NT)),
     &            ABS(IM(ISVC,NP)-IM(1,NT)))
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
          IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---      Fracture/fault triangle unknowns  ---
!
          MHBC_IJK = MAX( MHBC_IJK,
     &      ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
!
!---      Loop over fracture/fault triangle to
!         fracture/fault triangle connections  ---
!
          DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
            NT2X = ITCM_FRC(NCX)
            IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
            MHBC_IJK = MAX( MHBC_IJK,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &        ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Borehole node unknowns  ---
!
          MHBC_IJK = MAX( MHBC_IJK,
     &      ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN)) )
!
!---      Loop over borehole node to borehole node connections  ---
!
          DO ICX = 1,3
            NCX = IPB_BH(ICX,NBN)
            IF( NCX.LE.0 ) CYCLE
            NBN2 = IBCM_BH(NCX)
            MHBC_IJK = MAX( MHBC_IJK,
     &        ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN2)),
     &        ABS(IM_BH(ISVC,NBN)-IM_BH(1,NBN2)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fracture/fault triangle to 
!     borehole node connections  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes and
!       coaxial boreholes  ---
!
        IF( (IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29)
     &    .OR. IT_BH(1,NBH).GE.10000 ) CYCLE
        DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
          NTX = IBHT_FRC(NBTC)
          NBN = IBHN_FRC(NBTC)
          IF( NTX.EQ.0 .OR. NBN.EQ.0 ) CYCLE
          MHBC_IJK = MAX( MHBC_IJK,
     &      ABS(IM_FRC(1,NTX)-IM_BH(ISVC,NBN)),
     &      ABS(IM_FRC(ISVC,NTX)-IM_BH(1,NBN)) )
         ENDDO
      ENDDO
!
!---  Loop over fracture/fault triangle to matrix node 
!     connections, first looping over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---      Loop over fracture/fault triangle to grid cell 
!         connections  ---
!
          DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
            N = INCM_FRC(NCX)
            NP = IXP(N)
            IF( NP.EQ.0 ) PRINT *,'NTX = ',NTX,'N = ',N,'NC = ',NC,
     &        'IPN_FRC(1,NTX) = ',IPN_FRC(1,NTX),
     &        'IPN_FRC(2,NTX) = ',IPN_FRC(2,NTX)
            MHBC_IJK = MAX( MHBC_IJK,
     &        ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &        ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over borehole node to 
!     matrix node connections, first looping over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over borehole nodes  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Field node connected to borehole node  ---
!
          N = IBN_BH(NBN)
          IF( N.EQ.0 ) CYCLE
          NP = IXP(N)
          MHBC_IJK = MAX( MHBC_IJK,
     &      ABS(IM_BH(1,NBN)-IM(ISVC,NP)),
     &      ABS(IM_BH(ISVC,NBN)-IM(1,NP)) )
        ENDDO
      ENDDO
!
!---  Coupled equations half band width using J,K,I ordering for
!     matrix nodes, assuming no block refinement  ---
!
      NC = 0
      DO I = 1,LFX
        DO K = 1,LFZ
          DO J = 1,LFY
            N = ND(I,J,K)
            IF( IXP(N).EQ.0 ) CYCLE
            NC = NC + 1
            IXP(N) = NC
          ENDDO
        ENDDO
      ENDDO
      NC = 0
      MHBC_JKI = 0
!
!---  Loop over matrix nodes using J,K,I ordering  ---
!
      DO I = 1,LFX
        DO K = 1,LFZ
          DO J = 1,LFY
            N = ND(I,J,K)
            IF( IXP(N).EQ.0 ) CYCLE
            NMD = IXP(N)
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_FRC(M,NTX) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over number of borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_BH(M,NBN) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Determine matrix half-band widths, using J,K,I ordering  ---
!
      DO I = 1,LFX
        DO K = 1,LFZ
          DO J = 1,LFY
            N = ND(I,J,K)
!
!---        Skip to next active node  ---
!
            IF( IXP(N).EQ.0 ) CYCLE
            NP = IXP(N)
!
!---        Node  ---
!
            MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                NB = ICM(1,1,N)
                IF( NB.EQ.0 ) EXIT
                NB = IXP(NB)
                MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                NS = ICM(1,2,N)
                IF( NS.EQ.0 ) EXIT
                NS = IXP(NS)
                MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NS)),
     &            ABS(IM(ISVC,NP)-IM(1,NS)))
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                NW = ICM(1,3,N)
                IF( NW.EQ.0 ) EXIT
                NW = IXP(NW)
                MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NW)),
     &            ABS(IM(ISVC,NP)-IM(1,NW)))
              ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                NE = ICM(1,4,N)
                IF( NE.EQ.0 ) EXIT
                NE = IXP(NE)
                MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NE)),
     &            ABS(IM(ISVC,NP)-IM(1,NE)))
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                NN = ICM(1,5,N)
                IF( NN.EQ.0 ) EXIT
                NN = IXP(NN)
                MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NN)),
     &            ABS(IM(ISVC,NP)-IM(1,NN)))
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                NT = ICM(1,6,N)
                IF( NT.EQ.0 ) EXIT
                NT = IXP(NT)
                MHBC_JKI = MAX(MHBC_JKI,ABS(IM(1,NP)-IM(ISVC,NT)),
     &            ABS(IM(ISVC,NP)-IM(1,NT)))
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
          IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---      Fracture/fault triangle unknowns  ---
!
          MHBC_JKI = MAX( MHBC_JKI,
     &      ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
!
!---      Loop over fracture/fault triangle to
!         fracture/fault triangle connections  ---
!
          DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
            NT2X = ITCM_FRC(NCX)
            IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
            MHBC_JKI = MAX( MHBC_JKI,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &        ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Borehole node unknowns  ---
!
          MHBC_JKI = MAX( MHBC_JKI,
     &      ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN)) )
!
!---      Loop over borehole node to borehole node connections  ---
!
          DO ICX = 1,3
            NCX = IPB_BH(ICX,NBN)
            IF( NCX.LE.0 ) CYCLE
            NBN2 = IBCM_BH(NCX)
            MHBC_JKI = MAX( MHBC_JKI,
     &        ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN2)),
     &        ABS(IM_BH(ISVC,NBN)-IM_BH(1,NBN2)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fracture/fault triangle to 
!     borehole node connections  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes or
!       coaxial boreholes  ---
!
        IF( (IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29)
     &    .OR. IT_BH(1,NBH).GE.10000 ) CYCLE
        DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
          NTX = IBHT_FRC(NBTC)
          NBN = IBHN_FRC(NBTC)
          IF( NTX.EQ.0 .OR. NBN.EQ.0 ) CYCLE
          MHBC_JKI = MAX( MHBC_JKI,
     &      ABS(IM_FRC(1,NTX)-IM_BH(ISVC,NBN)),
     &      ABS(IM_FRC(ISVC,NTX)-IM_BH(1,NBN)) )
         ENDDO
      ENDDO
!
!---  Loop over fracture/fault triangle to 
!     matrix node connections, first looping over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---      Loop over fracture/fault triangle to grid cell 
!         connections  ---
!
          DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
            N = INCM_FRC(NCX)
            NP = IXP(N)
            MHBC_JKI = MAX( MHBC_JKI,
     &        ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &        ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over borehole node to 
!     matrix node connections, first looping over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over borehole nodes  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Field node connected to borehole node  ---
!
          N = IBN_BH(NBN)
          IF( N.EQ.0 ) CYCLE
          NP = IXP(N)
          MHBC_JKI = MAX( MHBC_JKI,
     &      ABS(IM_BH(1,NBN)-IM(ISVC,NP)),
     &      ABS(IM_BH(ISVC,NBN)-IM(1,NP)) )
        ENDDO
      ENDDO
!
!---  Coupled equations half band width using K,I,J ordering for
!     matrix nodes, assuming no block refinement  ---
!
      NC = 0
      DO J = 1,LFY
        DO I = 1,LFX
          DO K = 1,LFZ
            N = ND(I,J,K)
            IF( IXP(N).EQ.0 ) CYCLE
            NC = NC + 1
            IXP(N) = NC
          ENDDO
        ENDDO
      ENDDO
      NC = 0
      MHBC_KIJ = 0
!
!---  Loop over matrix nodes using K,I,J ordering  ---
!
      DO J = 1,LFY
        DO I = 1,LFX
          DO K = 1,LFZ
            N = ND(I,J,K)
            IF( IXP(N).EQ.0 ) CYCLE
            NMD = IXP(N)
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC+1
              IM(M,NMD) = NC
            ENDDO
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_FRC(M,NTX) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over number of borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Loop over active unknowns  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            IM_BH(M,NBN) = NC
          ENDDO
        ENDDO
      ENDDO
!
!---  Determine matrix half-band widths, using K,I,J ordering  ---
!
      DO J = 1,LFY
        DO I = 1,LFX
          DO K = 1,LFZ
            N = ND(I,J,K)
!
!---        Skip to next active node  ---
!
            IF( IXP(N).EQ.0 ) CYCLE
            NP = IXP(N)
!
!---        Node  ---
!
            MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NP)))
!
!---        Bottom node neighbors  ---
!
            IF( K.GT.1 ) THEN
              IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                NB = ICM(1,1,N)
                IF( NB.EQ.0 ) EXIT
                NB = IXP(NB)
                MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NB)),
     &              ABS(IM(ISVC,NP)-IM(1,NB)))
              ENDIF
            ENDIF
!
!---        South node neighbors  ---
!
            IF( J.GT.1 ) THEN
              IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                NS = ICM(1,2,N)
                IF( NS.EQ.0 ) EXIT
                NS = IXP(NS)
                MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NS)),
     &            ABS(IM(ISVC,NP)-IM(1,NS)))
              ENDIF
            ENDIF
!
!---        West node neighbors  ---
!
            IF( I.GT.1 ) THEN
              IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                NW = ICM(1,3,N)
                IF( NW.EQ.0 ) EXIT
                NW = IXP(NW)
                MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NW)),
     &            ABS(IM(ISVC,NP)-IM(1,NW)))
              ENDIF
            ENDIF
!
!---        East node neighbors  ---
!
            IF( I.LT.LFX ) THEN
              IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                NE = ICM(1,4,N)
                IF( NE.EQ.0 ) EXIT
                NE = IXP(NE)
                MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NE)),
     &            ABS(IM(ISVC,NP)-IM(1,NE)))
              ENDIF
            ENDIF
!
!---        North node neighbors  ---
!
            IF( J.LT.LFY ) THEN
              IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                NN = ICM(1,5,N)
                IF( NN.EQ.0 ) EXIT
                NN = IXP(NN)
                MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NN)),
     &            ABS(IM(ISVC,NP)-IM(1,NN)))
              ENDIF
            ENDIF
!
!---        Top node neighbors  ---
!
            IF( K.LT.LFZ ) THEN
              IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                NT = ICM(1,6,N)
                IF( NT.EQ.0 ) EXIT
                NT = IXP(NT)
                MHBC_KIJ = MAX(MHBC_KIJ,ABS(IM(1,NP)-IM(ISVC,NT)),
     &            ABS(IM(ISVC,NP)-IM(1,NT)))
              ENDIF
            ENDIF
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
          IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---      Fracture/fault triangle unknowns  ---
!
          MHBC_KIJ = MAX( MHBC_KIJ,
     &      ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
!
!---      Loop over fracture/fault triangle to
!         fracture/fault triangle connections  ---
!
          DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
            NT2X = ITCM_FRC(NCX)
            IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
            MHBC_KIJ = MAX( MHBC_KIJ,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &        ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over borehole nodes in borehole  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Borehole node unknowns  ---
!
          MHBC_KIJ = MAX( MHBC_KIJ,
     &      ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN)) )
!
!---      Loop over borehole node to borehole node connections  ---
!
          DO ICX = 1,3
            NCX = IPB_BH(ICX,NBN)
            IF( NCX.LE.0 ) CYCLE
            NBN2 = IBCM_BH(NCX)
            MHBC_KIJ = MAX( MHBC_KIJ,
     &        ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN2)),
     &        ABS(IM_BH(ISVC,NBN)-IM_BH(1,NBN2)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over fracture/fault triangle to 
!     borehole node connections  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes or
!       coaxial boreholes  ---
!
        IF( (IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29)
     &    .OR. IT_BH(1,NBH).GE.10000 ) CYCLE
        DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
          NTX = IBHT_FRC(NBTC)
          NBN = IBHN_FRC(NBTC)
          IF( NTX.EQ.0 .OR. NBN.EQ.0 ) CYCLE
          MHBC_KIJ = MAX( MHBC_KIJ,
     &      ABS(IM_FRC(1,NTX)-IM_BH(ISVC,NBN)),
     &      ABS(IM_FRC(ISVC,NTX)-IM_BH(1,NBN)) )
         ENDDO
      ENDDO
!
!---  Loop over fracture/fault triangle to 
!     matrix node connections, first looping over fractures/faults  ---
!
      DO NFX = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---      Loop over fracture/fault triangle to grid cell 
!         connections  ---
!
          DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
            N = INCM_FRC(NCX)
            NP = IXP(N)
            MHBC_KIJ = MAX( MHBC_KIJ,
     &        ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &        ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
          ENDDO
        ENDDO
      ENDDO
!
!---  Loop over borehole node to 
!     matrix node connections, first looping over boreholes  ---
!
      DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes  ---
!
        IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---    Loop over borehole nodes  ---
!
        DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---      Field node connected to borehole node  ---
!
          N = IBN_BH(NBN)
          IF( N.EQ.0 ) CYCLE
          NP = IXP(N)
          MHBC_KIJ = MAX( MHBC_KIJ,
     &      ABS(IM_BH(1,NBN)-IM(ISVC,NP)),
     &      ABS(IM_BH(ISVC,NBN)-IM(1,NP)) )
        ENDDO
      ENDDO
!
!---  I,J,K ordering yields the lowest half band width   ---
!
      IF( MHBC_IJK.LE.MHBC_JKI .AND. MHBC_IJK.LE.MHBC_KIJ ) THEN
!
!---    Coupled equations half band width using I,J,K ordering for
!       matrix nodes, assuming no block refinement  ---
!
        NC = 0
        DO K = 1,LFZ
          DO J = 1,LFY
            DO I = 1,LFX
              N = ND(I,J,K)
              IF( IXP(N).EQ.0 ) CYCLE
              NC = NC + 1
              IXP(N) = NC
            ENDDO
          ENDDO
        ENDDO
        NC = 0
        MHBC = 0
!
!---    Loop over matrix nodes using I,J,K ordering  ---
!
        DO K = 1,LFZ
          DO J = 1,LFY
            DO I = 1,LFX
              N = ND(I,J,K)
              IF( IXP(N).EQ.0 ) CYCLE
              NMD = IXP(N)
!
!---          Loop over active unknowns  ---
!
              DO M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
              ENDDO
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over boreholes  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over number of borehole nodes in borehole  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_BH(M,NBN) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths, using I,J,K ordering  ---
!
        NC = 0
        NCC = 0
        DO K = 1,LFZ
          DO J = 1,LFY
            DO I = 1,LFX
              N = ND(I,J,K)
!
!---          Skip to next active node  ---
!
              IF( IXP(N).EQ.0 ) CYCLE
              NP = IXP(N)
!
!---          Node  ---
!
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NP)))
              NC = NC + (ISVC**2)
              NCC = NCC + 1
!
!---          Bottom node neighbors  ---
!
              IF( K.GT.1 ) THEN
                IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                  NB = ICM(1,1,N)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &                ABS(IM(ISVC,NP)-IM(1,NB)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          South node neighbors  ---
!
              IF( J.GT.1 ) THEN
                IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                  NS = ICM(1,2,N)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          West node neighbors  ---
!
              IF( I.GT.1 ) THEN
                IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                  NW = ICM(1,3,N)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          East node neighbors  ---
!
              IF( I.LT.LFX ) THEN
                IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                  NE = ICM(1,4,N)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          North node neighbors  ---
!
              IF( J.LT.LFY ) THEN
                IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                  NN = ICM(1,5,N)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NN)),
     &              ABS(IM(ISVC,NP)-IM(1,NN)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          Top node neighbors  ---
!
              IF( K.LT.LFZ ) THEN
                IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                  NT = ICM(1,6,N)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        fracture/fault triangle unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over boreholes  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over borehole nodes in borehole  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Borehole node unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over borehole node to borehole node connections  ---
!
            DO ICX = 1,3
              NCX = IPB_BH(ICX,NBN)
              IF( NCX.LE.0 ) CYCLE
              NBN2 = IBCM_BH(NCX)
              MHBC = MAX( MHBC,
     &          ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN2)),
     &          ABS(IM_BH(ISVC,NBN)-IM_BH(1,NBN2)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to 
!       borehole node connections, counting double
!       for fracture/fault triangle and borehole node equations  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes or
!       coaxial boreholes  ---
!
          IF( (IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29)
     &      .OR. IT_BH(1,NBH).GE.10000 ) CYCLE
          DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
            NT1X = IBHT_FRC(NBTC)
            NBN = IBHN_FRC(NBTC)
            NT2X = IBHN_FRC(NBTC) + NT_FRC - NXP_FRC
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_BH(ISVC,NBN)),
     &        ABS(IM_FRC(ISVC,NT1X)-IM_BH(1,NBN)) )
            NC = NC + 2*(ISVC**2)
            NCC = NCC + 2
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to 
!       matrix node connections, first looping over fractures/faults, 
!       counting double for fracture/fault triangle and matrix 
!       grid cell equations  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to grid cell 
!           connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
              NC = NC + 2*(ISVC**2)
              NCC = NCC + 2
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over borehole node to 
!       matrix node connections, first looping over boreholes, counting
!       double for borehole node and matrix grid cell equations  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over borehole nodes  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Field node connected to borehole node  ---
!
            N = IBN_BH(NBN)
            IF( N.EQ.0 ) CYCLE
            NP = IXP(N)
            MHBC = MAX( MHBC,
     &        ABS(IM_BH(1,NBN)-IM(ISVC,NP)),
     &        ABS(IM_BH(ISVC,NBN)-IM(1,NP)) )
            NC = NC + 2*(ISVC**2)
            NCC = NCC + 2
          ENDDO
        ENDDO
!
!---  J,K,I ordering yields the lowest half band width   ---
!
      ELSEIF( MHBC_JKI.LE.MHBC_KIJ ) THEN
        NC = 0
        DO I = 1,LFX
          DO K = 1,LFZ
            DO J = 1,LFY
              N = ND(I,J,K)
              IF( IXP(N).EQ.0 ) CYCLE
              NC = NC + 1
              IXP(N) = NC
            ENDDO
          ENDDO
        ENDDO
        NC = 0
        MHBC = 0
!
!---    Loop over matrix nodes using J,K,I ordering  ---
!
        DO I = 1,LFX
          DO K = 1,LFZ
            DO J = 1,LFY
              N = ND(I,J,K)
              IF( IXP(N).EQ.0 ) CYCLE
              NMD = IXP(N)
!
!---          Loop over active unknowns  ---
!
              DO M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
              ENDDO
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over boreholes  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over number of borehole nodes in borehole  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_BH(M,NBN) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths, using J,K,I ordering  ---
!
        NC = 0
        NCC = 0
        DO I = 1,LFX
          DO K = 1,LFZ
            DO J = 1,LFY
              N = ND(I,J,K)
!
!---          Skip to next active node  ---
!
              IF( IXP(N).EQ.0 ) CYCLE
              NP = IXP(N)
!
!---          Node  ---
!
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NP)))
              NC = NC + (ISVC**2)
              NCC = NCC + 1
!
!---          Bottom node neighbors  ---
!
              IF( K.GT.1 ) THEN
                IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                  NB = ICM(1,1,N)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &                ABS(IM(ISVC,NP)-IM(1,NB)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          South node neighbors  ---
!
              IF( J.GT.1 ) THEN
                IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                  NS = ICM(1,2,N)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          West node neighbors  ---
!
              IF( I.GT.1 ) THEN
                IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                  NW = ICM(1,3,N)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          East node neighbors  ---
!
              IF( I.LT.LFX ) THEN
                IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                  NE = ICM(1,4,N)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          North node neighbors  ---
!
              IF( J.LT.LFY ) THEN
                IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                  NN = ICM(1,5,N)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NN)),
     &              ABS(IM(ISVC,NP)-IM(1,NN)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          Top node neighbors  ---
!
              IF( K.LT.LFZ ) THEN
                IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                  NT = ICM(1,6,N)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        Fracture/fault triangle unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over boreholes  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over borehole nodes in borehole  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Borehole node unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over borehole node to borehole node connections  ---
!
            DO ICX = 1,3
              NCX = IPB_BH(ICX,NBN)
              IF( NCX.LE.0 ) CYCLE
              NBN2 = IBCM_BH(NCX)
              MHBC = MAX( MHBC,
     &          ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN2)),
     &          ABS(IM_BH(ISVC,NBN)-IM_BH(1,NBN2)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to 
!       borehole node connections, counting double for 
!       fracture/fault triangle and borehole node equations  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes or
!         coaxial boreholes  ---
!
          IF( (IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29)
     &      .OR. IT_BH(1,NBH).GE.10000 ) CYCLE
          DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
            NT1X = IBHT_FRC(NBTC)
            NBN = IBHN_FRC(NBTC)
            NT2X = IBHN_FRC(NBTC) + NT_FRC - NXP_FRC
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_BH(ISVC,NBN)),
     &        ABS(IM_FRC(ISVC,NT1X)-IM_BH(1,NBN)) )
            NC = NC + 2*(ISVC**2)
            NCC = NCC + 2
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to matrix node connections, 
!       first looping over fractures/faults, counting double for 
!       fracture/fault triangle and matrix grid cell equations  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to grid cell 
!           connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
              NC = NC + 2*(ISVC**2)
              NCC = NCC + 2
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over borehole node to 
!       matrix node connections, first looping over boreholes, counting
!       double for borehole node and matrix grid cell equations  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over borehole nodes  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Field node connected to borehole node  ---
!
            N = IBN_BH(NBN)
            IF( N.EQ.0 ) CYCLE
            NP = IXP(N)
            MHBC = MAX( MHBC,
     &        ABS(IM_BH(1,NBN)-IM(ISVC,NP)),
     &        ABS(IM_BH(ISVC,NBN)-IM(1,NP)) )
            NC = NC + 2*(ISVC**2)
            NCC = NCC + 2
          ENDDO
        ENDDO
!
!---  K,I,J ordering yields the lowest half band width   ---
!
      ELSE
!
!---    Coupled equations half band width using K,I,J ordering for
!       matrix nodes, assuming no block refinement  ---
!
        NC = 0
        DO J = 1,LFY
          DO I = 1,LFX
            DO K = 1,LFZ
              N = ND(I,J,K)
              IF( IXP(N).EQ.0 ) CYCLE
              NC = NC + 1
              IXP(N) = NC
            ENDDO
          ENDDO
        ENDDO
        NC = 0
        MHBC = 0
!
!---    Loop over matrix nodes using K,I,J ordering  ---
!
        DO J = 1,LFY
          DO I = 1,LFX
            DO K = 1,LFZ
              N = ND(I,J,K)
              IF( IXP(N).EQ.0 ) CYCLE
              NMD = IXP(N)
!
!---          Loop over active unknowns  ---
!
              DO M = 1,ISVC
                NC = NC+1
                IM(M,NMD) = NC
              ENDDO
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_FRC(M,NTX) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over boreholes  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over number of borehole nodes in borehole  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Loop over active unknowns  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              IM_BH(M,NBN) = NC
            ENDDO
          ENDDO
        ENDDO
!
!---    Determine matrix half-band widths, using K,I,J ordering  ---
!
        NC = 0
        NCC = 0
        DO J = 1,LFY
          DO I = 1,LFX
            DO K = 1,LFZ
              N = ND(I,J,K)
!
!---          Skip to next active node  ---
!
              IF( IXP(N).EQ.0 ) CYCLE
              NP = IXP(N)
!
!---          Node  ---
!
              MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NP)))
              NC = NC + (ISVC**2)
              NCC = NCC + 1
!
!---          Bottom node neighbors  ---
!
              IF( K.GT.1 ) THEN
                IF( IXP(N-LFXY).NE.0 .AND. INBS(1,N).LE.0 ) THEN
                  NB = ICM(1,1,N)
                  IF( NB.EQ.0 ) EXIT
                  NB = IXP(NB)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NB)),
     &                ABS(IM(ISVC,NP)-IM(1,NB)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          South node neighbors  ---
!
              IF( J.GT.1 ) THEN
                IF( IXP(N-LFX).NE.0 .AND. INBS(2,N).LE.0 ) THEN
                  NS = ICM(1,2,N)
                  IF( NS.EQ.0 ) EXIT
                  NS = IXP(NS)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NS)),
     &              ABS(IM(ISVC,NP)-IM(1,NS)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          West node neighbors  ---
!
              IF( I.GT.1 ) THEN
                IF( IXP(N-1).NE.0 .AND. INBS(3,N).LE.0 ) THEN
                  NW = ICM(1,3,N)
                  IF( NW.EQ.0 ) EXIT
                  NW = IXP(NW)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NW)),
     &              ABS(IM(ISVC,NP)-IM(1,NW)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          East node neighbors  ---
!
              IF( I.LT.LFX ) THEN
                IF( IXP(N+1).NE.0 .AND. INBS(4,N).LE.0 ) THEN
                  NE = ICM(1,4,N)
                  IF( NE.EQ.0 ) EXIT
                  NE = IXP(NE)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NE)),
     &              ABS(IM(ISVC,NP)-IM(1,NE)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          North node neighbors  ---
!
              IF( J.LT.LFY ) THEN
                IF( IXP(N+LFX).NE.0 .AND. INBS(5,N).LE.0 ) THEN
                  NN = ICM(1,5,N)
                  IF( NN.EQ.0 ) EXIT
                  NN = IXP(NN)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NN)),
     &              ABS(IM(ISVC,NP)-IM(1,NN)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
!
!---          Top node neighbors  ---
!
              IF( K.LT.LFZ ) THEN
                IF( IXP(N+LFXY).NE.0 .AND. INBS(6,N).LE.0 ) THEN
                  NT = ICM(1,6,N)
                  IF( NT.EQ.0 ) EXIT
                  NT = IXP(NT)
                  MHBC = MAX(MHBC,ABS(IM(1,NP)-IM(ISVC,NT)),
     &              ABS(IM(ISVC,NP)-IM(1,NT)))
                  NC = NC + (ISVC**2)
                  NCC = NCC + 1
                ENDIF
              ENDIF
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT1X = IP_FRC(1,NFX),IP_FRC(2,NFX)
            IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
!
!---        Fracture/fault triangle unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT1X)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over fracture/fault triangle to
!           fracture/fault triangle connections  ---
!
            DO NCX = IPF_FRC(1,NT1X),IPF_FRC(2,NT1X)
              NT2X = ITCM_FRC(NCX)
              IF( IXP_FRC(NT2X).EQ.0 ) CYCLE
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NT1X)-IM_FRC(ISVC,NT2X)),
     &          ABS(IM_FRC(ISVC,NT1X)-IM_FRC(1,NT2X)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over boreholes  ---
!
        DO NBH = 1,N_BH
!
!---      Skip for boundary condition type boreholes  ---
!
          IF( IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29 ) CYCLE
!
!---      Loop over borehole nodes in borehole  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Borehole node unknowns  ---
!
            MHBC = MAX( MHBC,
     &        ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN)) )
            NC = NC + (ISVC**2)
            NCC = NCC + 1
!
!---        Loop over borehole node to borehole node connections  ---
!
            DO ICX = 1,3
              NCX = IPB_BH(ICX,NBN)
              IF( NCX.LE.0 ) CYCLE
              NBN2 = IBCM_BH(NCX)
              MHBC = MAX( MHBC,
     &          ABS(IM_BH(1,NBN)-IM_BH(ISVC,NBN2)),
     &          ABS(IM_BH(ISVC,NBN)-IM_BH(1,NBN2)) )
              NC = NC + (ISVC**2)
              NCC = NCC + 1
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to 
!       borehole node connections, counting double for 
!       fracture/fault triangle and borehole node equations  ---
!
        DO NBH = 1,N_BH
!
!---    Skip for boundary condition type boreholes or
!       coaxial boreholes  ---
!
          IF( (IT_BH(1,NBH).GE.21.AND.IT_BH(1,NBH).LE.29)
     &      .OR. IT_BH(1,NBH).GE.10000 ) CYCLE
          DO NBTC = ID_BH(5,NBH),ID_BH(6,NBH)
            NT1X = IBHT_FRC(NBTC)
            NBN = IBHN_FRC(NBTC)
            NT2X = IBHN_FRC(NBTC) + NT_FRC - NXP_FRC
            MHBC = MAX( MHBC,
     &        ABS(IM_FRC(1,NT1X)-IM_BH(ISVC,NBN)),
     &        ABS(IM_FRC(ISVC,NT1X)-IM_BH(1,NBN)) )
            NC = NC + 2*(ISVC**2)
            NCC = NCC + 2
          ENDDO
        ENDDO
!
!---    Loop over fracture/fault triangle to matrix node connections, 
!       first looping over fractures/faults, counting double for 
!       fracture/fault triangle and matrix grid cell equations  ---
!
        DO NFX = 1,NF_FRC
!
!---      Loop over fracture/fault triangles  ---
!
          DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
!
!---        Skip inactive triangles  ---
!
            IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---        Loop over fracture/fault triangle to 
!           grid cell connections  ---
!
            DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
              N = INCM_FRC(NCX)
              NP = IXP(N)
              MHBC = MAX( MHBC,
     &          ABS(IM_FRC(1,NTX)-IM(ISVC,NP)),
     &          ABS(IM_FRC(ISVC,NTX)-IM(1,NP)) )
              NC = NC + 2*(ISVC**2)
              NCC = NCC + 2
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over borehole node to 
!       matrix node connections, first looping over boreholes, counting
!       double for borehole node and matrix grid cell equations  ---
!
        DO NBH = 1,N_BH
!
!---      Loop over borehole nodes  ---
!
          DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
!
!---        Field node connected to borehole node  ---
!
            N = IBN_BH(NBN)
            IF( N.EQ.0 ) CYCLE
            NP = IXP(N)
            MHBC = MAX( MHBC,
     &        ABS(IM_BH(1,NBN)-IM(ISVC,NP)),
     &        ABS(IM_BH(ISVC,NBN)-IM(1,NP)) )
            NC = NC + 2*(ISVC**2)
            NCC = NCC + 2
          ENDDO
        ENDDO
      ENDIF



!
!---  SPLIB .or. Lis .or. PETSc Solver  ---
!
      LJO = NC
      LJM = NCC
!
!---  Deallocate memory for fracture/fault Jacobian matrix 
!     equation index  ---
!
      IF( ALLOCATED(IM_FRC) ) THEN
        DEALLOCATE( IM_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(IM_BH) ) THEN
        DEALLOCATE( IM_BH,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IM_BH'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(IP_FRC) ) THEN
        DEALLOCATE( IP_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(ITCM_FRC) ) THEN
        DEALLOCATE( ITCM_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ITCM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(IPF_FRC) ) THEN
        DEALLOCATE( IPF_FRC,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: IPF_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_MFB group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_NCW
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for no coupled
!     well model
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 03 February 2014.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE LEAK_WELL
      USE JACOB
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_NCW'

!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_NCW group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_NCW_DP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for no coupled
!     well model
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 03 February 2014.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE DUAL_POR
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_NCW_DP'

!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_NCW_DP group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_SURF_COV
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the matrix half band width for surface covers
!     for STOMP-GT.
!
!     Nodes adjacent to surface cover nodes include 2 bare surface
!     equations + 3 vegetated surface equations.
!     Nodes connected to surface cover nodes include 3 vegetated
!     surface equations.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 22 November 2015.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PLT_ATM
      USE JACOB
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_SURF_COV'

!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_SURF_COV group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE L_CASE( CHDUM )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------!opyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Convert all upper-case characters in a variable-length string
!     variable to lower case.  This subroutine does not disturb
!     non-alphabetic characters; only captial letters
!     (ASCII 65 through 90) are modified.
!
!----------------------Authors-----------------------------------------!
!
!     Written by WE Nichols, Battelle, March, 1991.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/L_CASE'
      DO 10 N = 1,LEN(CHDUM)
        M = ICHAR(CHDUM(N:N))
        IF( M .GE. 65 .AND. M .LE. 90 ) THEN
          M = M + 32
          CHDUM(N:N) = CHAR(M)
        ENDIF
   10 CONTINUE
      ISUB_LOG = ISUB_LOG-1
!
!---  End of L_CASE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LINE_I( DX,DV1X,DV2X,P1X,P2X,PN1X,PN2X,V1X,V2X )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Find the x,y,z coordinates of the four intersection points of 
!     two triangles along the intersection line.
!
!     DX - direction vector of intersection line
!     DV1X - signed distances from triangle 1 to plane Pi2
!     DV2X - signed distances from triangle 2 to plane Pi1
!     PN1X - normal vector to triangle 1 or plane Pi1
!     PN2X - normal vector to triangle 2 or plane Pi2
!     P1X - x,y,z coordinates of point 1 (triangle 1)
!     P2X - x,y,z coordinates of point 2 (triangle 1)
!     P3X - x,y,z coordinates of point 1 (triangle 2)
!     P4X - x,y,z coordinates of point 2 (triangle 2)
!     V1X - x,y,z coordinates of vertices of triangle 1
!     V2X - x,y,z coordinates of vertices of triangle 2
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 15 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 DX(3),PN1X(3),PN2X(3)
      REAL*8 DV1X(3),DV2X(3)
      REAL*8 P1X(3),P2X(3),P3X(3),P4X(3)
      REAL*8 POX(3),PNX(3)
      REAL*8 AX(3),BX(3),CX(3),CABX(3),CCBX(3)
      REAL*8 V1X(3,3),V2X(3,3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LINE_I'
!
!---  Pi1 and Pi2 plane equations  ---
!
      A1X = PN1X(1)
      B1X = PN1X(2)
      C1X = PN1X(3)
      D1X = A1X*V1X(1,3) + B1X*V1X(2,3) + C1X*V1X(3,3)
      A2X = PN2X(1)
      B2X = PN2X(2)
      C2X = PN2X(3)
      D2X = A2X*V2X(1,3) + B2X*V2X(2,3) + C2X*V2X(3,3)
!
!---  Intersection line of plane Pi1 and Pi2  ---
!
      IF( ABS(A1X).GT.EPSL .AND. ABS(B2X-B1X*A2X/A1X).GT.EPSL ) THEN
        POX(3) = (V1X(3,1)+V1X(3,2)+V1X(3,3)+V2X(3,1)+V2X(3,2)+V2X(3,3))
     &    /6.D+0
        POX(2) = (POX(3)*(C1X*A2X/A1X - C2X) + (D2X - D1X*A2X/A1X))/
     &    (B2X - B1X*A2X/A1X)
        POX(1) = (D1X - B1X*POX(2) - C1X*POX(3))/A1X
        PNX(1) = POX(1) + DX(1)
        PNX(2) = POX(2) + DX(2)
        PNX(3) = POX(3) + DX(3)
      ELSEIF( ABS(B1X).GT.EPSL .AND. ABS(C2X-C1X*B2X/B1X).GT.EPSL ) THEN
        POX(1) = (V1X(1,1)+V1X(1,2)+V1X(1,3)+V2X(1,1)+V2X(1,2)+V2X(1,3))
     &    /6.D+0
        POX(3) = (POX(1)*(A1X*B2X/B1X - A2X) + (D2X - D1X*B2X/B1X))/
     &    (C2X - C1X*B2X/B1X)
        POX(2) = (D1X - A1X*POX(1) - C1X*POX(3))/B1X
        PNX(1) = POX(1) + DX(1)
        PNX(2) = POX(2) + DX(2)
        PNX(3) = POX(3) + DX(3)
      ELSEIF( ABS(C1X).GT.EPSL .AND. ABS(A2X-A1X*C2X/C1X).GT.EPSL ) THEN
        POX(2) = (V1X(2,1)+V1X(2,2)+V1X(2,3)+V2X(2,1)+V2X(2,2)+V2X(2,3))
     &    /6.D+0
        POX(1) = (POX(2)*(B1X*C2X/C1X - B2X) + (D2X - D1X*C2X/C1X))/
     &    (A2X - A1X*C2X/C1X)
        POX(3) = (D1X - A1X*POX(1) - B1X*POX(2))/C1X
        PNX(1) = POX(1) + DX(1)
        PNX(2) = POX(2) + DX(2)
        PNX(3) = POX(3) + DX(3)
      ELSEIF( ABS(A2X).GT.EPSL .AND. ABS(B1X-B2X*A1X/A2X).GT.EPSL ) THEN
        POX(3) = (V2X(3,1)+V2X(3,2)+V2X(3,3)+V1X(3,1)+V1X(3,2)+V1X(3,3))
     &    /6.D+0
        POX(2) = (POX(3)*(C2X*A1X/A2X - C1X) + (D1X - D2X*A1X/A2X))/
     &    (B1X - B2X*A1X/A2X)
        POX(1) = (D2X - B2X*POX(2) - C2X*POX(3))/A2X
        PNX(1) = POX(1) + DX(1)
        PNX(2) = POX(2) + DX(2)
        PNX(3) = POX(3) + DX(3)
      ELSEIF( ABS(B2X).GT.EPSL .AND. ABS(C1X-C2X*B1X/B2X).GT.EPSL ) THEN
        POX(1) = (V2X(1,1)+V2X(1,2)+V2X(1,3)+V1X(1,1)+V1X(1,2)+V1X(1,3))
     &    /6.D+0
        POX(3) = (POX(1)*(A2X*B1X/B2X - A1X) + (D1X - D2X*B1X/B2X))/
     &    (C1X - C2X*B1X/B2X)
        POX(2) = (D2X - A2X*POX(1) - C2X*POX(3))/B2X
        PNX(1) = POX(1) + DX(1)
        PNX(2) = POX(2) + DX(2)
        PNX(3) = POX(3) + DX(3)
      ELSEIF( ABS(C2X).GT.EPSL .AND. ABS(A1X-A2X*C1X/C2X).GT.EPSL ) THEN
        POX(2) = (V2X(2,1)+V2X(2,2)+V2X(2,3)+V1X(2,1)+V1X(2,2)+V1X(2,3))
     &    /6.D+0
        POX(1) = (POX(2)*(B2X*C1X/C2X - B1X) + (D1X - D2X*C1X/C2X))/
     &    (A1X - A2X*C1X/C2X)
        POX(3) = (D2X - A2X*POX(1) - B2X*POX(2))/C2X
        PNX(1) = POX(1) + DX(1)
        PNX(2) = POX(2) + DX(2)
        PNX(3) = POX(3) + DX(3)
      ENDIF
!
!---  Vertices 1 and 2 of triangle 1 on the same side of plane Pi2, 
!     P1X and P2X are the fracture/fault triangle points  ---
!
      IF( SIGN(1.D+0,DV1X(1)).EQ.SIGN(1.D+0,DV1X(2)) ) THEN
        DO M = 1,3
          AX(M) = V1X(M,1)-V1X(M,3)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V1X(M,3)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P1X(M) = V1X(M,3) + AX(M)*SX
        ENDDO
        T1X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T1X = T1X + (P1X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T1X = T1X/REAL(NC)
        DO M = 1,3
          AX(M) = V1X(M,2)-V1X(M,3)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V1X(M,3)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P2X(M) = V1X(M,3) + AX(M)*SX
        ENDDO
        T2X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T2X = T2X + (P2X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T2X = T2X/REAL(NC)
!
!---  Vertices 2 and 3 of triangle 1 on the same side of plane Pi2, 
!     P1X and P2X are the fracture/fault triangle points  ---  ---
!
      ELSEIF( SIGN(1.D+0,DV1X(2)).EQ.SIGN(1.D+0,DV1X(3)) ) THEN
        DO M = 1,3
          AX(M) = V1X(M,3)-V1X(M,1)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V1X(M,1)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P1X(M) = V1X(M,1) + AX(M)*SX
        ENDDO
        T1X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T1X = T1X + (P1X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T1X = T1X/REAL(NC)
        DO M = 1,3
          AX(M) = V1X(M,2)-V1X(M,1)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V1X(M,1)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P2X(M) = V1X(M,1) + AX(M)*SX
        ENDDO
        T2X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T2X = T2X + (P2X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T2X = T2X/REAL(NC)
!
!---  Vertices 3 and 1 of triangle 1 on the same side of plane Pi2, 
!     P1X and P2X are the fracture/fault triangle points  ---  ---
!
      ELSE
        DO M = 1,3
          AX(M) = V1X(M,1)-V1X(M,2)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V1X(M,2)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P1X(M) = V1X(M,2) + AX(M)*SX
        ENDDO
        T1X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T1X = T1X + (P1X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T1X = T1X/REAL(NC)
        DO M = 1,3
          AX(M) = V1X(M,3)-V1X(M,2)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V1X(M,2)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P2X(M) = V1X(M,2) + AX(M)*SX
        ENDDO
        T2X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T2X = T2X + (P2X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T2X = T2X/REAL(NC)
      ENDIF
!
!---  Vertices 1 and 2 of triangle 2 on the same side of plane Pi1, 
!     P3X and P4X are the grid-cell surface triangle points  ---
!
      IF( SIGN(1.D+0,DV2X(1)).EQ.SIGN(1.D+0,DV2X(2)) ) THEN
        DO M = 1,3
          AX(M) = V2X(M,1)-V2X(M,3)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V2X(M,3)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P3X(M) = V2X(M,3) + AX(M)*SX
        ENDDO
        T3X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T3X = T3X + (P3X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T3X = T3X/REAL(NC)
        DO M = 1,3
          AX(M) = V2X(M,2)-V2X(M,3)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V2X(M,3)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P4X(M) = V2X(M,3) + AX(M)*SX
        ENDDO
        T4X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T4X = T4X + (P4X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T4X = T4X/REAL(NC)
!
!---  Vertices 2 and 3 of triangle 2 on the same side of plane Pi1, 
!     P3X and P4X are the grid-cell surface triangle points  ---
!
      ELSEIF( SIGN(1.D+0,DV2X(2)).EQ.SIGN(1.D+0,DV2X(3)) ) THEN
        DO M = 1,3
          AX(M) = V2X(M,3)-V2X(M,1)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V2X(M,1)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P3X(M) = V2X(M,1) + AX(M)*SX
        ENDDO
        T3X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T3X = T3X + (P3X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T3X = T3X/REAL(NC)
        DO M = 1,3
          AX(M) = V2X(M,2)-V2X(M,1)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V2X(M,1)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P4X(M) = V2X(M,1) + AX(M)*SX
        ENDDO
        T4X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T4X = T4X + (P4X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T4X = T4X/REAL(NC)
!
!---  Vertices 3 and 1 of triangle 2 on the same side of plane Pi1, 
!     P3X and P4X are the grid-cell surface triangle points  ---
!
      ELSE
        DO M = 1,3
          AX(M) = V2X(M,1)-V2X(M,2)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V2X(M,2)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P3X(M) = V2X(M,2) + AX(M)*SX
        ENDDO
        T3X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T3X = T3X + (P3X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T3X = T3X/REAL(NC)
        DO M = 1,3
          AX(M) = V2X(M,3)-V2X(M,2)
          BX(M) = PNX(M)-POX(M)
          CX(M) = POX(M)-V2X(M,2)
        ENDDO
        CALL VCROSSP( AX,BX,CABX )
        CALL VCROSSP( CX,BX,CCBX )
        SX = VDOTP( CABX,CCBX )/(VDOTP( CABX,CABX ) + SMALL)
        DO M = 1,3
          P4X(M) = V2X(M,2) + AX(M)*SX
        ENDDO
        T4X = 0.D+0
        NC = 0
        DO M = 1,3
          IF( ABS(DX(M))/EPSL.GT.EPSL ) THEN
            NC = NC + 1
            T4X = T4X + (P4X(M)-POX(M))/DX(M)
          ENDIF
        ENDDO
        T4X = T4X/REAL(NC)
      ENDIF
!
!---  Limit the intersection of the fracture/fault triangle and 
!     the grid-cell surface triangle to the bounds of the later  ---
!
      TLX = MAX( MIN( T3X,T4X ),MIN( T1X,T2X ) )
      TUX = MIN( MAX( T3X,T4X ),MAX( T1X,T2X ) )
!
!---  Intersection points on the intersection line, limited by
!     the fracture/fault and grid-cell surface triangle extents  ---
!
      P1X(1) = POX(1) + DX(1)*TLX
      P1X(2) = POX(2) + DX(2)*TLX
      P1X(3) = POX(3) + DX(3)*TLX
      P2X(1) = POX(1) + DX(1)*TUX
      P2X(2) = POX(2) + DX(2)*TUX
      P2X(3) = POX(3) + DX(3)*TUX
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LINE_I group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LOC_PT( X0,Y0,X,Y,N,IINOUT,IPATH )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     LOC_PT locates whether a point is inside a polygon in a 2D plane
!
!
!     Method:
!
!     Given a polygonal line connecting the vertices (x(i),y(i)) (i = 1,...,n)
!     taken in this order.  It is assumed that the polygonal path is a loop,
!     where (x(n),y(n)) = (x(1),y(1)) or there is an arc from (x(n),y(n)) to
!     (x(1),y(1)). The polygon may cross itself any number of times.
!
!     Reference:
!
!     Fortran 66 version by A.H. Morris
!     Converted to ELF90 compatibility by Alan Miller, 15 February 1997
!     Available at http://jblevins.org/mirror/amiller/    
!
!     Author:
!
!     John Burkardt
!
!     Parameters:
!
!     Input, real X0, Y0, the coordinate of the point.
!     Input, real X(N), Y(N), the coordinates of the points defining the polygon.
!     Input, integer N, the number of the points defining the polygon.
! 
!     Output, integer IINOUT, assigned as follows:
!             L = -1   if (X0,Y0) is outside the polygonal path
!             L =  0   if (X0,Y0) lies on the polygonal path
!             L =  1   if (X0,Y0) is inside the polygonal path
!
!     Output, integer IPATH, where IPATH = 0 if (X0,Y0) is on or outside the path. 
!                        if (X0,Y0) is inside the path then m is the winding 
!                        number of the path around the point (X0,Y0).
!
!----------------------Authors-----------------------------------------!
!
!     Written by SK White, PNNL, 15 September 2015.
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 X(N),Y(N)
!      
!----------------------Executable Lines--------------------------------!
!      
      EPSL = 1.D-14
      N0 = N
      IF (X(1) == X(N) .AND. Y(1) == Y(N)) N0 = N - 1
      PIX = ATAN2(0.D+0,-1.D+0)
      PI2 = 2.D+0 * PIX
      TOL = 4.D+0*EPSL*PIX
      IINOUT = -1
      IPATH = 0
!      
      U = X(1) - X0
      V = Y(1) - Y0
      IF (U .EQ. 0.D+0 .AND. V .EQ. 0.D+0) GO TO 20
      IF (N0 .LT. 2) RETURN
      THETA1 = ATAN2(V, U)
!      
      SUM = 0.0
      THETA = THETA1
      DO I = 2, N0
        U = X(I) - X0
        V = Y(I) - Y0
        IF (U .EQ. 0.D+0 .AND. V .EQ. 0.D+0) GO TO 20
        THETAI = ATAN2(V, U)
!        
        ANGLE = ABS(THETAI - THETA)
        IF (ABS(ANGLE - PIX) .LT. TOL) GO TO 20
        IF (ANGLE .GT. PIX) ANGLE = ANGLE - PI2
        IF (THETA .GT. THETAI) ANGLE = -ANGLE
        SUM = SUM + ANGLE
        THETA = THETAI
      END DO
!      
      ANGLE = ABS(THETA1 - THETA)
      IF (ABS(ANGLE - PIX) .LT. TOL) GO TO 20
      IF (ANGLE .GT. PIX) ANGLE = ANGLE - PI2
      IF (THETA .GT. THETA1) ANGLE = -ANGLE
      SUM = SUM + ANGLE
!      
!     SUM = 2*PIX*IPATH WHERE IPATH IS THE WINDING NUMBER
!      
      IPATH = INT( ABS(SUM)/PI2 + 0.2D+0 )
      IF (IPATH .EQ. 0) RETURN
      IINOUT = 1
      IF (SUM .LT. 0.D+0) M = -1 * IPATH
      RETURN
!      
!     (X0, Y0) IS ON THE BOUNDARY OF THE PATH
!      
   20 IINOUT = 0
!
!---  End of LOC_PT group ---
!
      RETURN
      END
      
!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LSEG_C( P1X,P2X,P3X,P4X,I0X,I1X,ITX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Check for the intersection of two line segments.
!     http://paulbourke.net/geometry/pointlineplane/pdb.c
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 31 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 P1X(3),P2X(3),P3X(3),P4X(3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LSEG_C'
      AX = P1X(I0X)-P2X(I0X)
      AY = P1X(I1X)-P2X(I1X)
      BX = P3X(I0X)-P4X(I0X)
      BY = P3X(I1X)-P4X(I1X)
      CX = P2X(I0X)-P3X(I0X)
      CY = P2X(I1X)-P3X(I1X)
      FX = AY*BX - AX*BY
      DX = BY*CX - BX*CY
      IF( (FX.GT.0.D+0 .AND. DX.GE.0.D+0 .AND. DX.LE.FX) .OR.
     &  (FX.LT.0.D+0 .AND. DX.LE.0.D+0 .AND. DX.GE.FX) ) THEN
        EX = AX*CY - AY*CX
        IF( FX.GT.0.D+0 ) THEN
          IF( EX.GE.0.D+0 .AND. EX.LE.FX ) ITX = 1
        ELSE
          IF( EX.LE.0.D+0 .AND. EX.GE.FX ) ITX = 1
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LSEG_C group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LSEG_I( P1X,P2X,P3X,P4X,PIX,NPIX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine the intersection point(s) of two line segments.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 29 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 P1X(2),P2X(2),P3X(2),P4X(2)
      REAL*8 PIX(2,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LSEG_I'
      DENOMX = (P4X(2)-P3X(2))*(P2X(1)-P1X(1)) - 
     &  (P4X(1)-P3X(1))*(P2X(2)-P1X(2))
      ANUMERX = (P4X(1)-P3X(1))*(P1X(2)-P3X(2)) - 
     &  (P4X(2)-P3X(2))*(P1X(1)-P3X(1))
      BNUMERX = (P2X(1)-P1X(1))*(P1X(2)-P3X(2)) - 
     &  (P2X(2)-P1X(2))*(P1X(1)-P3X(1))
!
!---  Line segments are coincidental  ---
!
      IF( ABS(ANUMERX).LT.EPSL .AND. ABS(BNUMERX).LT.EPSL. AND.
     &  ABS(DENOMX) < EPSL ) THEN
        NPIX = NPIX + 1
        DO M = 1,2
          PIX(M,NPIX) = P1X(M)
        ENDDO
        NPIX = NPIX + 1
        DO M = 1,2
          PIX(M,NPIX) = P2X(M)
        ENDDO
!
!---  Line segments are parallel, no intersection  ---
!
      ELSEIF( ABS(DENOMX) < EPSL ) THEN
        NPIX = NPIX + 0
!
!---  Check for intersection along line segments  ---
!
      ELSE
        AMUX = ANUMERX/DENOMX
        BMUX = BNUMERX/DENOMX
!
!---    No intersection along line segments  ---
!
        IF( AMUX.LT.0.D+0 .OR. AMUX.GT.1.D+0 .OR. BMUX.LT.0.D+0 
     &    .OR. BMUX.GT.1.D+0 ) THEN
          NPIX = NPIX + 0
        ELSE
          NPIX = NPIX + 1
          DO M = 1,2
            PIX(M,NPIX) = P1X(M) + AMUX*(P2X(M)-P1X(M))
          ENDDO
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LSEG_I group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LU_DCMP( A,N,NP,IX,D )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996.
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Numerical Recipes, The Art of Scientific Computing
!     W.H. Press, B.P. Flannery, Saul A. Teukolsky, and W.T. Vetterling
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, August 1, 2000.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 A(NP,NP),VV(NP)
      INTEGER IX(NP)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LU_DCMP'
      D = 1.D+0
      DO 12 I = 1,N
        AAMAX = 0.D+0
        DO 11 J = 1,N
          IF( ABS(A(I,J)).GT.AAMAX ) AAMAX = ABS(A(I,J))
   11   CONTINUE
        IF( ABS(AAMAX)/EPSL.LT.EPSL ) THEN
          INDX = 20
          CHMSG = 'Singular Matrix: '
          IMSG = NP
          CALL WRMSGP( INDX )
        ENDIF
        VV(I) = 1.D+0/AAMAX
   12 CONTINUE
      IMAX = 0
      DO 19 J = 1,N
        DO 14 I = 1,J-1
          SUM = A(I,J)
          DO 13 K = 1,I-1
            SUM = SUM - A(I,K)*A(K,J)
   13     CONTINUE
          A(I,J) = SUM
   14   CONTINUE
        AAMAX = 0.D+0
        DO 16 I = J,N
          SUM = A(I,J)
          DO 15 K = 1,J-1
            SUM = SUM - A(I,K)*A(K,J)
   15     CONTINUE
          A(I,J) = SUM
          DUM = VV(I)*ABS(SUM)
          IF( DUM.GE.AAMAX ) THEN
            IMAX = I
            AAMAX = DUM
          ENDIF
   16   CONTINUE
        IF( J.NE.IMAX ) THEN
          DO 17 K = 1,N
            DUM = A(IMAX,K)
            A(IMAX,K) = A(J,K)
            A(J,K) = DUM
   17     CONTINUE
          D = -D
          VV(IMAX) = VV(J)
        ENDIF
        IX(J) = IMAX
        IF( ABS(A(J,J))/EPSL.LT.EPSL ) A(J,J) = 1.D-30
        IF( J.NE.N ) THEN
          DUM = 1.D+0/A(J,J)
          DO 18 I = J+1,N
            A(I,J) = A(I,J)*DUM
   18     CONTINUE
        ENDIF
   19 CONTINUE
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LU_DCMP group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LU_BKSB( A,N,NP,IX,B )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996.
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Numerical Recipes, The Art of Scientific Computing
!     W.H. Press, B.P. Flannery, Saul A. Teukolsky, and W.T. Vetterling
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, August 1, 2000.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 A(NP,NP),B(NP)
      INTEGER IX(NP)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LU_BKSB'
      II = 0
      DO 12 I = 1,N
        IL = IX(I)
        SUM = B(IL)
        B(IL) = B(I)
        IF( II.NE.0 ) THEN
          DO 11 J = II,I-1
            SUM = SUM - A(I,J)*B(J)
   11     CONTINUE
        ELSEIF( ABS(SUM)/EPSL.GT.EPSL ) THEN
          II = I
        ENDIF
        B(I) = SUM
   12 CONTINUE
      DO 14 I = N,1,-1
        SUM = B(I)
        IF( I.LT.N ) THEN
          DO 13 J = I+1,N
            SUM = SUM - A(I,J)*B(J)
   13     CONTINUE
        ENDIF
        B(I) = SUM/A(I,I)
   14 CONTINUE
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LU_BKSB group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE MAT_MUL( AX,BX,CX,IX,JX,KX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Multiple the matrix AX (IX X JX) and BX (JX X KX), returning the
!     result in matrix CX (IX X KX).
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 7 November 2016 (Ensisheim meteorite).
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 AX(IX,JX),BX(JX,KX),CX(IX,KX)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/MAT_MUL'
!
!---  Initialize CX  ---
!
      DO K = 1,KX
        DO I = 1,IX
          CX(I,K) = 0.D+0
        ENDDO
      ENDDO
!
!---  Matrix multiply  ---
!
      DO I = 1,IX
        DO K = 1,KX
          DO J = 1,JX
            CX(I,K) = CX(I,K) + AX(I,J)*BX(J,K)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of MAT_MUL group  ---
!
      RETURN
      END

!------------------------Function--------------------------------------!
!
      FUNCTION ND_BR( IX,IRX,JX,JRX,KX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Block refined node index
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 28 January.
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER ND_BR
!
!----------------------Executable Lines--------------------------------!
!
      ND_BR = (KX-1)*IRX*JRX + (JX-1)*IRX + IX - 1
!
!---  End of ND_BR group  ---
!
      RETURN
      END
      
!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE PNT_TRI_C( VX,UX,I0X,I1X,ITX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Check to see if triangle V is totally within triangle U
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 29 August 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 VX(3),UX(3,3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/PNT_TRI_C'
      ITX = 0
      AX = UX(I1X,2) - UX(I1X,1)
      BX = -(UX(I0X,2) - UX(I0X,1))
      CX = -AX*UX(I0X,1) - BX*UX(I1X,1)
      D0X = AX*VX(I0X) + BX*VX(I1X) + CX
      AX = UX(I1X,3) - UX(I1X,2)
      BX = -(UX(I0X,3) - UX(I0X,2))
      CX = -AX*UX(I0X,2) - BX*UX(I1X,2)
      D1X = AX*VX(I0X) + BX*VX(I1X) + CX
      AX = UX(I1X,1) - UX(I1X,3)
      BX = -(UX(I0X,1) - UX(I0X,3))
      CX = -AX*UX(I0X,3) - BX*UX(I1X,3)
      D2X = AX*VX(I0X) + BX*VX(I1X) + CX
      IF( D0X*D1X .GT. 0.D+0 ) THEN
        IF( D0X*D2X .GT. 0.D+0 ) THEN
          ITX = 1
        ENDIF
      ENDIF
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of PNT_TRI_C group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_AQSP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read aqueous reaction species.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 8 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*64 UNTS,ADUM
      REAL(KIND=DP) VAR
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_AQSP'
!
!---  Assign card string  ---
!
      CARD = 'Aqueous Species Card'
!
!---  Read number of aqueous species  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Aqueous Species'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSPL)
      LSPL = MAX( LSPL,NSPL )
!
!---  First check for Molecular diffusion option  ---
!
      VARB = 'Aqueous Species Molecular Diffusion Option'
      IVR = INDEX( VARB,'  ')-1
      CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
      IF( INDX.EQ.0 ) THEN
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      ENDIF
!
!---  Check for Pitzer activity coefficient option  ---
!
      CALL RD_DPR(ISTART,ICOMMA,CHDUM,SP_MDL)
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)

      CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
      IF( INDX.EQ.1 ) THEN
        VARB = 'Activity Coefficient Option: '
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        LMCG = 0
        LCAT = 0
        LANI = 0
        LNEU = 0
        NULLIFY( SPCL_PTR )
        IF( INDEX(ADUM(1:),'pitzer').NE.0 ) THEN
!
!---      Loop over the aqueous species  ---
!
          DO NSP = 1,NSPL
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
            VARB = 'Aqueous Species Name: '
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Empty aqueous species name list  ---
!
            IF( .NOT.ASSOCIATED(SPCL_PTR) ) THEN
              ALLOCATE( SPCL_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: SPCL_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              SPCL_PTR%LIST_NAME = ADUM
              NULLIFY(SPCL_PTR%NEXT)
!
!---        Established aqueous species name list  ---
!
            ELSE
              LOC_PTR => SPCL_PTR
!
!---          Check for repeated aqueous species name  ---
!
              DO
                IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
                IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                  INDX = 4
                  CHMSG = 'Duplicate Aqueous Species Name: ' // 
     &              ADUM(1:NCH)
                  CALL WRMSGP( INDX )
                ENDIF
                LOC_PTR => LOC_PTR%NEXT
              ENDDO
!
!---          Add aqueous species name to aqueous species list  ---
!
              ALLOCATE( TMP_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: SPCL_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              TMP_PTR%LIST_NAME = ADUM
              TMP_PTR%NEXT => SPCL_PTR
              SPCL_PTR => TMP_PTR
            ENDIF
            VARB = 'Charge'
            VAR = 0.0
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            IF (VAR > 0) THEN
              LCAT = LCAT+1
            ELSEIF(VAR < 0) THEN
              LANI = LANI+1
            ELSE
              LNEU = LNEU+1
            ENDIF
            LMCG = MAX(LMCG,INT(ABS(VAR)))
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          ENDDO
        ELSE
!
!---      Loop over the aqueous species  ---
!
          DO NSP = 1,NSPL
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
            VARB = 'Aqueous Species Name: '
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Empty aqueous species name list  ---
!
            IF( .NOT.ASSOCIATED(SPCL_PTR) ) THEN
              ALLOCATE( SPCL_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: SPCL_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              SPCL_PTR%LIST_NAME = ADUM
              NULLIFY(SPCL_PTR%NEXT)
!
!---        Established aqueous species name list  ---
!
            ELSE
              LOC_PTR => SPCL_PTR
!
!---          Check for repeated aqueous species name  ---
!
              DO
                IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
                IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                  INDX = 4
                  CHMSG = 'Duplicate Aqueous Species Name: ' // 
     &              ADUM(1:NCH)
                  CALL WRMSGP( INDX )
                ENDIF
                LOC_PTR => LOC_PTR%NEXT
              ENDDO
!
!---          Add aqueous species name to aqueous species list  ---
!
              ALLOCATE( TMP_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: SPCL_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              TMP_PTR%LIST_NAME = ADUM
              TMP_PTR%NEXT => SPCL_PTR
              SPCL_PTR => TMP_PTR
            ENDIF
          ENDDO
        ENDIF
      ENDIF
      LNAF = LANI*(LANI-1)+1
      LNCF = LCAT*(LCAT-1)+1
      LNNC = MAX(LCAT,LNEU)
      LNNA = MAX(LNEU,LANI)
      LNNF = MAX(LNNC,LNNA)
      LNNF = LNNF*LNEU
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_AQSP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_ATMOS
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Atmospheric Conditions Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 29 October 2003.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM,FDUM,CDUM
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_ATMOS'
!
!---  Assign card string  ---
!
      CARD = 'Atmospheric Conditions Card'
!
!---  Skip over the static atmospheric conditions card inputs  ---
!
      CALL RD_INPL( CHDUM )
!
!---  Read number of atmospheric condition times  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Input Option [File, Integer]'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---  Read atmospheric conditions from an external file  ---
!
      IF( INDEX(ADUM,'file').NE.0 ) THEN
        VARB = 'External Atmospheric Conditions File Name'
        CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
        INQUIRE( FILE=FDUM(1:NCHF), FORM=CDUM, EXIST=FCHK )
        IF( .NOT.FCHK ) THEN
          INDX = 4
          CHMSG = 'Atmospheric conditions file does not exist: '
     &      // FDUM(1:NCHF)
          CALL WRMSGP( INDX )
        ELSEIF( CDUM.EQ.'UNFORMATTED' ) THEN
          INDX = 4
          CHMSG = 'Atmospheric conditions file is unformatted: '
     &      // FDUM(1:NCHF)
          CALL WRMSGP( INDX )
        END IF
        OPEN(UNIT=27, FILE=FDUM(1:NCHF), STATUS='OLD', FORM='FORMATTED')
        READ(27,*,END=10) NATM
        CLOSE(UNIT=27)
!
!---    Cyclic atmospheric conditions  ---
!
        IF( NATM.LE.-3 ) THEN
          NATM = ABS(NATM)
!
!---    Empty atmospheric conditions file  ---
!
        ELSEIF( NATM.EQ.0 ) THEN
          INDX = 2
          CHMSG = 'No Atmospheric Condition Times'
          CALL WRMSGP( INDX )
!
!---    Ill-defined cyclic atmospheric conditions  ---
!
        ELSEIF( NATM.GT.-3 .AND. NATM.LT.0 ) THEN
          INDX = 4
          CHMSG = 'Number of Cyclic Atmospheric Conditions Times < 3'
          CALL WRMSGP( INDX )
        ENDIF
        LATM = MAX( LATM,NATM )
        GOTO 20
   10   CONTINUE
        INDX = 4
        CHMSG = 'Empty Atmospheric Conditions File'
        CALL WRMSGP( INDX )
   20   CONTINUE
!
!---  Read atmospheric conditions from input file  ---
!
      ELSE
        ISTART = 1
        VARB = 'Number of Atmospheric Condition Times'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NATM)
        LATM = MAX( LATM,NATM )
      ENDIF
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_ATMOS group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_AVSUCD
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read LaGrit AVS ASCII UCD file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 5 April 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VERTX,VERTY,VERTZ
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVERT
      INTEGER JVERT(8)
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_AVSUCD'
!
!---  Read AVS ASCII UCD file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'AVS ASCII UCD File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing AVS ASCII UCD File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'AVS ASCII UCD File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Read x length units  ---
!      
      VARB = 'X-direction Coordinate System Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      IUNM = 1
      INDX = 0
      VARX = 1.D+0
      CALL RD_UNIT( UNTS,VARX,INDX )
!
!---  Read y length units  ---
!      
      VARB = 'Y-direction Coordinate System Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      IUNM = 1
      INDX = 0
      VARY = 1.D+0
      CALL RD_UNIT( UNTS,VARY,INDX )
!
!---  Read z length units  ---
!      
      VARB = 'Z-direction Coordinate System Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      IUNM = 1
      INDX = 0
      VARZ = 1.D+0
      CALL RD_UNIT( UNTS,VARZ,INDX )
!
!---  Read number of nodes, layers, iz, and ic ---
!
      READ(9,*) NVERTX,NFLDX
      IF( NFLDX.NE.LFX*LFY*LFZ ) THEN
        INDX = 7
        IMSG = NFLDX
        CHMSG = 'Number of Nodes in AVS ASCII UCD File'
        CALL WRMSGP( INDX )        
      ENDIF
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VERTX(1:NVERTX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTY(1:NVERTX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTZ(1:NVERTX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( IVERT(1:NVERTX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IVERT'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read x-, y-, and z-vertices from file, in MODFLOW
!     or GSF node order  ---
!
      DO N = 1,NVERTX
        READ(9,*) IVERTX,VERTX(N),VERTY(N),VERTZ(N)
        IVERT(IVERTX) = N
      ENDDO
!
!---  Read node vertices  ---
!
      DO N = 1,NFLDX
        READ(9,'(A)') CHDUM
        ISX = 1
        IEX = INDEX( CHDUM(1:),' ' ) - 1
        READ(CHDUM(ISX:IEX),*) NX
        ISX = INDEX( CHDUM(1:),'hex' ) + 3
        IF( ISX.LE.3 ) THEN
          INDX = 4
          CHMSG = 'Non-hex grid in AVS ASCII UCD File'
          CALL WRMSGP( INDX )        
        ENDIF
        READ(CHDUM(ISX:),*)(JVERT(J),J=1,8)
        M = IVERT(JVERT(1))
        XE(1,N) = VERTX(M)*VARX
        YE(1,N) = VERTY(M)*VARY
        ZE(5,N) = VERTZ(M)*VARZ
        M = IVERT(JVERT(2))
        XE(2,N) = VERTX(M)*VARX
        YE(2,N) = VERTY(M)*VARY
        ZE(6,N) = VERTZ(M)*VARZ
        M = IVERT(JVERT(4))
        XE(3,N) = VERTX(M)*VARX
        YE(3,N) = VERTY(M)*VARY
        ZE(7,N) = VERTZ(M)*VARZ
        M = IVERT(JVERT(3))
        XE(4,N) = VERTX(M)*VARX
        YE(4,N) = VERTY(M)*VARY
        ZE(8,N) = VERTZ(M)*VARZ
        M = IVERT(JVERT(5))
        XE(5,N) = VERTX(M)*VARX
        YE(5,N) = VERTY(M)*VARY
        ZE(1,N) = VERTZ(M)*VARZ
        M = IVERT(JVERT(6))
        XE(6,N) = VERTX(M)*VARX
        YE(6,N) = VERTY(M)*VARY
        ZE(2,N) = VERTZ(M)*VARZ
        M = IVERT(JVERT(8))
        XE(7,N) = VERTX(M)*VARX
        YE(7,N) = VERTY(M)*VARY
        ZE(3,N) = VERTZ(M)*VARZ
        M = IVERT(JVERT(7))
        XE(8,N) = VERTX(M)*VARX
        YE(8,N) = VERTY(M)*VARY
        ZE(4,N) = VERTZ(M)*VARZ
      ENDDO
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VERTX) ) THEN
      DEALLOCATE( VERTX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTY) ) THEN
      DEALLOCATE( VERTY,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTZ) ) THEN
      DEALLOCATE( VERTZ,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(IVERT) ) THEN
      DEALLOCATE( IVERT,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: IVERT'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Close AVS ASCII UCD File  ---
!
      CLOSE(UNIT=9)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_AVSUCD group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_BALA
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Balance Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by WE Nichols, PNNL, 13 June 2003.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_BALA'
!
!---  Assign card string  ---
!
      CARD = 'Balance Card'
!
!---  Grid dimension parameters  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Mass Balance Report Times'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LBAL)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_BALA group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_BC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Boundary Conditions Card for number of boundary conditions
!     and number of boundary condition times.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 10 October 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TRNSPT
      USE SOLTN
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM,BDUM,CDUM,FDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_BC'
!
!---  Assign card string  ---
!
      CARD = 'Boundary Conditions Card'
!
!---  Read number of boundary condition inputs  ---
!
      LBC = 1
      LBCIN = 1
      LBTM = 1
      NBC = 0
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Boundary Condition Inputs: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
      LBCIN = MAX( LBCIN,NLIN )
      LXYZG = 0
      DO 400 NB = 1, NLIN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    Read boundary orientation  ---
!
        VARB = 'Boundary Condition Orientation: '
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'west').NE.0 ) THEN
          IBCDX = -1
        ELSEIF( INDEX(ADUM(1:),'east').NE.0 ) THEN
          IBCDX = 1
        ELSEIF( INDEX(ADUM(1:),'south').NE.0 ) THEN
          IBCDX = -2
        ELSEIF( INDEX(ADUM(1:),'north').NE.0 ) THEN
          IBCDX = 2
        ELSEIF( INDEX(ADUM(1:),'bottom').NE.0 ) THEN
          IBCDX = -3
        ELSEIF( INDEX(ADUM(1:),'top').NE.0 ) THEN
          IBCDX = 3
        ELSEIF( INDEX(ADUM(1:),'file').NE.0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
          NCH = INDEX(FDUM,'  ')-1
          OPEN(UNIT=27,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED')
          I1X = 1
          I2X = 1
          J1X = 1
          J2X = 1
          K1X = 1
          K2X = 0
    5     CONTINUE
          READ(27,*,END=10) IX,JX,KX,IBCDX
          K2X = K2X+1
          GOTO 5
   10     CONTINUE
          REWIND(27)
        ENDIF
!
!---    Loop over coupled flow and transport boundary types  ---
!
        NBTX = LD+LG+LL+LN+LS+LT-ISLC(30)-ISLC(46)
        IF( IOM.EQ.50 .OR. IOM.EQ.51 .OR. IOM.EQ.52 ) NBTX = 3
!
!---    STOMP-EOR  ---
!
        IF( IOM.EQ.43 ) THEN
          NBTX = 2
!
!---      Isothermal option  ---
!
          IF( ISLC(30).EQ.0 ) NBTX = 3
        ENDIF
!
!---    STOMP-HYDT-KE  ---
!
        IF( IOM.EQ.37 .OR. IOM.EQ.39 ) THEN
          NBTX = 2
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) NBTX = 3
        ENDIF
!
!---    STOMP-CO2  ---
!
        IF( IOM.EQ.32 ) THEN
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.1 ) NBTX = NBTX - 1
        ENDIF
!
!---    STOMP-CO2e  ---
!
        IF( IOM.EQ.33 ) THEN
!
!---      Isothermal option  ---
!
          IF( ISLC(30).EQ.1 ) NBTX = NBTX - 1
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.1 ) NBTX = NBTX - 1
        ENDIF
!
!---    STOMP-SEQ  ---
!
        IF( IOM.EQ.34 ) THEN
          NBTX = 3
!
!---      Isothermal option  ---
!
          IF( ISLC(30).EQ.1 ) NBTX = NBTX - 1
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.1 ) NBTX = NBTX - 1
        ENDIF
!
!---     STOMP-GT  ---
!
        IF( IOM.EQ.3 ) THEN
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.1 ) NBTX = NBTX - 1
        ENDIF
!
!---    Loop over the number of boundary condition types  ---
!
        DO 50 NBT = 1,NBTX
!
!---      Check for Shuttleworth-Wallace boundary conditions  ---
!
          VARB = 'Boundary Condition Type'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
          IF( INDEX(BDUM(1:),'shuttleworth').NE.0 .OR.
     &      ((INDEX(BDUM(1:),'shuttle').NE.0 ) .AND.
     &      (INDEX(BDUM(1:),'worth').NE.0 )) .OR.
     &      INDEX(BDUM(1:),'wallace').NE.0 ) LSW = 1
          IF( INDEX(BDUM(1:),'x-y-z').NE.0 .AND.
     &      ( INDEX(BDUM(1:),'hydraulic gradient').NE.0 .OR.
     &        INDEX(BDUM(1:),'seepage face').NE.0 ) ) LXYZG = 1
!
!---      STOMP-EOR  ---
!
          IF( IOM.EQ.43 .AND. INDEX(BDUM(1:),'bc1').NE.0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
          ELSEIF( IOM.EQ.43 .AND. INDEX(BDUM(1:),'bc2').NE.0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
          ENDIF
!
!---      STOMP-CO2  ---
!
          IF( IOM.EQ.32 .AND. INDEX(BDUM(1:),'hydrostatic').NE.0 ) EXIT
!
!---      STOMP-CO2e  ---
!
          IF( IOM.EQ.33 .AND. INDEX(BDUM(1:),'hydrostatic').NE.0 ) EXIT
!
!---      STOMP-GT  ---
!
          IF( IOM.EQ.3 .AND. INDEX(BDUM(1:),'neumann').NE.0 ) EXIT
          IF( IOM.EQ.3 .AND. INDEX(BDUM(1:),'barometric').NE.0 ) EXIT
          IF( IOM.EQ.3 .AND. INDEX(BDUM(1:),'hydrostatic').NE.0 ) EXIT
          IF( IOM.EQ.3 .AND. INDEX(BDUM(1:),'evaporative').NE.0 ) EXIT
          IF( IOM.EQ.3 .AND. INDEX(BDUM(1:),'initial').NE.0 ) EXIT
   50   CONTINUE
!
!---    Loop over solute and reactive species boundary types,
!       allowing for returns in input lines  ---
!
        NBTX = (LSOLU*LC)+((LL+LG+LN)*LR)
        DO NBT = 1,NBTX
          IF( NBT.LE.LSOLU*LC ) THEN
            IF( IEDL(NBT).EQ.4 ) CYCLE
          ENDIF 
          VARB = 'Solute or Reactive Species Boundary Condition Type'
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
        ENDDO
!
!---    Read number of reactive species in boundary
!       condition  ---
!
        NBCSPX = 0
        IF( LR.EQ.1 ) THEN
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NBCSPX)
          LSPBC = MAX( LSPBC,NBCSPX )
!
!---      Loop over reactive species, allowing for returns
!         in the input lines  ---
!
          DO 70 NSPX = 1,NBCSPX
            VARB = 'Boundary Condition Species Name'
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
   70     CONTINUE
        ENDIF
!
!---    Read and write boundary domain indices  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        IF( INDEX(ADUM(1:),'file').EQ.0 ) THEN
          VARB = 'Boundary Condition Domain: '
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I2X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J2X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K2X)
!
!---  Check boundary domain  ---
!
          IF( I1X.GT.I2X .OR. J1X.GT.J2X .OR. K1X.GT.K2X ) THEN
            INDX = 4
            CHMSG = 'Nonascending Boundary Condition Domain Indices'
            CALL WRMSGP( INDX )
          ENDIF
        ENDIF
!
!---  Read number of boundary times  ---
!
        VARB = 'Number of Boundary Condition Times: '
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IBCMX)
        IF( IBCMX.LE.-3 ) THEN
          IBCCX = 1
          IBCMX = -IBCMX
        ELSEIF( IBCMX.GE.1 ) THEN
          IBCCX = 0
        ELSEIF( IBCMX.EQ.0 ) THEN
          INDX = 4
          CHMSG = 'No Boundary Condition Times'
          CALL WRMSGP( INDX )
        ELSE
          INDX = 4
          CHMSG = 'Number of Cyclic Boundary Conditions Times < 3'
          CALL WRMSGP( INDX )
        ENDIF
        LBTM = MAX( LBTM,IBCMX )
!
!---    Skip over the boundary condition variables and units  ---
!
        DO 100 NTM = 1,IBCMX
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
!
!---      Check for external boundary condition time file  ---
!
          IF( NTM.EQ.1 ) CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,CDUM)
          CALL L_CASE( CDUM )
          IF( INDEX(CDUM(1:),'file').NE.0 ) GOTO 110
!
!---      Read gas component boundary condition line  ---
!
          IF( IOM.EQ.30 .OR. IOM.EQ.40 .OR. IOM.EQ.50 .OR. 
     &      IOM.EQ.51 .OR. IOM.EQ.52 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
!
!---      Loop over reactive species inputs, allowing for
!         returns in input lines  ---
!      
          DO 90 NSPX = 1,NBCSPX
            IF( NSPX.EQ.1 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
   90     CONTINUE
  100   CONTINUE
  110   CONTINUE
!
!---    Compute the number of boundary surfaces  ---
!
        NBC = NBC + (K2X-K1X+1)*(J2X-J1X+1)*(I2X-I1X+1)
        LBC = MAX( LBC,NBC )
        IF( INDEX(ADUM(1:),'file').NE.0 ) CLOSE(UNIT=27)
  400 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_BC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_BH
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Borehole Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 5 April 2019.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_BH
      USE GRID
      USE GEOM_FRC
      USE GEOM_BH
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM,BDUM
      CHARACTER*64 UNTS,ROCKX(10)
      TYPE(LIST_INTERVAL), POINTER :: IN_TMP_PTR
      TYPE(LIST_TRANSITION), POINTER :: TP_TMP_PTR
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_BH'
!
!---  Assign card string  ---
!
      CARD = 'Borehole Card'
      L_BH = 1
!
!---  Check for pre-processed borehole data  ---
!
      ISTART = 1
      CALL RDINPL( CHDUM )
      CALL LCASE( CHDUM )
      CALL RDCHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      IF( INDEX(ADUM(1:),'preprocess').NE.0 .AND.
     &  INDEX(ADUM(1:),'borehole').NE.0 ) THEN
        INQUIRE( FILE='ppbh.dat',EXIST=FCHK )
        IF( .NOT.FCHK ) THEN
          INDX = 4
          CHMSG = 'Missing Preprocessed Borehole File: ppbh.dat'
          CALL WRMSGP( INDX )
        ELSE  
          OPEN(UNIT=35, FILE='ppbh.dat', STATUS='OLD', FORM='FORMATTED')
        ENDIF
!
!---    Read borehole parameters  ---
!
        READ(35,*) LBC_BH,LBC_FRC,LBN_BH,LFC_BH,LI_BH,LN_BH,LT_BH,
     &    LSOLU_BH,LRC
!
!---    Read range of borehole rock/soil type indices  ---
!
        READ(35,*) I1X,I2X
        NROCK = I2X
!
!---    Read range of borehole rock/soil names  ---
!
        J1X = I1X
        L1 : DO IX = I1X,I2X,10
          J2X = MIN( J1X+9,I2X )
          READ(35,*) (ROCKX(JX),JX=J1X,J2X)
          L2 : DO JX = J1X,J2X
            LOC_PTR => ROCK_PTR
!
!---        Check for repeated rock/soil name  ---
!
            L3 : DO
              IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
              IF( LOC_PTR%LIST_NAME == ROCKX(JX) ) CYCLE L2
              LOC_PTR => LOC_PTR%NEXT
            ENDDO L3
!
!---        Add rock/soil name to rock list  ---
!
            ALLOCATE( TMP_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            TMP_PTR%LIST_NAME = ROCKX(JX)
            TMP_PTR%NEXT => ROCK_PTR
            ROCK_PTR => TMP_PTR
          ENDDO L2
          J1X = J1X + 10
        ENDDO L1
!
!---    Allocate memory for borehole types  ---
!
        ALLOCATE( IT_BH(1:2,1:LN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IT_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for borehole interval/node index array  ---
!
        ALLOCATE( ID_BH(1:6,1:LN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ID_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for x-transition points array  ---
!
        ALLOCATE( XTP_BH(1:2,1:LI_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: XTP_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for y-transition points array  ---
!
        ALLOCATE( YTP_BH(1:2,1:LI_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: YTP_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for z-transition points array  ---
!
        ALLOCATE( ZTP_BH(1:2,1:LI_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ZTP_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for borehole node to borehole node connection
!       pointer array  ---
!
        ALLOCATE( IPB_BH(1:3,1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IPB_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for borehole node to borehole node connection
!       map  ---
!
        ALLOCATE( IBCM_BH(1:LBC_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IBCM_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for borehole-node index array  ---
!
        ALLOCATE( IBN_BH(1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IBN_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for the borehole x-projection array  ---
!
        ALLOCATE( XP_BH(1:2,1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: XP_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for the borehole y-projection array  ---
!
        ALLOCATE( YP_BH(1:2,1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: YP_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for the borehole z-projection array  ---
!
        ALLOCATE( ZP_BH(1:2,1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ZP_BH'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for triangle of borehole-fracture/fault connection
!       assuming fewer connections than borehole nodes   ---
!
        ALLOCATE( IBHT_FRC(1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IBHT_FRC'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for borehole node of borehole-fracture
!        connection assuming fewer connections than borehole nodes   ---
!
        ALLOCATE( IBHN_FRC(1:LBN_BH),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IBHN_FRC'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Read number of boreholes and borehole nodes  ---
!
        READ(35,*) N_BH,NBN_BH
!
!---    Loop over boreholes  ---
!
        DO NBH = 1,N_BH
!
!---      Read borehole preprocessed file  ---
!
          CALL RD_PREP_BH( NBH )
        ENDDO     
!
!---    Close borehole preprocessed file  ---
!
        CLOSE(UNIT=35)
!
!---    Reset subroutine string sequence  ---
!
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ELSE
        BACKSPACE(UNIT=IRD)
      ENDIF
!
!---  Read number of boreholes  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Boreholes'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,N_BH)
      LN_BH = MAX( LN_BH,N_BH )
!
!---  Allocate memory for borehole types  ---
!
      ALLOCATE( IT_BH(1:2,1:LN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IT_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Loop over number of boreholes  ---
!
      NIT_BH = 0
      NULLIFY( IN_BH_PTR )
      NULLIFY( TP_BH_PTR )
      DO 500 NBH = 1,N_BH
!
!---    Read borehole type  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        JNDX = 1
        DO M = 1,2
        IF( JNDX.EQ.0 ) CYCLE
        VARB = 'Borehole Type'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'start').NE.0 ) THEN
          INDX = 1
          JNDX = 1
        ELSEIF( INDEX(ADUM(1:),'end').NE.0 ) THEN
          INDX = 2
          JNDX = 1
        ELSE
          INDX = 1
          JNDX = 0
        ENDIF
        IF( INDEX(ADUM(1:),'coaxial').NE.0 ) THEN
          IT_BH(1,NBH) = 10000
          IT_BH(2,NBH) = 0
          LCOAX_BH = 1
        ELSEIF( INDEX(ADUM(1:),'gas').NE.0 .AND.
     &    INDEX(ADUM(1:),'injection').NE.0 ) THEN
          VARB = 'Water-Vapor Option'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IT_BH(INDX,NBH) = 1
        ELSEIF( INDEX(ADUM(1:),'aqueous').NE.0 .AND.
     &    INDEX(ADUM(1:),'injection').NE.0 ) THEN
          VARB = 'Dissolved Air and Salt Option'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IT_BH(INDX,NBH) = 4
        ELSEIF( INDEX(ADUM(1:),'dirichlet').NE.0 .AND.
     &    INDEX(ADUM(1:),'energy').NE.0 ) THEN
          IT_BH(1,NBH) = 21
          IT_BH(2,NBH) = 21
          JNDX = 0
        ELSEIF( INDEX(ADUM(1:),'neumann').NE.0 .AND.
     &    INDEX(ADUM(1:),'energy').NE.0 ) THEN
          IT_BH(1,NBH) = 22
          IT_BH(2,NBH) = 22
          JNDX = 0
        ELSEIF( INDEX(ADUM(1:),'pressure').NE.0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCHB,CHDUM,BDUM)
          IF( INDEX(BDUM(1:),'1').NE.0 ) THEN
            IT_BH(INDX,NBH) = 7
          ELSEIF( INDEX(BDUM(1:),'2').NE.0 ) THEN
            IT_BH(INDX,NBH) = 8
          ELSEIF( INDEX(BDUM(1:),'3').NE.0 ) THEN
            IT_BH(INDX,NBH) = 9
          ELSE
            IT_BH(INDX,NBH) = 7
          ENDIF
        ELSE
          IT_BH(INDX,NBH) = 0
          INDX = 4
          CHMSG = 'Unrecognized Borehole Type: ' // ADUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Check for solutes  ---
!
        IF( LC.NE.0 ) THEN
          NC = 0
          DO
!
!---        Check for solute names or borehole name  ---
!
            CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) EXIT
!
!---        Check for solute names  ---
!
            ADUM(1:) = ' '
            VARB = 'Solute Name'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IFIND = 0
            LOC_PTR => SOLUT_PTR
            DO
              IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
!
!---          Solute name found  ---
!
              IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                NC = NC + 1
                IFIND = 1
                EXIT
              ENDIF
              LOC_PTR => LOC_PTR%NEXT
            ENDDO
            IF( IFIND.EQ.0 ) EXIT
          ENDDO
          LSOLU_BH = MAX( LSOLU_BH,NC )
        ENDIF
        ENDDO
!
!---    Read number of borehole intervals  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Number of Borehole Intervals'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NI_BH)
        NIT_BH = NIT_BH + NI_BH
        LI_BH = MAX( NIT_BH,LI_BH )
!
!---    Allocate memory for new borehole interval element  ---
!
        ALLOCATE( IN_TMP_PTR,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IN_TMP_PTR'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Assign borehole transition pointers  ---
!
        IF( NBH.EQ.1 ) THEN
          IN_TMP_PTR%ID1_CW = 1
        ELSE
          IN_TMP_PTR%ID1_CW = NIT_BH - NI_BH + 1
        ENDIF
        IN_TMP_PTR%ID2_CW = IN_TMP_PTR%ID1_CW + NI_BH - 1
        IN_TMP_PTR%NEXT => IN_BH_PTR
        IN_BH_PTR => IN_TMP_PTR
!
!---    Check for interval increment input type  ---
!
        III_BHX = 0
        CALL CHK_CHR(ISTART,ICOMMA,CHDUM,INDX )
        IF( INDX.EQ.1 ) THEN
          IDFLT = 1
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,BDUM )
          IF( INDEX(BDUM(1:),'increment').NE.0 ) THEN
            III_BHX = 1
!
!---        Read first x-transition point  ---
!
            VARB = 'Interval First X-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP1_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,XTP1_BHX,INDX)
!
!---        Read first y-transition point  ---
!
            VARB = 'Interval First Y-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP1_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,YTP1_BHX,INDX)
!
!---        Cylindrical coordinates with azimuthal symmetry  ---
!
            IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
              IF( ABS(XTP1_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
                CHMSG = 'Non-Zero Interval First X-Transition Point ' // 
     &            'for Radially Symmetric Domain: XTP_BH ='
                RLMSG = XTP1_BHX
                CALL WRMSGP( INDX )
              ENDIF
              IF( ABS(YTP1_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
                CHMSG = 'Non-Zero Interval First Y-Transition Point ' // 
     &            'for Radially Symmetric Domain: YTP_BH ='
                RLMSG = YTP1_BHX
                CALL WRMSGP( INDX )
              ENDIF
            ENDIF
!
!---        Read first z-transition point  ---
!
            VARB = 'Interval First Z-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP1_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,ZTP1_BHX,INDX)
          ENDIF
        ENDIF
!
!---    Loop over number of borehole intervals  ---
!
        DO 100 NICW = 1,NI_BH
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          IF( III_BHX.EQ.1 ) THEN
            IF( NICW.GT.1 ) THEN
              XTP1_BHX = XTP2_BHX
              YTP1_BHX = YTP2_BHX
              ZTP1_BHX = ZTP2_BHX
            ENDIF
!
!---        Read x-direction interval increment  ---
!
            VARB = 'X-Direction Interval Increment'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP2_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,XTP2_BHX,INDX)
            XTP2_BHX = XTP2_BHX + XTP1_BHX
!
!---        Read y-direction interval increment  ---
!
            VARB = 'Y-Direction Interval Increment'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP2_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,YTP2_BHX,INDX)
            YTP2_BHX = YTP2_BHX + YTP1_BHX
!
!---        Cylindrical coordinates with azimuthal symmetry  ---
!
            IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
              IF( ABS(XTP2_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
               CHMSG = 'Non-Zero Interval Second X-Transition ' // 
     &            'Point for Radially Symmetric Domain: XTP_BH ='
                RLMSG = XTP2_BHX
                CALL WRMSGP( INDX )
              ENDIF
              IF( ABS(YTP2_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
                CHMSG = 'Non-Zero Interval Second Y-Transition ' // 
     &            'Point for Radially Symmetric Domain: YTP_BH ='
                RLMSG = YTP2_BHX
                CALL WRMSGP( INDX )
              ENDIF
            ENDIF
!
!---        Read second z-transition point  ---
!
            VARB = 'Interval Second Z-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP2_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,ZTP2_BHX,INDX)
            ZTP2_BHX = ZTP2_BHX + ZTP1_BHX
          ELSE
!
!---        Read first x-transition point  ---
!
            VARB = 'Interval First X-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP1_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,XTP1_BHX,INDX)
!
!---        Read first y-transition point  ---
!
            VARB = 'Interval First Y-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP1_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,YTP1_BHX,INDX)
!
!---        Cylindrical coordinates with azimuthal symmetry  ---
!
            IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
              IF( ABS(XTP1_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
                CHMSG = 'Non-Zero Interval First X-Transition Point ' // 
     &            'for Radially Symmetric Domain: XTP_BH ='
                RLMSG = XTP1_BHX
                CALL WRMSGP( INDX )
              ENDIF
              IF( ABS(YTP1_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
                CHMSG = 'Non-Zero Interval First Y-Transition Point ' // 
     &            'for Radially Symmetric Domain: YTP_BH ='
                RLMSG = YTP1_BHX
                CALL WRMSGP( INDX )
              ENDIF
            ENDIF
!
!---        Read first z-transition point  ---
!
            VARB = 'Interval First Z-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP1_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,ZTP1_BHX,INDX)
!
!---        Read second x-transition point  ---
!
            VARB = 'Interval Second X-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP2_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,XTP2_BHX,INDX)
!
!---        Read second y-transition point  ---
!
            VARB = 'Interval Second Y-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP2_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,YTP2_BHX,INDX)
!
!---        Cylindrical coordinates with azimuthal symmetry  ---
!
            IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
              IF( ABS(XTP2_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
                CHMSG = 'Non-Zero Interval Second X-Transition ' // 
     &            'Point for Radially Symmetric Domain: XTP_BH ='
                RLMSG = XTP2_BHX
                CALL WRMSGP( INDX )
              ENDIF
              IF( ABS(YTP2_BHX)/EPSL.GT.EPSL ) THEN
                INDX = 9
                CHMSG = 'Non-Zero Interval Second Y-Transition ' // 
     &            'Point for Radially Symmetric Domain: YTP_BH ='
                RLMSG = YTP2_BHX
                CALL WRMSGP( INDX )
              ENDIF
            ENDIF
!
!---        Read second z-transition point  ---
!
            VARB = 'Interval Second Z-Transition Point'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP2_BHX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,ZTP2_BHX,INDX)
          ENDIF
!
!---      Non-coaxial borehole  ---
!
          IF( IT_BH(1,NBH).LT.10000 ) THEN
!
!---        Read borehole radius  ---
!
            VARB = 'Interval Borehole Radius'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Read borehole interval skin factor  ---
!
            VARB = 'Interval Skin Factor'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Read borehole interval screen option  ---
!
            VARB = 'Interval Screen Option'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IF( INDEX(ADUM(1:),'open').NE.0 ) THEN
              IS_BHX = 1
            ELSEIF( INDEX(ADUM(1:),'screened pipe').NE.0 ) THEN
              IS_BHX = 2
            ELSEIF( INDEX(ADUM(1:),'pipe').NE.0 ) THEN
              IS_BHX = 3
            ELSE
              IS_BHX = 0
            ENDIF
!
!---        Read borehole interval rock/soil/grout/fill for filled
!           borehole interval types  ---
!
            IF( IS_BHX.LE.1 ) THEN
              VARB = 'Interval Rock/Soil Name'
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
              LOC_PTR => ROCK_PTR
!
!---          Check for repeated rock/soil name  ---
!
              DO
                IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
                IF( LOC_PTR%LIST_NAME == ADUM ) GOTO 60
                LOC_PTR => LOC_PTR%NEXT
              ENDDO
!
!---          Add rock/soil name to rock list  ---
!
              NROCK = NROCK + 1
              ALLOCATE( TMP_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: ROCK_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              TMP_PTR%LIST_NAME = ADUM
              TMP_PTR%NEXT => ROCK_PTR
              ROCK_PTR => TMP_PTR
   60         CONTINUE
            ENDIF
          ENDIF
!
!---      Allocate memory for new transition point element  ---
!
          ALLOCATE( TP_TMP_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: TP_TMP_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          TP_TMP_PTR%XTP1_CW = XTP1_BHX
          TP_TMP_PTR%YTP1_CW = YTP1_BHX
          TP_TMP_PTR%ZTP1_CW = ZTP1_BHX
          TP_TMP_PTR%XTP2_CW = XTP2_BHX
          TP_TMP_PTR%YTP2_CW = YTP2_BHX
          TP_TMP_PTR%ZTP2_CW = ZTP2_BHX
          TP_TMP_PTR%PAR3_CW = 0.D+0
          TP_TMP_PTR%NEXT => TP_BH_PTR
          TP_BH_PTR => TP_TMP_PTR
  100   CONTINUE
!
!---    Read number of borehole times  ---
!
        VARB = 'Number of Borehole Times'
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        CALL RD_INT(ISTART,ICOMMA,CHDUM,ISRM_BHX)
        LT_BH = MAX( LT_BH,ISRM_BHX )
!
!---    Loop over number of borehole times  ---
!
        DO 300 M = 1,ISRM_BHX
          CALL RD_INPL( CHDUM )
  300   CONTINUE
  500 CONTINUE
!
!---  Allocate memory for borehole interval/node index array  ---
!
      ALLOCATE( ID_BH(1:6,1:LN_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ID_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load borehole interval/node index array  ---
!
      IN_TMP_PTR => IN_BH_PTR
      DO 510 NBH = 1,N_BH
        M = N_BH-NBH+1
        ID_BH(1,M) = IN_TMP_PTR%ID1_CW
        ID_BH(2,M) = IN_TMP_PTR%ID2_CW
        IN_TMP_PTR => IN_TMP_PTR%NEXT
  510 CONTINUE
!
!---  Allocate memory for x-transition points array  ---
!
      ALLOCATE( XTP_BH(1:2,1:LI_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XTP_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for y-transition points array  ---
!
      ALLOCATE( YTP_BH(1:2,1:LI_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YTP_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for z-transition points array  ---
!
      ALLOCATE( ZTP_BH(1:2,1:LI_BH),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZTP_BH'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load x-, y-, and z-transition point arrays  ---
!
      TP_TMP_PTR => TP_BH_PTR
      DO 520 NICW = 1,LI_BH
        M = LI_BH-NICW+1
        XTP_BH(1,M) = TP_TMP_PTR%XTP1_CW
        XTP_BH(2,M) = TP_TMP_PTR%XTP2_CW
        YTP_BH(1,M) = TP_TMP_PTR%YTP1_CW
        YTP_BH(2,M) = TP_TMP_PTR%YTP2_CW
        ZTP_BH(1,M) = TP_TMP_PTR%ZTP1_CW
        ZTP_BH(2,M) = TP_TMP_PTR%ZTP2_CW
        VARX = TP_TMP_PTR%PAR3_CW
        TP_TMP_PTR => TP_TMP_PTR%NEXT
  520 CONTINUE
!
!---  Number and location of borehole nodes  ---
!
      CALL CHK_BH
      LBN_BH = MAX( LBN_BH,1 )
!
!---  Update the number of rock types parameter  ---
!
      LRC = MAX( NROCK,LRC )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_BH group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_BR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Block Refinement Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 18 January 2014.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM
      CHARACTER*512 CHDUM
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER, DIMENSION(:), ALLOCATABLE :: IXP_TMP
      INTEGER, DIMENSION(:), ALLOCATABLE :: ID_TMP,JD_TMP,KD_TMP
      REAL*8, DIMENSION(:,:), ALLOCATABLE :: XE_TMP,YE_TMP,ZE_TMP
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_BR'
!
!---  Assign card string  ---
!
      CARD = 'Block Refinement Card'
!
!---  Read number of grid refinement domains  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Grid Refinement Domains'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NDOMX)
!
!---  Loop over number of grid refinement domains  ---
!
      MXBRFX = 0
      MXBRFY = 0
      MXBRFZ = 0
      DO 100 NX = 1,NDOMX     
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Grid Refinement Domain I-Start Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,I1X)
        VARB = 'Grid Refinement Domain I-End Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,I2X)
        VARB = 'Grid Refinement Domain J-Start Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,J1X)
        VARB = 'Grid Refinement Domain J-End Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,J2X)
        VARB = 'Grid Refinement Domain K-Start Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,K1X)
        VARB = 'Grid Refinement Domain K-End Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,K2X)
        IBRFX = 0
        IBRFY = 0
        IBRFZ = 0
   10   CONTINUE
        VARB = 'Grid Refinement Level'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'1x').NE.0 ) THEN
          IBRFX = 1
        ELSEIF( INDEX(ADUM(1:),'2x').NE.0 ) THEN
          IBRFX = 2
        ELSEIF( INDEX(ADUM(1:),'3x').NE.0 ) THEN
          IBRFX = 3
        ELSEIF( INDEX(ADUM(1:),'1y').NE.0 ) THEN
          IBRFY = 1
        ELSEIF( INDEX(ADUM(1:),'2y').NE.0 ) THEN
          IBRFY = 2
        ELSEIF( INDEX(ADUM(1:),'3y').NE.0 ) THEN
          IBRFY = 3
        ELSEIF( INDEX(ADUM(1:),'1z').NE.0 ) THEN
          IBRFZ = 1
        ELSEIF( INDEX(ADUM(1:),'2z').NE.0 ) THEN
          IBRFZ = 2
        ELSEIF( INDEX(ADUM(1:),'3z').NE.0 ) THEN
          IBRFZ = 3
        ELSE
          INDX = 4
          CHMSG = 'Unrecognized Grid Refinement Level: ' // ADUM
          CALL WRMSGP( INDX )
        ENDIF
        IF( LFX.EQ.1 .AND. IBRFX.GT.0 ) THEN
          INDX = 4
          CHMSG = 'X-Grid Refinement for 1D X-Grid Domain: ' // ADUM
          CALL WRMSGP( INDX )
        ENDIF
        IF( LFY.EQ.1 .AND. IBRFY.GT.0 ) THEN
          INDX = 4
          CHMSG = 'Y-Grid Refinement for 1D Y-Grid Domain: ' // ADUM
          CALL WRMSGP( INDX )
        ENDIF
        IF( LFZ.EQ.1 .AND. IBRFZ.GT.0 ) THEN
          INDX = 4
          CHMSG = 'Z-Grid Refinement for 1D Z-Grid Domain: ' // ADUM
          CALL WRMSGP( INDX )
        ENDIF
        CALL CHK_CHR(ISTART,ICOMMA,CHDUM,INDX)
        IF( INDX.EQ.1 ) GOTO 10 
        I1X = MAX( 1,I1X )
        I1X = MIN( I1X,I2X,LFX )
        I2X = MAX( 1,I1X,I2X )
        I2X = MIN( I2X,LFX )
        J1X = MAX( 1,J1X )
        J1X = MIN( J1X,J2X,LFY )
        J2X = MAX( 1,J1X,J2X )
        J2X = MIN( J2X,LFY )
        K1X = MAX( 1,K1X )
        K1X = MIN( K1X,K2X,LFZ )
        K2X = MAX( 1,K1X,K2X )
        K2X = MIN( K2X,LFZ )
!
!---    Assign grid refinement indexing  ---
!
        DO K = K1X,K2X
        DO J = J1X,J2X
        DO I = I1X,I2X
          N = ND(I,J,K)
!
!---      Skip inactive nodes  ---
!
          IF( IXP(N).EQ.0 ) CYCLE
          IBR(1,N) = IBRFX
          IBR(2,N) = IBRFY
          IBR(3,N) = IBRFZ
        ENDDO
        ENDDO
        ENDDO
        MXBRFX = MAX( MXBRFX,IBRFX )
        MXBRFY = MAX( MXBRFY,IBRFY )
        MXBRFZ = MAX( MXBRFZ,IBRFZ )
  100 CONTINUE
!  
!---  Re-assign grid refinement indexing at node, honoring adjacent 
!     refinement levels (adjacent upgrade)  ---
!
      DO 310 M = 1,MAX(1,MXBRFX-1)
        DO K = 1,LFZ
        DO J = 1,LFY
        DO I = 1,LFX
          N = ND(I,J,K)
!  
!---      Skip inactive nodes  ---
!  
          IF( IXP(N).EQ.0 ) CYCLE
!  
!---      Bottom boundary  ---
!  
          IF( LFZ.GT.1 ) THEN
            IF( K.GT.1 ) THEN
              NB = N-LFXY
              IBR(1,N) = MAX( IBR(1,N),IBR(1,NB)-1 )
              IBR(2,N) = MAX( IBR(2,N),IBR(2,NB)-1 )
              IBR(3,N) = MAX( IBR(3,N),IBR(3,NB)-1 )
            ENDIF
          ENDIF
!  
!---      South boundary  ---
!  
          IF( LFY.GT.1 ) THEN
            IF( J.GT.1 ) THEN
              NS = N-LFX
              IBR(1,N) = MAX( IBR(1,N),IBR(1,NS)-1 )
              IBR(2,N) = MAX( IBR(2,N),IBR(2,NS)-1 )
              IBR(3,N) = MAX( IBR(3,N),IBR(3,NS)-1 )
            ENDIF
          ENDIF
!  
!---      West boundary  ---
!  
          IF( LFX.GT.1 ) THEN
            IF( I.GT.1 ) THEN
              NW = N-1
              IBR(1,N) = MAX( IBR(1,N),IBR(1,NW)-1 )
              IBR(2,N) = MAX( IBR(2,N),IBR(2,NW)-1 )
              IBR(3,N) = MAX( IBR(3,N),IBR(3,NW)-1 )
            ENDIF
          ENDIF
!  
!---      East boundary  ---
!  
          IF( LFX.GT.1 ) THEN
            IF( I.LT.LFX ) THEN
              NE = N+1
              IBR(1,N) = MAX( IBR(1,N),IBR(1,NE)-1 )
              IBR(2,N) = MAX( IBR(2,N),IBR(2,NE)-1 )
              IBR(3,N) = MAX( IBR(3,N),IBR(3,NE)-1 )
            ENDIF
          ENDIF
!  
!---      North boundary  ---
!  
          IF( LFY.GT.1 ) THEN
            IF( J.LT.LFY ) THEN
              NN = N+LFX
              IBR(1,N) = MAX( IBR(1,N),IBR(1,NN)-1 )
              IBR(2,N) = MAX( IBR(2,N),IBR(2,NN)-1 )
              IBR(3,N) = MAX( IBR(3,N),IBR(3,NN)-1 )
            ENDIF
          ENDIF
!  
!---      Top boundary  ---
!  
          IF( LFZ.GT.1 ) THEN
            IF( K.LT.LFZ ) THEN
              NT = N+LFXY
              IBR(1,N) = MAX( IBR(1,N),IBR(1,NT)-1 )
              IBR(2,N) = MAX( IBR(2,N),IBR(2,NT)-1 )
              IBR(3,N) = MAX( IBR(3,N),IBR(3,NT)-1 )
            ENDIF
          ENDIF
        ENDDO
        ENDDO
        ENDDO
  310 CONTINUE
!  
!---  Refined node pointers  ---
!
      NC = LFD
      LRFN = 0
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        NX = 1
        IBRX = (2**IBR(1,N))
        JBRX = (2**IBR(2,N))
        KBRX = (2**IBR(3,N))
        IF( LFX.GT.1 ) NX = NX*IBRX
        IF( LFY.GT.1 ) NX = NX*JBRX
        IF( LFZ.GT.1 ) NX = NX*KBRX
        IF( NX.GT.1 ) THEN
          IBR(4,N) = NC+1
          IBR(5,N) = NC+NX
          NC = NC+NX
          LSRX = LSRX + (IBRX+1)*JBRX*KBRX
          LSRY = LSRY + IBRX*(JBRX+1)*KBRX
          LSRZ = LSRZ + IBRX*JBRX*(KBRX+1)
          LRFN = LRFN + 1
        ENDIF
      ENDDO
      ENDDO
      ENDDO
      LBR = NC-LFD
      LAN = LAN + LBR - LRFN
!
!---  Allocate memory for temporary inactive nodes index  ---
!
      ALLOCATE( IXP_TMP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IXP_TMP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for temporary I-index nodes index  ---
!
      ALLOCATE( ID_TMP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ID_TMP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for temporary J-index nodes index  ---
!
      ALLOCATE( JD_TMP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: JD_TMP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for temporary K-index nodes index  ---
!
      ALLOCATE( KD_TMP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: KD_TMP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for temporary x-direction vertices  ---
!
      ALLOCATE( XE_TMP(1:8,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XE_TMP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for temporary y-direction vertices  ---
!
      ALLOCATE( YE_TMP(1:8,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YE_TMP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for temporary z-direction vertices  ---
!
      ALLOCATE( ZE_TMP(1:8,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZE_TMP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Store inactive nodes array  ---
!
      DO 410 N = 1,LFD
        DO 402 M = 1,8
           XE_TMP(M,N) = XE(M,N)
           YE_TMP(M,N) = YE(M,N)
           ZE_TMP(M,N) = ZE(M,N)
  402   CONTINUE
        IXP_TMP(N) = IXP(N)
        ID_TMP(N) = ID(N)
        JD_TMP(N) = JD(N)
        KD_TMP(N) = KD(N)
  410 CONTINUE
!
!---  Deallocate memory for the inactive nodes index  ---
!
      IF( ALLOCATED(IXP) ) THEN
      DEALLOCATE( IXP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: IXP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate memory for the I-index nodes index  ---
!
      IF( ALLOCATED(ID) ) THEN
      DEALLOCATE( ID,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: ID'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate memory for the J-index nodes index  ---
!
      IF( ALLOCATED(JD) ) THEN
      DEALLOCATE( JD,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: JD'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate memory for the K-index nodes index  ---
!
      IF( ALLOCATED(KD) ) THEN
      DEALLOCATE( KD,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: KD'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate memory for the x-direction vertices  ---
!
      IF( ALLOCATED(XE) ) THEN
      DEALLOCATE( XE,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: XE'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate memory for the y-direction vertices  ---
!
      IF( ALLOCATED(YE) ) THEN
      DEALLOCATE( YE,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: YE'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate memory for the z-direction vertices  ---
!
      IF( ALLOCATED(ZE) ) THEN
      DEALLOCATE( ZE,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: ZE'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Reallocate memory for the inactive nodes index to include
!     field nodes and block refinement nodes  ---
!
      ALLOCATE( IXP(1:LFD+LBR),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IXP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Reallocate memory for the I-index nodes index to include
!     field nodes and block refinement nodes  ---
!
      ALLOCATE( ID(1:LFD+LBR),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ID'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Reallocate memory for the J-index nodes index to include
!     field nodes and block refinement nodes  ---
!
      ALLOCATE( JD(1:LFD+LBR),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: JD'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Reallocate memory for the K-index nodes index to include
!     field nodes and block refinement nodes  ---
!
      ALLOCATE( KD(1:LFD+LBR),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: KD'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Reallocate memory for the x-direction vertices to include
!     field nodes and block refinement nodes  ---
!
      ALLOCATE( XE(1:8,1:LFD+LBR),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XE'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Reallocate memory for the y-direction vertices to include
!     field nodes and block refinement nodes  ---
!
      ALLOCATE( YE(1:8,1:LFD+LBR),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YE'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Reallocate memory for the z-direction vertices to include
!     field nodes and block refinement nodes  ---
!
      ALLOCATE( ZE(1:8,1:LFD+LBR),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZE'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Reassign inactive nodes array  ---
!
      DO 420 N = 1,LFD
        DO 412 M = 1,8
           XE(M,N) = XE_TMP(M,N)
           YE(M,N) = YE_TMP(M,N)
           ZE(M,N) = ZE_TMP(M,N)
  412   CONTINUE
        IXP(N) = IXP_TMP(N)
        ID(N) = ID_TMP(N)
        JD(N) = JD_TMP(N)
        KD(N) = KD_TMP(N)
  420 CONTINUE
!
!---  Deallocate temporary memory for the inactive nodes index  ---
!
      IF( ALLOCATED(IXP_TMP) ) THEN
      DEALLOCATE( IXP_TMP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: IXP_TMP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate temporary memory for the I-index nodes index  ---
!
      IF( ALLOCATED(ID_TMP) ) THEN
      DEALLOCATE( ID_TMP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: ID_TMP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate temporary memory for the J-index nodes index  ---
!
      IF( ALLOCATED(JD_TMP) ) THEN
      DEALLOCATE( JD_TMP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: JD_TMP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate temporary memory for the K-index nodes index  ---
!
      IF( ALLOCATED(KD_TMP) ) THEN
      DEALLOCATE( KD_TMP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: KD_TMP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate temporary memory for the x-direction vertices  ---
!
      IF( ALLOCATED(XE_TMP) ) THEN
      DEALLOCATE( XE_TMP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: XE_TMP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate temporary memory for the y-direction vertices  ---
!
      IF( ALLOCATED(YE_TMP) ) THEN
      DEALLOCATE( YE_TMP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: YE_TMP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Deallocate temporary memory for the z-direction vertices  ---
!
      IF( ALLOCATED(ZE_TMP) ) THEN
      DEALLOCATE( ZE_TMP,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: ZE_TMP'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Define the grid pointers and refined grid vertices  ---
!
      DO 540 N = 1,LFD
        NBRX = IBR(4,N)
        IF( NBRX.GT.N ) THEN
          IBRX = 2**IBR(1,N)
          JBRX = 2**IBR(2,N)
          KBRX = 2**IBR(3,N)
          DO K = 1,KBRX
          DO J = 1,JBRX
          DO I = 1,IBRX
            IXP(NBRX) = NBRX
            ID(NBRX) = I
            JD(NBRX) = J
            KD(NBRX) = K
!
!---        Vertices 1 and 2  ---
!
            X15X = XE(1,N) + (XE(5,N)-XE(1,N))*REAL(K-1)/REAL(KBRX)
            X37X = XE(3,N) + (XE(7,N)-XE(3,N))*REAL(K-1)/REAL(KBRX)
            X26X = XE(2,N) + (XE(6,N)-XE(2,N))*REAL(K-1)/REAL(KBRX)
            X48X = XE(4,N) + (XE(8,N)-XE(4,N))*REAL(K-1)/REAL(KBRX)
            XLX = X15X + (X37X-X15X)*REAL(J-1)/REAL(JBRX)
            XUX = X26X + (X48X-X26X)*REAL(J-1)/REAL(JBRX)
            XE(1,NBRX) = XLX + (XUX-XLX)*REAL(I-1)/REAL(IBRX)
            XE(2,NBRX) = XLX + (XUX-XLX)*REAL(I)/REAL(IBRX)
            Y15X = YE(1,N) + (YE(5,N)-YE(1,N))*REAL(K-1)/REAL(KBRX)
            Y37X = YE(3,N) + (YE(7,N)-YE(3,N))*REAL(K-1)/REAL(KBRX)
            Y26X = YE(2,N) + (YE(6,N)-YE(2,N))*REAL(K-1)/REAL(KBRX)
            Y48X = YE(4,N) + (YE(8,N)-YE(4,N))*REAL(K-1)/REAL(KBRX)
            YLX = Y15X + (Y37X-Y15X)*REAL(J-1)/REAL(JBRX)
            YUX = Y26X + (Y48X-Y26X)*REAL(J-1)/REAL(JBRX)
            YE(1,NBRX) = YLX + (YUX-YLX)*REAL(I-1)/REAL(IBRX)
            YE(2,NBRX) = YLX + (YUX-YLX)*REAL(I)/REAL(IBRX)
            Z15X = ZE(1,N) + (ZE(5,N)-ZE(1,N))*REAL(K-1)/REAL(KBRX)
            Z37X = ZE(3,N) + (ZE(7,N)-ZE(3,N))*REAL(K-1)/REAL(KBRX)
            Z26X = ZE(2,N) + (ZE(6,N)-ZE(2,N))*REAL(K-1)/REAL(KBRX)
            Z48X = ZE(4,N) + (ZE(8,N)-ZE(4,N))*REAL(K-1)/REAL(KBRX)
            ZLX = Z15X + (Z37X-Z15X)*REAL(J-1)/REAL(JBRX)
            ZUX = Z26X + (Z48X-Z26X)*REAL(J-1)/REAL(JBRX)
            ZE(1,NBRX) = ZLX + (ZUX-ZLX)*REAL(I-1)/REAL(IBRX)
            ZE(2,NBRX) = ZLX + (ZUX-ZLX)*REAL(I)/REAL(IBRX)
!
!---        Vertices 3 and 4  ---
!
            XLX = X15X + (X37X-X15X)*REAL(J)/REAL(JBRX)
            XUX = X26X + (X48X-X26X)*REAL(J)/REAL(JBRX)
            XE(3,NBRX) = XLX + (XUX-XLX)*REAL(I-1)/REAL(IBRX)
            XE(4,NBRX) = XLX + (XUX-XLX)*REAL(I)/REAL(IBRX)
            YLX = Y15X + (Y37X-Y15X)*REAL(J)/REAL(JBRX)
            YUX = Y26X + (Y48X-Y26X)*REAL(J)/REAL(JBRX)
            YE(3,NBRX) = YLX + (YUX-YLX)*REAL(I-1)/REAL(IBRX)
            YE(4,NBRX) = YLX + (YUX-YLX)*REAL(I)/REAL(IBRX)
            ZLX = Z15X + (Z37X-Z15X)*REAL(J)/REAL(JBRX)
            ZUX = Z26X + (Z48X-Z26X)*REAL(J)/REAL(JBRX)
            ZE(3,NBRX) = ZLX + (ZUX-ZLX)*REAL(I-1)/REAL(IBRX)
            ZE(4,NBRX) = ZLX + (ZUX-ZLX)*REAL(I)/REAL(IBRX)
!
!---        Vertices 5 and 6  ---
!
            X15X = XE(1,N) + (XE(5,N)-XE(1,N))*REAL(K)/REAL(KBRX)
            X37X = XE(3,N) + (XE(7,N)-XE(3,N))*REAL(K)/REAL(KBRX)
            X26X = XE(2,N) + (XE(6,N)-XE(2,N))*REAL(K)/REAL(KBRX)
            X48X = XE(4,N) + (XE(8,N)-XE(4,N))*REAL(K)/REAL(KBRX)
            XLX = X15X + (X37X-X15X)*REAL(J-1)/REAL(JBRX)
            XUX = X26X + (X48X-X26X)*REAL(J-1)/REAL(JBRX)
            XE(5,NBRX) = XLX + (XUX-XLX)*REAL(I-1)/REAL(IBRX)
            XE(6,NBRX) = XLX + (XUX-XLX)*REAL(I)/REAL(IBRX)
            Y15X = YE(1,N) + (YE(5,N)-YE(1,N))*REAL(K)/REAL(KBRX)
            Y37X = YE(3,N) + (YE(7,N)-YE(3,N))*REAL(K)/REAL(KBRX)
            Y26X = YE(2,N) + (YE(6,N)-YE(2,N))*REAL(K)/REAL(KBRX)
            Y48X = YE(4,N) + (YE(8,N)-YE(4,N))*REAL(K)/REAL(KBRX)
            YLX = Y15X + (Y37X-Y15X)*REAL(J-1)/REAL(JBRX)
            YUX = Y26X + (Y48X-Y26X)*REAL(J-1)/REAL(JBRX)
            YE(5,NBRX) = YLX + (YUX-YLX)*REAL(I-1)/REAL(IBRX)
            YE(6,NBRX) = YLX + (YUX-YLX)*REAL(I)/REAL(IBRX)
            Z15X = ZE(1,N) + (ZE(5,N)-ZE(1,N))*REAL(K)/REAL(KBRX)
            Z37X = ZE(3,N) + (ZE(7,N)-ZE(3,N))*REAL(K)/REAL(KBRX)
            Z26X = ZE(2,N) + (ZE(6,N)-ZE(2,N))*REAL(K)/REAL(KBRX)
            Z48X = ZE(4,N) + (ZE(8,N)-ZE(4,N))*REAL(K)/REAL(KBRX)
            ZLX = Z15X + (Z37X-Z15X)*REAL(J-1)/REAL(JBRX)
            ZUX = Z26X + (Z48X-Z26X)*REAL(J-1)/REAL(JBRX)
            ZE(5,NBRX) = ZLX + (ZUX-ZLX)*REAL(I-1)/REAL(IBRX)
            ZE(6,NBRX) = ZLX + (ZUX-ZLX)*REAL(I)/REAL(IBRX)
!
!---        Vertices 7 and 8  ---
!
            XLX = X15X + (X37X-X15X)*REAL(J)/REAL(JBRX)
            XUX = X26X + (X48X-X26X)*REAL(J)/REAL(JBRX)
            XE(7,NBRX) = XLX + (XUX-XLX)*REAL(I-1)/REAL(IBRX)
            XE(8,NBRX) = XLX + (XUX-XLX)*REAL(I)/REAL(IBRX)
            YLX = Y15X + (Y37X-Y15X)*REAL(J)/REAL(JBRX)
            YUX = Y26X + (Y48X-Y26X)*REAL(J)/REAL(JBRX)
            YE(7,NBRX) = YLX + (YUX-YLX)*REAL(I-1)/REAL(IBRX)
            YE(8,NBRX) = YLX + (YUX-YLX)*REAL(I)/REAL(IBRX)
            ZLX = Z15X + (Z37X-Z15X)*REAL(J)/REAL(JBRX)
            ZUX = Z26X + (Z48X-Z26X)*REAL(J)/REAL(JBRX)
            ZE(7,NBRX) = ZLX + (ZUX-ZLX)*REAL(I-1)/REAL(IBRX)
            ZE(8,NBRX) = ZLX + (ZUX-ZLX)*REAL(I)/REAL(IBRX)
            NBRX = NBRX+1
          ENDDO
          ENDDO
          ENDDO
        ENDIF
  540 CONTINUE
!
!---  Include block refinement nodes in field node parameter  ---
!
      LFD = LFD + LBR
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_BR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Fill character string ADUM with characters between commas.
!     Return 'null' for null entries.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNNL, November 1992.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) ADUM
      CHARACTER*(*) CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_CHR'
      IDFLTD = 0
      ICD = INDEX( CARD,'  ')-1
      IVR = INDEX( VARB,'  ')-1
      NCH = INDEX( ADUM,'  ')-1
!
!---  End of card record error ---
!
      IF( CHDUM(1:1) .EQ. '~' ) THEN
        INDX = 4
        CHMSG = 'End of Card Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Find next comma  ---
!
      ICOMMA = INDEX (CHDUM(ISTART:), ',') + ISTART - 1
      ISTOP = ICOMMA
  100 CONTINUE
!
!---  Comma not found, missing character string data  ---
!
      IF( ISTOP.LT.ISTART ) THEN
        INDX = 4
        CHMSG = 'Missing Character-String Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
!
!---  Null entry  ---
!
      ELSEIF( ISTOP.EQ.ISTART ) THEN
        IF( IDFLT .EQ. 0 ) THEN
          ADUM = 'null'
          NCH = 4
          IDFLTD = 1
        ENDIF
        ISTART = ICOMMA + 1
        ICOMMA = ISTART
!
!---  Characters between commas  ---
!
      ELSE
!
!---  Eliminate leading blank spaces  ---
!
        IF( ICHAR(CHDUM(ISTART:ISTART)).EQ.32 ) THEN
          ISTART = ISTART+1
          GOTO 100
        ENDIF
!
!---  Eliminate trailing blank spaces  ---
!
        ISTOP = ISTOP-1
  110   CONTINUE
        IF( ICHAR(CHDUM(ISTOP:ISTOP)).EQ.32 ) THEN
          ISTOP = ISTOP-1
          GOTO 110
        ENDIF
!
!---  Translate character string into a character string  ---
!
        ADUM = ' '
        NCH = ISTOP-ISTART+1
        READ (CHDUM(ISTART:ISTOP), '(A)') ADUM(1:NCH)
        ISTART = ICOMMA + 1
      ENDIF
      IDFLT = 0
!
!---  End of RD_CHR group  ---
!
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_CNEQ
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read conservation equations for reactions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 9 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_CNEQ'
!
!---  Assign card string  ---
!
      CARD = 'Conservation Equations Card'
!
!---  Read number of conservation equations  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Conservation Equations'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NEQC)
      LEQC = MAX( LEQC,NEQC )
      LSPT = LSPT + LEQC
!
!---  Loop over the conservation equations  ---
!
      DO 100 NEQ = 1,NEQC
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Component Species Name: '
        CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
        VARB = 'Number of Species in Conservation Equation'
        CALL RD_INT( ISTART,ICOMMA,CHDUM,NSEC )
        LSEC = MAX( LSEC,NSEC )
!
!---    Loop over the conservation species allowing for
!       returns in the input  ---
!
        DO 90 NSP = 1,NSEC
          VARB = 'Conservation-Equation Species Name: '
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
          VARB = 'Conservation-Equation Species Coefficient: '
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
   90   CONTINUE
  100 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_CNEQ group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_CW
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Coupled Well Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 25 March 2011.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM
      CHARACTER*64 UNTS
      TYPE(LIST_INTERVAL), POINTER :: IN_TMP_PTR
      TYPE(LIST_TRANSITION), POINTER :: TP_TMP_PTR
      TYPE(LIST_NODE), POINTER :: LOC_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_CW'
!
!---  Assign card string  ---
!
      CARD = 'Coupled Well Card'
      L_CW = 1
!
!---  Read number of wells  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Coupled Wells'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,N_CW)
      LN_CW = MAX( LN_CW,N_CW )
!
!---  Loop over number of coupled wells  ---
!
      NIT_CW = 0
      NULLIFY( IN_CW_PTR )
      NULLIFY( TP_CW_PTR )
      DO 500 NCW = 1,N_CW
!
!---    Read well type  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Coupled Well Type'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---    Check for STOMP-EOR or STOMP-CO2 or STOMP-CO2E  ---
!
        IT_CWX = 0
        IF( IOM.EQ.43 .OR. IOM.EQ.32 .OR. IOM.EQ.33 ) THEN
          IF( IOM.EQ.43 ) THEN
            IT_CWX = 1
            IF( INDEX(ADUM(1:),'production').NE.0 ) IT_CWX = -1
          ENDIF
          IF( IOM.EQ.32 .AND. INDEX(ADUM(1:),'alter').NE.0 ) IT_CWX = 1
          IF( IOM.EQ.33 .AND. INDEX(ADUM(1:),'alter').NE.0 ) IT_CWX = 1
          IF( IOM.EQ.32 .OR. IOM.EQ.33 ) THEN
            IF( INDEX(ADUM(1:),'co2').NE.0 .AND.
     &        INDEX(ADUM(1:),'injection').NE.0 ) THEN
              VARB = 'Water-Vapor Fraction'
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ELSEIF( INDEX(ADUM(1:),'aqueous').NE.0 .AND.
     &        INDEX(ADUM(1:),'injection').NE.0 ) THEN
              VARB = 'Dissolved-CO2 Option'
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
              VARB = 'Dissolved-Salt Option'
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ENDIF
          ENDIF
          VARB = 'X-Well Fraction Factor'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          VARB = 'Y-Well Fraction Factor'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          VARB = 'Z-Well Fraction Factor'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      For STOMP-CO2 or STOMP-CO2E read total injection limit
!         and units  ---
!
          IF( IOM.EQ.32 .OR. IOM.EQ.33 ) THEN          
            VARB = 'Total Injection Limit'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          ENDIF
!
!---      Check for solutes or species  ---
!
          IF( LC.NE.0 .OR. LR.NE.0 ) THEN
            NC_SOLU = 0
            NC_SPC = 0
            DO
!
!---          Check for solute names or well name  ---
!
              CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
              IF( INDX.EQ.0 ) EXIT
!
!---          Check for solute or species names  ---
!
              ADUM(1:) = ' '
              VARB = 'Solute or Species Name'
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
              IFIND = 0
              LOC_PTR => SOLUT_PTR
              DO
                IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
!
!---            Solute name found  ---
!
                IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                  NC_SOLU = NC_SOLU + 1
                  IFIND = 1
                  EXIT
                ENDIF
                LOC_PTR => LOC_PTR%NEXT
              ENDDO
              LOC_PTR => SPCL_PTR
              DO
                IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
!
!---            Aqueous species name found  ---
!
                IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                  NC_SPC = NC_SPC + 1
                  IFIND = 1
                  EXIT
                ENDIF
!
!---            pH found  ---
!
                IF( 'ph' == ADUM(1:NCH) ) THEN
                  NC_SPC = NC_SPC + 1
                  IFIND = 1
                  EXIT
                ENDIF
                LOC_PTR => LOC_PTR%NEXT
              ENDDO
              LOC_PTR => SPCG_PTR
              DO
                IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
!
!---            Gas species name found  ---
!
                IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                  NC_SPC = NC_SPC + 1
                  IFIND = 1
                  EXIT
                ENDIF
                LOC_PTR => LOC_PTR%NEXT
              ENDDO
              IF( IFIND.EQ.0 ) EXIT
            ENDDO
            LSOLU_CW = MAX( LSOLU_CW,NC_SOLU )
            LSPC_CW = MAX( LSPC_CW,NC_SPC )
          ENDIF
        ENDIF
!
!---    Read number of well intervals  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Number of Well Intervals'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NI_CW)
        NIT_CW = NIT_CW + NI_CW
        LWI_CW = MAX( NIT_CW,LWI_CW )
!
!---    Allocate memory for new well interval element  ---
!
        ALLOCATE( IN_TMP_PTR,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IN_TMP_PTR'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Assign well transition pointers  ---
!
        IF( NCW.EQ.1 ) THEN
          IN_TMP_PTR%ID1_CW = 1
        ELSE
          IN_TMP_PTR%ID1_CW = NIT_CW - NI_CW + 1
        ENDIF
        IN_TMP_PTR%ID2_CW = IN_TMP_PTR%ID1_CW + NI_CW - 1
        IN_TMP_PTR%NEXT => IN_CW_PTR
        IN_CW_PTR => IN_TMP_PTR
!
!---    Loop over number of well intervals  ---
!
        DO 100 NICW = 1,NI_CW
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
!
!---      Read first x-transition point  ---
!
          VARB = 'Interval First X-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP1_CWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,XTP1_CWX,INDX)
!
!---      Read first y-transition point  ---
!
          VARB = 'Interval First Y-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP1_CWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,YTP1_CWX,INDX)
!
!---      Cylindrical coordinates with azimuthal symmetry  ---
!
          IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
            IF( ABS(XTP1_CWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval First X-Transition Point ' // 
     &          'for Radially Symmetric Domain: XTP_CW ='
              RLMSG = XTP1_CWX
              CALL WRMSGP( INDX )
            ENDIF
            IF( ABS(YTP1_CWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval First Y-Transition Point ' // 
     &          'for Radially Symmetric Domain: YTP_CW ='
              RLMSG = YTP1_CWX
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
!
!---      Read first z-transition point  ---
!
          VARB = 'Interval First Z-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP1_CWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,ZTP1_CWX,INDX)
!
!---      Read second x-transition point  ---
!
          VARB = 'Interval Second X-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP2_CWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,XTP2_CWX,INDX)
!
!---      Read second y-transition point  ---
!
          VARB = 'Interval Second Y-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP2_CWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,YTP2_CWX,INDX)
!
!---      Cylindrical coordinates with azimuthal symmetry  ---
!
          IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
            IF( ABS(XTP2_CWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval Second X-Transition Point ' // 
     &          'for Radially Symmetric Domain: XTP_CW ='
              RLMSG = XTP2_CWX
              CALL WRMSGP( INDX )
            ENDIF
            IF( ABS(YTP2_CWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval Second Y-Transition Point ' // 
     &          'for Radially Symmetric Domain: YTP_CW ='
              RLMSG = YTP2_CWX
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
!
!---      Read second z-transition point  ---
!
          VARB = 'Interval Second Z-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP2_CWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,ZTP2_CWX,INDX)
!
!---      Allocate memory for new transition point element  ---
!
          ALLOCATE( TP_TMP_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: TP_TMP_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          TP_TMP_PTR%XTP1_CW = XTP1_CWX
          TP_TMP_PTR%YTP1_CW = YTP1_CWX
          TP_TMP_PTR%ZTP1_CW = ZTP1_CWX
          TP_TMP_PTR%XTP2_CW = XTP2_CWX
          TP_TMP_PTR%YTP2_CW = YTP2_CWX
          TP_TMP_PTR%ZTP2_CW = ZTP2_CWX
          TP_TMP_PTR%PAR3_CW = 0.D+0
          TP_TMP_PTR%NEXT => TP_CW_PTR
          TP_CW_PTR => TP_TMP_PTR
  100   CONTINUE
!
!---    Read number of well times or well time periods  ---
!
        IF( IT_CWX.EQ.1 ) THEN
          VARB = 'Number of Well Time Periods'
        ELSE
          VARB = 'Number of Well Times'
        ENDIF
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IM_CWX)
!
!---    STOMP-EOR injection well, 
!       STOMP-CO2 alternating state injection well, or
!       STOMP-CO2E alternating state injection well, 
!       loop over the number of well time periods, and well times  ---
!
        IF( IT_CWX.EQ.1 ) THEN
          LWTP_CW = MAX( LWTP_CW,IM_CWX )
!
!---      Loop over number of well time periods  ---
!
          NC = 0
          DO 210 M = 1,IM_CWX
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
            CALL RD_INT(ISTART,ICOMMA,CHDUM,IMP_CWX)
            NC = NC + IMP_CWX
!
!---        Loop over number of well times  ---
!
            DO 200 MX = 1,IMP_CWX
              CALL RD_INPL( CHDUM )
  200       CONTINUE
  210     CONTINUE
          LWT_CW = MAX( LWT_CW,NC )
        ELSE
          LWTP_CW = MAX( LWTP_CW,IM_CWX )
          LWT_CW = MAX( LWT_CW,IM_CWX )
!
!---      Loop over number of well times  ---
!
          DO 300 M = 1,IM_CWX
            CALL RD_INPL( CHDUM )
  300     CONTINUE
        ENDIF
  500 CONTINUE
!
!---  Allocate memory for coupled-well interval/node index array  ---
!
      ALLOCATE( ID_CW(1:7,1:LN_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ID_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load coupled-well interval/node index array  ---
!
      IN_TMP_PTR => IN_CW_PTR
      DO 510 NCW = 1,N_CW
        M = N_CW-NCW+1
        ID_CW(1,M) = IN_TMP_PTR%ID1_CW
        ID_CW(2,M) = IN_TMP_PTR%ID2_CW
        IN_TMP_PTR => IN_TMP_PTR%NEXT
  510 CONTINUE
!
!---  Allocate memory for x-transition points array  ---
!
      ALLOCATE( XTP_CW(1:2,1:LWI_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XTP_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for y-transition points array  ---
!
      ALLOCATE( YTP_CW(1:2,1:LWI_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YTP_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for z-transition points array  ---
!
      ALLOCATE( ZTP_CW(1:2,1:LWI_CW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZTP_CW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load x-, y-, and z-transition point arrays  ---
!
      TP_TMP_PTR => TP_CW_PTR
      DO 520 NICW = 1,LWI_CW
        M = LWI_CW-NICW+1
        XTP_CW(1,M) = TP_TMP_PTR%XTP1_CW
        XTP_CW(2,M) = TP_TMP_PTR%XTP2_CW
        YTP_CW(1,M) = TP_TMP_PTR%YTP1_CW
        YTP_CW(2,M) = TP_TMP_PTR%YTP2_CW
        ZTP_CW(1,M) = TP_TMP_PTR%ZTP1_CW
        ZTP_CW(2,M) = TP_TMP_PTR%ZTP2_CW
        VARX = TP_TMP_PTR%PAR3_CW
        TP_TMP_PTR => TP_TMP_PTR%NEXT
  520 CONTINUE
!
!---  Number and location of coupled well nodes  ---
!
      CALL CHK_CW
      LWN_CW = MAX( LWN_CW,1 )
      LWF_CW = MAX( LWF_CW,1 )
!
!---  Maximum number of well equation unknowns  ---
!
      LUKX = 2*LUK
      DO 530 NCW = 1,N_CW
        LUK_CW = MAX( LUK_CW,(LUKX*(ABS(ID_CW(6,NCW)-ID_CW(5,NCW))+1)) )
  530 CONTINUE
      LUK_CW = LUK_CW + 1
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_CW group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_DPR( ISTART,ICOMMA,CHDUM,VAR )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Fill double precision variable VAR with data between commas.
!     Return default value or zero for null entries.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, November 1992.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) CHDUM
      CHARACTER*6 FORM1
      CHARACTER*7 FORM2
!
!----------------------Data Statements---------------------------------!
!
      SAVE FORM1,FORM2
      DATA FORM1 /'(D .0)'/
      DATA FORM2 /'(D  .0)'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_DPR'
      IDFLTD = 0
      ICD = INDEX( CARD,'  ')-1
      IVR = INDEX( VARB,'  ')-1
!
!---  End of card record error ---
!
      IF( CHDUM(1:1) .EQ. '~' ) THEN
        INDX = 4
        CHMSG = 'End of Card Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Find next comma  ---
!
      ICOMMA = INDEX (CHDUM(ISTART:), ',') + ISTART - 1
      ISTOP = ICOMMA
  100 CONTINUE
!
!---  Comma not found, missing real data  ---
!
      IF( ISTOP.LT.ISTART ) THEN
        INDX = 4
        CHMSG = 'Missing Real Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
!
!---  Null entry  ---
!
      ELSEIF( ISTOP.EQ.ISTART ) THEN
        IF( IDFLT .EQ. 0 ) THEN
          VAR = 0.D+0
          IDFLTD = 1
        ENDIF
        ISTART = ICOMMA + 1
        ICOMMA = ISTART
!
!---  Characters between commas  ---
!
      ELSE
!
!---  Eliminate leading blank spaces  ---
!
        IF( ICHAR(CHDUM(ISTART:ISTART)).EQ.32 ) THEN
          ISTART = ISTART+1
          GOTO 100
        ENDIF
!
!---  Eliminate trailing blank spaces  ---
!
        ISTOP = ISTOP-1
  110   CONTINUE
        IF( ICHAR(CHDUM(ISTOP:ISTOP)).EQ.32 ) THEN
          ISTOP = ISTOP-1
          GOTO 110
        ENDIF
!
!---  Check for scientific notation  ---
!
        IEXP = ISTART-1
        IF( INDEX( CHDUM(ISTART:ISTOP),'e' ).NE.0 ) THEN
          IEXP = INDEX( CHDUM(ISTART:ISTOP),'e' )+ISTART-1
        ELSEIF( INDEX( CHDUM(ISTART:ISTOP),'d' ).NE.0 ) THEN
          IEXP = INDEX( CHDUM(ISTART:ISTOP),'d' )+ISTART-1
        ENDIF
        IPER = INDEX( CHDUM(ISTART:ISTOP),'.' )+ISTART-1
!
!---  Check for non-numerical characters  ---
!
        DO 120 N = ISTART,ISTOP
          IF( N.EQ.IEXP .OR. N.EQ.IPER ) GOTO 120
          NC = ICHAR(CHDUM(N:N))
          IF( ( N.EQ.ISTART .OR. N.EQ.IEXP+1 ) .AND.
     &      ( NC.EQ.43 .OR. NC.EQ.45 ) ) GOTO 120
          IF( NC.LT.48 .OR. NC.GT.57 ) THEN
            INDX = 4
            CHMSG = 'Real Format: Nonnumeric Character: ' //
     &        VARB(1:IVR) // ': ' // CHDUM(ISTART:ISTOP)
            CALL WRMSGP(INDX)
          ENDIF
  120   CONTINUE
!
!---  Translate character string into a double precision real  ---
!
        NCHR = ISTOP-ISTART+1
        IF( NCHR .LT. 10 ) THEN
          WRITE( FORM1(3:3), '(I1)' ) NCHR
          READ (CHDUM(ISTART:ISTOP), FORM1 ) VAR
        ELSEIF( NCHR .LT. 100 ) THEN
          WRITE( FORM2(3:4), '(I2)' ) NCHR
          READ (CHDUM(ISTART:ISTOP), FORM2 ) VAR
        ELSE
          INDX = 4
          CHMSG = 'Excessive Length Real Record: ' //
     &      VARB(1:IVR) // ': ' // CHDUM(ISTART:ISTOP)
          CALL WRMSGP( INDX )
        ENDIF
        ISTART = ICOMMA + 1
      ENDIF
      IDFLT = 0
!
!---  End of RD_DPR group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_ECLGRID
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read ECLIPSE formatted grids.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 30 November 2011.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:,:), ALLOCATABLE :: XX,YX,ZX
      REAL*8, DIMENSION(:), ALLOCATABLE :: XPETX
      REAL*8, DIMENSION(:), ALLOCATABLE :: ZCORNX
      CHARACTER*64 BDUM,BMDUM,FDUM,FMDUM,UNTS
      CHARACTER*512 BHDUM,CHDUM
      INTEGER ICX(2,2,2)
      LOGICAL BCHK,FCHK
!
!----------------------Data Statements---------------------------------!
!
      SAVE ICX
      DATA ICX / 8,7,6,5,4,3,2,1 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_ECLGRID'
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( XX(1:8,1:LFY+1),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( YX(1:8,1:LFY+1),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( ZX(1:8,1:LFY+1),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( XPETX(1:(LFX+1)*(LFY+1)*6),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XPETX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( ZCORNX(1:LFX*LFY*LFZ*8),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZCORNX'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read Eclipse file name  ---
!
      IFILE = 9
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Generic Eclipse File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing Generic Eclipse File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'Generic Eclipse File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
      INDX = 0
      DZMINX = 0.D+0
      VARB = 'Minimum Z Grid Spacing'
      CALL RD_DPR(ISTART,ICOMMA,CHDUM,DZMINX)
      VARB = 'Minimum Z Grid Spacing Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      IUNM = 1
      CALL RD_UNIT( UNTS,DZMINX,INDX )
!!
!!---  Search file for Petrel version number---
!!
!      IPET = 0
!  100 READ(9,'(A)',END=110) CHDUM   
!      CALL L_CASE( CHDUM )
!      IF( INDEX(CHDUM(1:),'-- exported').NE.0 ) THEN
!        IF( INDEX(CHDUM(25:),'2013').NE.0 ) THEN
!          IPET=2013
!        ELSEIF( INDEX(CHDUM(25:),'2011').NE.0 ) THEN
!          IPET=2011
!        ELSE
!          IPET=2009
!        ENDIF
!        GOTO 120
!      ELSE
!        GOTO 100
!      ENDIF
!  110 CONTINUE
!!
!!---  Petrel Version number not found  ---
!!
!      INDX = 18
!      CHMSG = 'Missing Petrel Version Number'
!      CALL WRMSGP( INDX )
!  120 CONTINUE
!
!
!---  Search file for key word "GRIDUNIT"  ---
!
  130 READ(9,'(A)',END=140) CHDUM   
      CALL L_CASE( CHDUM )
      IF( INDEX(CHDUM(1:),'gridunit').NE.0 ) THEN
        GOTO 150
      ELSE
        GOTO 130
      ENDIF
  140 CONTINUE
!
!---  Key word "GRIDUNIT" not found  ---
!
      INDX = 18
      CHMSG = 'Missing Grid Units'
      CALL WRMSGP( INDX )
  150 CONTINUE
!
!---  Read number of grid units  ---
!
      READ(9,'(A)') CHDUM
      CALL L_CASE( CHDUM )
      VARX = 1.D+0
      IF( INDEX(CHDUM(1:),'metres').NE.0 ) THEN
        INDX = 0
        IUNM = 1
        UNTS = 'm'
        CALL RD_UNIT(UNTS,VARX,INDX)
      ELSEIF( INDEX(CHDUM(1:),'feet').NE.0 ) THEN
        INDX = 0
        IUNM = 1
        UNTS = 'ft'
        CALL RD_UNIT(UNTS,VARX,INDX)
      ELSEIF( INDEX(CHDUM(1:),'nm').NE.0 ) THEN
        INDX = 0
        IUNM = 1
        UNTS = 'nm'
        CALL RD_UNIT(UNTS,VARX,INDX)
      ENDIF
!
!---  Search file for key word "SPECGRID"  ---
!
  160 READ(9,'(A)',END=170) CHDUM   
      CALL L_CASE( CHDUM )
      IF( INDEX(CHDUM(1:),'specgrid').NE.0 ) THEN
        GOTO 180
      ELSE
        GOTO 160
      ENDIF
  170 CONTINUE
!
!---  Key word "SPECGRID" not found  ---
!
      INDX = 18
      CHMSG = 'Missing Grid Specification'
      CALL WRMSGP( INDX )
  180 CONTINUE
!
!---  Read number of grid cells in each direction  ---
!
      READ(9,*) IFLDX,JFLDX,KFLDX
!
!---  Check grid dimensions against STOMP input  ---
!
      IF( IFLDX.NE.LFX .OR. JFLDX.NE.LFY .OR. KFLDX.NE.LFZ ) THEN
        INDX = 4
        CHMSG = 'STOMP-ECLIPSE Grid Conflict'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Search file for key word "COORD"  ---
!
  190 READ(9,'(A)', END=200) CHDUM   
      CALL L_CASE( CHDUM )
!
!---  Key word "COORD" found in main file  ---
!
      IF( INDEX(CHDUM(1:),'coord').NE.0 .AND.
     &  INDEX(CHDUM(1:),'coordsys').EQ.0 ) THEN
        GOTO 210
!
!---  Search for key word "COORD" found in include file  ---
!
      ELSEIF( INDEX(CHDUM(1:),'include').NE.0 ) THEN
        READ(9,'(A)',END=200) CHDUM
        ISTX = INDEX( CHDUM(1:),'''' )
        ISTX = ISTX + 1
        ISPX = INDEX( CHDUM(ISTX:),'''' ) + ISTX - 1
        BDUM = ' '
        ISPX = ISPX - 1
        NCH = ISPX-ISTX+1
        IF( NCH.LT.1 ) THEN
          INDX = 4
          CHMSG = 'Unrecognized File Name after INCLUDE'
          CALL WRMSGP( INDX )
        ENDIF
        READ(CHDUM(ISTX:ISPX),'(A)') BDUM(1:NCH)
        INQUIRE( FILE=BDUM(1:NCH), FORM=BMDUM, EXIST=BCHK )
        IF( .NOT.BCHK ) THEN
          INDX = 4
          CHMSG = 'Missing Include File: ' // BDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        OPEN( UNIT=10,FILE=BDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
        REWIND( UNIT=10 )
  192   READ(10,'(A)',END=200) BHDUM
        CALL L_CASE( BHDUM )
!
!---    Skip header information in include file  ---
!
        IF( INDEX(BHDUM(1:2),'--').NE.0 ) THEN
          GOTO 192
!
!---    Key word "COORD" found in include file  ---
!
        ELSEIF( INDEX(BHDUM(1:),'coord').NE.0 .AND.
     &    INDEX(BHDUM(1:),'coordsys').EQ.0 ) THEN
          IFILE = 10
          GOTO 210
        ELSEIF( SCAN(BHDUM(1:),'0123456789').NE.0 ) THEN 
          CLOSE( UNIT=10 )
          IFILE = 9
        ELSE
          GOTO 192
        ENDIF
      ELSE
        GOTO 190
      ENDIF
  200 CONTINUE
!
!---  Key word "COORD" not found  ---
!
      INDX = 18
      CHMSG = 'Missing Coordinate Data'
      CALL WRMSGP( INDX )
  210 CONTINUE
!
!---  For Petrel 2009/2011 read all coordinates into array and assign 
!     to X and Y and convert coordinates to meters
!
      NCORX = (IFLDX+1)*(JFLDX+1)*6
      READ(IFILE,*,END=212) (XPETX(L),L=1,NCORX)
!
!---  Close include file  ---
!
      IF( IFILE.EQ.10 ) THEN
        CLOSE( UNIT=10 )
        IFILE = 9
      ENDIF
      GOTO 214
!
!---  End-of-file error for Generic Eclipse File ---
!
  212 CONTINUE
      INDX = 18
      CHMSG = 'Generic Eclipse EOF: COORD'
      CALL WRMSGP( INDX )
!
!---  File read completed for Generic Eclipse File ---
!
  214 CONTINUE
      DO 224 K = 1,LFZ
        DO 222 J = 1,LFY
          DO 220 I = 1,LFX
            N = ND(I,J,K)
!
!---        Points 1 and 5  ---
!
            IX = I
            JX = J
            L = (JX-1)*(IFLDX+1)*6 + (IX-1)*6
            XE(1,N) = XPETX(L+1)*VARX
            YE(1,N) = XPETX(L+2)*VARX
            XE(5,N) = XPETX(L+1)*VARX
            YE(5,N) = XPETX(L+2)*VARX
            ZTX = -XPETX(L+3)*VARX
            ZBX = -XPETX(L+6)*VARX
            IF( ZBX.GT.ZTX ) THEN
              INDX = 7
              IMSG = (J-1)*(LFX+1) + I
              CHMSG = 'STOMP-ECLIPSE Grid Reversal: COORD Line'
              CALL WRMSGP( INDX )
            ENDIF                 
!
!---        Points 2 and 6  ---
!
            IX = I+1
            JX = J
            L = (JX-1)*(IFLDX+1)*6 + (IX-1)*6
            XE(2,N) = XPETX(L+1)*VARX
            YE(2,N) = XPETX(L+2)*VARX
            XE(6,N) = XPETX(L+1)*VARX
            YE(6,N) = XPETX(L+2)*VARX
            ZTX = -XPETX(L+3)*VARX
            ZBX = -XPETX(L+6)*VARX
            IF( ZBX.GT.ZTX ) THEN
              INDX = 7
              IMSG = (J-1)*(LFX+1) + I
              CHMSG = 'STOMP-ECLIPSE Grid Reversal: COORD Line'
              CALL WRMSGP( INDX )
            ENDIF                 
!
!---        Points 3 and 7  ---
!
            IX = I
            JX = J+1
            L = (JX-1)*(IFLDX+1)*6 + (IX-1)*6
            XE(3,N) = XPETX(L+1)*VARX
            YE(3,N) = XPETX(L+2)*VARX
            XE(7,N) = XPETX(L+1)*VARX
            YE(7,N) = XPETX(L+2)*VARX
            ZTX = -XPETX(L+3)*VARX
            ZBX = -XPETX(L+6)*VARX
            IF( ZBX.GT.ZTX ) THEN
              INDX = 7
              IMSG = (J-1)*(LFX+1) + I
              CHMSG = 'STOMP-ECLIPSE Grid Reversal: COORD Line'
              CALL WRMSGP( INDX )
            ENDIF                 
!
!---        Points 4 and 8  ---
!
            IX = I+1
            JX = J+1
            L = (JX-1)*(IFLDX+1)*6 + (IX-1)*6
            XE(4,N) = XPETX(L+1)*VARX
            YE(4,N) = XPETX(L+2)*VARX
            XE(8,N) = XPETX(L+1)*VARX
            YE(8,N) = XPETX(L+2)*VARX
            ZTX = -XPETX(L+3)*VARX
            ZBX = -XPETX(L+6)*VARX
            IF( ZBX.GT.ZTX ) THEN
              INDX = 7
              IMSG = (J-1)*(LFX+1) + I
              CHMSG = 'STOMP-ECLIPSE Grid Reversal: COORD Line'
              CALL WRMSGP( INDX )
            ENDIF                 
  220     CONTINUE
  222   CONTINUE
  224 CONTINUE
!
!---  Search file for key word "ZCORN"  ---
!
  290 READ(9,'(A)',END=300) CHDUM   
      CALL L_CASE( CHDUM )
!
!---  Key word "ZCORN" found in main file  ---
!
      IF( INDEX(CHDUM(1:),'zcorn').NE.0 ) THEN
        GOTO 310
!
!---  Search for key word "ZCORN" found in include file  ---
!
      ELSEIF( INDEX(CHDUM(1:),'include').NE.0 ) THEN
        READ(9,'(A)',END=200) CHDUM
        ISTX = INDEX( CHDUM(1:),'''' )
        ISTX = ISTX + 1
        ISPX = INDEX( CHDUM(ISTX:),'''' ) + ISTX - 1
        BDUM = ' '
        ISPX = ISPX - 1
        NCH = ISPX-ISTX+1
        IF( NCH.LT.1 ) THEN
          INDX = 4
          CHMSG = 'Unrecognized File Name after INCLUDE'
          CALL WRMSGP( INDX )
        ENDIF
        READ(CHDUM(ISTX:ISPX),'(A)') BDUM(1:NCH)
        INQUIRE( FILE=BDUM(1:NCH), FORM=BMDUM, EXIST=BCHK )
        IF( .NOT.BCHK ) THEN
          INDX = 4
          CHMSG = 'Missing Include File: ' // BDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        OPEN( UNIT=10,FILE=BDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
        REWIND( UNIT=10 )
  292   READ(10,'(A)',END=200) BHDUM
        CALL L_CASE( BHDUM )
!
!---    Skip header information in include file  ---
!
        IF( INDEX(BHDUM(1:2),'--').NE.0 ) THEN
          GOTO 292
!
!---    Key word "ZCORN" found in include file  ---
!
        ELSEIF( INDEX(BHDUM(1:),'zcorn').NE.0 ) THEN
          IFILE = 10
          GOTO 310
        ELSEIF( SCAN(BHDUM(1:),'0123456789').NE.0 ) THEN 
          CLOSE( UNIT=10 )
          IFILE = 9
        ELSE
          GOTO 292
        ENDIF
      ELSE
        GOTO 290
      ENDIF
  300 CONTINUE
!
!---  Key word "ZCORN" not found  ---
!
      INDX = 18
      CHMSG = 'Missing Z-Corner Data'
      CALL WRMSGP( INDX )
  310 CONTINUE
!
!---  Loop over the z corner data for Petrel version 2011 ---
!
      NCORN = LFX*LFY*LFZ*8
      READ(IFILE,*,END=312) ZCORNX(1:NCORN)
!
!---  Close include file  ---
!
      IF( IFILE.EQ.10 ) THEN
        CLOSE( UNIT=10 )
        IFILE = 9
      ENDIF
      GOTO 314
!
!---  End-of-file error for Generic Eclipse File ---
!
  312 CONTINUE
      INDX = 18
      CHMSG = 'Generic Eclipse EOF: ZCORN'
      CALL WRMSGP( INDX )
  314 CONTINUE
      NX = 0
!
!---  Loop from the top tier down  ---
!
      DO 340 K = LFZ,1,-1
!
!---    Upper ZE values  ---
!
        DO 324 J = 1,LFY
          DO 320 I = 1,LFX
            N = ND(I,J,K)
            NX = NX + 1
            ZE(5,N) = -ZCORNX(NX)*VARX
            NX = NX + 1
            ZE(6,N) = -ZCORNX(NX)*VARX
  320     CONTINUE
          DO 322 I = 1,LFX
            N = ND(I,J,K)
            NX = NX + 1
            ZE(7,N) = -ZCORNX(NX)*VARX
            NX = NX + 1
            ZE(8,N) = -ZCORNX(NX)*VARX
  322     CONTINUE
  324   CONTINUE
!
!---    Lower ZE values  ---
!
        DO 334 J = 1,LFY
          DO 330 I = 1,LFX
            N = ND(I,J,K)
            NX = NX + 1
            ZE(1,N) = -ZCORNX(NX)*VARX
            NX = NX + 1
            ZE(2,N) = -ZCORNX(NX)*VARX
  330     CONTINUE
          DO 332 I = 1,LFX
            N = ND(I,J,K)
            NX = NX + 1
            ZE(3,N) = -ZCORNX(NX)*VARX
            NX = NX + 1
            ZE(4,N) = -ZCORNX(NX)*VARX
  332     CONTINUE
  334   CONTINUE
  340 CONTINUE
!
!---  Set minimum z grid spacing, honoring the top
!     surface  ---
!
      DO 430 J = 1,LFY
        DO 420 I = 1,LFX
!
!---      Loop over four vertical corners of the hexahedral node  ---
!
          DO 410 M = 1,4
!
!---        Loop over nodes vertically top to bottom  ---
!
            DO 402 K = LFZ,1,-1
              N = ND(I,J,K)
              DZX = ZE(M+4,N)-ZE(M,N)
!
!---          Spacing of vertical corner < than specified minimum  ---
!
              IF( DZX.LT.DZMINX ) THEN
!
!---            Push lower vertices downward  ---
!
                ZE(M,N) = ZE(M,N) - DZMINX
                IF( K.GT.1 ) THEN
                  DO 400 KX = K-1,1,-1
                    NX = ND(I,J,KX)
                    ZE(M+4,NX) = ZE(M+4,NX) - DZMINX
                    ZE(M,NX) = ZE(M,NX) - DZMINX
  400             CONTINUE
                ENDIF
              ENDIF
  402       CONTINUE
  410     CONTINUE
  420   CONTINUE
  430 CONTINUE
!
!---  Transpose y grid  ---
!
      DO 470 K = 1,LFZ
        DO 460 I = 1,LFX
          DO 440 J = 1,LFY
            N = ND(I,J,K)
            DO 432 M = 1,8
              XX(M,J) = XE(M,N)
              YX(M,J) = YE(M,N)
              ZX(M,J) = ZE(M,N)
  432       CONTINUE
  440     CONTINUE
          DO 450 J = 1,LFY
            JX = LFY-J+1
            N = ND(I,J,K)
            XE(1,N) = XX(3,JX)
            YE(1,N) = YX(3,JX)
            ZE(1,N) = ZX(3,JX) 
            XE(2,N) = XX(4,JX)
            YE(2,N) = YX(4,JX)
            ZE(2,N) = ZX(4,JX) 
            XE(3,N) = XX(1,JX)
            YE(3,N) = YX(1,JX)
            ZE(3,N) = ZX(1,JX) 
            XE(4,N) = XX(2,JX)
            YE(4,N) = YX(2,JX)
            ZE(4,N) = ZX(2,JX) 
            XE(5,N) = XX(7,JX)
            YE(5,N) = YX(7,JX)
            ZE(5,N) = ZX(7,JX) 
            XE(6,N) = XX(8,JX)
            YE(6,N) = YX(8,JX)
            ZE(6,N) = ZX(8,JX) 
            XE(7,N) = XX(5,JX)
            YE(7,N) = YX(5,JX)
            ZE(7,N) = ZX(5,JX) 
            XE(8,N) = XX(6,JX)
            YE(8,N) = YX(6,JX)
            ZE(8,N) = ZX(6,JX) 
  450     CONTINUE
  460   CONTINUE
  470 CONTINUE
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(XX) ) THEN
        DEALLOCATE( XX,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XX'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(YX) ) THEN
        DEALLOCATE( YX,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: YX'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(ZX) ) THEN
        DEALLOCATE( ZX,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: ZX'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
      IF( ALLOCATED(XPETX) ) THEN
        DEALLOCATE( XPETX,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Deallocation Error: XPETX'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Close Generic Eclipse File   ---
!
      CLOSE( UNIT=9 )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_ECLGRID group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_ELMGRID
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read grid elements and vertices.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 1 December 2011.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 VDX(8),VARX(3)
      REAL*8, DIMENSION(:,:), ALLOCATABLE :: VX
      INTEGER IVX(8),JVX(8)
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      LOGICAL FCHK
!
!----------------------Data Statements---------------------------------!
!
      SAVE JVX
      DATA JVX / 1,2,4,3,5,6,8,7 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_ELMGRID'
!
!---  Read external vertices file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'External Vertices File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing Vertices File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'Vertices File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Number of vertices  ---
!
      VARB = 'Number of Vertices'
      CALL RD_INT( ISTART,ICOMMA,CHDUM,NVX )
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VX(1:3,1:NVX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VX'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read vertice units  ---
!
      ISTART = 1
      READ(9,'(A)') CHDUM
      CALL L_CASE( CHDUM )
      ISTART = INDEX( CHDUM(ISTART:), 'x[' ) + ISTART + 1
      ICOMMA = INDEX( CHDUM(ISTART:), ']' ) + ISTART - 1
      UNTS = ' '
      NCH = ICOMMA-ISTART
      ISTOP = ICOMMA-1
      READ (CHDUM(ISTART:ISTOP), '(A)') UNTS(1:NCH)
      INDX = 0
      VARX(1) = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX(1),INDX)
      ISTART = ICOMMA + 1
      ISTART = INDEX( CHDUM(ISTART:), 'y[' ) + ISTART + 1
      ICOMMA = INDEX( CHDUM(ISTART:), ']' ) + ISTART - 1
      UNTS = ' '
      NCH = ICOMMA-ISTART
      ISTOP = ICOMMA-1
      READ (CHDUM(ISTART:ISTOP), '(A)') UNTS(1:NCH)
      INDX = 0
      VARX(2) = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX(2),INDX)
      ISTART = ICOMMA + 1
      ISTART = INDEX( CHDUM(ISTART:), 'z[' ) + ISTART + 1
      ICOMMA = INDEX( CHDUM(ISTART:), ']' ) + ISTART - 1
      UNTS = ' '
      NCH = ICOMMA-ISTART
      ISTOP = ICOMMA-1
      READ (CHDUM(ISTART:ISTOP), '(A)') UNTS(1:NCH)
      INDX = 0
      VARX(3) = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX(3),INDX)
!
!---  Read vertices  ---
!
      DO 100 NX = 1,NVX
        READ(9,*) N,(VDX(M),M=1,3)
        IF( N.GT.NVX ) THEN
          INDX = 4
          CHMSG = 'Mismatch between Input File and Vertices File: '
     &      // FDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        DO 10 M = 1,3
          VX(M,N) = VDX(M)
   10   CONTINUE
  100 CONTINUE
!
!---  Close vertices file   ---
!
      CLOSE( UNIT=9 )
!
!---  Read external elements file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'External Elements File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing Elements File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'Elements File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Assign vertices  ---
!
      DO 200 NX = 1,LFD
        READ(9,*) N,(IVX(M),M=1,8)
        DO 110 M = 1,8
          XE(M,N) = VX(1,IVX(M))*VARX(1)
          YE(M,N) = VX(2,IVX(M))*VARX(2)
          ZE(M,N) = VX(3,IVX(M))*VARX(3)
  110   CONTINUE
  200 CONTINUE
!
!---  Close elements File   ---
!
      CLOSE( UNIT=9 )
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VX) ) THEN
      DEALLOCATE( VX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_ECLGRID group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_EQEQ
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read equilibrium equations for reactions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 9 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_EQEQ'
!
!---  Assign card string  ---
!
      CARD = 'Equilibrium Equations Card'
!
!---  Read number of equilibrium equations  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Equilibrium Equations'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NEQE)
      LEQE = MAX( LEQE,NEQE )
!
!---  Loop over the equilibrium equations  ---
!
      DO 100 NEQ = 1,NEQE
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Number of Species in Equilibrium Equation'
        CALL RD_INT( ISTART,ICOMMA,CHDUM,NSEE )
        LSEE = MAX( LSEE,NSEE )
!
!---    Loop over the equilibrium-equation species allowing for
!       returns in the input  ---
!
        DO 90 NSP = 1,NSEE
          VARB = 'Equilibrium-Equation Species Name: '
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
          IF( NSP.GT.1 ) THEN
            VARB = 'Equilibrium-Equation Species Exponent: '
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
   90   CONTINUE
  100 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_EQEQ group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_EQRC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read equilibrium reactions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 9 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_EQRC'
!
!---  Assign card string  ---
!
      CARD = 'Equilibrium Reactions Card'
!
!---  Read number of equilibrium reactions  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Equilibrium Reactions'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NRCE)
      LRCE = MAX( LRCE,NRCE )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_EQRC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_EXSP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read exchanged species.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 8 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_EXSP'
!
!---  Assign card string  ---
!
      CARD = 'Exchanged Species Card'
!
!---  Read number of exchanged species  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Exchanged Species'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSPE)
      LSPE = MAX( LSPE,NSPE )
!
!---  Read number of exchange sites  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Exchange Sites'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NESITE)
      LESITE = MAX( LESITE,NESITE )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_EXSP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_GEOM_FRC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Triangle Fracture/Fault Parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 31 July 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE GEOM_FRC
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM,CHDUM0
      CHARACTER*128 ADUM,BDUM,FDUM
      CHARACTER*64 UNTS
      CHARACTER*13 FORM4
      CHARACTER*18 FORM5
      REAL*8 XPX(5),YPX(5),ZPX(5)
      REAL*8, DIMENSION(1) :: SIGNX,VAMX,VDMX
      REAL*8, DIMENSION(3) :: VNX,VPX,VQX
      REAL*8, DIMENSION(3) :: VAX,VBX,VCX,VDX
      REAL*8, DIMENSION(3) :: P1X,P2X,PN1X,PN2X
      REAL*8, DIMENSION(3,3) :: SIGX
      REAL*8, DIMENSION(3,3) :: V1X,V2X
      REAL*8, DIMENSION(3,24) :: PTX
      REAL*8, DIMENSION(3,6) :: CPX
      REAL*8, DIMENSION(24) :: XPTX,YPTX,ZPTX,ROTX
      REAL*8, DIMENSION(3) :: SIGN_FRCX
      INTEGER MSX(4,6),N1X(4),N2X(4)
      INTEGER, DIMENSION(:), ALLOCATABLE :: ITCM_FRCX,INCM_FRCX
      LOGICAL FCHK
!
!----------------------Data Statements---------------------------------!
!
      DATA FORM4 /'(A,I3,A,I3,A)'/
      DATA FORM5 /'(A,I3,A,I3,A,I3,A)'/
      DATA MSX / 1,2,4,3,1,5,6,2,1,3,7,5,2,6,8,4,3,4,8,7,5,7,8,6 /
      DATA N1X / 2,3,4,1 /
      DATA N2X / 1,2,3,4 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_GEOM_FRC'
!
!---  Node centroids  ---
!
      DO N = 1,LFD-LBR-LWN_LW
        IF( IXP(N).EQ.0 ) CYCLE
        XP(N) = 0.D+0
        YP(N) = 0.D+0
        ZP(N) = 0.D+0
        DO M = 1,8
          XP(N) = XP(N) + XE(M,N)
          YP(N) = YP(N) + YE(M,N)
          ZP(N) = ZP(N) + ZE(M,N)
        ENDDO
        XP(N) = XP(N)/8.D+0
        YP(N) = YP(N)/8.D+0
        ZP(N) = ZP(N)/8.D+0
      ENDDO
!
!---  Check for pre-processed fracture data  ---
!
      ISTART = 1
      CALL RDINPL( CHDUM )
      CALL LCASE( CHDUM )
      CALL RDCHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      IF( INDEX(ADUM(1:),'preprocess').NE.0 .AND.
     &  INDEX(ADUM(1:),'fracture').NE.0 ) THEN
        INQUIRE( FILE='ppfrac.dat',EXIST=FCHK )
        IF( .NOT.FCHK ) THEN
          INDX = 4
          CHMSG = 'Missing Fracture/Fault File: ppfrac.dat'
          CALL WRMSGP( INDX )
        ELSE  
          OPEN(UNIT=35, FILE='ppfrac.dat', 
     &      STATUS='OLD', FORM='FORMATTED')
        ENDIF
!
!---    Read fracture parameters  ---
!
        READ(35,*) LF_FRC,LFC_FRC,LNC_FRC,LT_FRC,LTC_FRC,LXP_FRC
!
!---    Allocate memory for number of triangles in fracture/fault  ---
!
        ALLOCATE( NTP_FRC(1:LF_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: NTP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for number of triangle to grid cell 
!       connections  ---
!
        ALLOCATE( INCM_FRC(1:LNC_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: INCM_FRC'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Allocate memory for fracture/fault vertices  ---
!
        ALLOCATE( XE_FRC(1:3,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: XE_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( YE_FRC(1:3,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: YE_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( ZE_FRC(1:3,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ZE_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( XP_FRC(1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: XP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( YP_FRC(1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: YP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( ZP_FRC(1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ZP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( AF_FRC(1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: AF_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( IP_FRC(1:2,1:LF_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( ND_FRC(1:3,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ND_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( IPN_FRC(1:2,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IPN_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( IPF_FRC(1:2,1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IPF_FRC'
          CALL WRMSGS( INDX )
        ENDIF
        ALLOCATE( IXP_FRC(1:LT_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IXP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( ITCM_FRC(1:LFC_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ITCM_FRC'
          CALL WRMSGS( INDX )
        ENDIF
!
!---    Read number of fractures and number of inactive
!       fracture triangles  ---
!
        READ(35,*) NF_FRC,NXP_FRC
!
!---    Loop over fractures/faults  ---
!
        DO NFX = 1,NF_FRC
!
!---      Read fracture/fault preprocessed file  ---
!
          CALL RD_PREP_FRC( NFX )
        ENDDO     
!
!---    Close fracture/fault preprocessed file  ---
!
        CLOSE(UNIT=35)
!
!---    Reset subroutine string sequence  ---
!
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ELSE
        BACKSPACE(UNIT=IRD)
      ENDIF
!
!---  Assign card string  ---
!
      CARD = 'Fracture/Fault Geometry Card'
      OPEN(UNIT=16, FILE='step_tnc.dat', STATUS='UNKNOWN', 
     &  FORM='FORMATTED')
      CLOSE(UNIT=16,STATUS='DELETE')
      OPEN(UNIT=16, FILE='step_tnc.dat', STATUS='NEW', 
     &  FORM='FORMATTED')
!
!---  Read the number of fractures/faults  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Fractures/Faults'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NF_FRC)
!
!---  Parameter for number of fractures/faults  ---
!
      LF_FRC = MAX( NF_FRC,LF_FRC )
!
!---  Allocate memory for number of triangles in fracture/fault  ---
!
      IF( .NOT.ALLOCATED(NTP_FRC) ) THEN
        ALLOCATE( NTP_FRC(1:LF_FRC),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: NTP_FRC'
          CALL WRMSGP( INDX )
        ENDIF
      ENDIF
!
!---  Loop over the number of fractures/faults  ---
!
      NT_FRC = 0
      DO NFX = 1,NF_FRC
!
!---    Read new input line  ---
!
        CALL RD_INPL( CHDUM )
        CHDUM0 = CHDUM
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    Check for an external file  ---
!
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'file').NE.0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM0,FDUM)
          INQUIRE( FILE=TRIM(ADJUSTL(FDUM)),EXIST=FCHK )
          IF( .NOT.FCHK ) THEN
            INDX = 4
            CHMSG = 'Missing Fracture/Fault File: ' // 
     &        TRIM(ADJUSTL(FDUM))
            CALL WRMSGP( INDX )   
          ELSE
            OPEN(UNIT=35, FILE=TRIM(ADJUSTL(FDUM)), 
     &        STATUS='OLD', FORM='FORMATTED')
            IRDX = IRD
            IRD = 35
            IFILE = 1
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
          ENDIF
        ELSE
          ISTART = 1
          IFILE = 0
        ENDIF
!
!---    Read the number of triangles in the fracture/fault  ---
!
        VARB = 'Number of Triangles in Fracture/Fault'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NTP_FRC(NFX))
        NT_FRC = NT_FRC + NTP_FRC(NFX)
!
!---    Loop over the number of triangles in the fracture/fault  ---
!
        DO NTX = 1,NTP_FRC(NFX)
!
!---      Read parameters and vertices  ---
!
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
        ENDDO
        IF( IFILE.EQ.1 ) THEN
          IRD = IRDX
          IFILE = 0
          CLOSE(UNIT=35)
        ENDIF
      ENDDO
!
!---  Parameter for number of fracture/fault triangles  ---
!
      LT_FRC = MAX( NT_FRC,LT_FRC )
!
!---  Allocate memory for number of triangle to grid cell 
!     connections  ---
!
      LNC_FRC = LT_FRC
      ALLOCATE( INCM_FRC(1:LNC_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: INCM_FRC'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for fracture/fault vertices  ---
!
      ALLOCATE( XE_FRC(1:3,1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XE_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( YE_FRC(1:3,1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YE_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( ZE_FRC(1:3,1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZE_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( XP_FRC(1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XP_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( YP_FRC(1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YP_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( ZP_FRC(1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZP_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( AF_FRC(1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: AF_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( IP_FRC(1:2,1:LF_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IP_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( ND_FRC(1:3,1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ND_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( IPN_FRC(1:2,1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IPN_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( IXP_FRC(1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IXP_FRC'
        CALL WRMSGP( INDX )
      ENDIF
      DO N = 1,LT_FRC
        DO M = 1,3
          ND_FRC(M,N) = 0
        ENDDO
        DO M = 1,2
          IPN_FRC(M,N) = 0
        ENDDO
        IXP_FRC(N) = 0
      ENDDO
!
!---  Rewind input file to the start of the card  ---
!
      REWIND(IRD)
      DO
        READ(IRD,'(A)') CHDUM
        IF( CHDUM(1:1).EQ.'#' ) CYCLE
        CALL L_CASE( CHDUM )
        IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'fracture').NE.0 .AND.
     &    INDEX(CHDUM(2:),'geometry').NE.0 ) EXIT
        IF( CHDUM(1:1).EQ.'~' .AND.
     &    INDEX(CHDUM(2:),'fault').NE.0 .AND.
     &    INDEX(CHDUM(2:),'geometry').NE.0 ) EXIT
      ENDDO
!
!---  Read the number of fractures/faults  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Fractures/Faults'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NF_FRC)
!
!---  Loop over the number of fractures/faults  ---
!
      NT_FRC = 0
      DO NFX = 1,NF_FRC
        IP_FRC(1,NFX) = NT_FRC + 1
!
!---    Read new input line  ---
!
        CALL RD_INPL( CHDUM )
        CHDUM0 = CHDUM
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    Check for an external file  ---
!
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'file').NE.0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM0,FDUM)
          INQUIRE( FILE=TRIM(ADJUSTL(FDUM)),EXIST=FCHK )
          IF( .NOT.FCHK ) THEN
            INDX = 4
            CHMSG = 'Missing Fracture/Fault File: ' // 
     &        TRIM(ADJUSTL(FDUM))
            CALL WRMSGP( INDX )   
          ELSE
            OPEN(UNIT=35, FILE=TRIM(ADJUSTL(FDUM)), 
     &        STATUS='OLD', FORM='FORMATTED')
            IRDX = IRD
            IRD = 35
            IFILE = 1
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
          ENDIF
        ELSE
          ISTART = 1
          IFILE = 0
        ENDIF
!
!---    Read the number of triangles in the fracture/fault  ---
!
        VARB = 'Number of Triangles in Fracture/Fault'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NTP_FRC(NFX))
!
!---    Read fracture/fault joint model  ---
!
        VARB = 'Fracture/Fault Joint Model'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'dynamic').NE.0 .AND.
     &    INDEX(ADUM(1:),'sneddon').NE.0 .AND.
     &    INDEX(ADUM(1:),'barton').NE.0 .AND.
     &    INDEX(ADUM(1:),'bandis').NE.0 ) THEN
          IJM_FRCX = 11
        ELSEIF( INDEX(ADUM(1:),'barton').NE.0 .AND.
     &    INDEX(ADUM(1:),'bandis').NE.0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
          IF( INDEX(BDUM(1:),'roughness').NE.0 .AND.
     &      INDEX(BDUM(1:),'coeff').NE.0 ) THEN
            IJM_FRCX = 1
          ELSEIF( INDEX(BDUM(1:),'unstressed').NE.0 .AND.
     &      INDEX(BDUM(1:),'aperture').NE.0 ) THEN
            IJM_FRCX = 2
          ELSEIF( INDEX(BDUM(1:),'residual').NE.0 .AND.
     &      INDEX(BDUM(1:),'aperture').NE.0 ) THEN
            IJM_FRCX = 3
          ELSE
            INDX = 4
            CHMSG = 'Unrecognized Barton-Bandis Joint Model ' // 
     &        'Option: ' // BDUM
            CALL WRMSGP( INDX )
          ENDIF
        ELSEIF( INDEX(ADUM(1:),'constant').NE.0 .AND.
     &    INDEX(ADUM(1:),'aperture').NE.0 ) THEN
          IJM_FRCX = 0
        ELSEIF( INDEX(ADUM(1:),'sneddon').NE.0 .AND.
     &    INDEX(ADUM(1:),'aperture').NE.0 ) THEN
          IJM_FRCX = 10
        ELSE
          INDX = 4
          CHMSG = 'Unrecognized Fracture/Fault Joint Model: '//ADUM
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Loop over the number of triangles in the fracture/fault  ---
!
        DO MTX = 1,NTP_FRC(NFX)
          NTX = MTX + IP_FRC(1,NFX) - 1
!
!---      Read parameters and vertices for each triangle  ---
!
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
!
!---      Read triangle aperture  ---
!
          IF( IJM_FRCX.EQ.0 ) THEN
            VARB = 'Triangle Aperture'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            VARB = 'Triangle Aperture Units'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Read triangle joint roughness coefficient  ---
!
          ELSEIF( IJM_FRCX.EQ.1 ) THEN
            VARB = 'Triangle Joint Roughness Coefficient'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Read unstressed aperture, m  ---
!
          ELSEIF( IJM_FRCX.EQ.2 ) THEN
            VARB = 'Triangle Joint Unstressed Aperture'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            VARB = 'Triangle Joint Unstressed Aperture Units'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Read residual aperture, m  ---
!
          ELSEIF( IJM_FRCX.EQ.3 ) THEN
            VARB = 'Triangle Joint Residual Aperture'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            VARB = 'Triangle Joint Residual Aperture Units'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ENDIF
!
!---      Read triangle joint wall compressive strength  ---
!
          IF( IJM_FRCX.GE.1 .AND. IJM_FRCX.LE.3 ) THEN
            VARB = 'Triangle Joint Wall Compressive Strength'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            VARB = 'Triangle Joint Wall Compressive Strength Units'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Read triangle unconfined compressive strength of rock
!             adjacent to joint wall  ---
!
            VARB = 'Triangle Unconfined Compressive Strength ' // 
     &          '(Adjac. Rock)'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            VARB = 'Triangle Unconfined Compressive Strength Units'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ENDIF
!
!---      Loop over the three vertices in the triangle  ---
!
          DO NVX = 1,3
            VARB = 'X Vertex Dimension'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,XE_FRC(NVX,NTX))
            VARB = 'X Vertex Dimension Units'
            UNTS = 'm'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            IUNM = 1
            IDFLT = 1
            INDX = 0
            CALL RD_UNIT(UNTS,XE_FRC(NVX,NTX),INDX)
            VARB = 'Y Vertex Dimension'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,YE_FRC(NVX,NTX))
            VARB = 'Y Vertex Dimension Units'
            UNTS = 'm'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            IUNM = 1
            IDFLT = 1
            INDX = 0
            CALL RD_UNIT(UNTS,YE_FRC(NVX,NTX),INDX)
            VARB = 'Z Vertex Dimension'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZE_FRC(NVX,NTX))
            VARB = 'Z Vertex Dimension Units'
            UNTS = 'm'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
            IUNM = 1
            IDFLT = 1
            INDX = 0
            CALL RD_UNIT(UNTS,ZE_FRC(NVX,NTX),INDX)
            ENDDO
        ENDDO
        NT_FRC = NT_FRC + NTP_FRC(NFX)
        IP_FRC(2,NFX) = NT_FRC
        IF( IFILE.EQ.1 ) THEN
          IRD = IRDX
          IFILE = 0
          CLOSE(UNIT=35)
        ENDIF
      ENDDO
!
!---  Surface normals of the fracture/fault triangles  ---
!
      NFNCX = 0
      NAT_FRC = 0
      DO NFX = 1,NF_FRC
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
          IPN_FRC(1,NTX) = NFNCX + 1
!
!---      Determine triangle areas  ---
!
          CALL TRGAREA( XE_FRC(1,NTX),YE_FRC(1,NTX),ZE_FRC(1,NTX),
     &      XE_FRC(2,NTX),YE_FRC(2,NTX),ZE_FRC(2,NTX),
     &      XE_FRC(3,NTX),YE_FRC(3,NTX),ZE_FRC(3,NTX),AF_FRC(NTX) )
          CALL PGCNTRD( 3,XE_FRC(1,NTX),YE_FRC(1,NTX),ZE_FRC(1,NTX),
     &      XP_FRC(NTX),YP_FRC(NTX),ZP_FRC(NTX) )
!
!---      x,y,z coordinates of the fracture/fault triangle vertices ---
!
          DO NVX = 1,3
            V1X(1,NVX) = XE_FRC(NVX,NTX)
            V1X(2,NVX) = YE_FRC(NVX,NTX)
            V1X(3,NVX) = ZE_FRC(NVX,NTX)
          ENDDO
!
!---      Surface parallel vectors of the fracture/fault triangles ---
!
          VAX(1) = XE_FRC(2,NTX) - XE_FRC(1,NTX)
          VBX(1) = XE_FRC(3,NTX) - XE_FRC(1,NTX)
          VAX(2) = YE_FRC(2,NTX) - YE_FRC(1,NTX)
          VBX(2) = YE_FRC(3,NTX) - YE_FRC(1,NTX)
          VAX(3) = ZE_FRC(2,NTX) - ZE_FRC(1,NTX)
          VBX(3) = ZE_FRC(3,NTX) - ZE_FRC(1,NTX)
!
!---      Surface normal vector of the fracture/fault triangle ---
!
          SIGN_FRCX(1) = VAX(2)*VBX(3) - VAX(3)*VBX(2)
          SIGN_FRCX(2) = VAX(3)*VBX(1) - VAX(1)*VBX(3)
          SIGN_FRCX(3) = VAX(1)*VBX(2) - VAX(2)*VBX(1)
!
!---      Unit surface normal vector of the fracture/fault triangle ---
!
          SNMX = SQRT( SIGN_FRCX(1)**2 + 
     &      SIGN_FRCX(2)**2 + SIGN_FRCX(3)**2)
          SIGN_FRCX(1) = SIGN_FRCX(1)/SNMX
          SIGN_FRCX(2) = SIGN_FRCX(2)/SNMX
          SIGN_FRCX(3) = SIGN_FRCX(3)/SNMX
!
!---      Unit surface parallel vector of the fracture/fault triangle ---
!
          VAMX(1) = SQRT( VAX(1)**2 +  VAX(2)**2 + VAX(3)**2)
          VAX(1) = VAX(1)/VAMX(1)
          VAX(2) = VAX(2)/VAMX(1)
          VAX(3) = VAX(3)/VAMX(1)
!
!---      Unit orthogonal vector to surface normal and 
!         surface parallel vectors ---
!
          VDX(1) = VAX(2)*SIGN_FRCX(3) - VAX(3)*SIGN_FRCX(2)
          VDX(2) = VAX(3)*SIGN_FRCX(1) - VAX(1)*SIGN_FRCX(3)
          VDX(3) = VAX(1)*SIGN_FRCX(2) - VAX(2)*SIGN_FRCX(1)
!
!---      Normal stress (Pa) on fracture/fault triangle---
!
          CALL MAT_MUL( SIGN_FRCX(1),SIGX,VCX,1,3,3 )
          CALL MAT_MUL( VCX,SIGN_FRCX(1),SIGNX,1,3,1 )
!
!---      Shear stress (Pa) on fracture/fault triangle in direction 
!         of VAX ---
!
          CALL MAT_MUL( VAX,SIGX,VCX,1,3,3 )
          CALL MAT_MUL( VCX,SIGN_FRCX(1),VAMX,1,3,1 )
!
!---      Shear stress (Pa) on fracture/fault triangle in 
!         direction of VDX ---
!
          CALL MAT_MUL( VDX,SIGX,VCX,1,3,3 )
          CALL MAT_MUL( VCX,SIGN_FRCX(1),VDMX,1,3,1 )
!
!---      Magnitude weighted normal and shear stress (Pa) on 
!         fracture/fault triangle ---
!
          DO NVX = 1,3
            SIGN_FRCX(NVX) = SIGN_FRCX(NVX)*SIGNX(1)
          ENDDO
!
!---      For MPI preprocessing find the node with the closest
!         centroid to the fracture triangle centroid, and then
!         associate just that node with the fracture triangle. One
!         field node can be associated with multiple fracture triangles
!         but each fracture triangle is only associate with one
!         field node  ---
!
          IF( ISLC(67).EQ.1 ) THEN
            DISTX = 1.D+20
            ICHKX = 0
            NX = 0
            DO N = 1,LFD-LBR-LWN_LW
              IFLGX = 0
              IF( IXP(N).EQ.0 ) CYCLE
              XMNX = XE(1,N)
              XMAX = XE(1,N)
              YMNX = YE(1,N)
              YMAX = YE(1,N)
              ZMNX = ZE(1,N)
              ZMAX = ZE(1,N)
              DO M = 2,8
                XMNX = MIN( XMNX,XE(M,N) )
                XMAX = MAX( XMAX,XE(M,N) )
                YMNX = MIN( YMNX,YE(M,N) )
                YMAX = MAX( YMAX,YE(M,N) )
                ZMNX = MIN( ZMNX,ZE(M,N) )
                ZMAX = MAX( ZMAX,ZE(M,N) )
              ENDDO
              XMNX = XMNX - 1.D-6
              XMAX = XMAX + 1.D-6
              YMNX = YMNX - 1.D-6
              YMAX = YMAX + 1.D-6
              ZMNX = ZMNX - 1.D-6
              ZMAX = ZMAX + 1.D-6
!
!---          Check for triangle vertices within domain  ---
!
              DO NVX = 1,3
                IF( XE_FRC(NVX,NTX).LT.XMNX .OR. 
     &            XE_FRC(NVX,NTX).GT.XMAX .OR. 
     &            YE_FRC(NVX,NTX).LT.YMNX .OR. 
     &            YE_FRC(NVX,NTX).GT.YMAX .OR. 
     &            ZE_FRC(NVX,NTX).LT.ZMNX .OR. 
     &            ZE_FRC(NVX,NTX).GT.ZMAX ) CYCLE
                CALL WITH_IN( XE_FRC(NVX,NTX),YE_FRC(NVX,NTX),
     &            ZE_FRC(NVX,NTX),IFLGX,N )
                ICHKX = MAX( ICHKX,IFLGX )
              ENDDO
!
!---          Check for triangle centroid within domain  ---
!
              IF( XP_FRC(NTX).GE.XMNX .AND. 
     &          XP_FRC(NTX).LE.XMAX .AND. 
     &          YP_FRC(NTX).GE.YMNX .AND. 
     &          YP_FRC(NTX).LE.YMAX .AND. 
     &          ZP_FRC(NTX).GE.ZMNX .AND. 
     &          ZP_FRC(NTX).LE.ZMAX ) THEN
                CALL WITH_IN( XP_FRC(NTX),YP_FRC(NTX),
     &            ZP_FRC(NTX),IFLGX,N )
                ICHKX = MAX( ICHKX,IFLGX )
              ENDIF
              VARX = SQRT((XP_FRC(NTX)-XP(N))**2 + 
     &          (YP_FRC(NTX)-YP(N))**2 + (ZP_FRC(NTX)-ZP(N))**2)
              IF( VARX.LT.DISTX ) THEN
                DISTX = VARX
                NX = N
              ENDIF
            ENDDO
            IF( ICHKX.EQ.1 ) THEN
              DO NVZ = 1,3
                ND_FRC(NVZ,NTX) = NX
              ENDDO
              NFNCX = NFNCX + 1
              IF( NFNCX.GT.LNC_FRC ) THEN
                INDX = 4
                CHMSG = 'Number of Fracture to Grid-Cell ' //
     &            'Connections > Number of Fractures for ' //
     &            'MPI Preprocessing'
                CALL WRMSGP( INDX )  
              ENDIF 
              INCM_FRC(NFNCX) = NX               
!
!---        All three fracture triangle vertices and centroid outside of 
!           computational domain, make triangle inactive  ---
!
            ELSE
              NXP_FRC = NXP_FRC + 1
              CYCLE
            ENDIF
          ELSE
!
!---        Resident node number for fracture/fault triangle 
!           vertices  ---
!
            DO NVX = 1,3
              DO N = 1,LFD-LBR-LWN_LW
                IF( IXP(N).EQ.0 ) CYCLE
                XMNX = XE(1,N)
                XMAX = XE(1,N)
                YMNX = YE(1,N)
                YMAX = YE(1,N)
                ZMNX = ZE(1,N)
                ZMAX = ZE(1,N)
                DO M = 2,8
                  XMNX = MIN( XMNX,XE(M,N) )
                  XMAX = MAX( XMAX,XE(M,N) )
                  YMNX = MIN( YMNX,YE(M,N) )
                  YMAX = MAX( YMAX,YE(M,N) )
                  ZMNX = MIN( ZMNX,ZE(M,N) )
                  ZMAX = MAX( ZMAX,ZE(M,N) )
                ENDDO
                XMNX = XMNX - 1.D-6
                XMAX = XMAX + 1.D-6
                YMNX = YMNX - 1.D-6
                YMAX = YMAX + 1.D-6
                ZMNX = ZMNX - 1.D-6
                ZMAX = ZMAX + 1.D-6
                IF( XE_FRC(NVX,NTX).LT.XMNX .OR. 
     &            XE_FRC(NVX,NTX).GT.XMAX .OR. 
     &            YE_FRC(NVX,NTX).LT.YMNX .OR. 
     &            YE_FRC(NVX,NTX).GT.YMAX .OR. 
     &            ZE_FRC(NVX,NTX).LT.ZMNX .OR. 
     &            ZE_FRC(NVX,NTX).GT.ZMAX ) CYCLE
                CALL WITH_IN( XE_FRC(NVX,NTX),YE_FRC(NVX,NTX),
     &            ZE_FRC(NVX,NTX),IFLGX,N )
                IF( IFLGX.NE.0 ) THEN
                  ND_FRC(NVX,NTX) = N
                  EXIT
                ENDIF
              ENDDO
            ENDDO
!
!---        For fracture/fault triangle vertices in multiple grid cells,
!           check whether a single grid cell is inclusive  ---
!
            IF( (ND_FRC(1,NTX).NE.ND_FRC(2,NTX) .OR. 
     &        ND_FRC(2,NTX).NE.ND_FRC(3,NTX)) .AND.
     &        ND_FRC(1,NTX)*ND_FRC(2,NTX)*ND_FRC(3,NTX).GT.0 ) THEN
              DO NVX = 1,3
                ICHKX = 1
                N = ND_FRC(NVX,NTX)
                DO NVZ = 1,3
                  CALL WITH_IN( XE_FRC(NVZ,NTX),YE_FRC(NVZ,NTX),
     &              ZE_FRC(NVZ,NTX),IFLGX,N )
                  IF( IFLGX.EQ.0 ) ICHKX = 0
                ENDDO
                IF( ICHKX.EQ.1 ) THEN
                  DO NVZ = 1,3
                    ND_FRC(NVZ,NTX) = N
                  ENDDO
                  EXIT
                ENDIF
              ENDDO
            ENDIF
!
!---        Any fracture triangle vertex outside of 
!           computational domain, make triangle inactive  ---
!
            IF( ND_FRC(1,NTX).EQ.0 .OR. ND_FRC(2,NTX).EQ.0 .OR.
     &        ND_FRC(3,NTX).EQ.0 ) THEN
              NXP_FRC = NXP_FRC + 1
              CYCLE
!!
!!---        Fracture/fault triangle vertex outside of 
!!           computational domain  ---
!!
!            IF( ND_FRC(1,NTX).EQ.0 .OR. ND_FRC(2,NTX).EQ.0 .OR.
!       &      ND_FRC(3,NTX).EQ.0 ) THEN
!              INDX = 4
!              WRITE(FORM4(5:5),'(I1)') I_COUNT(NFX)
!              WRITE(FORM4(10:10),'(I1)') I_COUNT(NTX)
!              NC = I_COUNT(NFX) + I_COUNT(NTX) + 31
!              WRITE(ADUM(1:NC),FORM4) '(Fracture/Fault #:',NFX,
!       &        ' Triangle #:',NTX,')'
!              CHMSG = 'Fracture/Fault Triangle Vertex Outside ' //  
!       &        'of Domain: ' // ADUM(1:NC)
!              CALL WRMSGP( INDX )
!
!---        Grid cell to fracture/fault triangle contacts  ---
!
            ELSEIF( ND_FRC(1,NTX).NE.ND_FRC(2,NTX) .OR.
     &        ND_FRC(2,NTX).NE.ND_FRC(3,NTX) ) THEN
!
!---          Fracture/fault triangle contacts multiple nodes  ---
!
              IHI = 1
              ILO = LFX
              JHI = 1
              JLO = LFY
              KHI = 1
              KLO = LFZ
              DO NVX = 1,3
                IF( ND_FRC(NVX,NTX).EQ.0 ) CYCLE
                ILO = MIN( ILO,ID(ND_FRC(NVX,NTX)) )
                IHI = MAX( IHI,ID(ND_FRC(NVX,NTX)) )
                JLO = MIN( JLO,JD(ND_FRC(NVX,NTX)) )
                JHI = MAX( JHI,JD(ND_FRC(NVX,NTX)) )
                KLO = MIN( KLO,KD(ND_FRC(NVX,NTX)) )
                KHI = MAX( KHI,KD(ND_FRC(NVX,NTX)) )
              ENDDO
!
!---          Loop over the range of nodes  ---
!
              DO K = KLO,KHI
              DO J = JLO,JHI
              DO I = ILO,IHI
                NPTX = 0
                N = ND(I,J,K)
                IF( IXP(N).EQ.0 ) CYCLE
                DO NVX = 1,3
                  IF( ND_FRC(NVX,NTX).EQ.N ) THEN
                    NPTX = NPTX+1
                    PTX(1,NPTX) = XE_FRC(NVX,NTX)
                    PTX(2,NPTX) = YE_FRC(NVX,NTX)
                    PTX(3,NPTX) = ZE_FRC(NVX,NTX)
                  ENDIF
                ENDDO
!
!---            Loop over the surfaces of the node and the triangles
!               of the node surface, checking for intersections of 
!               the fracture/fault triangle and node surface 
!               triangles  ---
!
                ICPX = 0
                DO NS1X = 1,6
                  DO NS2X = 1,4
                    MX = MSX(NS2X,NS1X)
!
!---                Cylindrical coordinates---
!
                    IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
                      XPX(NS2X) = XE(MX,N)*COS(YE(MX,N))
                      YPX(NS2X) = XE(MX,N)*SIN(YE(MX,N))
                      ZPX(NS2X) = ZE(MX,N)
                    ELSE
                      XPX(NS2X) = XE(MX,N)
                      YPX(NS2X) = YE(MX,N)
                      ZPX(NS2X) = ZE(MX,N)
                    ENDIF                
                  ENDDO
                  NPX = 4
                  CALL PGCNTRD( NPX,XPX(1),YPX(1),ZPX(1),
     &              XPX(5),YPX(5),ZPX(5) )            
                  V2X(1,3) = XPX(5)
                  V2X(2,3) = YPX(5)
                  V2X(3,3) = ZPX(5)
                  DO NS2X = 1,4
!
!---                x,y,z coordinates of the node surface triangle 
!                   vertices ---
!
                    V2X(1,1) = XPX(N1X(NS2X))
                    V2X(2,1) = YPX(N1X(NS2X))
                    V2X(3,1) = ZPX(N1X(NS2X))
                    V2X(1,2) = XPX(N2X(NS2X))
                    V2X(2,2) = YPX(N2X(NS2X))
                    V2X(3,2) = ZPX(N2X(NS2X))
!
!---                Fast triangle-triangle intersection test, with 
!                   intersection point finder when intersection
!                   noted  ---
!
!                    CALL FTT_IT( V1X,V2X,P1X,P2X,PN1X,PN2X,ICPX,ITX )
                    CALL TTIT3D(V1X,V2X,P1X,P2X,PN1X,PN2X,CPX,ICPX,ITX)
!
!---                Record intersection points  ---
!
                    IF( ITX.EQ.1 ) THEN
!
!---                  Skip duplicate points  ---
!
                      ISKPX = 0
                      DO M = 1,NPTX
                        IF( ABS(P1X(1)-PTX(1,M)).LT.EPSL .AND. 
     &                    ABS(P1X(2)-PTX(2,M)).LT.EPSL .AND.
     &                    ABS(P1X(3)-PTX(3,M)).LT.EPSL ) THEN
                          ISKPX = 1
                          EXIT
                        ENDIF
                      ENDDO
                      IF( ISKPX.EQ.0 ) THEN
                        NPTX = NPTX + 1
                        PTX(1,NPTX) = P1X(1)
                        PTX(2,NPTX) = P1X(2)
                        PTX(3,NPTX) = P1X(3)
                      ENDIF
!
!---                  Skip duplicate points  ---
!
                      ISKPX = 0
                      DO M = 1,NPTX
                        IF( ABS(P2X(1)-PTX(1,M)).LT.EPSL .AND. 
     &                    ABS(P2X(2)-PTX(2,M)).LT.EPSL .AND.
     &                    ABS(P2X(3)-PTX(3,M)).LT.EPSL ) THEN
                          ISKPX = 1
                          EXIT
                        ENDIF
                      ENDDO
                      IF( ISKPX.EQ.0 ) THEN
                        NPTX = NPTX + 1
                        PTX(1,NPTX) = P2X(1)
                        PTX(2,NPTX) = P2X(2)
                        PTX(3,NPTX) = P2X(3)
                      ENDIF
                    ENDIF
!
!---                Coplanar triangle sets identified, record
!                   intersection points  ---
!
                    IF( ICPX.NE.0 ) THEN
                      DO IC = 1,ICPX
!
!---                    Skip duplicate points  ---
!
                        ISKPX = 0
                        DO M = 1,NPTX
                          IF( ABS(CPX(1,IC)-PTX(1,M)).LT.EPSL .AND. 
     &                      ABS(CPX(2,IC)-PTX(2,M)).LT.EPSL .AND.
     &                      ABS(CPX(3,IC)-PTX(3,M)).LT.EPSL ) THEN
                            ISKPX = 1
                            EXIT
                          ENDIF
                        ENDDO
                        IF( ISKPX.EQ.0 ) THEN
                          NPTX = NPTX + 1
                          PTX(1,NPTX) = CPX(1,IC)
                          PTX(2,NPTX) = CPX(2,IC)
                          PTX(3,NPTX) = CPX(3,IC)
                        ENDIF
                      ENDDO
                    ENDIF
                  ENDDO
                ENDDO
!
!---            Surface area of fracture triangle within grid-cell  ---
!
                IF( NPTX.GT.2 ) THEN
                  IF( NPTX.GT.3 ) THEN
                    DO M = 1,NPTX
                      XPTX(M) = PTX(1,M)
                      YPTX(M) = PTX(2,M)
                      ZPTX(M) = PTX(3,M)
                    ENDDO
!
!---                Check for nonzero surface area of polygon  ---
!
                    APX = 0.D+0
                    DO M = 1,NPTX-2
                      CALL TRGAREA( PTX(1,M),PTX(2,M),PTX(3,M),
     &                  PTX(1,M+1),PTX(2,M+1),PTX(3,M+1),
     &                  PTX(1,NPTX),PTX(2,NPTX),PTX(3,NPTX),ATX )
                      APX = APX + ATX
                    ENDDO
!
!---                Ignore relatively small surface areas   ---
!
                    IF( APX.LT.1.D-2*AF_FRC(NTX) ) CYCLE
                    CALL PGCNTRD(NPTX,XPTX,YPTX,ZPTX,XCNTX,YCNTX,ZCNTX)
!
!---                Angles between centroid to vertex 1 vector and
!                   centroid to vertex n vector  ---
!
                    ROTX(1) = 0.D+0
                    VPX(1) = PTX(1,1)-XCNTX
                    VPX(2) = PTX(2,1)-YCNTX
                    VPX(3) = PTX(3,1)-ZCNTX
                    VPLX = SQRT( VPX(1)**2 + VPX(2)**2 + VPX(3)**2 )
                    DO M = 2,NPTX
                      VQX(1) = PTX(1,M)-XCNTX
                      VQX(2) = PTX(2,M)-YCNTX
                      VQX(3) = PTX(3,M)-ZCNTX
                      VQLX = SQRT( VQX(1)**2 + VQX(2)**2 + VQX(3)**2 )
                      DPNX = VDOTP(VPX,VQX)/(VPLX*VQLX)
                      DPNX = MAX( MIN( DPNX,1.D+0 ),-1.D+0 )
                      ROTX(M) = ACOS( DPNX )
                      CALL VCROSSP( VQX,VPX,VNX )
                      ROTX(M) = SIGN( ROTX(M),VDOTP(VNX,PN1X) )
                      IF( ROTX(M).LT.0.D+0 ) ROTX(M) = 2.D+0*GPI+ROTX(M)
                    ENDDO
!
!---                Sort vertices by rotation angles  ---
!
                    DO M = 2,NPTX
                      RTX = ROTX(M)
                      PT1X = PTX(1,M)
                      PT2X = PTX(2,M)
                      PT3X = PTX(3,M)
                      DO L = M-1,1,-1
                        IF( ROTX(L).LE.RTX ) GOTO 10
                        ROTX(L+1) = ROTX(L)
                        PTX(1,L+1) = PTX(1,L)
                        PTX(2,L+1) = PTX(2,L)
                        PTX(3,L+1) = PTX(3,L)
                      ENDDO
                      L = 0
   10                 CONTINUE
                      ROTX(L+1) = RTX
                      PTX(1,L+1) = PT1X
                      PTX(2,L+1) = PT2X
                      PTX(3,L+1) = PT3X
                    ENDDO
                    NPTX = NPTX + 1
                    PTX(1,NPTX) = XCNTX
                    PTX(2,NPTX) = YCNTX
                    PTX(3,NPTX) = ZCNTX
                  ENDIF
                  APX = 0.D+0
                  DO M = 1,NPTX-2
                    CALL TRGAREA( PTX(1,M),PTX(2,M),PTX(3,M),
     &                PTX(1,M+1),PTX(2,M+1),PTX(3,M+1),
     &                PTX(1,NPTX),PTX(2,NPTX),PTX(3,NPTX),ATX )
                    APX = APX + ATX
                  ENDDO
                  IF( NPTX.GT.3 ) THEN
                    CALL TRGAREA( PTX(1,1),PTX(2,1),PTX(3,1),
     &                PTX(1,NPTX-1),PTX(2,NPTX-1),PTX(3,NPTX-1),
     &                PTX(1,NPTX),PTX(2,NPTX),PTX(3,NPTX),ATX )
                    APX = APX + ATX
                  ENDIF
!
!---              Ignore relatively small surface areas   ---
!
                  IF( APX.GE.1.D-2*AF_FRC(NTX) ) THEN
                    NFNCX = NFNCX + 1
                    WRITE(16,'(4(A,I9),2(A,1PE12.5))') 
     &                '1: Fracture #: ',NFX,
     &                ' Triangle #: ',NTX,
     &                ' Node #: ',N,' Connection #: ',NFNCX,
     &                ' Area,m^2: ',APX,
     &                ' Triangle Area,m^2: ',AF_FRC(NTX)
                    IF( NFNCX.GT.LNC_FRC ) THEN
                      ALLOCATE( INCM_FRCX(1:LNC_FRC),STAT=ISTAT )
                      IF( ISTAT.NE.0 ) THEN
                        INDX = 3
                        CHMSG = 'Allocation Error: INCM_FRCX'
                        CALL WRMSGP( INDX )
                      ENDIF
                      DO L = 1,LNC_FRC
                        INCM_FRCX(L) = INCM_FRC(L)
                      ENDDO
                      DEALLOCATE( INCM_FRC,STAT=ISTAT )
                      IF( ISTAT.NE.0 ) THEN
                        INDX = 3
                        CHMSG = 'Deallocation Error: INCM_FRC'
                        CALL WRMSGS( INDX )
                      ENDIF
                      LNC_FRC = LNC_FRC + LT_FRC
                      ALLOCATE( INCM_FRC(1:LNC_FRC),STAT=ISTAT )
                      IF( ISTAT.NE.0 ) THEN
                        INDX = 3
                        CHMSG = 'Allocation Error: INCM_FRC'
                        CALL WRMSGP( INDX )
                      ENDIF
                      DO L = 1,LNC_FRC-LT_FRC
                        INCM_FRC(L) = INCM_FRCX(L)
                      ENDDO
                      DEALLOCATE( INCM_FRCX,STAT=ISTAT )
                      IF( ISTAT.NE.0 ) THEN
                        INDX = 3
                        CHMSG = 'Deallocation Error: INCM_FRCX'
                        CALL WRMSGS( INDX )
                      ENDIF
                    ENDIF   
                    INCM_FRC(NFNCX) = N                 
!
!---                For coplanar fractures/faults, link to 
!                   adjacent node  ---
!
                    IF( ICPX.NE.0 ) THEN
                      NFNCX = NFNCX + 1
                      WRITE(16,'(4(A,I9),2(A,1PE12.5))') 
     &                  '2: Fracture #: ',NFX,
     &                  ' Triangle #: ',NTX,
     &                  ' Node #: ',N,' Connection #: ',NFNCX,
     &                  ' Area,m^2: ',APX,
     &                  ' Triangle Area,m^2: ',AF_FRC(NTX)
                      IF( NFNCX.GT.LNC_FRC ) THEN
                        ALLOCATE( INCM_FRCX(1:LNC_FRC),STAT=ISTAT )
                        IF( ISTAT.NE.0 ) THEN
                          INDX = 3
                          CHMSG = 'Allocation Error: INCM_FRCX'
                          CALL WRMSGP( INDX )
                        ENDIF
                        DO L = 1,LNC_FRC
                          INCM_FRCX(L) = INCM_FRC(L)
                        ENDDO
                        DEALLOCATE( INCM_FRC,STAT=ISTAT )
                        IF( ISTAT.NE.0 ) THEN
                          INDX = 3
                          CHMSG = 'Deallocation Error: INCM_FRC'
                          CALL WRMSGS( INDX )
                        ENDIF
                        LNC_FRC = LNC_FRC + LT_FRC
                        ALLOCATE( INCM_FRC(1:LNC_FRC),STAT=ISTAT )
                        IF( ISTAT.NE.0 ) THEN
                          INDX = 3
                          CHMSG = 'Allocation Error: INCM_FRC'
                          CALL WRMSGP( INDX )
                        ENDIF
                        DO L = 1,LNC_FRC-LT_FRC
                          INCM_FRC(L) = INCM_FRCX(L)
                        ENDDO
                        DEALLOCATE( INCM_FRCX,STAT=ISTAT )
                        IF( ISTAT.NE.0 ) THEN
                          INDX = 3
                          CHMSG = 'Deallocation Error: INCM_FRCX'
                          CALL WRMSGS( INDX )
                        ENDIF
                      ENDIF   
                      NAX = ICM(1,NS1X,N)
                      INCM_FRC(NFNCX) = NAX
                    ENDIF
                  ENDIF
                ENDIF
              ENDDO
              ENDDO
              ENDDO
!
!---        Fracture/fault triangle completely within grid-cell, record
!           points and surface area  ---
!
            ELSE
              CALL TRGAREA( XE_FRC(1,NTX),YE_FRC(1,NTX),
     &          ZE_FRC(1,NTX),XE_FRC(2,NTX),YE_FRC(2,NTX),
     &          ZE_FRC(2,NTX),XE_FRC(3,NTX),YE_FRC(3,NTX),
     &          ZE_FRC(3,NTX),APX )
!
!---          Ignore relatively small surface areas   ---
!
              IF( APX.GE.1.D-2*AF_FRC(NTX) ) THEN
                NFNCX = NFNCX + 1
                WRITE(16,'(4(A,I9),2(A,1PE12.5))') 
     &            '3: Fracture #: ',NFX,
     &            ' Triangle #: ',NTX,
     &            ' Node #: ',N,' Connection #: ',NFNCX,
     &            ' Area,m^2: ',APX,
     &            ' Triangle Area,m^2: ',AF_FRC(NTX)
                IF( NFNCX.GT.LNC_FRC ) THEN
                  ALLOCATE( INCM_FRCX(1:LNC_FRC),STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Allocation Error: INCM_FRCX'
                    CALL WRMSGP( INDX )
                  ENDIF
                  DO L = 1,LNC_FRC
                    INCM_FRCX(L) = INCM_FRC(L)
                  ENDDO
                  DEALLOCATE( INCM_FRC,STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Deallocation Error: INCM_FRC'
                    CALL WRMSGS( INDX )
                  ENDIF
                  LNC_FRC = LNC_FRC + LT_FRC
                  ALLOCATE( INCM_FRC(1:LNC_FRC),STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Allocation Error: INCM_FRC'
                    CALL WRMSGP( INDX )
                  ENDIF
                  DO L = 1,LNC_FRC-LT_FRC
                    INCM_FRC(L) = INCM_FRCX(L)
                  ENDDO
                  DEALLOCATE( INCM_FRCX,STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Deallocation Error: INCM_FRCX'
                    CALL WRMSGS( INDX )
                  ENDIF
                ENDIF   
                INCM_FRC(NFNCX) = N                 
                CALL PGCNTRD( 3,XE_FRC(1,NTX),YE_FRC(1,NTX),
     &            ZE_FRC(1,NTX),XCNTX,YCNTX,ZCNTX )
              ENDIF
            ENDIF
          ENDIF
          NAT_FRC = NAT_FRC + 1
          IXP_FRC(NTX) = NAT_FRC
          IPN_FRC(2,NTX) = NFNCX
        ENDDO
      ENDDO
!
!---  Fracture/fault to fracture/fault connections  ---
!
      NFFCX = 0
!
!---  Allocate memory by assuming each fracture/fault triangle is
!     connected to three other fracture/fault triangles, then 
!     check to see if more memory is required   ---
!
      LFC_FRC = 3*LT_FRC
      ALLOCATE( ITCM_FRC(1:LFC_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ITCM_FRC'
        CALL WRMSGS( INDX )
      ENDIF
      ALLOCATE( IPF_FRC(1:2,1:LT_FRC),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IPF_FRC'
        CALL WRMSGS( INDX )
      ENDIF
!
!---  Loop over fractures/faults  ---
!
      DO NF1X = 1,NF_FRC
!
!---    Loop over fracture/fault triangles  ---
!
        DO NT1X = IP_FRC(1,NF1X),IP_FRC(2,NF1X)
!
!---      Skip inactive triangles  ---
!
          IF( IXP_FRC(NT1X).EQ.0 ) CYCLE
          IPF_FRC(1,NT1X) = NFFCX + 1
!
!---      Loop over fracture/fault triangles  ---
!
          DO NT2X = IP_FRC(1,NF1X),IP_FRC(2,NF1X)
            IF( NT1X.EQ.NT2X ) CYCLE
            NVVCX = 0
!
!---        Loop over vertices on first fracture/fault triangle  ---
!
            DO IVP1X = 1,3
!
!---        Loop over vertices on second fracture/fault triangle  ---
!
              DO IVP2X = 1,3
                DVX = ABS(XE_FRC(IVP1X,NT1X) - XE_FRC(IVP2X,NT2X)) +
     &            ABS(YE_FRC(IVP1X,NT1X) - YE_FRC(IVP2X,NT2X)) + 
     &            ABS(ZE_FRC(IVP1X,NT1X) - ZE_FRC(IVP2X,NT2X)) 
!
!---            Matching vertices found  ---
!
                IF( DVX.LE.1.D-9 ) THEN
                  NVVCX = NVVCX + 1
!
!---              Overlapping fracture/fault triangles found  ---
!
                  IF( NVVCX.EQ.3 ) THEN
                    INDX = 4
                    WRITE(FORM4(5:5),'(I1)') I_COUNT(NF1X)
                    WRITE(FORM4(10:10),'(I1)') I_COUNT(NT1X)
                    NC = I_COUNT(NF1X) + I_COUNT(NT1X) + 31
                    WRITE(ADUM(1:NC),FORM4) '(Fracture/Fault #:',NF1X,
     &                ' Triangle #:',NT1X,')'
                    CHMSG = 'Overlapping Fracture/Fault Triangle: ' 
     &                // ADUM(1:NC)
                    CALL WRMSGP( INDX )
                  ENDIF
                  EXIT
                ENDIF
              ENDDO
            ENDDO
!
!---        Connecting fracture/fault triangle found  ---
!
            IF( NVVCX.EQ.2 ) THEN
              NFFCX = NFFCX + 1
              IF( NFFCX.GT.LFC_FRC ) THEN
                ALLOCATE( ITCM_FRCX(1:LFC_FRC),STAT=ISTAT )
                IF( ISTAT.NE.0 ) THEN
                  INDX = 3
                  CHMSG = 'Allocation Error: ITCM_FRCX'
                  CALL WRMSGS( INDX )
                ENDIF
                DO M = 1,LFC_FRC
                  ITCM_FRCX(M) = ITCM_FRC(M)
                ENDDO
                DEALLOCATE( ITCM_FRC,STAT=ISTAT )
                IF( ISTAT.NE.0 ) THEN
                  INDX = 3
                  CHMSG = 'Deallocation Error: ITCM_FRC'
                  CALL WRMSGS( INDX )
                ENDIF
                LFC_FRC = LFC_FRC + LT_FRC
                ALLOCATE( ITCM_FRC(1:LFC_FRC),STAT=ISTAT )
                IF( ISTAT.NE.0 ) THEN
                  INDX = 3
                  CHMSG = 'Allocation Error: ITCM_FRC'
                  CALL WRMSGS( INDX )
                ENDIF
                DO M = 1,LFC_FRC-LT_FRC
                  ITCM_FRC(M) = ITCM_FRCX(M) 
                ENDDO
                DEALLOCATE( ITCM_FRCX,STAT=ISTAT )
                IF( ISTAT.NE.0 ) THEN
                  INDX = 3
                  CHMSG = 'Deallocation Error: ITCM_FRCX'
                  CALL WRMSGS( INDX )
                ENDIF
              ENDIF
              ITCM_FRC(NFFCX) = NT2X
            ENDIF
          ENDDO
!
!---      Check for fracture/fault triangle intersections with other
!         fractures/faults  ---
!
          DO M = 1,3
            V1X(1,M) = XE_FRC(M,NT1X)
            V1X(2,M) = YE_FRC(M,NT1X)
            V1X(3,M) = ZE_FRC(M,NT1X)
          ENDDO
!
!---      Loop over fractures/faults  ---
!
          DO NF2X = 1,NF_FRC
            IF( NF1X.EQ.NF2X ) CYCLE
!
!---        Loop over fracture/fault triangles  ---
!
            DO NT2X = IP_FRC(1,NF2X),IP_FRC(2,NF2X)
              IF( NT1X.EQ.NT2X ) CYCLE
              DO M = 1,3
                V2X(1,M) = XE_FRC(M,NT2X)
                V2X(2,M) = YE_FRC(M,NT2X)
                V2X(3,M) = ZE_FRC(M,NT2X)
              ENDDO
!
!---          Fast triangle-triangle intersection test, with 
!             intersection point finder when intersection
!             noted  ---
!
              ICPX = 0
              ITX = 0
!              CALL FTT_IT( V1X,V2X,P1X,P2X,PN1X,PN2X,ICPX,ITX )
              CALL TTIT3D( V1X,V2X,P1X,P2X,PN1X,PN2X,CPX,ICPX,ITX )
              IF( ITX.EQ.1 .OR. ICPX.GT.0 ) THEN
                NFFCX = NFFCX + 1
                IF( NFFCX.GT.LFC_FRC ) THEN
                  ALLOCATE( ITCM_FRCX(1:LFC_FRC),STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Allocation Error: ITCM_FRCX'
                    CALL WRMSGS( INDX )
                  ENDIF
                  DO M = 1,LFC_FRC
                    ITCM_FRCX(M) = ITCM_FRC(M)
                  ENDDO
                  DEALLOCATE( ITCM_FRC,STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Deallocation Error: ITCM_FRC'
                    CALL WRMSGS( INDX )
                  ENDIF
                  LFC_FRC = LFC_FRC + LT_FRC
                  ALLOCATE( ITCM_FRC(1:LFC_FRC),STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Allocation Error: ITCM_FRC'
                    CALL WRMSGS( INDX )
                  ENDIF
                  DO M = 1,LFC_FRC-LT_FRC
                    ITCM_FRC(M) = ITCM_FRCX(M) 
                  ENDDO
                  DEALLOCATE( ITCM_FRCX,STAT=ISTAT )
                  IF( ISTAT.NE.0 ) THEN
                    INDX = 3
                    CHMSG = 'Deallocation Error: ITCM_FRCX'
                    CALL WRMSGS( INDX )
                  ENDIF
                ENDIF
                ITCM_FRC(NFFCX) = NT2X
              ENDIF
            ENDDO
          ENDDO
          IPF_FRC(2,NT1X) = NFFCX
          LTC_FRC = MAX( LTC_FRC,(IPF_FRC(2,NT1X)-IPF_FRC(1,NT1X)+1) )
        ENDDO
      ENDDO
!
!---  Parameter for the number of fracture/fault triangle to 
!     grid cell connections  ---
!
      LNC_FRC = MIN( LNC_FRC,MAX( 1,NFNCX ) )
!
!---  Parameter for the  number of fracture/fault triangle to  
!     fracture/fault triangle connections  ---
!
      LFC_FRC = 1
      LFC_FRC = MAX( LFC_FRC,NFFCX )
!
!---  Parameter for number of inactive fratures  ---
!
      LXP_FRC = MAX( LXP_FRC,NXP_FRC )
      CLOSE(UNIT=16)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_GEOM_FRC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_GMBC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Geomechanics Boundary Conditions Card for number of 
!     boundary conditions and number of boundary condition times.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 29 November 2016.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM,CDUM,FDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_GMBC'
!
!---  Assign card string  ---
!
      CARD = 'Geomechanical Boundary Conditions Card'
!
!---  Read number of boundary condition inputs  ---
!
      LBC_GM = 1
      LBCIN_GM = 1
      LBTM_GM = 1
      NBC = 0
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Geomechanical Boundary Condition Inputs: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
      LBCIN_GM = MAX( LBCIN_GM,NLIN )
      DO 400 NB = 1, NLIN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    Read boundary orientation  ---
!
        VARB = 'Boundary Condition Orientation: '
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'west').NE.0 ) THEN
          IBCDX = -1
        ELSEIF( INDEX(ADUM(1:),'east').NE.0 ) THEN
          IBCDX = 1
        ELSEIF( INDEX(ADUM(1:),'south').NE.0 ) THEN
          IBCDX = -2
        ELSEIF( INDEX(ADUM(1:),'north').NE.0 ) THEN
          IBCDX = 2
        ELSEIF( INDEX(ADUM(1:),'bottom').NE.0 ) THEN
          IBCDX = -3
        ELSEIF( INDEX(ADUM(1:),'top').NE.0 ) THEN
          IBCDX = 3
        ELSEIF( INDEX(ADUM(1:),'file').NE.0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
          NCH = INDEX(FDUM,'  ')-1
          OPEN(UNIT=27,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED')
          I1X = 1
          I2X = 1
          J1X = 1
          J2X = 1
          K1X = 1
          K2X = 0
    5     CONTINUE
          READ(27,*,END=10) IX,JX,KX,IBCDX
          K2X = K2X+1
          GOTO 5
   10     CONTINUE
          REWIND(27)
        ENDIF
!
!---    Read and write boundary domain indices  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        IF( INDEX(ADUM(1:),'file').EQ.0 ) THEN
          VARB = 'Boundary Condition Domain: '
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I2X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J2X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K2X)
!
!---      Check geomechanical boundary domain  ---
!
          IF( I1X.GT.I2X .OR. J1X.GT.J2X .OR. K1X.GT.K2X ) THEN
            INDX = 4
            CHMSG = 'Nonascending Geomechanical Boundary Condition '
     &        // 'FE Nodal Domain Indices'
            CALL WRMSGP( INDX )
          ENDIF
          IF( I1X.LT.1 .OR. I2X.GT.LFX+1. OR. J1X.LT.1 .OR.
     &      J2X.GT.LFY+1 .OR. K1X.LT.1 .OR. K2X.GT.LFZ+1 ) THEN
            INDX = 4
            CHMSG = 'Illegal Geomechanical Boundary Condition ' // 
     &        'FE Nodal Domain'
            CALL WRMSGP( INDX )
          ENDIF
        ENDIF
!
!---  Read number of geomechanical boundary times  ---
!
        VARB = 'Number of Geomechanical Boundary Condition Times'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IBCMX)
        IF( IBCMX.LE.-3 ) THEN
          IBCCX = 1
          IBCMX = -IBCMX
        ELSEIF( IBCMX.GE.1 ) THEN
          IBCCX = 0
        ELSEIF( IBCMX.EQ.0 ) THEN
          INDX = 4
          CHMSG = 'No Boundary Condition Times'
          CALL WRMSGP( INDX )
        ELSE
          INDX = 4
          CHMSG = 'Number of Cyclic Boundary Conditions Times < 3'
          CALL WRMSGP( INDX )
        ENDIF
        LBTM_GM = MAX( LBTM_GM,IBCMX )
!
!---    Skip over the geomechanical boundary condition variables 
!       and units  ---
!
        DO 100 NTM = 1,IBCMX
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
!
!---      Check for external geomechanical boundary condition 
!         time file  ---
!
          IF( NTM.EQ.1 ) CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,CDUM)
          CALL L_CASE( CDUM )
          IF( INDEX(CDUM(1:),'file').NE.0 ) GOTO 110
  100   CONTINUE
  110   CONTINUE
!
!---    Compute the number of geomechanical boundary FE nodes  ---
!
        NBC = NBC + (K2X-K1X+1)*(J2X-J1X+1)*(I2X-I1X+1)
        LBC_GM = MAX( LBC_GM,NBC )
        IF( INDEX(ADUM(1:),'file').NE.0 ) CLOSE(UNIT=27)
  400 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_GMBC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_IC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Initial Conditions Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 25 August 2020.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_IC'
!
!---  Assign card string  ---
!
      CARD = 'Initial Conditions Card'
!
!---  Read saturation initial condition option ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Initial Saturation Option'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      NLIN = 0
      IF( INDEX(ADUM(1:),'hydrostatic').NE.0 .AND.
     &  INDEX(ADUM(1:),'geothermal').NE.0 .AND.
     &  INDEX(ADUM(1:),'zone').NE.0 ) THEN
        VARB = 'Number of Hydrostatic Geothermal Zonal Lines'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN )
      ENDIF
      LINC = MAX( LINC,10*NLIN )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_IC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_INPL( CHDUM )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read input line.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, November 10, 1999.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE FILES
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_INPL'
!
!---  Skip input lines that begin with '#' or '!'  ---
!
   10 READ(IRD,'(A)') CHDUM
      IF( CHDUM(1:1).EQ.'#' .OR. CHDUM(1:1).EQ.'!' ) GOTO 10
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_INPL group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_INT( ISTART,ICOMMA,CHDUM,IVAR )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Fill integer variable IVAR with data between commas.
!     Return default value or zero for null entries.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNNL, November 1992.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*(*) CHDUM
      CHARACTER*4 FORM1
!
!----------------------Data Statements---------------------------------!
!
      SAVE FORM1
      DATA FORM1 /'(I )'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_INT'
      IDFLTD = 0
      ICD = INDEX( CARD,'  ')-1
      IVR = INDEX( VARB,'  ')-1
!
!---  End of card record error ---
!
      IF( CHDUM(1:1) .EQ. '~' ) THEN
        INDX = 4
        CHMSG = 'End of Card Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read numbers between commas  ---
!
      ICOMMA = INDEX (CHDUM(ISTART:), ',') + ISTART - 1
      ISTOP = ICOMMA
  100 CONTINUE
!
!---  Comma not found, missing integer data  ---
!
      IF( ISTOP.LT.ISTART ) THEN
        INDX = 4
        CHMSG = 'Missing Integer Record: ' // VARB(1:IVR)
        CALL WRMSGP( INDX )
!
!---  Null entry  ---
!
      ELSEIF( ISTOP.EQ.ISTART ) THEN
        IF( IDFLT .EQ. 0 ) THEN
          IVAR = 0
          IDFLTD = 1
        ENDIF
        ISTART = ICOMMA + 1
        ICOMMA = ISTART
!
!---  Characters between commas  ---
!
      ELSE
!
!---  Eliminate leading blank spaces  ---
!
        IF( ICHAR(CHDUM(ISTART:ISTART)).EQ.32 ) THEN
          ISTART = ISTART+1
          GOTO 100
        ENDIF
!
!---  Eliminate trailing blank spaces  ---
!
        ISTOP = ISTOP-1
  110   CONTINUE
        IF( ICHAR(CHDUM(ISTOP:ISTOP)).EQ.32 ) THEN
          ISTOP = ISTOP-1
          GOTO 110
        ENDIF
!
!---  Check for non-numerical characters  ---
!
        DO 120 N = ISTART,ISTOP
          NC = ICHAR(CHDUM(N:N))
          IF( N.EQ.ISTART .AND. ( NC.EQ.43 .OR. NC.EQ.45 ) ) GOTO 120
          IF( NC.LT.48 .OR. NC.GT.57 ) THEN
            INDX = 4
            CHMSG = 'Integer Format: Nonnumeric Character: ' //
     &        VARB(1:IVR) // ': ' // CHDUM(ISTART:ISTOP)
            CALL WRMSGP(INDX)
          ENDIF
  120   CONTINUE
!
!---  Translate character string into an integer  ---
!
        NCHR = ISTOP-ISTART+1
        IF( NCHR.LT.10 ) THEN
          WRITE( FORM1(3:3),'(I1)' ) NCHR
          READ( CHDUM(ISTART:ISTOP),FORM1 ) IVAR
        ELSE
          INDX = 4
          CHMSG = 'Excessive Length Integer Record: ' //
     &      VARB(1:IVR) // ': ' // CHDUM(ISTART:ISTOP)
          CALL WRMSGP( INDX )
        ENDIF
        ISTART = ICOMMA + 1
      ENDIF
      IDFLT = 0
!
!---  End of RD_INT group  ---
!
      ISUB_LOG = ISUB_LOG-1
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_GCP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Gas Components Properties Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 27 November 2007.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_GCP'
!
!---  Assign card string  ---
!
      CARD = 'Gas Components Properties Card'
!
!---  Read number of gas components  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Gas Components'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NGC)
      LNGC = MAX( LNGC,NGC )
      LUK = LUK + LNGC
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_GCP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_GRID
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Grid Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 21 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,UNTS
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_GRID'
!
!---  Assign card string  ---
!
      CARD = 'Grid Card'
!
!---  Read coordinate system type  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Coordinate System'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      IF( INDEX(ADUM(1:),'tilted').NE.0 ) THEN
        ICS = 1
        VARB = 'X-Z Plane Horizontal Tilt'
        CALL RD_DPR(ISTART,ICOMMA,CHDUM,THXZ)
        VARB = 'X-Z Plane Horizontal Tilt Units'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
        INDX = 0
        CALL RD_UNIT(UNTS,THXZ,INDX)
        VARB = 'Y-Z Plane Horizontal Tilt'
        CALL RD_DPR(ISTART,ICOMMA,CHDUM,THYZ)
        VARB = 'Y-Z Plane Horizontal Tilt Units'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
        INDX = 0
        CALL RD_UNIT(UNTS,THYZ,INDX)
      ELSEIF( INDEX(ADUM(1:),'cartesian').NE.0 ) THEN
        IF( INDEX(ADUM(1:),'uniform').NE.0 ) THEN
          ICS = 5
        ELSE
          ICS = 1
        ENDIF
      ELSEIF( INDEX(ADUM(1:),'cylindrical').NE.0 ) THEN
        IF( INDEX(ADUM(1:),'uniform').NE.0 ) THEN
          ICS = 6
        ELSE
          ICS = 2
        ENDIF
      ELSEIF( INDEX(ADUM(1:),'boundary').NE.0 .OR.
     &  INDEX(ADUM(1:),'fitted').NE.0  .OR.
     &  INDEX(ADUM(1:),'orthogonal').NE.0 ) THEN
        ICS = 3
      ELSEIF( INDEX(ADUM(1:),'eclipse').NE.0 .AND.
     &  INDEX(ADUM(1:),'generic').NE.0 ) THEN
        ICS = 7
      ELSEIF( INDEX(ADUM(1:),'earthvision').NE.0 .AND.
     &  INDEX(ADUM(1:),'sampled').NE.0 ) THEN
        ICS = 8
      ELSEIF( INDEX(ADUM(1:),'element').NE.0 .AND.
     &  INDEX(ADUM(1:),'vertices').NE.0 ) THEN
        ICS = 9
      ELSEIF( INDEX(ADUM(1:),'kij').NE.0 .AND.
     &  INDEX(ADUM(1:),'vertices').NE.0 ) THEN
        ICS = 11
      ELSEIF( INDEX(ADUM(1:),'jki').NE.0 .AND.
     &  INDEX(ADUM(1:),'vertices').NE.0 ) THEN
        ICS = 12
      ELSEIF( INDEX(ADUM(1:),'ijk').NE.0 .AND.
     &  INDEX(ADUM(1:),'vertices').NE.0 ) THEN
        ICS = 13
      ELSEIF( INDEX(ADUM(1:),'kji').NE.0 .AND.
     &  INDEX(ADUM(1:),'vertices').NE.0 ) THEN
        ICS = 14
      ELSEIF( INDEX(ADUM(1:),'gsf').NE.0 .AND.
     &  INDEX(ADUM(1:),'unstructured').NE.0 ) THEN
        ICS = 15
      ELSEIF( INDEX(ADUM(1:),'modflow').NE.0 .AND.
     &  INDEX(ADUM(1:),'discret').NE.0 ) THEN
        ICS = 16
      ELSEIF( INDEX(ADUM(1:),'avs').NE.0 .AND.
     &  INDEX(ADUM(1:),'ascii').NE.0 .AND.
     &  INDEX(ADUM(1:),'ucd').NE.0 ) THEN
        ICS = 17
      ELSE
        INDX = 4
        CHMSG = 'Unrecognized Coordinate System Type: ' // ADUM
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read coordinate system node dimensions  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of I-indexed Nodes'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LFX)
      IF( LFX.LT.1 ) THEN
        INDX = 4
        CHMSG = 'LFX < 1'
        CALL WRMSGP( INDX )
      ENDIF
      VARB = 'Number of J-indexed Nodes'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LFY)
      IF( LFY.LT.1 ) THEN
        INDX = 4
        CHMSG = 'LFY < 1'
        CALL WRMSGP( INDX )
      ENDIF
      VARB = 'Number of K-indexed Nodes'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LFZ)
      IF( LFZ.LT.1 ) THEN
        INDX = 4
        CHMSG = 'LFZ < 1'
        CALL WRMSGP( INDX )
      ENDIF
      LAD = 0
      IF( LFX.GT.1 ) LAD = LAD+1
      IF( LFY.GT.1 ) LAD = LAD+1
      IF( LFZ.GT.1 ) LAD = LAD+1
      LAD = MAX( LAD,1 )
      LAN = LFX*LFY*LFZ
      LFXY = LFX*LFY
      LFYZ = LFY*LFZ
      LFZX = LFZ*LFX
      LFD = LFX*LFY*LFZ
      LSTC = 2*LAD+1
!
!---  Read MPI processor counts  ---
!
      IF( ISLC(67).EQ.1 ) THEN
        VARB = 'Number of I-indexed Processors'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,LPX_MPI)
        IF( LPX_MPI.GT.LFX  ) THEN
          INDX = 4
          CHMSG = 'LPX_MPI > LFX'
          CALL WRMSGP( INDX )
        ENDIF
        VARB = 'Number of J-indexed Processors'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,LPY_MPI)
        IF( LPY_MPI.GT.LFY  ) THEN
          INDX = 4
          CHMSG = 'LPY_MPI > LFY'
          CALL WRMSGP( INDX )
        ENDIF
        VARB = 'Number of K-indexed Processors'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,LPZ_MPI)
        IF( LPZ_MPI.GT.LFZ  ) THEN
          INDX = 4
          CHMSG = 'LPZ_MPI > LFZ'
          CALL WRMSGP( INDX )
        ENDIF
        LP_MPI = LPX_MPI*LPY_MPI*LPZ_MPI
        IF( LPX_MPI.EQ.1 ) THEN
          LFX_MPI = LFX
        ELSEIF( MOD(LFX,LPX_MPI).EQ.0 ) THEN
          LFX_MPI = LFX/LPX_MPI
        ELSE
          LFX_MPI = LFX/LPX_MPI + 1
        ENDIF
        IF( LPY_MPI.EQ.1 ) THEN
          LFY_MPI = LFY
        ELSEIF( MOD(LFY,LPY_MPI).EQ.0 ) THEN
          LFY_MPI = LFY/LPY_MPI
        ELSE
          LFY_MPI = LFY/LPY_MPI + 1
        ENDIF
        IF( LPZ_MPI.EQ.1 ) THEN
          LFZ_MPI = LFZ
        ELSEIF( MOD(LFZ,LPZ_MPI).EQ.0 ) THEN
          LFZ_MPI = LFZ/LPZ_MPI
        ELSE
          LFZ_MPI = LFZ/LPZ_MPI + 1
        ENDIF
      ENDIF
!
!---  Allocate memory for the grid geometry arrays  ---
!
      ALLOCATE( XE(1:8,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XE'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( YE(1:8,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YE'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( ZE(1:8,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZE'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( XP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XP'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( YP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YP'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( ZP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZP'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the internal boundary conditions  ---
!
      ALLOCATE( INBS(1:8,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: INBS'
        CALL WRMSGP( INDX )
      ENDIF
      DO M0 = 1,8
        DO M1 = 1,LFD
          INBS(M0,M1) = 0
        ENDDO
      ENDDO
!
!---  Allocate memory for the inactive nodes array  ---
!
      ALLOCATE( IXP(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IXP'
        CALL WRMSGP( INDX )
      ENDIF
      DO M0 = 1,LFD
        IXP(M0) = 0
      ENDDO
!
!---  Allocate memory for the i-index nodes array  ---
!
      ALLOCATE( ID(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ID'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the j-index nodes array  ---
!
      ALLOCATE( JD(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: JD'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the k-index nodes array  ---
!
      ALLOCATE( KD(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: KD'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the node index array  ---
!
      ALLOCATE( ND(1:LFX,1:LFY,1:LFZ),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ND'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the block refinement pointers  ---
!
      ALLOCATE( IBR(1:5,1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IBR'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Define the grid pointers  ---
!
      DO 130 K = 1,LFZ
        DO 120 J = 1,LFY
          DO 110 I = 1,LFX
            N = (K-1)*LFXY + (J-1)*LFX + I
            ID(N) = I
            JD(N) = J
            KD(N) = K
            ND(I,J,K) = N
            IBR(1,N) = 0
            IBR(2,N) = 0
            IBR(3,N) = 0
            IBR(4,N) = N
            IBR(5,N) = N
  110     CONTINUE
  120   CONTINUE
  130 CONTINUE
!
!---  Minimum band width parameter according
!     to solver type; parameter LMNP will be reset
!     for coupled wells  ---
!

!
!---  Define active nodes assuming no inactive nodes  ---
!
      NC = 1
      IF( LFXY.LE.LFYZ .AND. LFXY.LE.LFZX ) THEN
!
!---  X-Y Plane yields the lowest band width.
!---  Load Jacobian matrix in the increment order I,J,K
!
        DO 230 K = 1,LFZ
          DO 220 J = 1,LFY
            DO 210 I = 1,LFX
              N = (K-1)*LFXY + (J-1)*LFX + I
              IXP(N) = NC
              NC = NC+1
  210       CONTINUE
  220     CONTINUE
  230   CONTINUE
      ELSEIF( LFYZ.LE.LFXY .AND. LFYZ.LE.LFZX ) THEN
!
!---  Y-Z Plane yields the lowest band width.
!---  Load Jacobian matrix in the increment order J,K,I
!
        DO 330 I = 1,LFX
          DO 320 K = 1,LFZ
            DO 310 J = 1,LFY
              N = (K-1)*LFXY + (J-1)*LFX + I
              IXP(N) = NC
              NC = NC+1
  310       CONTINUE
  320     CONTINUE
  330   CONTINUE
      ELSEIF( LFZX.LE.LFXY .AND. LFZX.LE.LFYZ ) THEN
!
!---  Z-X Plane yields the lowest band width.
!---  Load Jacobian matrix in the increment order K,I,J
!
        DO 430 J = 1,LFY
          DO 420 I = 1,LFX
            DO 410 K = 1,LFZ
              N = (K-1)*LFXY + (J-1)*LFX + I
              IXP(N) = NC
              NC = NC+1
  410       CONTINUE
  420     CONTINUE
  430   CONTINUE
      ENDIF
!
!---  Variable grid spacing  ---
!
      IF( ICS.EQ.1 .OR. ICS.EQ.2 ) THEN
        CALL RD_VBLGRID
!
!---  Uniform grid spacing  ---
!
      ELSEIF( ICS.EQ.5 .OR. ICS.EQ.6 ) THEN
        CALL RD_UNFGRID
!
!---  ECLIPSE formatted grids  ---
!
      ELSEIF( ICS.EQ.7 ) THEN
        CALL RD_ECLGRID
!
!---  Grids defined through hexahedral vertices  ---
!
      ELSEIF( ICS.EQ.3 .OR. ICS.EQ.8 ) THEN
        CALL RD_HEXGRID

!---  Grids defined through hexahedral elements and vertices  ---
!
      ELSEIF( ICS.EQ.9 ) THEN
        CALL RD_ELMGRID
!
!---  Grids defined through a listing of x, y, and z-vertices,
!     for vertices ordered kij  ---
!
      ELSEIF( ICS.EQ.11 ) THEN
        CALL RDKIJ_VERT
!
!---  Grids defined through a listing of x, y, and z-vertices,
!     for vertices ordered jki  ---
!
      ELSEIF( ICS.EQ.12 ) THEN
        CALL RDJKI_VERT
!
!---  Grids defined through a listing of x, y, and z-vertices,
!     for vertices ordered ijk  ---
!
      ELSEIF( ICS.EQ.13 ) THEN
        CALL RDIJK_VERT
!
!---  Grids defined through a listing of x, y, and z-vertices,
!     for vertices ordered kji  ---
!
      ELSEIF( ICS.EQ.14 ) THEN
        CALL RDKJI_VERT
!
!---  Grids defined via MODFLOW, exported as a Grid Specification
!     File (*.gsf)  ---
!
      ELSEIF( ICS.EQ.15 ) THEN
        CALL RD_GSF
!
!---  Grids defined via LaGrit AVS ASCII UCD file  ---
!
      ELSEIF( ICS.EQ.17 ) THEN
        CALL RD_AVSUCD
!
!---  Grids defined through a MODFLOW Discretization file (*.dis)  ---
!
      ELSEIF( ICS.EQ.16 ) THEN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        INDX = 0
        VARB = 'X Reference Point'
        CALL RD_DPR(ISTART,ICOMMA,CHDUM,XREFX)
        VARB = 'X Reference Point Units'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
        IUNM = 1
        CALL RD_UNIT( UNTS,XREFX,INDX )
        VARB = 'Y Reference Point'
        CALL RD_DPR(ISTART,ICOMMA,CHDUM,YREFX)
        VARB = 'Y Reference Point Units'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
        VARB = 'Y-Direction Distance from Reference Point'
        IUNM = 1
        CALL RD_UNIT( UNTS,YREFX,INDX )
        CALL RD_MFDIS( XREFX,YREFX )
      ENDIF
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_GRID group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_GRP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Gas Relative Permeability Function Parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 11 December 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TABL
      USE SOLTN
      USE PORMED
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,RDUM
      CHARACTER*512 CHDUM
      TYPE(LIST_NODE), POINTER :: LOC_PTR
      TYPE(LIST_SCALING), POINTER :: SC_LOC_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_GRP'
!
!---  Assign card string  ---
!
      CARD = 'Gas Relative Permeability Card'
!
!---  Loop over the rock/soil gas relative permeability
!     information lines  ---
!
      N = 0
      IJK = 0
   10 CONTINUE
      IF( N.GE.NROCK .OR. IJK.GT.0 ) GOTO 500
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Rock/Soil Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,RDUM)
!
!---  Check for a pair of delimiting slashes in the rock/soil name,
!     indicating a pattern of rock/soil types  ---
!
      KBS = 0
      IBS = INDEX( RDUM(1:),'/' )
      IF( IBS.GT.0 ) THEN
        IBS = IBS + 1
        JBS = INDEX( RDUM(IBS:),'/')
        IF( JBS.GT.0 ) THEN
          JBS = IBS + JBS - 2
          KBS = 1
          ISBS = ISTART
        ENDIF
      ENDIF
      IROCK = 1
   20 CONTINUE
!
!---  IJK, KIJ, or JKI indexing  ---
!
      IF( INDEX(RDUM(1:),'indexing').NE.0 ) THEN
        IF( INDEX(RDUM,'ijk').NE.0 ) THEN
          IJK = 1
        ELSEIF( INDEX(RDUM,'jki').NE.0 ) THEN
          IJK = 2
        ELSEIF( INDEX(RDUM,'kij').NE.0 ) THEN
          IJK = 3
        ELSE
          INDX = 4
          CHMSG = 'Unrecognized Indexing Option' // RDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        IROCK = 1
        GOTO 220
      ENDIF
!
!---  Search known rock types for a matching type  ---
!
          LOC_PTR => ROCK_PTR
          IROCK = 0
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IROCK = IROCK + 1
            IF( LOC_PTR%LIST_NAME == RDUM ) THEN
              GOTO 200
            ELSE
              LOC_PTR => LOC_PTR%NEXT
            ENDIF
          ENDDO
!
!---  Search known scaling groups for a matching type  ---
!
        IF( ISLC(19).EQ.1 ) THEN
          SC_LOC_PTR => SCALING_PTR
          ISGRP = 0
          DO
            IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
            IF( SC_LOC_PTR%SCALING_NAME == RDUM ) THEN
              ISGRP = SC_LOC_PTR%SCALING_NUM
              IROCK = 1
              GOTO 200
            ELSE
              SC_LOC_PTR => SC_LOC_PTR%NEXT
            ENDIF
          ENDDO
          INDX = 2
          CHMSG = 'Unrecognized Rock/Soil Type or Scaling Group: '
     &      // RDUM(1:NCH)
          CALL WRMSGP( INDX )
          GOTO 10
        ENDIF
        INDX = 2
        CHMSG = 'Unrecognized Rock/Soil Type: ' // RDUM(1:NCH)
        CALL WRMSGP( INDX )
        GOTO 10
  200   CONTINUE
!
!---  Loop over rock/soils within scaling group  ---
!
        IF( ISLC(19).EQ.1 .AND. ISGRP.NE.0 ) THEN
          DO 202 M = IROCK,NROCK
            IF( ISCALE(M).EQ.ISGRP ) THEN
              IROCK = M
              GOTO 204
            ENDIF
  202     CONTINUE
        ENDIF
  204   CONTINUE
!
!---  Read gas relative permeability pressure function  ---
!
  220 CONTINUE
      N = N + 1
!
!---  Read saturation/capillary pressure function for
!     tabular forms  ---
!
      VARB = 'Gas Relative Permeability Function'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---    Tabular (relative permeability versus liquid saturation)  ---
!
      IF( INDEX(ADUM(1:),'tabular') .NE. 0 ) THEN
        IF( INDEX( ADUM(1:),'spline' ).NE.0 ) THEN
          IRPGX = 11
        ELSE
          IRPGX = 10
        ENDIF
!
!---    IJK Indexing  ---
!
        IF( IJK.GT.0 ) THEN
          VARB = 'Number of Tables'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NTABX)
          NTBL = 0
          DO 240 NTX = 1,NTABX
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            VARB = 'Number of Table Entries'
            CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
            IF( NLIN.LT.2 ) THEN
              INDX = 4
              CHMSG = 'Invalid Gas Relative Permeability Table'
              CALL WRMSGP( INDX )
            ENDIF
            NTBL = NTBL + NLIN
            DO 230 NLX = 1,NLIN
              CALL RD_INPL( CHDUM )
  230       CONTINUE
  240     CONTINUE
          LTBL = LTBL + NTBL
        ELSE
          VARB = 'Number of Tabular Entries'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
          IF( NLIN.LT.2 ) THEN
            INDX = 4
            CHMSG = 'Invalid Gas Relative Permeability Table'
            CALL WRMSGP( INDX )
          ENDIF
          DO 250 NL = 1,NLIN
            CALL RD_INPL( CHDUM )
 250      CONTINUE
          IF( IJK.GT.0 ) THEN
            NTBL = LFD*NLIN
          ELSE
            NTBL = NLIN
          ENDIF
          LTBL = LTBL + NTBL
        ENDIF
      ENDIF
!
!---  Continue reading rock/soil type names for a pattern match  ---
!
      IF( KBS.EQ.1 .AND. IROCK.LT.NROCK ) THEN
        IROCK = IROCK + 1
        ISTART = ISBS
        GOTO 20
      ENDIF
!
!---  Loop over remaining rock/soils within scaling group  ---
!
      IF( ISLC(19).EQ.1 .AND. IROCK.LT.NROCK ) THEN
        DO 490 M = IROCK+1,NROCK
          IF( ISCALE(M).EQ.ISGRP ) THEN
            N = N+1
          ENDIF
  490   CONTINUE
      ENDIF
!
!---  Read next rock/soil type or scaling group  ---
!
      GOTO 10
 500  CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_GRP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_GSF
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read grid defined via MODFLOW, exported as a Grid Specification
!     File (*.gsf)
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 24 April 2019.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VERTX,VERTY,VERTZ
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: IVERT
      INTEGER JVERT(8)
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_GSF'
!
!---  Read GSF file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'GSF File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing GSF File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'GSF File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Read length units  ---
!      
      VARB = 'Grid Coordinate System Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      IUNM = 1
      INDX = 0
      VARX = 1.D+0
      CALL RD_UNIT( UNTS,VARX,INDX )
!
!---  Read file, skipping comment lines  ---
!
      DO
        READ(9,*) CHDUM
        IF( CHDUM(1:1).EQ.'#' .OR. CHDUM(1:1).EQ.'!' ) CYCLE
        BACKSPACE(9)
        EXIT
      ENDDO
!
!---  Read mesh type ---
!
      READ(9,*) CHDUM
      CALL L_CASE( CHDUM )
      IF( INDEX(CHDUM(1:),'unstructured').EQ.0 ) THEN
        INDX = 4
        CHMSG = 'Unrecognized GSF Grid Type'
        CALL WRMSGP( INDX )        
      ENDIF
!
!---  Read number of nodes, layers, iz, and ic ---
!
      READ(9,*) NFLDX,KFLDX,IZX,ICX
      IF( NFLDX.NE.LFX*LFY*LFZ ) THEN
        INDX = 7
        IMSG = NFLDX
        CHMSG = 'Number of Nodes in GSF File'
        CALL WRMSGP( INDX )        
      ENDIF
!
!---  Read number of vertices ---
!
      READ(9,*) NVERTX
!
!---  Check number of vertices  ---
!
      IFLDX = LFX + 1
      JFLDX = LFY + 1
      KFLDX = LFZ + 1
      IF( IFLDX*JFLDX*KFLDX.NE.NVERTX ) THEN
        INDX = 7
        IMSG = NVERTX
        CHMSG = 'Number of Vertices in GSF File'
        CALL WRMSGP( INDX )        
      ENDIF
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VERTX(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTY(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTZ(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( IVERT(1:8,1:LFX*LFY*LFZ),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IVERT'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read x-, y-, and z-vertices from file, in MODFLOW
!     or GSF node order  ---
!
      DO N = 1,IFLDX*JFLDX*KFLDX
        READ(9,*) VERTX(N),VERTY(N),VERTZ(N)
      ENDDO
!
!---  Read node vertices  ---
!
      DO N = 1,LFX*LFY*LFZ
        READ(9,*) NX,XPX,YPX,ZPX,NLAY,NVERT,(JVERT(M),M=1,8)
        DO M = 1,8
          IVERT(M,NX) = JVERT(M)
        ENDDO
      ENDDO
!
!---  Loop over nodes, assigning STOMP vertices  ---
!
      NC = 0
      DO K = LFZ,1,-1
        DO J = LFY,1,-1
          DO I = 1,LFX
            NC = NC + 1
            N = ND(I,J,K)
            M = IVERT(2,NC)
            XE(1,N) = VERTX(M)*VARX
            YE(1,N) = VERTY(M)*VARX
            ZE(1,N) = VERTZ(M)*VARX
            M = IVERT(3,NC)
            XE(2,N) = VERTX(M)*VARX
            YE(2,N) = VERTY(M)*VARX
            ZE(2,N) = VERTZ(M)*VARX
            M = IVERT(1,NC)
            XE(3,N) = VERTX(M)*VARX
            YE(3,N) = VERTY(M)*VARX
            ZE(3,N) = VERTZ(M)*VARX
            M = IVERT(4,NC)
            XE(4,N) = VERTX(M)*VARX
            YE(4,N) = VERTY(M)*VARX
            ZE(4,N) = VERTZ(M)*VARX
            M = IVERT(6,NC)
            XE(5,N) = VERTX(M)*VARX
            YE(5,N) = VERTY(M)*VARX
            ZE(5,N) = VERTZ(M)*VARX
            M = IVERT(7,NC)
            XE(6,N) = VERTX(M)*VARX
            YE(6,N) = VERTY(M)*VARX
            ZE(6,N) = VERTZ(M)*VARX
            M = IVERT(5,NC)
            XE(7,N) = VERTX(M)*VARX
            YE(7,N) = VERTY(M)*VARX
            ZE(7,N) = VERTZ(M)*VARX
            M = IVERT(8,NC)
            XE(8,N) = VERTX(M)*VARX
            YE(8,N) = VERTY(M)*VARX
            ZE(8,N) = VERTZ(M)*VARX
          ENDDO
        ENDDO
      ENDDO
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VERTX) ) THEN
      DEALLOCATE( VERTX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTY) ) THEN
      DEALLOCATE( VERTY,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTZ) ) THEN
      DEALLOCATE( VERTZ,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(IVERT) ) THEN
      DEALLOCATE( IVERT,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: IVERT'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Closes Vertices File  ---
!
      CLOSE(UNIT=9)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_GSF group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_GSSP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read gas species.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 16 August 2005.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*64 ADUM
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_GSSP'
!
!---  Assign card string  ---
!
      CARD = 'Gas Species Card'
!
!---  Read number of equilibrium reactions  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Gas Species'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSPG)
      LSPG = MAX( LSPG,NSPG )
      NULLIFY( SPCG_PTR )
!
!---  Loop over the gas species  ---
!
      DO NSP = 1,NSPG
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Gas Species Name: '
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---    Empty gas species name list  ---
!
        IF( .NOT.ASSOCIATED(SPCG_PTR) ) THEN
          ALLOCATE( SPCG_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: SPCG_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          SPCG_PTR%LIST_NAME = ADUM
          NULLIFY(SPCG_PTR%NEXT)
!
!---    Established gas species name list  ---
!
        ELSE
          LOC_PTR => SPCG_PTR
!
!---      Check for repeated gas species name  ---
!
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
                IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                  INDX = 4
                  CHMSG = 'Duplicate Gas Species Name: ' // 
     &              ADUM(1:NCH)
                  CALL WRMSGP( INDX )
                ENDIF
            LOC_PTR => LOC_PTR%NEXT
          ENDDO
!
!---      Add gas species name to gas species list  ---
!
          ALLOCATE( TMP_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: SPCG_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          TMP_PTR%LIST_NAME = ADUM
          TMP_PTR%NEXT => SPCG_PTR
          SPCG_PTR => TMP_PTR
        ENDIF
      ENDDO
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_GSSP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_HEXGRID
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read hexahedral grid.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 1 December 2011.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:,:,:), ALLOCATABLE :: VX
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_HEXGRID'
!
!---  Read vertices file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Vertices File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing Vertices File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'Vertices File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
      READ(9,*) IFLDX,JFLDX,KFLDX
      IFLDZ = IFLDX
      JFLDZ = JFLDX
      KFLDZ = KFLDX
      IF(IFLDX.GT.1) IFLDZ = IFLDX-1
      IF(JFLDX.GT.1) JFLDZ = JFLDX-1
      IF(KFLDX.GT.1) KFLDZ = KFLDX-1
      IF( IFLDZ.NE.LFX .OR. JFLDZ.NE.LFY .OR. KFLDZ.NE.LFZ ) THEN
        INDX = 4
        CHMSG = 'Orthogonal Grid Dimension Conflict'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VX(1:IFLDX,1:JFLDX,1:KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VX'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read length units  ---
!
      VARB = 'Grid File Length Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      INDX = 0
      VARX = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX,INDX)
!
!---  Read x-vertices from file  ---
!
      IF( IFLDX.GT.1 ) THEN
        READ(9,*)(((VX(I,J,K),I=1,IFLDX),J=1,JFLDX),K=1,KFLDX)
!
!---    3D-xyz domain  ---
!
        IF( JFLDX.GT.1 .AND. KFLDX.GT.1 ) THEN
          DO K = 1,LFZ
          DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            XE(1,N) = VX(I,J,K)*VARX
            XE(2,N) = VX(I+1,J,K)*VARX
            XE(3,N) = VX(I,J+1,K)*VARX
            XE(4,N) = VX(I+1,J+1,K)*VARX
            XE(5,N) = VX(I,J,K+1)*VARX
            XE(6,N) = VX(I+1,J,K+1)*VARX
            XE(7,N) = VX(I,J+1,K+1)*VARX
            XE(8,N) = VX(I+1,J+1,K+1)*VARX
          ENDDO
          ENDDO
          ENDDO
!
!---    2D-xy domain, unit z dimension  ---
!
        ELSEIF( JFLDX.GT.1 ) THEN
          DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,1)
            XE(1,N) = VX(I,J,1)*VARX
            XE(2,N) = VX(I+1,J,1)*VARX
            XE(3,N) = VX(I,J+1,1)*VARX
            XE(4,N) = VX(I+1,J+1,1)*VARX
            XE(5,N) = VX(I,J,1)*VARX
            XE(6,N) = VX(I+1,J,1)*VARX
            XE(7,N) = VX(I,J+1,1)*VARX
            XE(8,N) = VX(I+1,J+1,1)*VARX
          ENDDO
          ENDDO
!
!---    2D-xz domain, unit y dimension  ---
!
        ELSEIF( KFLDX.GT.1 ) THEN
          DO K = 1,LFZ
          DO I = 1,LFX
            N = ND(I,1,K)
            XE(1,N) = VX(I,1,K)*VARX
            XE(2,N) = VX(I+1,1,K)*VARX
            XE(3,N) = VX(I,1,K)*VARX
            XE(4,N) = VX(I+1,1,K)*VARX
            XE(5,N) = VX(I,1,K+1)*VARX
            XE(6,N) = VX(I+1,1,K+1)*VARX
            XE(7,N) = VX(I,1,K+1)*VARX
            XE(8,N) = VX(I+1,1,K+1)*VARX
          ENDDO
          ENDDO
!
!---    1D-x domain  ---
!
        ELSE
          INDX = 4
          CHMSG = 'Single Dimensioned Orthogonal Grid'
          CALL WRMSGP( INDX )
        ENDIF
!
!---  2D-yz domain, unit x dimension  ---
!
      ELSE
        DO N = 1,LFD
          XE(1,N) = 0.D+0
          XE(2,N) = 1.D+0
          XE(3,N) = 0.D+0
          XE(4,N) = 1.D+0
          XE(5,N) = 0.D+0
          XE(6,N) = 1.D+0
          XE(7,N) = 0.D+0
          XE(8,N) = 1.D+0
        ENDDO
      ENDIF
!
!---  Read y-vertices from file  ---
!
      IF( JFLDX.GT.1 ) THEN
        READ(9,*)(((VX(I,J,K),I=1,IFLDX),J=1,JFLDX),K=1,KFLDX)
!
!---    3D-xyz domain  ---
!
        IF( IFLDX.GT.1 .AND. KFLDX.GT.1 ) THEN
          DO K = 1,LFZ
          DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            YE(1,N) = VX(I,J,K)*VARX
            YE(2,N) = VX(I+1,J,K)*VARX
            YE(3,N) = VX(I,J+1,K)*VARX
            YE(4,N) = VX(I+1,J+1,K)*VARX
            YE(5,N) = VX(I,J,K+1)*VARX
            YE(6,N) = VX(I+1,J,K+1)*VARX
            YE(7,N) = VX(I,J+1,K+1)*VARX
            YE(8,N) = VX(I+1,J+1,K+1)*VARX
          ENDDO
          ENDDO
          ENDDO
!
!---    2D-xy domain, unit z dimension  ---
!
        ELSEIF( IFLDX.GT.1 ) THEN
          DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,1)
            YE(1,N) = VX(I,J,1)*VARX
            YE(2,N) = VX(I+1,J,1)*VARX
            YE(3,N) = VX(I,J+1,1)*VARX
            YE(4,N) = VX(I+1,J+1,1)*VARX
            YE(5,N) = VX(I,J,1)*VARX
            YE(6,N) = VX(I+1,J,1)*VARX
            YE(7,N) = VX(I,J+1,1)*VARX
            YE(8,N) = VX(I+1,J+1,1)*VARX
          ENDDO
          ENDDO
!
!---    2D-yz domain, unit x dimension  ---
!
        ELSEIF( KFLDX.GT.1 ) THEN
          DO K = 1,LFZ
          DO J = 1,LFY
            N = ND(1,J,K)
            YE(1,N) = VX(1,J,K)*VARX
            YE(2,N) = VX(1,J,K)*VARX
            YE(3,N) = VX(1,J+1,K)*VARX
            YE(4,N) = VX(1,J+1,K)*VARX
            YE(5,N) = VX(1,J,K+1)*VARX
            YE(6,N) = VX(1,J,K+1)*VARX
            YE(7,N) = VX(1,J+1,K+1)*VARX
            YE(8,N) = VX(1,J+1,K+1)*VARX
          ENDDO
          ENDDO
!
!---    1D-y domain  ---
!
        ELSE
          INDX = 4
          CHMSG = 'Single Dimensioned Orthogonal Grid'
          CALL WRMSGP( INDX )
        ENDIF
!
!---  2D-xz domain, unit y dimension  ---
!
      ELSE
        DO N = 1,LFD
          YE(1,N) = 0.D+0
          YE(2,N) = 0.D+0
          YE(3,N) = 1.D+0
          YE(4,N) = 1.D+0
          YE(5,N) = 0.D+0
          YE(6,N) = 0.D+0
          YE(7,N) = 1.D+0
          YE(8,N) = 1.D+0
        ENDDO
      ENDIF
!
!---  Read z-vertices from file  ---
!
      IF( KFLDX.GT.1 ) THEN
        READ(9,*)(((VX(I,J,K),I=1,IFLDX),J=1,JFLDX),K=1,KFLDX)
!
!---    3D-xyz domain  ---
!
        IF( IFLDX.GT.1 .AND. JFLDX.GT.1 ) THEN
          DO K = 1,LFZ
          DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            ZE(1,N) = VX(I,J,K)*VARX
            ZE(2,N) = VX(I+1,J,K)*VARX
            ZE(3,N) = VX(I,J+1,K)*VARX
            ZE(4,N) = VX(I+1,J+1,K)*VARX
            ZE(5,N) = VX(I,J,K+1)*VARX
            ZE(6,N) = VX(I+1,J,K+1)*VARX
            ZE(7,N) = VX(I,J+1,K+1)*VARX
            ZE(8,N) = VX(I+1,J+1,K+1)*VARX
          ENDDO
          ENDDO
          ENDDO
!
!---    2D-yz domain, unit x dimension  ---
!
        ELSEIF( JFLDX.GT.1 ) THEN
          DO K = 1,LFZ
          DO J = 1,LFY
            N = ND(1,J,K)
            ZE(1,N) = VX(1,J,K)*VARX
            ZE(2,N) = VX(1,J,K)*VARX
            ZE(3,N) = VX(1,J+1,K)*VARX
            ZE(4,N) = VX(1,J+1,K)*VARX
            ZE(5,N) = VX(1,J,K+1)*VARX
            ZE(6,N) = VX(1,J,K+1)*VARX
            ZE(7,N) = VX(1,J+1,K+1)*VARX
            ZE(8,N) = VX(1,J+1,K+1)*VARX
          ENDDO
          ENDDO
!
!---    2D-xz domain, unit y dimension  ---
!
        ELSEIF( KFLDX.GT.1 ) THEN
          DO K = 1,LFZ
          DO I = 1,LFX
            N = ND(I,1,K)
            ZE(1,N) = VX(I,1,K)*VARX
            ZE(2,N) = VX(I+1,1,K)*VARX
            ZE(3,N) = VX(I,1,K)*VARX
            ZE(4,N) = VX(I+1,1,K)*VARX
            ZE(5,N) = VX(I,1,K+1)*VARX
            ZE(6,N) = VX(I+1,1,K+1)*VARX
            ZE(7,N) = VX(I,1,K+1)*VARX
            ZE(8,N) = VX(I+1,1,K+1)*VARX
          ENDDO
          ENDDO
!
!---    1D-z domain  ---
!
        ELSE
          INDX = 4
          CHMSG = 'Single Dimensioned Orthogonal Grid'
          CALL WRMSGP( INDX )
        ENDIF
!
!---  2D-xy domain, unit z dimension  ---
!
      ELSE
        DO N = 1,LFD
          ZE(1,N) = 0.D+0
          ZE(2,N) = 0.D+0
          ZE(3,N) = 0.D+0
          ZE(4,N) = 0.D+0
          ZE(5,N) = 1.D+0
          ZE(6,N) = 1.D+0
          ZE(7,N) = 1.D+0
          ZE(8,N) = 1.D+0
        ENDDO
      ENDIF
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VX) ) THEN
      DEALLOCATE( VX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Closes Vertices File  ---
!
      CLOSE(UNIT=9)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_HEXGRID group
!
      RETURN
      END
      
!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_INAC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Inactive Node Parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 22 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,BDUM,FDUM,FMDUM
      CHARACTER*512 CHDUM,CHDUMX
      TYPE(LIST_NODE), POINTER :: LOC_PTR
      REAL(KIND=DP), DIMENSION(:), ALLOCATABLE ::  IZ_TMP
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_INAC'
!
!---  Assign card string  ---
!
      CARD = 'Inactive Nodes Card'
!
!---  Read optional number of inactive node card entries, or
!     read first line of single entry  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Multiple Entries Switch'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      NDOM = 1
!
!---  Read boundary surface printing  ---
!
      IF( INDEX(ADUM,'boundary').NE.0 .AND.
     &  INDEX(ADUM,'surface').NE.0 ) THEN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Multiple Entries Switch'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      ENDIF
!
!---  Read number of multiple entries and first line
!     of first entry  ---
!
      IF( INDEX(ADUM,'multiple').NE.0 ) THEN
        VARB = 'Number of Entries'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NDOM)
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
      ENDIF
      DO 450 NDM = 1,NDOM
      ISTART = 1
!
!---  Read first line for more than one entry  ---
!
      IF( NDM.GT.1 ) THEN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
      ENDIF
      VARB = 'Input Option [Rock/Soil, Zonation File, File, Integer]'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---  Read inactive node information according to rock/soil type  ---
!
      IF( INDEX(ADUM,'rock').NE.0 .OR. INDEX(ADUM,'soil').NE.0 ) THEN
        VARB = 'Number of Rock/Soil Type Lines'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
        DO 60 L = 1,NLIN
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          VARB = 'Rock/Soil Name'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---  Search known rock types for a matching type ---
!
          LOC_PTR => ROCK_PTR
          IROCK = NROCK+1
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IROCK = IROCK - 1
            IF( LOC_PTR%LIST_NAME == ADUM ) THEN
              GOTO 40
            ELSE
              LOC_PTR => LOC_PTR%NEXT
            ENDIF
          ENDDO
          INDX = 2
          CHMSG = 'Unrecognized Rock/Soil Type: '//ADUM(1:NCH)
          CALL WRMSGP( INDX )
          GOTO 60
   40     CONTINUE
          DO 50 N = 1,LFD
            IF( IZ(N).EQ.IROCK ) THEN
              NXP = NXP + 1
              IXP(N) = 0
            ENDIF
   50     CONTINUE
   60   CONTINUE
!
!---    Read inactive node information from an
!       AVS ASCII UCD file  ---
!
      ELSEIF( INDEX(ADUM(1:),'avs').NE.0 .AND.
     &    INDEX(ADUM(1:),'ascii').NE.0 .AND.
     &    INDEX(ADUM(1:),'ucd').NE.0 ) THEN
!
!---    Dynamic memory allocation  ---
!
        ALLOCATE( IZ_TMP(1:LFD),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IZ_TMP'
          CALL WRMSGP( INDX )
        ENDIF
        VARB = 'AVS ASCII UCD File Name'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
        OPEN( UNIT=27,FILE=BDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
        REWIND( UNIT=27 )
!
!---    Read number of vertices and number of grid cells (nodes) ---
!
        READ(27,*) NVERTX,NFLDX
        DO N = 1,NVERTX
          READ(27,'(A)') CHDUMX
        ENDDO
        DO N = 1,NFLDX
          READ(27,'(A)') CHDUMX
          ISX = INDEX( CHDUMX(1:),' ' )
          IEX = INDEX( CHDUMX(1:),'hex' ) - 1
         READ(CHDUMX(ISX:IEX),*) IZ_TMP(N)
        ENDDO
        CLOSE(UNIT=27)
        DO N = 1,NFLDX
          IF( IZ_TMP(N).EQ.0 ) THEN
            NXP = NXP + 1
            IXP(N) = 0
          ENDIF
        ENDDO
        IF( ALLOCATED(IZ_TMP) ) THEN
          DEALLOCATE( IZ_TMP,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Deallocation Error: IZ_TMP'
            CALL WRMSGP( INDX )
          ENDIF
        ENDIF
!
!---  Read inactive node information from an external zonation file  ---
!
      ELSEIF( INDEX(ADUM,'zonation').NE.0 .AND.
     &  INDEX(ADUM,'file').NE.0 ) THEN
        VARB = 'Rock/soil zonation external file name'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(CHDUM,'formatted').NE.0 ) THEN
          OPEN( UNIT=27,FILE=ADUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
          READ(27,*)(IZ(N),N=1,LFD)
          CLOSE(UNIT=27)
        ELSE
          OPEN( UNIT=27,FILE=ADUM(1:NCH),STATUS='OLD',
     &      FORM='UNFORMATTED' )
          READ(27)(IZ(N),N=1,LFD)
          CLOSE(UNIT=27)
        ENDIF
        DO 70 N = 1,LFD
          IF( IZ(N).EQ.0 ) THEN
            NXP = NXP + 1
            IXP(N) = 0
          ENDIF
   70   CONTINUE
!
!---  Read inactive node information from an external file  ---
!
      ELSEIF( INDEX(ADUM,'file').NE.0 ) THEN
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        NCH = INDEX(ADUM,'  ')-1
        OPEN(UNIT=27, FILE=ADUM(1:NCH), STATUS='OLD', FORM='FORMATTED')
   80   CONTINUE
        READ(27,*,END=90) I,J,K
        IF( I.LT.1 .OR. I.GT.LFX .OR. J.LT.1 .OR. J.GT.LFY
     &    .OR. K.LT.1 .OR. K.GT.LFZ ) THEN
          INDX = 4
          CHMSG = 'Inactive Node Index Out of Range'
          CALL WRMSGP(INDX)
        ENDIF
        NXP = NXP + 1
        N = (K-1)*LFXY + (J-1)*LFX + I
        IXP(N) = 0
        GOTO 80
   90   CONTINUE
        CLOSE(UNIT=27)
!
!---  Read inactive node information from a GSF index file  ---
!
      ELSEIF( INDEX(ADUM,'gsf').NE.0 .AND.
     &  INDEX(ADUM,'indexing').NE.0 ) THEN
        VARB = 'GSF Indexing File Name'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
        INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
        IF( .NOT.FCHK ) THEN
          INDX = 4
          CHMSG = 'Missing GSF Indexing File: ' // FDUM(1:NCH)
          CALL WRMSGP( INDX )
        ELSEIF( FDUM.EQ.'unformatted' ) THEN
          INDX = 4
          CHMSG = 'GSF Indexing File Format: ' // FDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        OPEN( UNIT=27,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
        READ(27,*) CHDUMX
        DO NC = 1,LFD
          READ(27,*) ID1X,ID2X,KX,JX,IX,FX,IAX
          K = LFZ - KX + 1
          J = LFY - JX + 1
          I = IX
          N = (K-1)*LFXY + (J-1)*LFX + I
          IF( FX.GT.5.D-1 ) THEN
            IXP(N) = 1
          ELSE
            NXP = NXP + 1
            IXP(N) = 0
          ENDIF
        ENDDO
        CLOSE(UNIT=27)
      ELSE
!
!---  Read inactive node information from the input file  ---
!
        VARB = 'Number of Inactive Node Lines'
        ISTART = 1
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
        DO 400 NL = 1, NLIN
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          VARB = 'Inactive Node Domain Index'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I1)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I2)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J1)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J2)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K1)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K2)
          I1 = MAX( 1,I1 )
          I1 = MIN( I1,I2,LFX )
          I2 = MAX( 1,I1,I2 )
          I2 = MIN( I2,LFX )
          J1 = MAX( 1,J1 )
          J1 = MIN( J1,J2,LFY )
          J2 = MAX( 1,J1,J2 )
          J2 = MIN( J2,LFY )
          K1 = MAX( 1,K1 )
          K1 = MIN( K1,K2,LFZ )
          K2 = MAX( 1,K1,K2 )
          K2 = MIN( K2,LFZ )
          DO 300 K = K1,K2
            DO 200 J = J1,J2
              DO 100 I = I1,I2
                N = (K-1)*LFXY + (J-1)*LFX + I
                IF( IXP(N).NE.0 ) THEN
                  NXP = NXP + 1
                  IXP(N) = 0
                ENDIF
  100         CONTINUE
  200       CONTINUE
  300     CONTINUE
  400   CONTINUE
      ENDIF
  450 CONTINUE
!
!---  Redefine active nodes parameter ---
!
      LAN = LFD - NXP
      NC = 1
!
!---  X-Y Plane yields the lowest band width or
!     active surface spill nodes,
!---  load Jacobian matrix in the increment order I,J,K  ---
!
      IF( (LFXY.LE.LFYZ .AND. LFXY.LE.LFZX) .OR. LSPILL.EQ.1 ) THEN
        DO 530 K = 1,LFZ
          DO 520 J = 1,LFY
            DO 510 I = 1,LFX
              N = (K-1)*LFXY + (J-1)*LFX + I
              IF( IXP(N).NE.0 ) THEN
                IXP(N) = NC
                NC = NC+1
              ENDIF
  510       CONTINUE
  520     CONTINUE
  530   CONTINUE
!
!---  Y-Z Plane yields the lowest band width,
!---  load Jacobian matrix in the increment order J,K,I  ---
!
      ELSEIF( LFYZ.LE.LFXY .AND. LFYZ.LE.LFZX ) THEN
        DO 630 I = 1,LFX
          DO 620 K = 1,LFZ
            DO 610 J = 1,LFY
              N = (K-1)*LFXY + (J-1)*LFX + I
              IF( IXP(N).NE.0 ) THEN
                IXP(N) = NC
                NC = NC+1
              ENDIF
  610       CONTINUE
  620     CONTINUE
  630   CONTINUE
!
!---  Z-X Plane yields the lowest band width,
!---  load Jacobian matrix in the increment order K,I,J  ---
!
      ELSEIF( LFZX.LE.LFXY .AND. LFZX.LE.LFYZ ) THEN
        DO 730 J = 1,LFY
          DO 720 I = 1,LFX
            DO 710 K = 1,LFZ
              N = (K-1)*LFXY + (J-1)*LFX + I
              IF( IXP(N).NE.0 ) THEN
                IXP(N) = NC
                NC = NC+1
              ENDIF
  710       CONTINUE
  720     CONTINUE
  730   CONTINUE
      ENDIF
!
!---  Define upper active node for surface spills  ---
!
      KSPSX = 0
      IF( LSPILL.EQ.1 ) THEN
        DO 930 J = 1,LFX
          DO 920 I = 1,LFY
            DO 910 K = LFZ,1,-1
              N = (K-1)*LFXY + (J-1)*LFX + I
              IF( IXP(N).NE.0 ) THEN
                KSPSX = MAX( KSPSX,LFZ-K )
                GOTO 920
              ENDIF
  910       CONTINUE
  920     CONTINUE
  930   CONTINUE
!
!---    Reset minimum band width for inactive nodes below
!       spill surfaces  --
!



      ENDIF
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_INAC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_INAC_FRC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read inactive triangle fracture/faults.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 21 February 2023.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE GEOM_FRC
      USE FILES
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_INAC_FRC'
!
!---  Assign card string  ---
!
      CARD = 'Fracture/Fault Geometry Card'
!
!---  Read number of lines of inactive triangle entries   ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Number of Inactive Triangle Entries'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NLINES)
!
!---  Loop over number of inactive triangle entries  ---
!
      DO NL = 1,NLINES
        ISTART = 1
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        VARB = 'Fracture/Fault Number'
        CALL RD_INT( ISTART,ICOMMA,CHDUM,NFX )
        VARB = 'Triangle Number'
        CALL RD_INT( ISTART,ICOMMA,CHDUM,NTLX )
!
!---    Check fracture and triangle numbers  ---
!
        IF( NTLX.LT.1 .OR. NTLX.GT.IP_FRC(2,NFX) ) THEN
          INDX = 7
          CHMSG = 'Out-of-Range Fracture/Fault Triangle'
          IMSG = NTLX
          CALL WRMSGP( INDX )
        ELSE
          NTX = IP_FRC(1,NFX) + NTLX - 1
          IF( IXP_FRC(NTX).NE.0 ) THEN
            IXP_FRC(NTX) = 0
            NXP_FRC = NXP_FRC + 1
          ENDIF
        ENDIF
      ENDDO
!
!---  Parameter for number of inactive fracture/fault triangles  ---
!
      LXP_FRC = MAX( LXP_FRC,NXP_FRC )
!
!---  Renumber fracture triangle equation indexing for
!     inactive fracture triangles  ---
!
      NC = 0
      DO NFX = 1,NF_FRC
        DO NTX = IP_FRC(1,NFX),IP_FRC(2,NFX)
          IF( IXP_FRC(NTX).EQ.0 ) CYCLE
          NC = NC + 1
          IXP_FRC(NTX) = NC
        ENDDO
      ENDDO
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_INAC_FRC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RDIJK_VERT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read hexahedral grid as a list of vertices read in ijk ordering.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 26 July 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VERTX,VERTY,VERTZ
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RDIJK_VERT'
!
!---  Read vertices file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Vertices File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing IJK Vertices File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'IJK Vertices File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Number of lines of vertices  ---
!
      IFLDX = LFX + 1
      JFLDX = LFY + 1
      KFLDX = LFZ + 1
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VERTX(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTY(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTZ(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read length units  ---
!
      VARB = 'Grid File Length Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      INDX = 0
      VARX = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX,INDX)
!
!---  Read x-, y-, and z-vertices from file, in ijk order  ---
!
      DO N = 1,IFLDX*JFLDX*KFLDX
        READ(9,*) VERTX(N),VERTY(N),VERTZ(N)
      ENDDO
!
!---  Loop over nodes, assigning STOMP vertices  ---
!
      DO K = 1,LFZ
        DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            M = (K-1)*IFLDX*JFLDX + (J-1)*IFLDX + I
            XE(1,N) = VERTX(M)*VARX
            YE(1,N) = VERTY(M)*VARX
            ZE(1,N) = VERTZ(M)*VARX
            M = (K-1)*IFLDX*JFLDX + (J-1)*IFLDX + I + 1
            XE(2,N) = VERTX(M)*VARX
            YE(2,N) = VERTY(M)*VARX
            ZE(2,N) = VERTZ(M)*VARX
            M = (K-1)*IFLDX*JFLDX + J*IFLDX + I
            XE(3,N) = VERTX(M)*VARX
            YE(3,N) = VERTY(M)*VARX
            ZE(3,N) = VERTZ(M)*VARX
            M = (K-1)*IFLDX*JFLDX + J*IFLDX + I + 1
            XE(4,N) = VERTX(M)*VARX
            YE(4,N) = VERTY(M)*VARX
            ZE(4,N) = VERTZ(M)*VARX
            M = K*IFLDX*JFLDX + (J-1)*IFLDX + I
            XE(5,N) = VERTX(M)*VARX
            YE(5,N) = VERTY(M)*VARX
            ZE(5,N) = VERTZ(M)*VARX
            M = K*IFLDX*JFLDX + (J-1)*IFLDX + I + 1
            XE(6,N) = VERTX(M)*VARX
            YE(6,N) = VERTY(M)*VARX
            ZE(6,N) = VERTZ(M)*VARX
            M = K*IFLDX*JFLDX + J*IFLDX + I
            XE(7,N) = VERTX(M)*VARX
            YE(7,N) = VERTY(M)*VARX
            ZE(7,N) = VERTZ(M)*VARX
            M = K*IFLDX*JFLDX + J*IFLDX + I + 1
            XE(8,N) = VERTX(M)*VARX
            YE(8,N) = VERTY(M)*VARX
            ZE(8,N) = VERTZ(M)*VARX
          ENDDO
        ENDDO
      ENDDO
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VERTX) ) THEN
      DEALLOCATE( VERTX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTY) ) THEN
      DEALLOCATE( VERTY,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTZ) ) THEN
      DEALLOCATE( VERTZ,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Closes Vertices File  ---
!
      CLOSE(UNIT=9)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RDIJK_VERT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RDJKI_VERT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read hexahedral grid as a list of vertices read in jki ordering.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 26 July 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VERTX,VERTY,VERTZ
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RDJKI_VERT'
!
!---  Read vertices file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Vertices File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing JKI Vertices File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'JKI Vertices File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Number of lines of vertices  ---
!
      IFLDX = LFX + 1
      JFLDX = LFY + 1
      KFLDX = LFZ + 1
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VERTX(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTY(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTZ(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read length units  ---
!
      VARB = 'Grid File Length Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      INDX = 0
      VARX = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX,INDX)
!
!---  Read x-, y-, and z-vertices from file, in jki order  ---
!
      DO N = 1,IFLDX*JFLDX*KFLDX
        READ(9,*) VERTX(N),VERTY(N),VERTZ(N)
      ENDDO
!
!---  Loop over nodes, assigning STOMP vertices  ---
!
      DO K = 1,LFZ
        DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            M = (I-1)*JFLDX*KFLDX + (K-1)*JFLDX + J
            XE(1,N) = VERTX(M)*VARX
            YE(1,N) = VERTY(M)*VARX
            ZE(1,N) = VERTZ(M)*VARX
            M = I*JFLDX*KFLDX + (K-1)*JFLDX + J
            XE(2,N) = VERTX(M)*VARX
            YE(2,N) = VERTY(M)*VARX
            ZE(2,N) = VERTZ(M)*VARX
            M = (I-1)*JFLDX*KFLDX + (K-1)*JFLDX + J + 1
            XE(3,N) = VERTX(M)*VARX
            YE(3,N) = VERTY(M)*VARX
            ZE(3,N) = VERTZ(M)*VARX
            M = I*JFLDX*KFLDX + (K-1)*JFLDX + J + 1
            XE(4,N) = VERTX(M)*VARX
            YE(4,N) = VERTY(M)*VARX
            ZE(4,N) = VERTZ(M)*VARX
            M = (I-1)*JFLDX*KFLDX + K*JFLDX + J
            XE(5,N) = VERTX(M)*VARX
            YE(5,N) = VERTY(M)*VARX
            ZE(5,N) = VERTZ(M)*VARX
            M = I*JFLDX*KFLDX + K*JFLDX + J
            XE(6,N) = VERTX(M)*VARX
            YE(6,N) = VERTY(M)*VARX
            ZE(6,N) = VERTZ(M)*VARX
            M = (I-1)*JFLDX*KFLDX + K*JFLDX + J + 1
            XE(7,N) = VERTX(M)*VARX
            YE(7,N) = VERTY(M)*VARX
            ZE(7,N) = VERTZ(M)*VARX
            M = I*JFLDX*KFLDX + K*JFLDX + J + 1
            XE(8,N) = VERTX(M)*VARX
            YE(8,N) = VERTY(M)*VARX
            ZE(8,N) = VERTZ(M)*VARX
          ENDDO
        ENDDO
      ENDDO
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VERTX) ) THEN
      DEALLOCATE( VERTX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTY) ) THEN
      DEALLOCATE( VERTY,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTZ) ) THEN
      DEALLOCATE( VERTZ,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Closes Vertices File  ---
!
      CLOSE(UNIT=9)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RDJKI_VERT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RDKIJ_VERT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read hexahedral grid as a list of vertices read in kij ordering.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 26 July 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VERTX,VERTY,VERTZ
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RDKIJ_VERT'
!
!---  Read vertices file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Vertices File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing KIJ Vertices File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'KIJ Vertices File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Number of lines of vertices  ---
!
      IFLDX = LFX + 1
      JFLDX = LFY + 1
      KFLDX = LFZ + 1
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VERTX(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTY(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTZ(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read length units  ---
!
      VARB = 'Grid File Length Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      INDX = 0
      VARX = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX,INDX)
!
!---  Read x-, y-, and z-vertices from file, in kij order  ---
!
      DO N = 1,IFLDX*JFLDX*KFLDX
        READ(9,*) VERTX(N),VERTY(N),VERTZ(N)
      ENDDO
!
!---  Loop over nodes, assigning STOMP vertices  ---
!
      DO K = 1,LFZ
        DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            M = (J-1)*KFLDX + (I-1)*KFLDX + K
            XE(1,N) = VERTX(M)*VARX
            YE(1,N) = VERTY(M)*VARX
            ZE(1,N) = VERTZ(M)*VARX
            M = (J-1)*KFLDX*IFLDX + I*KFLDX*JFLDX + K
            XE(2,N) = VERTX(M)*VARX
            YE(2,N) = VERTY(M)*VARX
            ZE(2,N) = VERTZ(M)*VARX
            M = J*KFLDX*IFLDX + (I-1)*KFLDX + K
            XE(3,N) = VERTX(M)*VARX
            YE(3,N) = VERTY(M)*VARX
            ZE(3,N) = VERTZ(M)*VARX
            M = J*KFLDX*IFLDX + I*KFLDX + K
            XE(4,N) = VERTX(M)*VARX
            YE(4,N) = VERTY(M)*VARX
            ZE(4,N) = VERTZ(M)*VARX
            M = (J-1)*KFLDX*IFLDX + (I-1)*KFLDX + K + 1
            XE(5,N) = VERTX(M)*VARX
            YE(5,N) = VERTY(M)*VARX
            ZE(5,N) = VERTZ(M)*VARX
            M = (J-1)*KFLDX*IFLDX + I*KFLDX + K + 1
            XE(6,N) = VERTX(M)*VARX
            YE(6,N) = VERTY(M)*VARX
            ZE(6,N) = VERTZ(M)*VARX
            M = J*KFLDX*IFLDX + (I-1)*KFLDX + K + 1
            XE(7,N) = VERTX(M)*VARX
            YE(7,N) = VERTY(M)*VARX
            ZE(7,N) = VERTZ(M)*VARX
            M = J*KFLDX*IFLDX + I*KFLDX + K + 1
            XE(8,N) = VERTX(M)*VARX
            YE(8,N) = VERTY(M)*VARX
            ZE(8,N) = VERTZ(M)*VARX
          ENDDO
        ENDDO
      ENDDO
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VERTX) ) THEN
      DEALLOCATE( VERTX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTY) ) THEN
      DEALLOCATE( VERTY,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTZ) ) THEN
      DEALLOCATE( VERTZ,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Closes Vertices File  ---
!
      CLOSE(UNIT=9)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RDKIJ_VERT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RDKJI_VERT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read hexahedral grid as a list of vertices read in kji ordering.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 26 July 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VERTX,VERTY,VERTZ
      CHARACTER*64 FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      LOGICAL FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RDKJI_VERT'
!
!---  Read vertices file name  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Vertices File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing KJI Vertices File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'KJI Vertices File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Number of lines of vertices  ---
!
      IFLDX = LFX + 1
      JFLDX = LFY + 1
      KFLDX = LFZ + 1
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( VERTX(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTY(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ALLOCATE( VERTZ(1:IFLDX*JFLDX*KFLDX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read length units  ---
!
      VARB = 'Grid File Length Units'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      INDX = 0
      VARX = 1.D+0
      IUNM = 1
      CALL RD_UNIT(UNTS,VARX,INDX)
!
!---  Read x-, y-, and z-vertices from file, in kji order  ---
!
      DO N = 1,IFLDX*JFLDX*KFLDX
        READ(9,*) VERTX(N),VERTY(N),VERTZ(N)
      ENDDO
!
!---  Loop over nodes, assigning STOMP vertices  ---
!
      DO K = 1,LFZ
        DO J = 1,LFY
          DO I = 1,LFX
            N = ND(I,J,K)
            M = (I-1)*KFLDX*JFLDX + (J-1)*KFLDX + K
            XE(1,N) = VERTX(M)*VARX
            YE(1,N) = VERTY(M)*VARX
            ZE(1,N) = VERTZ(M)*VARX
            M = I*KFLDX*JFLDX + (J-1)*KFLDX + K
            XE(2,N) = VERTX(M)*VARX
            YE(2,N) = VERTY(M)*VARX
            ZE(2,N) = VERTZ(M)*VARX
            M = (I-1)*KFLDX*JFLDX + J*KFLDX + K
            XE(3,N) = VERTX(M)*VARX
            YE(3,N) = VERTY(M)*VARX
            ZE(3,N) = VERTZ(M)*VARX
            M = I*KFLDX*JFLDX + J*KFLDX + K
            XE(4,N) = VERTX(M)*VARX
            YE(4,N) = VERTY(M)*VARX
            ZE(4,N) = VERTZ(M)*VARX
            M = (I-1)*KFLDX*JFLDX + (J-1)*KFLDX + K + 1
            XE(5,N) = VERTX(M)*VARX
            YE(5,N) = VERTY(M)*VARX
            ZE(5,N) = VERTZ(M)*VARX
            M = I*KFLDX*JFLDX + (J-1)*KFLDX + K + 1
            XE(6,N) = VERTX(M)*VARX
            YE(6,N) = VERTY(M)*VARX
            ZE(6,N) = VERTZ(M)*VARX
            M = (I-1)*KFLDX*JFLDX + J*KFLDX + K + 1
            XE(7,N) = VERTX(M)*VARX
            YE(7,N) = VERTY(M)*VARX
            ZE(7,N) = VERTZ(M)*VARX
            M = I*KFLDX*JFLDX + J*KFLDX + K + 1
            XE(8,N) = VERTX(M)*VARX
            YE(8,N) = VERTY(M)*VARX
            ZE(8,N) = VERTZ(M)*VARX
          ENDDO
        ENDDO
      ENDDO
!
!---  Dynamic memory deallocation  ---
!
      IF( ALLOCATED(VERTX) ) THEN
      DEALLOCATE( VERTX,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTX'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTY) ) THEN
      DEALLOCATE( VERTY,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTY'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
      IF( ALLOCATED(VERTZ) ) THEN
      DEALLOCATE( VERTZ,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: VERTZ'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Closes Vertices File  ---
!
      CLOSE(UNIT=9)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RDKJI_VERT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_KNEQ
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read kinetic equations for reactions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 9 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_KNEQ'
!
!---  Assign card string  ---
!
      CARD = 'Kinetic Equations Card'
!
!---  Read number of kinetic equations  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Kinetic Equations'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NEQK)
      LEQK = MAX( LEQK,NEQK )
      LSPT = LSPT + LEQK
!
!---  Loop over the kinetic reactions  ---
!
      DO 100 NEQ = 1,NEQK
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Kinetic Component Species Name'
        CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
        VARB = 'Number of Species in Kinetic Equation'
        CALL RD_INT( ISTART,ICOMMA,CHDUM,NSEK )
        LSEK = MAX( LSEK,NSEK )
!
!---    Loop over the kinetic-equation species allowing for
!       returns in the input  ---
!
        DO 80 NSP = 1,NSEK
          VARB = 'Kinetic-Equation Species Name: '
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
          VARB = 'Kinetic-Equation Species Coefficient: '
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
   80   CONTINUE
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Number of Reactions in Kinetic Equation'
        CALL RD_INT( ISTART,ICOMMA,CHDUM,NREK )
        LREK = MAX( LREK,NREK )
!
!---    Loop over the kinetic-equation kinetic reactions
!        allowing for returns in the input  ---
!
        DO 90 NSP = 1,NREK
          VARB = 'Kinetic-Equation Kinetic-Reaction Name: '
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
          VARB = 'Kinetic-Equation Kinetic-Reaction Coefficient: '
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
   90   CONTINUE
  100 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_KNEQ group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_KNRC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read kinetic reactions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 9 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*64 GDUM
      CHARACTER*128 ADUM,FDUM
      CHARACTER*512 CHDUM
      LOGICAL FLG_CHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_KNRC'
!
!---  Assign card string  ---
!
      CARD = 'Kinetic Reactions Card'
!
!---  Read number of equilibrium reactions  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Kinetic Reactions'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NRCK)
      LRCK = MAX( LRCK,NRCK )
      LCKN = 1
!
!---  Loop over the kinetic reactions  ---
!
      DO 500 NRC = 1,NRCK
        JCX = 0
        IRCKTX = 0
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Kinetic Reaction Name'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        VARB = 'Kinetic Reaction Type'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'dissolu').NE.0 .OR.
     &    INDEX(ADUM(1:),'precip').NE.0 .OR.
     &    INDEX(ADUM(1:),'tst').NE.0 ) THEN
          IF( INDEX(ADUM(1:),'ph').NE.0 ) THEN
            IRCKTX = 5
            IF( INDEX(ADUM(1:),'toward products').NE.0 ) THEN
              IRCKTX = 6
            ELSEIF( INDEX(ADUM(1:),'toward reactants').NE.0 ) THEN
              IRCKTX = 7
            ENDIF
          ELSE
            IRCKTX = 10
            IF( INDEX(ADUM(1:),'toward products').NE.0 ) THEN
              IRCKTX = 11
            ELSEIF( INDEX(ADUM(1:),'toward reactants').NE.0 ) THEN
              IRCKTX = 12
            ENDIF
          ENDIF
        ELSEIF( INDEX(ADUM(1:),'multi').NE.0 .AND.
     &    INDEX(ADUM(1:),'rate').NE.0 ) THEN
          IRCKTX = 20
        ELSEIF( INDEX(ADUM(1:),'forward').NE.0 .OR. 
     &    INDEX(ADUM(1:),'backward').NE.0 ) THEN
          IRCKTX = 1
        ELSEIF( INDEX(ADUM(1:),'monod').NE.0 .AND.
     &    INDEX(ADUM(1:),'dual').NE.0 .AND.
     &    INDEX(ADUM(1:),'inhib').NE.0 ) THEN
          IRCKTX = 37
        ELSEIF( INDEX(ADUM(1:),'monod').NE.0 .AND.
     &    INDEX(ADUM(1:),'dual').NE.0 ) THEN
          IRCKTX = 35
        ELSEIF( INDEX(ADUM(1:),'monod').NE.0 .AND.
     &    INDEX(ADUM(1:),'single').NE.0 ) THEN
          IRCKTX = 36
        ELSEIF( INDEX(ADUM(1:),'monod').NE.0 .AND.
     &    INDEX(ADUM(1:),'valocchi').NE.0 ) THEN
          IRCKTX = 2
        ELSEIF( INDEX(ADUM(1:),'monod').NE.0 .AND.
     &    INDEX(ADUM(1:),'schroth').NE.0 ) THEN
          IRCKTX = 17
        ELSEIF( INDEX(ADUM(1:),'sorption').NE.0 .AND.
     &    INDEX(ADUM(1:),'valocchi').NE.0 ) THEN
          IRCKTX = 3
        ELSEIF( INDEX(ADUM(1:),'sorption').NE.0 .AND.
     &    INDEX(ADUM(1:),'langmuir').NE.0 ) THEN
          IRCKTX = 13
        ELSEIF( INDEX(ADUM(1:),'biomass').NE.0 .AND.
     &    INDEX(ADUM(1:),'valocchi').NE.0 ) THEN
          IRCKTX = 4
        ELSEIF( INDEX(ADUM(1:),'monod').NE.0 ) THEN
          IRCKTX = 22
        ELSEIF( INDEX(ADUM(1:),'biomass').NE.0 ) THEN
          IRCKTX = 24
        ELSEIF( INDEX(ADUM(1:),'lognormal').NE.0 .AND.
     &    INDEX(ADUM(1:),'liu').NE.0 ) THEN
          IRCKTX = 41
        ELSEIF( INDEX(ADUM(1:),'dualdomain').NE.0 .AND.
     &    INDEX(ADUM(1:),'liu').NE.0 ) THEN
          IRCKTX = 42
        ENDIF
        IF ( INDEX(ADUM(1:),'w/coef').NE.0 ) THEN
          LMC = LFX*LFY*LFZ
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
        ELSE
          LMC = 1
        ENDIF
!
!---    Mineral  ---
!
        IF( (IRCKTX.GE.10 .AND. IRCKTX.LE.12) .OR.
     &    (IRCKTX.GE.5 .AND. IRCKTX.LE.9) .OR.
     &    IRCKTX.EQ.14 .OR. IRCKTX.EQ.16 .OR. IRCKTX.EQ.20 ) THEN
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          VARB = 'Mineral Name'
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
        ENDIF
!
!---    Multi-rate mineral  ---
!
        IF( IRCKTX.EQ.20 ) GOTO 400
!
!---    Number of reactants in kinetic reaction  ---
!
        VARB = 'Number of Reactants in Kinetic Reaction'
        CALL RD_INT( ISTART,ICOMMA,CHDUM,NSPRX )
!
!---    Loop over the kinetic reaction reactants allowing for
!       returns in the input  ---
!
        DO 10 NSP = 1,NSPRX
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
          VARB = 'Kinetic-Reaction Reactants Name: '
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Skip kinetic reaction reactant stoichiometric coefficient
!         for Monod and Biomass kinetics  ---
!
          IF( IRCKTX.NE.22 .AND. IRCKTX.NE.24 ) THEN
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
            JCX = JCX+1
            VARB = 'Kinetic-Reaction Reactant Stoichiometric ' // 
     &        'Coefficient: '
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!             
!---          Check that the file exists  ---
!             
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Kinetic-Reaction Reactant Stoichiometric ' //
     &            'Coefficient: ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Unformatted Kinetic-Reaction Reactant ' //
     &            'Stoichiometric Coefficient: ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          ENDIF
   10   CONTINUE
!
!---    Skip kinetic reaction products
!       for Monod and Biomass kinetics  ---
!
        IF( IRCKTX.NE.22 .AND. IRCKTX.NE.24 ) THEN
          VARB = 'Number of Products in Kinetic Reaction'
          CALL RD_INT( ISTART,ICOMMA,CHDUM,NSPPX )
!
!---      Loop over the kinetic reaction products allowing for
!         returns in the input  ---
!
          DO 20 NSP = 1,NSPPX
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
            VARB = 'Kinetic-Reaction Products Name: '
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
            JCX = JCX+1
            VARB = 'Kinetic-Reaction Product Stoichiometric ' // 
     &        'Coefficient: '
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!
!---          Check that the file exists  ---
!
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Kinetic-Reaction Reactant Stoichiometric ' //
     &            'Coefficient: ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Unformatted Kinetic-Reaction Reactant ' //
     &            'Stoichiometric Coefficient: ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
   20     CONTINUE
        ENDIF
!
!---    Read kinetic reaction parameters  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    TST type reactions  ---
!
        IF( (IRCKTX.GE.10 .AND. IRCKTX.LE.12) .OR.
     &    (IRCKTX.GE.5 .AND. IRCKTX.LE.7) ) THEN
!
!---      Read forward dissolution-precipitation
!         reference reaction rate  ---
!
          JCX = JCX+1
          VARB = 'Kinetic Reaction Reference Rate'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Kinetic-Reaction Reference Rate: ' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Kinetic-Reaction Reference Rate: ' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read activation energy  ---
!
          JCX = JCX+1
          VARB = 'Kinetic Reaction Activation Energy'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Kinetic-Reaction Activation Energy: '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Kinetic-Reaction Activation Energy: '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read forward dissolution-precipitation
!         reference reaction temperature  ---
!
          JCX = JCX+1
          VARB = 'Kinetic Reaction Reference Temperature'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Kinetic-Reaction Reference Temperature: '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Kinetic-Reaction Reference Temperature: '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read dissolution-precipitation
!         pH exponent  ---
!
          IF( IRCKTX.GE.5 .AND. IRCKTX.LE.9 ) THEN
            JCX = JCX+1
            VARB = 'Kinetic Reaction pH Exponent'
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!        
!---          Check that the file exists  ---
!        
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Kinetic-Reaction pH Exponent: '
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Kinetic-Reaction pH Exponent: '
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          ENDIF
!
!---      Read equilibrium constant function coefficients
!         where, log(K) = b1*ln(T) + b2 + b3*T + b4/T + b5/(T^2)
!         and the equilibrium constant relates the aqueous
!         activity-molality product, gas fugacity, and
!         mineral activity  ---
!
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          DO 300 M = 1,5
!
!---        Read equilibrium constant function coefficients  ---
!
            JCX = JCX+1
            VARB = 'Equilibrium Reaction Constant Coefficient'
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!           
!---          Check that the file exists  ---
!           
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Equilibrium Reaction Constant Coefficient: '
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Equilibrium Reaction Constant Coefficient: '
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
  300     CONTINUE
!
!---    Forward-backward type reactions  ---
!
        ELSEIF( IRCKTX.EQ.1 ) THEN
!
!---      Read forward reaction rate  ---
!
          JCX = JCX+1
          VARB = 'Forward Kinetic Reaction Rate Exponent'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Forward Kinetic Reaction Rate Exponent: '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Forward Kinetic Reaction Rate Exponent: '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read backward reaction rate  ---
!
          JCX = JCX+1
          VARB = 'Backward Kinetic Reaction Rate Exponent'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Backward Kinetic Reaction Rate Exponent '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Backward Kinetic Reaction Rate Exponent '
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---    Valocchi-Monod type reactions  ---
!
        ELSEIF( IRCKTX.EQ.2 ) THEN
!
!---      Read half-saturation constant for donor  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &      'Half-Saturation Constant for Donor'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valochhi-Monod Kinetic Reaction: '
     &         // 'Half-Saturation Constant for Donor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valochhi-Monod Kinetic Reaction: '
     &         // 'Half-Saturation Constant for Donor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read half-saturation constant for acceptor  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &      'Half-Saturation Constant for Acceptor'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction '
     &         // 'Half-Saturation Constant for Acceptor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction '
     &         // 'Half-Saturation Constant for Acceptor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read maximum specific rate of substrate utilization  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &        'Maximum Specific Rate of Substrate Utilization'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Maximum Specific Rate of Substrate Utilization' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &        'Maximum Specific Rate of Substrate Utilization'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---    Schroth-Monod type reactions  ---
!
        ELSEIF( IRCKTX.EQ.17 ) THEN
!
!---      Read half-saturation constant for donor  ---
!
          JCX = JCX+1
          VARB = 'Schroth-Monod Kinetic Reaction: ' //
     &      'Half-Saturation Constant for Donor'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valochhi-Monod Kinetic Reaction: '
     &         // 'Half-Saturation Constant for Donor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valochhi-Monod Kinetic Reaction: '
     &         // 'Half-Saturation Constant for Donor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read half-saturation constant for acceptor  ---
!
          JCX = JCX+1
          VARB = 'Schroth-Monod Kinetic Reaction: ' //
     &      'Half-Saturation Constant for Acceptor'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Schroth-Monod Kinetic Reaction '
     &         // 'Half-Saturation Constant for Acceptor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Schroth-Monod Kinetic Reaction '
     &         // 'Half-Saturation Constant for Acceptor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read maximum specific rate of substrate utilization  ---
!
          JCX = JCX+1
          VARB = 'Schroth-Monod Kinetic Reaction: ' //
     &        'Maximum Specific Rate of Substrate Utilization'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Schroth-Monod Kinetic Reaction:  ' //
     &         'Maximum Specific Rate of Substrate Utilization' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Schroth-Monod Kinetic Reaction:  ' //
     &        'Maximum Specific Rate of Substrate Utilization'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read half-saturation constant for limiters  ---
!
          JCX = JCX+1
          VARB = 'Schroth-Monod Kinetic Reaction: ' //
     &      'Half-Saturation Constant for Limiters'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Schroth-Monod Kinetic Reaction '
     &         // 'Half-Saturation Constant for Limiters' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Schroth-Monod Kinetic Reaction '
     &         // 'Half-Saturation Constant for Limiters' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read number of limiter species  ---
!
          VARB = 'Number of Limiter Species'
          CALL RD_INT( ISTART,ICOMMA,CHDUM,IRC_KX )
          IF( IRC_KX.GT.0 ) CALL RD_INPL( CHDUM )
          JCX = JCX + IRC_KX
!
!---    Valocchi-Sorption type reactions  ---
!
        ELSEIF( IRCKTX.EQ.3 ) THEN
!
!---      Read mass transfer coefficient  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Sorption Kinetic Reaction: ' //
     &      'Mass Transfer Coefficient'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Sorption Kinetic Reaction:  ' //
     &         'Mass Transfer Coefficient' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Sorption Kinetic Reaction:  ' //
     &         'Mass Transfer Coefficient' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read distribution coefficient  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Sorption Kinetic Reaction: ' //
     &      'Distribution Coefficient'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Sorption Kinetic Reaction:  ' //
     &         'Distribution Coefficient' 
     &          // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Sorption Kinetic Reaction:  ' //
     &         'Distribution Coefficient' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---    Valocchi-Biomass type reactions  ---
!
        ELSEIF( IRCKTX.EQ.4 ) THEN
!
!---      Read half-saturation constant for donor  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &      'Half-Saturation Constant for Donor'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Half-Saturation Constant for Donor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Half-Saturation Constant for Donor' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read half-saturation constant for acceptor  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &      'Half-Saturation Constant for Acceptor'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Half-Saturation Constant for Acceptor'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Half-Saturation Constant for Acceptor'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read maximum specific rate of substrate utilization  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &        'Maximum Specific Rate of Substrate Utilization'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Maximum Specific Rate of Substrate Utilization'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Maximum Specific Rate of Substrate Utilization'
     &        //  FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read microbial yield coefficient  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &      'Microbial Yield Coefficient'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Microbial Yield Coefficient'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'Microbial Yield Coefficient'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
!
!---      Read first-order micobial decay coefficient  ---
!
          JCX = JCX+1
          VARB = 'Valocchi-Monod Kinetic Reaction: ' //
     &      'First-Order Microbial Decay Coefficient'
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'First-Order Microbial Decay Coefficient'
     &        //  FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Valocchi-Monod Kinetic Reaction:  ' //
     &         'First-Order Microbial Decay Coefficient'
     &        // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---    Monod type reactions  ---
!
        ELSEIF( IRCKTX.EQ.22 ) THEN
!
!---      Loop over reactants, less one  ---
!
          DO 320 NSP = 1,NSPRX-1
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
!
!---        Read half-saturation constant  ---
!
            VARB = 'Monod Kinetic Reaction: ' //
     &        'Half-Saturation Constant'
            JCX = JCX+1
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!           
!---          Check that the file exists  ---
!           
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Monod Kinetic Reaction:  ' //
     &           'Half-Saturation Constant'
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Monod Kinetic Reaction:  ' //
     &           'Half-Saturation Constant'
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
  320     CONTINUE
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
!
!---      Read maximum specific rate of substrate utilization  ---
!
          VARB = 'Monod Kinetic Reaction: ' //
     &      'Maximum Specific Rate of Reactant Utilization'
          JCX = JCX+1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Monod Kinetic Reaction:  ' //
     &         'Maximum Specific Rate of Reactant Utilization'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Monod Kinetic Reaction:  ' //
     &         'Maximum Specific Rate of Reactant Utilization'
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
          CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---    Biomass type reactions  ---
!
        ELSEIF( IRCKTX.EQ.24 ) THEN
!
!---      Loop over reactants, less one  ---
!
          DO 330 NSP = 1,NSPRX-1
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
!
!---        Read half-saturation constant  ---
!
            VARB = 'Biomass Kinetic Reaction: ' //
     &        'Half-Saturation Constant'
            JCX = JCX+1
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!           
!---          Check that the file exists  ---
!           
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Biomass Kinetic Reaction:  ' //
     &           'Half-Saturation Constant' 
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Biomass Kinetic Reaction:  ' //
     &           'Half-Saturation Constant' 
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---        Allow for returns in input lines  ---
!
            CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
            IF( INDX.EQ.0 ) THEN
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
            ENDIF
!
!---        Read maximum specific rate of substrate utilization  ---
!
            VARB = 'Biomass Kinetic Reaction: ' //
     &        'Maximum Specific Rate of Reactant Utilization'
            JCX = JCX+1
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!           
!---          Check that the file exists  ---
!           
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Biomass Kinetic Reaction:  ' //
     &           'Maximum Specific Rate of Reactant Utilization'
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Biomass Kinetic Reaction:  ' //
     &           'Maximum Specific Rate of Reactant Utilization'
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
  330     CONTINUE
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
!
!---      Read microbial yield coefficient  ---
!
          VARB = 'Biomass Kinetic Reaction: ' //
     &      'Microbial Yield Coefficient'
          JCX = JCX+1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Biomass Kinetic Reaction:  ' //
     &         'Microbial Yield Coefficient' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Biomass Kinetic Reaction:  ' //
     &         'Microbial Yield Coefficient' 
     &         // FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
!
!---      Allow for returns in input lines  ---
!
          CALL CHK_DPR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.EQ.0 ) THEN
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            ISTART = 1
          ENDIF
!
!---    Read first-order micobial decay coefficient  ---
!
        VARB = 'Biomass Kinetic Reaction: ' //
     &    'Microbial Decay Coefficient'
        JCX = JCX+1
        IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
          NCH  = INDEX(FDUM,':')+1
          NCHF = INDEX(FDUM,'  ')-1
!
!---      Check that the file exists  ---
!
          INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
          IF( .NOT.FLG_CHK ) THEN
            INDX = 4
            CHMSG = 'Biomass Kinetic Reaction:  ' //
     &       'Microbial Decay Coefficient' 
     &       // FDUM(NCH:NCHF)
            CALL WRMSGP( INDX )
          ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
            INDX = 4
            CHMSG = 'Biomass Kinetic Reaction:  ' //
     &       'Microbial Decay Coefficient' 
     &      // FDUM(NCH:NCHF)
            CALL WRMSGP( INDX )
          ENDIF
          NCKN = LFX*LFY*LFZ
        ELSE
        CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
        ENDIF
        CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---    Liu's lognormal multi rate type reactions  ---
!
        ELSEIF( IRCKTX.EQ.41 ) THEN
!
!---      Read rate from lognormal distribution
!
          VARB = 'Liu Multi-Rate Kin. Reac.: ' //
     &      'Rate Constant'
          JCX = JCX + 1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read kinetic site density  ---
!
          VARB = 'Liu Multi-Rate Kin. Reac.: ' //
     &      'Kinetic Site Density'
          JCX = JCX + 1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---      Read pore ratio  ---
!
          VARB = 'Liu Multi-Rate Kin. Reac.: ' //
     &      'Pore Ratio.'
          JCX = JCX + 1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
!
!---      Read logK1 for the first sorped species on the site  ---
!
          VARB = 'Liu Multi-Rate Kin. Reac.: ' //
     &      'Log K1.'
          JCX = JCX + 1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
!
!---      Read logK2 for the second sorped species on the site ---
!
          VARB = 'Liu Multi-Rate Kin. Reac.: ' //
     &      'Log K2.'
          JCX = JCX + 1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
!
!---    Liu's dual domain rate type reactions  ---
!
        ELSEIF( IRCKTX.EQ.42 ) THEN
!
!---      Mass transfer rate
!
          VARB = 'Liu Dual-Domain Kin. Reac.: ' //
     &      'Rate Constant'
          JCX = JCX + 1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
!
!---      Read pore ratio (immobile pore/mobile pore) ---
!
          VARB = 'Liu Dual-Domain Kin. Reac.: ' //
     &      'Pore Ratio.'
          JCX = JCX + 1
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
          ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
          ENDIF
      ENDIF
!
!---    Multi-rate mineral  ---
!
  400   CONTINUE
        IF( IRCKTX.EQ.20 ) THEN
          VARB = 'Number of Mechanisms in Kinetic Reaction'
          JCX = 3
          IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
            CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
            NCH  = INDEX(FDUM,':')+1
            NCHF = INDEX(FDUM,'  ')-1
!
!---        Check that the file exists  ---
!
            INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
            IF( .NOT.FLG_CHK ) THEN
              INDX = 4
              CHMSG = 'Number of Mechanisms in Kinetic Reaction:  ' //
     &         FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
              INDX = 4
              CHMSG = 'Number of Mechanisms in Kinetic Reaction:  ' //
     &         FDUM(NCH:NCHF)
              CALL WRMSGP( INDX )
            ENDIF
            NCKN = LFX*LFY*LFZ
          ELSE
          CALL RD_INT( ISTART,ICOMMA,CHDUM,NKRMX )
          ENDIF
          CALL RD_INPL( CHDUM )
!
!---      Loop over mechanisms  ---
!
          DO 490 NKRM = 1,NKRMX
            CALL RD_INPL( CHDUM )
!
!---        Mechanism reference reaction rate  ---
!
            VARB = 'Mechanism Kinetic Reaction Reference Rate'
            JCX = JCX+1
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!           
!---          Check that the file exists  ---
!           
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Mechanism Kinetic Reaction Reference Rate: '
     &            // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Mechanism Kinetic Reaction Reference Rate: '
     &           // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---        Mechanism activation energy  ---
!
            VARB = 'Mechanism Kinetic Reaction Activation Energy'
            JCX = JCX+1
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!           
!---          Check that the file exists  ---
!           
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Mechanism Kinetic Reaction Activation Energy:  
     &           ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Mechanism Kinetic Reaction Activation Energy:  
     &           ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---        Mechanism reference reaction temperature  ---
!
            VARB = 'Mechanism Kinetic Reaction Reference Temperature'
            JCX = JCX+1
            IF( INDEX(CHDUM(ISTART:ISTART+5),'file') /= 0 ) THEN
              CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
              NCH  = INDEX(FDUM,':')+1
              NCHF = INDEX(FDUM,'  ')-1
!           
!---          Check that the file exists  ---
!           
              INQUIRE( FILE=FDUM(NCH:NCHF), FORM=GDUM, EXIST=FLG_CHK )
              IF( .NOT.FLG_CHK ) THEN
                INDX = 4
                CHMSG = 'Mechanism Kinetic Reaction Reference
     &            Temperature:  ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
                INDX = 4
                CHMSG = 'Mechanism Kinetic Reaction Reference
     &            Temperature:  ' // FDUM(NCH:NCHF)
                CALL WRMSGP( INDX )
              ENDIF
              NCKN = LFX*LFY*LFZ
            ELSE
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VAR)
            ENDIF
            CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---        Number of species in mechanism  ---
!
            CALL RD_INPL( CHDUM )
            VARB = 'Number of Species in Mechanism'
            CALL RD_INT( ISTART,ICOMMA,CHDUM,NKRSX )
            JCX = JCX+NKRSX
  490     CONTINUE
        ENDIF
        NCKN = LFX*LFY*LFZ  !xl
        LSPK = MAX( LSPK,JCX )
        LCKN = MAX( NCKN,LCKN )
  500 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_KNRC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_LW
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Leaky Well Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 10 October 2018.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE LEAK_WELL
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM
      CHARACTER*64 UNTS
      TYPE(LIST_INTERVAL), POINTER :: IN_TMP_PTR
      TYPE(LIST_TRANSITION), POINTER :: TP_TMP_PTR
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_LW'
!
!---  Assign card string  ---
!
      CARD = 'Leaky Well Card'
!
!---  Leaky well is not currently compatible with block refinement  ---
!
      IF( LBR.NE.0 ) THEN
        INDX = 4
        CHMSG = 'Leaky Well Not Compatible with Block Refinement'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read number of leaky wells  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Leaky Wells'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,N_LW)
      LN_LW = MAX( LN_LW,N_LW )
      L_LW = 1
!
!---  Loop over number of leaky wells  ---
!
      NIT_LW = 0
      NULLIFY( IN_LW_PTR )
      NULLIFY( TP_LW_PTR )
      DO 500 NCW = 1,N_LW
!
!---    Read well type  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Leaky Well Type'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        VARB = 'X-Well Fraction Factor'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        VARB = 'Y-Well Fraction Factor'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        VARB = 'Z-Well Fraction Factor'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)

!---    Read number of well intervals  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Number of Leaky Well Intervals'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NI_LW)
        NIT_LW = NIT_LW + NI_LW
        LWI_LW = MAX( NIT_LW,LWI_LW )
!
!---    Allocate memory for new well interval element  ---
!
        ALLOCATE( IN_TMP_PTR,STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: IN_TMP_PTR'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Assign well transition pointers  ---
!
        IF( NCW.EQ.1 ) THEN
          IN_TMP_PTR%ID1_CW = 1
        ELSE
          IN_TMP_PTR%ID1_CW = NIT_LW - NI_LW + 1
        ENDIF
        IN_TMP_PTR%ID2_CW = IN_TMP_PTR%ID1_CW + NI_LW - 1
        IN_TMP_PTR%NEXT => IN_LW_PTR
        IN_LW_PTR => IN_TMP_PTR
!
!---    Loop over number of well intervals  ---
!
        DO 100 NICW = 1,NI_LW
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
!
!---      Read first x-transition point  ---
!
          VARB = 'Interval First X-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP1_LWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,XTP1_LWX,INDX)
!
!---      Read first y-transition point  ---
!
          VARB = 'Interval First Y-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP1_LWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,YTP1_LWX,INDX)
!
!---      Cylindrical coordinates with azimuthal symmetry  ---
!
          IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
            IF( ABS(XTP1_LWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval First X-Transition Point ' // 
     &          'for Radially Symmetric Domain: XTP_LW ='
              RLMSG = XTP1_LWX
              CALL WRMSGP( INDX )
            ENDIF
            IF( ABS(YTP1_LWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval First Y-Transition Point ' // 
     &          'for Radially Symmetric Domain: YTP_LW ='
              RLMSG = YTP1_LWX
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
!
!---      Read first z-transition point  ---
!
          VARB = 'Interval First Z-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP1_LWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,ZTP1_LWX,INDX)
!
!---      Read second x-transition point  ---
!
          VARB = 'Interval Second X-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,XTP2_LWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,XTP2_LWX,INDX)
!
!---      Read second y-transition point  ---
!
          VARB = 'Interval Second Y-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,YTP2_LWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,YTP2_LWX,INDX)
!
!---      Cylindrical coordinates with azimuthal symmetry  ---
!
          IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
            IF( ABS(XTP2_LWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval Second X-Transition Point ' // 
     &          'for Radially Symmetric Domain: XTP_LW ='
              RLMSG = XTP2_LWX
              CALL WRMSGP( INDX )
            ENDIF
            IF( ABS(YTP2_LWX)/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Interval Second Y-Transition Point ' // 
     &          'for Radially Symmetric Domain: YTP_LW ='
              RLMSG = YTP2_LWX
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
!
!---      Read second z-transition point  ---
!
          VARB = 'Interval Second Z-Transition Point'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZTP2_LWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,ZTP2_LWX,INDX)
!
!---      Read interval well-bore radius  ---
!
          VARB = 'Interval Well-Bore Radius'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Read interval well skin factor  ---
!
          VARB = 'Interval Skin Factor'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Read interval nominal well node spacing  ---
!
          VARB = 'Interval Well Node Spacing'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,PAR3_LWX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,PAR3_LWX,INDX)
!
!---      Read well interval screen option  ---
!
          VARB = 'Interval Screen Option'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Read well interval rock/soil/grout/fill  ---
!
          VARB = 'Interval Rock/Soil Name'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          LOC_PTR => ROCK_PTR
!
!---      Allocate memory for new transition point element  ---
!
          ALLOCATE( TP_TMP_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: TP_TMP_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          TP_TMP_PTR%XTP1_CW = XTP1_LWX
          TP_TMP_PTR%YTP1_CW = YTP1_LWX
          TP_TMP_PTR%ZTP1_CW = ZTP1_LWX
          TP_TMP_PTR%XTP2_CW = XTP2_LWX
          TP_TMP_PTR%YTP2_CW = YTP2_LWX
          TP_TMP_PTR%ZTP2_CW = ZTP2_LWX
          TP_TMP_PTR%PAR3_CW = PAR3_LWX
          TP_TMP_PTR%NEXT => TP_LW_PTR
          TP_LW_PTR => TP_TMP_PTR
!
!---      Check for repeated rock/soil name  ---
!
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IF( LOC_PTR%LIST_NAME == ADUM ) GOTO 60
            LOC_PTR => LOC_PTR%NEXT
          ENDDO
!
!---      Add rock/soil name to rock list  ---
!
          NROCK = NROCK + 1
          ALLOCATE( TMP_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: ROCK_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          TMP_PTR%LIST_NAME = ADUM
          TMP_PTR%NEXT => ROCK_PTR
          ROCK_PTR => TMP_PTR
   60   CONTINUE
  100   CONTINUE
  500 CONTINUE
!
!---  Update the number of rock types parameter  ---
!
      LRC = MAX( NROCK,LRC )
!
!---  Allocate memory for leaky well interval/node index array  ---
!
      ALLOCATE( ID_LW(1:7,1:LN_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ID_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load leaky well interval/node index array  ---
!
      IN_TMP_PTR => IN_LW_PTR
      DO 510 NCW = 1,N_LW
        M = N_LW-NCW+1
        ID_LW(1,M) = IN_TMP_PTR%ID1_CW
        ID_LW(2,M) = IN_TMP_PTR%ID2_CW
        IN_TMP_PTR => IN_TMP_PTR%NEXT
  510 CONTINUE
!
!---  Allocate memory for x-transition points array  ---
!
      ALLOCATE( XTP_LW(1:2,1:LWI_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: XTP_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for y-transition points array  ---
!
      ALLOCATE( YTP_LW(1:2,1:LWI_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: YTP_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for z-transition points array  ---
!
      ALLOCATE( ZTP_LW(1:2,1:LWI_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZTP_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for leaky well parameter array  ---
!
      ALLOCATE( PAR_LW(1:5,1:LWI_LW),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: PAR_LW'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Load x-, y-, and z-transition point arrays  ---
!
      TP_TMP_PTR => TP_LW_PTR
      DO 520 NICW = 1,LWI_LW
        M = LWI_LW-NICW+1
        XTP_LW(1,M) = TP_TMP_PTR%XTP1_CW
        XTP_LW(2,M) = TP_TMP_PTR%XTP2_CW
        YTP_LW(1,M) = TP_TMP_PTR%YTP1_CW
        YTP_LW(2,M) = TP_TMP_PTR%YTP2_CW
        ZTP_LW(1,M) = TP_TMP_PTR%ZTP1_CW
        ZTP_LW(2,M) = TP_TMP_PTR%ZTP2_CW
        PAR_LW(3,M) = TP_TMP_PTR%PAR3_CW
        TP_TMP_PTR => TP_TMP_PTR%NEXT
  520 CONTINUE
!
!---  Number and location of leaky well nodes  ---
!
      CALL CHK_LW
      LWN_LW = MAX( LWN_LW,1 )
      LWF_LW = MAX( LWF_LW,1 )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_LW group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_LRP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Aqueous Relative Permeability Function Parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 26 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TABL
      USE SOLTN
      USE PORMED
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,RDUM
      CHARACTER*512 CHDUM
      TYPE(LIST_NODE), POINTER :: LOC_PTR
      TYPE(LIST_SCALING), POINTER :: SC_LOC_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_LRP'
!
!---  Assign card string  ---
!
      CARD = 'Aqueous Relative Permeability Card'
!
!---  Loop over the rock/soil aqueous relative permeability
!     information lines  ---
!
      N = 0
      IJK = 0
   10 CONTINUE
      IF( N.GE.NROCK .OR. IJK.GT.0 ) GOTO 500
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Rock/Soil Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,RDUM)
!
!---  Check for a pair of delimiting slashes in the rock/soil name,
!     indicating a pattern of rock/soil types  ---
!
      KBS = 0
      IBS = INDEX( RDUM(1:),'/' )
      IF( IBS.GT.0 ) THEN
        IBS = IBS + 1
        JBS = INDEX( RDUM(IBS:),'/')
        IF( JBS.GT.0 ) THEN
          JBS = IBS + JBS - 2
          KBS = 1
          ISBS = ISTART
        ENDIF
      ENDIF
      IROCK = 1
   20 CONTINUE
!
!---  IJK, KIJ, or JKI indexing  ---
!
      IF( INDEX(RDUM(1:),'indexing').NE.0 ) THEN
        IF( INDEX(RDUM,'ijk').NE.0 ) THEN
          IJK = 1
        ELSEIF( INDEX(RDUM,'jki').NE.0 ) THEN
          IJK = 2
        ELSEIF( INDEX(RDUM,'kij').NE.0 ) THEN
          IJK = 3
        ELSE
          INDX = 4
          CHMSG = 'Unrecognized Indexing Option' // RDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        IROCK = 1
        GOTO 220
      ENDIF
!
!---  Search known rock types for a matching type  ---
!
          LOC_PTR => ROCK_PTR
          IROCK = 0
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IROCK = IROCK + 1
            IF( LOC_PTR%LIST_NAME == RDUM ) THEN
              GOTO 200
            ELSE
              LOC_PTR => LOC_PTR%NEXT
            ENDIF
          ENDDO
!
!---  Search known scaling groups for a matching type  ---
!
        IF( ISLC(19).EQ.1 ) THEN
          SC_LOC_PTR => SCALING_PTR
          ISGRP = 0
          DO
            IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
            IF( SC_LOC_PTR%SCALING_NAME == RDUM ) THEN
              ISGRP = SC_LOC_PTR%SCALING_NUM
              IROCK = 1
              GOTO 200
            ELSE
              SC_LOC_PTR => SC_LOC_PTR%NEXT
            ENDIF
          ENDDO
          INDX = 2
          CHMSG = 'Unrecognized Rock/Soil Type or Scaling Group: '
     &      // RDUM(1:NCH)
          CALL WRMSGP( INDX )
          GOTO 10
        ENDIF
        INDX = 2
        CHMSG = 'Unrecognized Rock/Soil Type: ' // RDUM(1:NCH)
        CALL WRMSGP( INDX )
        GOTO 10
  200   CONTINUE
!
!---  Loop over rock/soils within scaling group  ---
!
        IF( ISLC(19).EQ.1 .AND. ISGRP.NE.0 ) THEN
          DO 202 M = IROCK,NROCK
            IF( ISCALE(M).EQ.ISGRP ) THEN
              IROCK = M
              GOTO 204
            ENDIF
  202     CONTINUE
        ENDIF
  204   CONTINUE
!
!---  Read aqueous relative permeability pressure function  ---
!
  220 CONTINUE
      N = N + 1
!
!---  Read saturation/capillary pressure function for
!     tabular forms  ---
!
      VARB = 'Aqueous Relative Permeability Function'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---  Tabular (relative permeability versus liquid saturation)  ---
!
      IF( INDEX(ADUM(1:),'tabular').NE.0 ) THEN
        IF( INDEX( ADUM(1:),'content' ).NE.0 ) THEN
          IRPLX = 10
        ELSEIF( INDEX( ADUM(1:),'head' ).NE.0 ) THEN
          IF( INDEX( ADUM(1:),'log' ).NE.0 ) THEN
            IRPLX = 14
          ELSE
            IRPLX = 12
          ENDIF
        ELSE
          IRPLX = 10
        ENDIF
!
!---    IJK Indexing  ---
!
        IF( IJK.GT.0 ) THEN
          VARB = 'Number of Tables'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NTABX)
          NTBL = 0
          DO 240 NTX = 1,NTABX
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            VARB = 'Number of Table Entries'
            CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
            IF( NLIN.LT.2 ) THEN
              INDX = 4
              CHMSG = 'Invalid Aqueous Relative Permeability Table'
              CALL WRMSGP( INDX )
            ENDIF
            NTBL = NTBL + NLIN
            DO 230 NLX = 1,NLIN
              CALL RD_INPL( CHDUM )
  230       CONTINUE
  240     CONTINUE
          LTBL = LTBL + NTBL
        ELSE
          VARB = 'Number of Tabular Entries'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
          IF( NLIN.LT.2 ) THEN
            INDX = 4
            CHMSG = 'Invalid Aqueous Relative Permeability Table'
            CALL WRMSGP( INDX )
          ENDIF
          DO 250 NL = 1,NLIN
            CALL RD_INPL( CHDUM )
 250      CONTINUE
          NTBL = NLIN
          LTBL = LTBL + NTBL
        ENDIF
!
!---  Polynomial function  ---
!
      ELSEIF( INDEX(ADUM(1:),'polynomial').NE.0 ) THEN
        IRPLX = 19
        VARB = 'Number of Polynomial Function Pieces'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NPOLY)
        LPOLYN = MAX( LPOLYN,NPOLY )
        DO 290 NP = 1,NPOLY
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          VARB = 'Number of Polynomial Coefficients'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NCOEF)
          LPOLYC = MAX( LPOLYC,NCOEF+4 )
 290    CONTINUE
      ENDIF
!
!---  Relative permeability model coefficients  ---
!
      LRPLC = 12
!
!---  Continue reading rock/soil type names for a pattern match  ---
!
      IF( KBS.EQ.1 .AND. IROCK.LT.NROCK ) THEN
        IROCK = IROCK + 1
        ISTART = ISBS
        GOTO 20
      ENDIF
!
!---  Loop over remaining rock/soils within scaling group  ---
!
      IF( ISLC(19).EQ.1 .AND. IROCK.LT.NROCK ) THEN
        DO 490 M = IROCK+1,NROCK
          IF( ISCALE(M).EQ.ISGRP ) THEN
            N = N+1
          ENDIF
  490   CONTINUE
      ENDIF
!
!---  Read next rock/soil type or scaling group  ---
!
      GOTO 10
 500  CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_LRP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_MFDIS( XREFX,YREFX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read MODFLOW discretization formatted grids
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 21 April 2021.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE FILES
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: DXX,DYX
      REAL*8, DIMENSION(:,:), ALLOCATABLE :: ZX
      REAL*8, DIMENSION(4) :: ZLX
      CHARACTER*64 BDUM,BMDUM,FDUM,FMDUM,UNTS
      CHARACTER*512 CHDUM
      LOGICAL BCHK,FCHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_MFDIS'
!
!---  Dynamic memory allocation  ---
!
      ALLOCATE( DXX(1:LFX),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: DXX'
        CALL WRMSGS( INDX )
      ENDIF
      ALLOCATE( DYX(1:LFY),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: DYX'
        CALL WRMSGS( INDX )
      ENDIF
      ALLOCATE( ZX(1:LFX*LFY,1:LFZ+1),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ZX'
        CALL WRMSGS( INDX )
      ENDIF
!
!---  Read MODFLOW discretization file name  ---
!
      IFILE = 9
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'MODFLOW Discretization File Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,FDUM)
!
!---  Check for external file  ---
!
      INQUIRE( FILE=FDUM(1:NCH), FORM=FMDUM, EXIST=FCHK )
      IF( .NOT.FCHK ) THEN
        INDX = 4
        CHMSG = 'Missing MODFLOW Discretization File: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ELSEIF( FDUM.EQ.'unformatted' ) THEN
        INDX = 4
        CHMSG = 'MODFLOW Discretization File Format: ' // FDUM(1:NCH)
        CALL WRMSGP( INDX )
      ENDIF
      OPEN( UNIT=9,FILE=FDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
      REWIND( UNIT=9 )
!
!---  Read KFLD, IFLD, JFLD,   ---
!
      READ(9,*) KFLD,IFLD,JFLD,NPERX,ITUNX,ILUNX
      IF( KFLD.NE.LFZ ) THEN
        INDX = 4
        CHMSG = 'KFLD != LFZ'
        CALL WRMSGP( INDX )
      ENDIF
      IF( IFLD.NE.LFX ) THEN
        INDX = 4
        CHMSG = 'IFLD != LFX'
        CALL WRMSGP( INDX )
      ENDIF
      IF( JFLD.NE.LFY ) THEN
        INDX = 4
        CHMSG = 'JFLD != LFY'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Convert grid units  ---
!
      VARX = 1.D+0
      IF( ILUNX.EQ.1 ) THEN
        INDX = 0
        IUNM = 1
        UNTS = 'ft'
        CALL RD_UNIT(UNTS,VARX,INDX)
      ELSEIF( ILUNX.EQ.2 ) THEN
        INDX = 0
        IUNM = 1
        UNTS = 'm'
        CALL RD_UNIT(UNTS,VARX,INDX)
      ELSEIF( ILUNX.EQ.3 ) THEN
        INDX = 0
        IUNM = 1
        UNTS = 'cm'
        CALL RD_UNIT(UNTS,VARX,INDX)
      ELSE
        INDX = 4
        CHMSG = 'Undefined Length Units'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Read x-direction spacings  ---
!
      READ(9,'(A)',IOSTAT=IOX) CHDUM   
      IF( IOX.NE.0 ) THEN
        INDX = 4
        CHMSG = 'MODFLOW Discretization File Read Error '
        CALL WRMSGP( INDX )
      ENDIF
      READ(9,'(A)',IOSTAT=IOX) CHDUM   
      IF( IOX.NE.0 ) THEN
        INDX = 4
        CHMSG = 'MODFLOW Discretization File Read Error '
        CALL WRMSGP( INDX )
      ENDIF
      CALL L_CASE( CHDUM )
      IF( INDEX(CHDUM(1:),'internal').NE.0 ) THEN
        DO M = 1,IFLD/10
          I1 = (M-1)*10 + 1
          I2 = (M-1)*10 + 10
          READ(9,*) (DXX(I),I=I1,I2)
        ENDDO
        IF( MOD(IFLD,10).GT.0 ) THEN
          M = IFLD/10
          I1 = (M-1)*10 + 1
          I2 = (M-1)*10 + MOD(IFLD,10)
          READ(9,*) (DXX(I),I=I1,I2)
        ENDIF
      ELSE
        INDX = 4
        CHMSG = 'Unrecognized y-direction header'
        CALL WRMSGP( INDX )
      ENDIF
      DO I = 1,IFLD
        DXX(I) = VARX*DXX(I)
      ENDDO
!
!---  Read Y-direction spacings  ---
!
      READ(9,'(A)',IOSTAT=IOX) CHDUM   
      IF( IOX.NE.0 ) THEN
        INDX = 4
        CHMSG = 'MODFLOW Discretization File Read Error '
        CALL WRMSGP( INDX )
      ENDIF
      CALL L_CASE( CHDUM )
      IF( INDEX(CHDUM(1:),'internal').NE.0 ) THEN
        DO M = 1,JFLD/10
          I1 = (M-1)*10 + 1
          I2 = (M-1)*10 + 10
          READ(9,*,IOSTAT=IOX) (DYX(I),I=I1,I2)
          IF( IOX.NE.0 ) THEN
            INDX = 4
            CHMSG = 'MODFLOW Discretization File Read Error '
            CALL WRMSGP( INDX )
          ENDIF
        ENDDO
        IF( MOD(JFLD,10).GT.0 ) THEN
          M = JFLD/10
          I1 = (M-1)*10 + 1
          I2 = (M-1)*10 + MOD(JFLD,10)
          READ(9,*,IOSTAT=IOX) (DYX(I),I=I1,I2)
          IF( IOX.NE.0 ) THEN
            INDX = 4
            CHMSG = 'MODFLOW Discretization File Read Error '
            CALL WRMSGP( INDX )
          ENDIF
        ENDIF
      ELSE
        INDX = 4
        CHMSG = 'Unrecognized x-direction header'
        CALL WRMSGP( INDX )
      ENDIF
      DO J = 1,JFLD
        DYX(J) = VARX*DYX(J)
      ENDDO
!
!---  Read z-direction elevations  ---
!
      DO K = KFLD+1,1,-1
        READ(9,'(A)',IOSTAT=IOX) CHDUM
        IF( IOX.NE.0 ) THEN
          INDX = 4
          CHMSG = 'MODFLOW OPEN/CLOSE File Read Error '
          CALL WRMSGP( INDX )
        ENDIF
        IF( INDEX(CHDUM(1:),'OPEN/CLOSE').NE.0 ) THEN
          ISTX = INDEX( CHDUM(1:),'''' )
          ISTX = ISTX + 1
          ISPX = INDEX( CHDUM(ISTX:),'''' ) + ISTX - 1
          BDUM = ' '
          ISPX = ISPX - 1
          NCH = ISPX-ISTX+1
          IF( NCH.LT.1 ) THEN
            INDX = 4
            CHMSG = 'Unrecognized File Name after OPEN/CLOSE'
            CALL WRMSGP( INDX )
          ENDIF
          READ(CHDUM(ISTX:ISPX),'(A)') BDUM(1:NCH)
          INQUIRE( FILE=BDUM(1:NCH), FORM=BMDUM, EXIST=BCHK )
          IF( .NOT.BCHK ) THEN
            INDX = 4
            CHMSG = 'Missing OPEN/CLOSE File: ' // BDUM(1:NCH)
            CALL WRMSGP( INDX )
          ENDIF
          OPEN( UNIT=10,FILE=BDUM(1:NCH),STATUS='OLD',FORM='FORMATTED' )
          REWIND( UNIT=10 )
          DO M = 1,IFLD*JFLD/10
            I1 = (M-1)*10 + 1
            I2 = (M-1)*10 + 10
            READ(10,*,IOSTAT=IOX) (ZX(I,K),I=I1,I2)
            IF( IOX.NE.0 ) THEN
              INDX = 4
              CHMSG = 'MODFLOW OPEN/CLOSE File Read Error '
              CALL WRMSGP( INDX )
            ENDIF
          ENDDO
          IF( MOD(IFLD*JFLD,10).GT.0 ) THEN
            M = JFLD/10
            I1 = (M-1)*10 + 1
            I2 = (M-1)*10 + MOD(IFLD*JFLD,10)
            READ(10,*,IOSTAT=IOX) (ZX(I,K),I=I1,I2)
            IF( IOX.NE.0 ) THEN
              INDX = 4
              CHMSG = 'MODFLOW OPEN/CLOSE File Read Error '
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
        ELSE
          INDX = 4
          CHMSG = 'Unrecognized z-direction header'
          CALL WRMSGP( INDX )
        ENDIF
!
!---    Close OPEN/CLOSE File   ---
!
        CLOSE( UNIT=10 )
      ENDDO
!
!---  Assign x-direction vertices   ---
!
      DO K = 1,KFLD
        DO J = 1,JFLD
          DO I = 1,IFLD
            N = ND(I,J,K)
            IF( I.EQ.1 ) THEN
              XE(1,N) = XREFX
              XE(2,N) = XE(1,N) + DXX(I)
              XE(3,N) = XREFX
              XE(4,N) = XE(3,N) + DXX(I)
              XE(5,N) = XREFX
              XE(6,N) = XE(5,N) + DXX(I)
              XE(7,N) = XREFX
              XE(8,N) = XE(7,N) + DXX(I)
            ELSE
              N1 = ND(I-1,J,K)
              XE(1,N) = XE(2,N1)
              XE(2,N) = XE(1,N) + DXX(I)
              XE(3,N) = XE(4,N1)
              XE(4,N) = XE(3,N) + DXX(I)
              XE(5,N) = XE(6,N1)
              XE(6,N) = XE(5,N) + DXX(I)
              XE(7,N) = XE(8,N1)
              XE(8,N) = XE(7,N) + DXX(I)
            ENDIF
          ENDDO
        ENDDO
      ENDDO
!
!---  Assign y-direction vertices   ---
!
      DO K = 1,KFLD
        DO J = 1,JFLD
          DO I = 1,IFLD
            N = ND(I,J,K)
            IF( J.EQ.1 ) THEN
              YE(1,N) = YREFX
              YE(2,N) = YREFX
              YE(3,N) = YE(1,N) + DYX(J)
              YE(4,N) = YE(2,N) + DYX(J)
              YE(5,N) = YREFX
              YE(6,N) = YREFX
              YE(7,N) = YE(5,N) + DYX(J)
              YE(8,N) = YE(6,N) + DYX(J)
            ELSE
              N1 = ND(I,J-1,K)
              YE(1,N) = YE(3,N1)
              YE(2,N) = YE(4,N1)
              YE(3,N) = YE(1,N) + DYX(J)
              YE(4,N) = YE(2,N) + DYX(J)
              YE(5,N) = YE(7,N1)
              YE(6,N) = YE(8,N1)
              YE(7,N) = YE(5,N) + DYX(J)
              YE(8,N) = YE(6,N) + DYX(J)
            ENDIF
          ENDDO
        ENDDO
      ENDDO
!
!---  Assign z-direction vertices   ---
!
      DO K = 1,KFLD
        DO J = 1,JFLD
          DO I = 1,IFLD
            N = ND(I,J,K)
            IF( I.EQ.1 .AND. J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              ZLX(2) = ZX(IJ,K)
              ZLX(3) = ZX(IJ,K)
              ZLX(4) = ZX(IJ,K)
            ELSEIF( I.EQ.1 ) THEN
              IJ = (J-2)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K)
              IJ = (J-2)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ELSEIF( J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ELSE
              IJ = (J-2)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K)
              IJ = (J-2)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ENDIF
            ZE(1,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
            IF( I.EQ.1 .AND. J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              ZLX(2) = ZX(IJ,K+1)
              ZLX(3) = ZX(IJ,K+1)
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( I.EQ.1 ) THEN
              IJ = (J-2)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-2)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ELSE
              IJ = (J-2)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-2)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ENDIF
            ZE(5,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
            IF( I.EQ.IFLD .AND. J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              ZLX(2) = ZX(IJ,K)
              ZLX(3) = ZX(IJ,K)
              ZLX(4) = ZX(IJ,K)
            ELSEIF( I.EQ.IFLD ) THEN
              IJ = (J-2)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K)
              IJ = (J-2)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ELSEIF( J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I + 1
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K)
            ELSE
              IJ = (J-2)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K)
              IJ = (J-2)*IFLD + I + 1
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K)
            ENDIF
            ZE(2,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
            IF( I.EQ.IFLD .AND. J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              ZLX(2) = ZX(IJ,K+1)
              ZLX(3) = ZX(IJ,K+1)
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( I.EQ.IFLD ) THEN
              IJ = (J-2)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-2)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( J.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I + 1
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K+1)
            ELSE
              IJ = (J-2)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-2)*IFLD + I + 1
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K+1)
            ENDIF
            ZE(6,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
            IF( I.EQ.1 .AND. J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              ZLX(2) = ZX(IJ,K)
              ZLX(3) = ZX(IJ,K)
              ZLX(4) = ZX(IJ,K)
            ELSEIF( I.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J)*IFLD + I
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ELSEIF( J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ELSE
              IJ = (J-1)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K)
              IJ = (J)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ENDIF
            ZE(3,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
            IF( I.EQ.1 .AND. J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              ZLX(2) = ZX(IJ,K+1)
              ZLX(3) = ZX(IJ,K+1)
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( I.EQ.1 ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ELSE
              IJ = (J-1)*IFLD + I - 1
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I - 1
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ENDIF
            ZE(7,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
            IF( I.EQ.IFLD .AND. J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              ZLX(2) = ZX(IJ,K)
              ZLX(3) = ZX(IJ,K)
              ZLX(4) = ZX(IJ,K)
            ELSEIF( I.EQ.IFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J)*IFLD + I
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J)*IFLD + I
              ZLX(4) = ZX(IJ,K)
            ELSEIF( J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I + 1
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K)
            ELSE
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K)
              IJ = (J)*IFLD + I
              ZLX(3) = ZX(IJ,K)
              IJ = (J-1)*IFLD + I + 1
              ZLX(2) = ZX(IJ,K)
              IJ = (J)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K)
            ENDIF
            ZE(4,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
            IF( I.EQ.IFLD .AND. J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              ZLX(2) = ZX(IJ,K+1)
              ZLX(3) = ZX(IJ,K+1)
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( I.EQ.IFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I
              ZLX(4) = ZX(IJ,K+1)
            ELSEIF( J.EQ.JFLD ) THEN
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I + 1
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K+1)
            ELSE
              IJ = (J-1)*IFLD + I
              ZLX(1) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I
              ZLX(3) = ZX(IJ,K+1)
              IJ = (J-1)*IFLD + I + 1
              ZLX(2) = ZX(IJ,K+1)
              IJ = (J)*IFLD + I + 1
              ZLX(4) = ZX(IJ,K+1)
            ENDIF
            ZE(8,N) = 2.5D-1*(ZLX(1)+ZLX(2)+ZLX(3)+ZLX(4))*VARX
          ENDDO
        ENDDO
      ENDDO
!
!---  Close MODFLOW Discretization File   ---
!
      CLOSE( UNIT=9 )
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_MFDIS group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_OBDA
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Observed Data Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 27 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,CDUM,FDUM
      CHARACTER*512 CHDUM
      REAL*8 R_OBDSX(2)
      LOGICAL FLG_CHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_OBDA'
!
!---  Assign card string  ---
!
      CARD = 'Observed-Data Card'
!
!---  Read number of observed-data types  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Observed-Data Types'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NOBDTX)
      LOBDT = MAX( LOBDT,NOBDTX )
      NSF = LSF
!
!---  Loop over the number of observed-data types  ---
!
      DO 300 NT = 1,NOBDTX
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Observed-Data Type'
        CALL RD_CHR( ISTART,ICOMMA,NCH,CHDUM,ADUM )
!
!---  Surface-rate-observation variable  ---
!
        IF( INDEX(ADUM(1:),'surface').NE.0 .AND.
     &    ( INDEX(ADUM(1:),'rate').NE.0 .OR.
     &    INDEX(ADUM(1:),'flux').NE.0 ) ) THEN
          NSF = NSF + 1
          LSF = MAX( LSF,NSF )
!
!---  Surface-integral-observation variable  ---
!
        ELSEIF( INDEX(ADUM(1:),'surface').NE.0 .AND.
     &    INDEX(ADUM(1:),'integral').NE.0 ) THEN
          NSF = NSF + 1
          LSF = MAX( LSF,NSF )
        ENDIF
!
!---    Read number of observed data samples
!       or an external file name  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    Read observed-data samples from an external file  ---
!
        IF( INDEX( CHDUM(1:),'file').NE.0 ) THEN
          VARB = 'Observed-Data External File Name'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
!
!---      Check that external file exists  ---
!
          INQUIRE( FILE=FDUM(1:NCHF), FORM=CDUM, EXIST=FLG_CHK )
          IF( .NOT.FLG_CHK ) THEN
            INDX = 4
            CHMSG = 'Missing Observed-Data External File: '
     &        // FDUM(1:NCHF)
            CALL WRMSGP( INDX )
          ELSEIF( CDUM.EQ.'UNFORMATTED' ) THEN
            INDX = 4
            CHMSG = 'Unformatted Observed-Data External File: '
     &        // FDUM(1:NCHF)
            CALL WRMSGP( INDX )
          ENDIF
          OPEN(UNIT=27,FILE=FDUM(1:NCHF),STATUS='OLD',FORM='FORMATTED')
          NS = 0
  100     READ(27,'(A)',END=110) CHDUM
          IF( CHDUM(1:1).EQ.'#' .OR. CHDUM(1:1).EQ.'!' ) GOTO 100
          BACKSPACE(27)
          NS = NS + 1
          LOBDS = MAX( LOBDS,NS )
          READ(27,*,END=110) R_OBDSX(2),R_OBDSX(1)
          GOTO 100
  110     CONTINUE
          CLOSE(UNIT=27)
          GOTO 300
        ENDIF
!
!---    Read observed-data samples from input file  ---
!
        VARB = 'Number of Observed Data Samples'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NOBDSX)
        LOBDS = MAX( LOBDS,NOBDSX )
!
!---    Loop over number of observed data samples  ---
!
        DO 200 NS = 1,NOBDSX
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
  200   CONTINUE
  300 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_OBDA group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_NCP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Oil Component Properties Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 12 January 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_NCP'
!
!---  Assign card string  ---
!
      CARD = 'NAPL Components Properties Card'
!
!---  Read number of oil components  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of NAPL Components'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NCN)
      LCN = MAX( LCN,NCN )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_NCP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_NRP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read NAPL Relative Permeability Function Parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 18 December 2013.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TABL
      USE SOLTN
      USE PORMED
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,RDUM
      CHARACTER*512 CHDUM
      TYPE(LIST_NODE), POINTER :: LOC_PTR
      TYPE(LIST_SCALING), POINTER :: SC_LOC_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_NRP'
!
!---  Assign card string  ---
!
      CARD = 'NAPL Relative Permeability Card'
!
!---  Loop over the rock/soil NAPL relative permeability
!     information lines  ---
!
      N = 0
      IJK = 0
   10 CONTINUE
      IF( N.GE.NROCK .OR. IJK.GT.0 ) GOTO 500
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      VARB = 'Rock/Soil Name'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,RDUM)
!
!---  Check for a pair of delimiting slashes in the rock/soil name,
!     indicating a pattern of rock/soil types  ---
!
      KBS = 0
      IBS = INDEX( RDUM(1:),'/' )
      IF( IBS.GT.0 ) THEN
        IBS = IBS + 1
        JBS = INDEX( RDUM(IBS:),'/')
        IF( JBS.GT.0 ) THEN
          JBS = IBS + JBS - 2
          KBS = 1
          ISBS = ISTART
        ENDIF
      ENDIF
      IROCK = 1
   20 CONTINUE
!
!---  IJK, KIJ, or JKI indexing  ---
!
      IF( INDEX(RDUM(1:),'indexing').NE.0 ) THEN
        IF( INDEX(RDUM,'ijk').NE.0 ) THEN
          IJK = 1
        ELSEIF( INDEX(RDUM,'jki').NE.0 ) THEN
          IJK = 2
        ELSEIF( INDEX(RDUM,'kij').NE.0 ) THEN
          IJK = 3
        ELSE
          INDX = 4
          CHMSG = 'Unrecognized Indexing Option' // RDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        IROCK = 1
        GOTO 220
      ENDIF
!
!---  Search known rock types for a matching type  ---
!
          LOC_PTR => ROCK_PTR
          IROCK = 0
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IROCK = IROCK + 1
            IF( LOC_PTR%LIST_NAME == RDUM ) THEN
              GOTO 200
            ELSE
              LOC_PTR => LOC_PTR%NEXT
            ENDIF
          ENDDO
!
!---  Search known scaling groups for a matching type  ---
!
        IF( ISLC(19).EQ.1 ) THEN
          SC_LOC_PTR => SCALING_PTR
          ISGRP = 0
          DO
            IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
            IF( SC_LOC_PTR%SCALING_NAME == RDUM ) THEN
              ISGRP = SC_LOC_PTR%SCALING_NUM
              IROCK = 1
              GOTO 200
            ELSE
              SC_LOC_PTR => SC_LOC_PTR%NEXT
            ENDIF
          ENDDO
          INDX = 2
          CHMSG = 'Unrecognized Rock/Soil Type or Scaling Group: '
     &      // RDUM(1:NCH)
          CALL WRMSGP( INDX )
          GOTO 10
        ENDIF
        INDX = 2
        CHMSG = 'Unrecognized Rock/Soil Type: ' // RDUM(1:NCH)
        CALL WRMSGP( INDX )
        GOTO 10
  200   CONTINUE
!
!---  Loop over rock/soils within scaling group  ---
!
        IF( ISLC(19).EQ.1 .AND. ISGRP.NE.0 ) THEN
          DO 202 M = IROCK,NROCK
            IF( ISCALE(M).EQ.ISGRP ) THEN
              IROCK = M
              GOTO 204
            ENDIF
  202     CONTINUE
        ENDIF
  204   CONTINUE
!
!---  Read gas relative permeability pressure function  ---
!
  220 CONTINUE
      N = N + 1
!
!---  Read saturation/capillary pressure function for
!     tabular forms  ---
!
      VARB = 'NAPL Relative Permeability Function'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---    Tabular (relative permeability versus liquid saturation)  ---
!
      IF( INDEX(ADUM(1:),'tabular') .NE. 0 ) THEN
        IF( INDEX( ADUM(1:),'spline' ).NE.0 ) THEN
          IRPGX = 11
        ELSE
          IRPGX = 10
        ENDIF
!
!---    IJK Indexing  ---
!
        IF( IJK.GT.0 ) THEN
          VARB = 'Number of Tables'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NTABX)
          NTBL = 0
          DO 240 NTX = 1,NTABX
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            VARB = 'Number of Table Entries'
            CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
            IF( NLIN.LT.2 ) THEN
              INDX = 4
              CHMSG = 'Invalid NAPL Relative Permeability Table'
              CALL WRMSGP( INDX )
            ENDIF
            NTBL = NTBL + NLIN
            DO 230 NLX = 1,NLIN
              CALL RD_INPL( CHDUM )
  230       CONTINUE
  240     CONTINUE
          LTBL = LTBL + NTBL
        ELSE
          VARB = 'Number of Tabular Entries'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
          IF( NLIN.LT.2 ) THEN
            INDX = 4
            CHMSG = 'Invalid NAPL Relative Permeability Table'
            CALL WRMSGP( INDX )
          ENDIF
          DO 250 NL = 1,NLIN
            CALL RD_INPL( CHDUM )
 250      CONTINUE
          IF( IJK.GT.0 ) THEN
            NTBL = LFD*NLIN
          ELSE
            NTBL = NLIN
          ENDIF
          LTBL = LTBL + NTBL
        ENDIF
      ENDIF
!
!---  Continue reading rock/soil type names for a pattern match  ---
!
      IF( KBS.EQ.1 .AND. IROCK.LT.NROCK ) THEN
        IROCK = IROCK + 1
        ISTART = ISBS
        GOTO 20
      ENDIF
!
!---  Loop over remaining rock/soils within scaling group  ---
!
      IF( ISLC(19).EQ.1 .AND. IROCK.LT.NROCK ) THEN
        DO 490 M = IROCK+1,NROCK
          IF( ISCALE(M).EQ.ISGRP ) THEN
            N = N+1
          ENDIF
  490   CONTINUE
      ENDIF
!
!---  Read next rock/soil type or scaling group  ---
!
      GOTO 10
 500  CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_NRP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_OU
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Output Control Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 26 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_FRC
      USE PARM_BH
      USE OUTPU
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_OU'
!
!---  Assign card string  ---
!
      CARD = 'Output Control Card'
!
!---  Read reference node information  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Reference Nodes: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NREF)
      LREF = MAX( LREF,NREF )
!
!---  Skip over reference node domain input  ---
!
      DO 100 N = 1,NREF
        CALL RD_INPL( CHDUM )
  100 CONTINUE
!
!---  Read fracture/fault reference node information  ---
!
      IF( L_FRC.EQ.1 ) THEN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Number of Fracture/Fault Reference Nodes: '
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NREF_FRC)
        LREF = MAX( LREF,NREF_FRC )
!
!---    Skip over reference node domain input  ---
!
        DO N = 1,NREF_FRC
          CALL RD_INPL( CHDUM )
        ENDDO
      ENDIF
!
!---  Read borehole reference node information  ---
!
      IF( L_BH.EQ.1 ) THEN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Number of Borehole Reference Nodes: '
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NREF_BH)
        LREF = MAX( LREF,NREF_BH )
!
!---    Skip over reference node domain input  ---
!
        DO N = 1,NREF_BH
          CALL RD_INPL( CHDUM )
        ENDDO
      ENDIF
!
!---  Skip over output frequency and significant digits  ---
!
      CALL RD_INPL( CHDUM )
!
!---  Number of reference node variables  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Reference Node Variables: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NVREF)
      DO 200 NV = 1,NVREF
        CALL RD_INPL( CHDUM )
  200 CONTINUE
      LVREF = MAX( LVREF,NVREF )
!
!---  Plot file output times  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Plot File Output Times: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NPRTM)
      IC = 0
      DO 300 N = 1,NPRTM
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        ICMX = INDEX( CHDUM(ISTART:), ',' )
        IATX = INDEX( CHDUM(ISTART:), '@' )
!
!---    Sequence of plot file output times  ---
!
        IF( IATX.GT.1 .AND. IATX.LT.ICMX ) THEN
          CHDUM(IATX:IATX) = ','
          VARB = 'Count Integer'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,IATX )
          IC = IC + IATX
!
!---    Single plot file output time  ---
!
        ELSE
          IC = IC + 1
        ENDIF
 300  CONTINUE
      LPTM = MAX( LPTM,IC )
!
!---  Number of plot file variables  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Plot File Variables: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NVPLOT)
      LVPLOT = MAX( LVPLOT,NVPLOT )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_OU group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_PCP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Petroleum Components Properties Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 25 March 2013.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*64 ADUM,BDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_PCP'
!
!---  Assign card string  ---
!
      CARD = 'Petroleum Components Properties Card'
!!
!!---  Read number of petroleum components  ---
!!
!      CALL RD_INPL( CHDUM )
!      CALL L_CASE( CHDUM )
!      ISTART = 1
!      VARB = 'Number of Petroleum Components'
!      CALL RD_INT(ISTART,ICOMMA,CHDUM,NGC)
!      LNGC = MAX( LNGC,NGC ) + 2
!      LUK = LUK + LNGC
!
!---  Loop over number of petroleum components  ---
!
      DO IGC = 3,NGC+2
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Petroleum Component Name'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        CALL CHK_INT(ISTART,ICOMMA,CHDUM,INDX1)
        CALL CHK_CHR(ISTART,ICOMMA,CHDUM,INDX2)
!
!---    Petroleum component composition declared as a combination
!       of petroluem component fractions  ---
!
        IF( INDX1.EQ.1 ) THEN
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NPCFX)
          LPCF = MAX( LPCF,NPCFX )
!
!---      Loop over the number of petroleum component fractions ---
!
          DO N = 1,NPCFX
            CALL RD_INPL( CHDUM )
          ENDDO
!
!---    Petroleum component critical properties entered directly  ---
!
        ELSE
!
!---      Petroleum component composition declared as a combination
!         of petroluem fraction components  ---
!
          IF( INDX2.EQ.1 ) THEN
            VARB = 'Petroleum Component Grouping Type'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
            IF( INDEX(BDUM(1:),'composite').NE.0 ) THEN
              CALL RD_INT(ISTART,ICOMMA,CHDUM,NPCFX)
              DO N = 1,NPCFX
                CALL RD_INPL( CHDUM )
              ENDDO
            ELSE
              INDX = 4
              CHMSG = 'Unrecognized Petroleum Component Grouping ' // 
     &          'Type: ' // BDUM
              CALL WRMSGP( INDX )
            ENDIF
          ELSE
            CALL RD_INPL( CHDUM )
          ENDIF
        ENDIF
      ENDDO
          
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_PCP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_PLANT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Plant Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 29 October 2003.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PLT_ATM
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*64 UNTS
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_PLANT'
!
!---  Assign card string  ---
!
      CARD = 'Plant Properties Card'
!
!---  Read number of plant varietals  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Plants'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NPLANT)
      LPLANT = MAX( LPLANT,NPLANT )
!
!---  Allocate memory for the plant parameters  ---
!
      ALLOCATE( PARMS_P(1:29,1:LPLANT),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: PARMS_P'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Allocate memory for the plant names  ---
!
      ALLOCATE( PLANT(1:LPLANT),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: PLANT'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Loop over the plants information lines  ---
!
      DO 500 IP = 1,NPLANT
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Plant Name: '
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,PLANT(IP))
        DO 100 M = 1,IP-1
          IF( PLANT(M).EQ.PLANT(IP) ) THEN
            INDX = 4
            CHMSG = 'Duplicate Plant Name: ' // PLANT(IP)
            CALL WRMSGP( INDX )
          ENDIF
  100   CONTINUE
!
!---    Read root (Z) depth characteristics  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Max. Root Depth'
        UNTS = 'm'
        IUNM = 1
        IDFLT = 1
        PARMS_P(1,IP) = 1.D-3
        CALL RD_DPR(ISTART,ICOMMA,CHDUM,PARMS_P(1,IP))
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
        CALL RD_UNIT(UNTS,PARMS_P(1,IP),INDX)
!
!---    Minimum maximum plant root depth of 1 mm  ---
!
        PARMS_P(1,IP) = MAX( 1.D-3,PARMS_P(1,IP) )
  500 CONTINUE
!
!---  Deallocate memory for the plant names  ---
!
      IF( ALLOCATED(PLANT) ) THEN
      DEALLOCATE( PLANT,STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Deallocation Error: PLANT'
        CALL WRMSGP( INDX )
      ENDIF
      ENDIF
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_PLANT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_PREP_BH( NBH )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read preprocessed input file for boreholes
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 24 February 2023.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_BH
      USE OUTPU
      USE GRID
      USE GEOM_FRC
      USE GEOM_BH
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 PAR_BHX(16),VAR_BHX(11,LT_BH),VARC_BHX(2*LSOLU_BH,LT_BH)
!
!----------------------Data Statements---------------------------------!
!
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_PREP_BH'
!
!---  Borehole type and borehole name  ---
!
      READ(35,*) (ID_BH(M,NBH),M=1,6),(IT_BH(M,NBH),M=1,2),ITM_BHX
!
!---  Loop over number of borehole intervals  ---
!
      DO NIBH = ID_BH(1,NBH),ID_BH(2,NBH)
        READ(35,*) (XTP_BH(M,NIBH),M=1,2),(YTP_BH(M,NIBH),M=1,2),
     &    (ZTP_BH(M,NIBH),M=1,2),(PAR_BHX(M),M=1,16)
      ENDDO
!
!---  Borehole sources  ---
!
      READ(35,*) ((VAR_BHX(M,N),M=1,11),N=1,ITM_BHX)
      READ(35,*) ((VARC_BHX(M,N),M=1,2*LSOLU_BH),N=1,ITM_BHX)
!
!---  Loop over borehole nodes  ---
!
      DO NBN = ID_BH(3,NBH),ID_BH(4,NBH)
        READ(35,*) INV_BHX
        READ(35,*) (XP_BH(M,NBN),M=1,2),(YP_BH(M,NBN),M=1,2),
     &    (ZP_BH(M,NBN),M=1,2),IBN_BH(NBN),(IPB_BH(M,NBN),M=1,3)
        DO ICX = 1,2
          NCX = IPB_BH(ICX,NBN)
          IF( NCX.LE.0 ) CYCLE
          READ(35,*) IBCM_BH(NCX)
        ENDDO
      ENDDO
!
!---  Skip for boundary condition type boreholes  ---
!
      IF( IT_BH(1,NBH).LT.21.OR.IT_BH(1,NBH).GT.29 ) THEN
!
!---    Loop over borehole node to fracture triangle connections  ---
!
        DO NCX = ID_BH(5,NBH),ID_BH(6,NBH)
          READ(35,*) IBHN_FRC(NCX),IBHT_FRC(NCX)
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_PREP_BH group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_PREP_FRC( NFX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read preprocessed input file for fractures/faults
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 24 February 2023.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PARM_FRC
      USE OUTPU
      USE GRID
      USE GEOM_FRC
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
       CHARACTER*512 CHDUM
!
!----------------------Data Statements---------------------------------!
!
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_PREP_FRC'
!
!---  Read number of fracture triangles  ---
!
      READ(35,*) NTP_FRC(NFX),IP_FRC(1,NFX),IP_FRC(2,NFX)
      NT_FRC = NT_FRC + NTP_FRC(NFX)
      IF( NT_FRC.GT.LT_FRC ) THEN
        INDX = 5
        CHMSG = 'Number of Fracture/Fault Triangles > Parameter LT_FRC'
        CALL WRMSGS( INDX )
      ENDIF
!
!---  Read joint model parameters  ---
!
      READ(35,'(A)') CHDUM
!
!---  Loop over the number of triangles in the fracture  ---
!
      DO MTX = 1,NTP_FRC(NFX)
        NTX = MTX + IP_FRC(1,NFX) - 1
!
!---    Fracture triangle index  ---
!
        READ(35,*) IXP_FRC(NTX)
!
!---    Read the fracture triangle vertices  ---
!
        READ(35,*) (XE_FRC(I,NTX),I=1,3),(YE_FRC(J,NTX),J=1,3),
     &    (ZE_FRC(K,NTX),K=1,3)
!
!---    Read the fracture triangle centroids and area  ---
!
        READ(35,*) XP_FRC(NTX),YP_FRC(NTX),ZP_FRC(NTX),AF_FRC(NTX)
!
!---    Surface normal vector of the fracture triangle ---
!
        READ(35,'(A)') CHDUM
!
!---    Read triangle joint parameters  ---
!
        READ(35,'(A)') CHDUM
!
!---    Skip for inactive triangles  ---
!
        IF( IXP_FRC(NTX).EQ.0 ) CYCLE
!
!---    Resident node number for fracture triangle vertices  ---
!
        READ(35,*) (ND_FRC(I,NTX),I=1,3)
!
!---    Number of node to fracture and fracture to fracture 
!       connections ---
!
        READ(35,*) (IPN_FRC(I,NTX),I=1,2),(IPF_FRC(J,NTX),J=1,2)
!
!---    Loop over fracture triangle to triangle connections ---
!
        DO NCX = IPF_FRC(1,NTX),IPF_FRC(2,NTX)
          READ(35,*) ITCM_FRC(NCX)
        ENDDO
!
!---    Loop over fracture triangle to grid-cell connections ---
!
        DO NCX = IPN_FRC(1,NTX),IPN_FRC(2,NTX)
          READ(35,*) INCM_FRC(NCX)
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_PREP_FRC group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_ROCK
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Rock/Soil Zonation Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 21 November 2002.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PORMED
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,BDUM,CDUM,FDUM
      CHARACTER*512 CHDUM,CHDUMX
      LOGICAL FCHK
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
      TYPE(LIST_SCALING), POINTER :: SC_LOC_PTR,SC_TMP_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_ROCK'
!
!---  Assign card string  ---
!
      CARD = 'Rock/Soil Zonation Card'
!
!---  Allocate memory for the rock/soil zonation index array  ---
!
      ALLOCATE( IZ(1:LFD),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IZ'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Rock/soil zonation input option  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Input Option [File, Zonation_File, Integer, Indexing]'
      CALL RD_CHR(ISTART,ICOMMA,NCHA,CHDUM,ADUM)
!
!---  Read rock/soil zonation information from an
!     AVS ASCII UCD file  ---
!
      IF( INDEX(ADUM(1:),'avs').NE.0 .AND.
     &  INDEX(ADUM(1:),'ascii').NE.0 .AND.
     &  INDEX(ADUM(1:),'ucd').NE.0 ) THEN
        VARB = 'AVS ASCII UCD File Name'
        CALL RD_CHR(ISTART,ICOMMA,NCHB,CHDUM,BDUM)
        IF( INDEX(ADUM,'file').NE.0 ) THEN
          FDUM = BDUM
          NCHF = NCHB
        ENDIF
        IF( INDEX(BDUM,'file').NE.0 ) THEN
          FDUM = ADUM
          NCHF = NCHA
        ENDIF
       INQUIRE( FILE=FDUM(1:NCHF), FORM=CDUM, EXIST=FCHK )
       IF( .NOT.FCHK ) THEN
         INDX = 4
         CHMSG = 'AVS ASCII UCD file does not exist: '
     &     // BDUM(1:NCHB)
         CALL WRMSGS( INDX )
       END IF
       OPEN( UNIT=36,FILE=FDUM(1:NCHF),STATUS='OLD',FORM='FORMATTED' )
       REWIND( UNIT=36 )
!
!---   Read number of vertices and number of grid cells (nodes) ---
!
       READ(36,*) NVERTX,NFLDX
       DO N = 1,NVERTX
         READ(36,'(A)') CHDUMX
       ENDDO
       DO N = 1,NFLDX
         READ(36,'(A)') CHDUMX
         ISX = INDEX( CHDUMX(1:),' ' )
         IEX = INDEX( CHDUMX(1:),'hex' ) - 1
         READ(CHDUMX(ISX:IEX),*) IZ(N)
       ENDDO
       CLOSE(UNIT=36)
!
!---  Read rock/soil zonation information from an external file  ---
!
      ELSEIF( INDEX(ADUM,'zonation').NE.0 .AND.
     &  INDEX(ADUM,'file').NE.0 ) THEN
        VARB = 'Rock/soil zonation external file name'
        CALL RD_CHR(ISTART,ICOMMA,NCHB,CHDUM,BDUM)
        IF( INDEX(ADUM,'file').NE.0 ) THEN
          FDUM = BDUM
          NCHF = NCHB
        ENDIF
        IF( INDEX(BDUM,'file').NE.0 ) THEN
          FDUM = ADUM
          NCHF = NCHA
        ENDIF
        IF( INDEX(CHDUM,'formatted').NE.0 ) THEN
          INQUIRE( FILE=FDUM(1:NCHF), FORM=CDUM, EXIST=FCHK )
          IF( .NOT.FCHK ) THEN
            INDX = 4
            CHMSG = 'Rock/soil zonational file does not exist: '
     &        // BDUM(1:NCHB)
            CALL WRMSGP( INDX )
          ELSEIF( CDUM.EQ.'UNFORMATTED' ) THEN
            INDX = 4
            CHMSG = 'Rock/soil zonational file is unformatted: '
     &        // BDUM(1:NCHB)
            CALL WRMSGP( INDX )
          END IF
          OPEN( UNIT=27,FILE=FDUM(1:NCHF),STATUS='OLD',
     &      FORM='FORMATTED' )
          NROCK = 1
          READ(27,*)(IZ(N),N=1,LFD)
          CLOSE( UNIT=27 )
          DO 10 N = 1,LFD
            NROCK = MAX( NROCK,IZ(N) )
   10     CONTINUE
          LRC = MAX( LRC,NROCK )
        ELSE
          INQUIRE( FILE=FDUM(1:NCHF), FORM=CDUM, EXIST=FCHK )
          IF( .NOT.FCHK ) THEN
            INDX = 4
            CHMSG = 'Rock/soil zonational file does not exist: '
     &        // BDUM(1:NCHB)
            CALL WRMSGP( INDX )
          ELSEIF( CDUM.EQ.'FORMATTED' ) THEN
            INDX = 4
            CHMSG = 'Rock/soil zonational file is formatted: '
     &        // BDUM(1:NCHB)
            CALL WRMSGP( INDX )
          END IF
          OPEN( UNIT=27,FILE=FDUM(1:NCHF),STATUS='OLD',
     &      FORM='UNFORMATTED' )
          NROCK = 1
          READ(27,*)(IZ(N),N=1,LFD)
          CLOSE( UNIT=27 )
          DO 20 N = 1,LFD
            NROCK = MAX( NROCK,IZ(N) )
   20     CONTINUE
          LRC = MAX( LRC,NROCK )
        ENDIF
        NULLIFY( ROCK_PTR )
        DO 50 NL = 1,NROCK
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          VARB = 'Rock/Soil Name: '
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Empty rock list  ---
!
          IF( .NOT.ASSOCIATED(ROCK_PTR) ) THEN
            ALLOCATE( ROCK_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            ROCK_PTR%LIST_NAME = ADUM
            NULLIFY(ROCK_PTR%NEXT)
          ELSE
            LOC_PTR => ROCK_PTR
!
!---        Check for duplicate rock/soil name  ---
!
            DO
              IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
              IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                INDX = 4
                CHMSG = 'Duplicate Rock/Soil Name: ' // ADUM
                CALL WRMSGP( INDX )
              ELSE
                LOC_PTR => LOC_PTR%NEXT
              ENDIF
            ENDDO
!
!---        Add rock/soil name to rock list  ---
!
            ALLOCATE( TMP_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            TMP_PTR%LIST_NAME = ADUM
            TMP_PTR%NEXT => ROCK_PTR
            ROCK_PTR => TMP_PTR
          ENDIF
   50   CONTINUE
!
!---  Read rock/soil zonation information from an external file  ---
!
      ELSEIF( INDEX(ADUM,'file').NE.0 ) THEN
        VARB = 'External File Name'
        CALL RD_CHR(ISTART,ICOMMA,NCHB,CHDUM,BDUM)
        INQUIRE( FILE=BDUM(1:NCHB), FORM=CDUM, EXIST=FCHK )
        IF( .NOT.FCHK ) THEN
          INDX = 4
          CHMSG = 'Rock/soil zonational file does not exist: '
     &      // BDUM(1:NCHB)
          CALL WRMSGP( INDX )
        ELSEIF( CDUM.EQ.'UNFORMATTED' ) THEN
          INDX = 4
          CHMSG = 'Rock/soil zonational file is unformatted: '
     &      // BDUM(1:NCHB)
          CALL WRMSGP( INDX )
        END IF
        OPEN(UNIT=27, FILE=BDUM(1:NCHB), STATUS='OLD',
     &    FORM='FORMATTED')
        VARB = 'Number of Zonation Lines'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
        NROCK = 0
        NULLIFY( ROCK_PTR )
        DO 440 NL = 1,NLIN
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          VARB = 'Rock/Soil Name: '
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Empty rock list  ---
!
          IF( .NOT.ASSOCIATED(ROCK_PTR) ) THEN
            ALLOCATE( ROCK_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            ROCK_PTR%LIST_NAME = ADUM
            NULLIFY(ROCK_PTR%NEXT)
            NROCK = NROCK + 1
          ELSE
            LOC_PTR => ROCK_PTR
!
!---        Check for duplicate rock/soil name  ---
!
            DO
              IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
              IF( LOC_PTR%LIST_NAME == ADUM ) THEN
                INDX = 4
                CHMSG = 'Duplicate Rock/Soil Name: ' // ADUM
                CALL WRMSGP( INDX )
              ELSE
                LOC_PTR => LOC_PTR%NEXT
              ENDIF
            ENDDO
!
!---        Add rock/soil name to rock list  ---
!
            NROCK = NROCK + 1
            ALLOCATE( TMP_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            TMP_PTR%LIST_NAME = ADUM
            TMP_PTR%NEXT => ROCK_PTR
            ROCK_PTR => TMP_PTR
          ENDIF
          LRC = NROCK
  440   CONTINUE
        CLOSE(UNIT=27)
!
!---  Assign rock/soil zonation information by indexing order,
!       useful for stochastic realizations  ---
!
      ELSEIF( INDEX(ADUM,'indexing').NE.0 ) THEN
        LRC = LFD
        NROCK = 1
!
!---  Read rock/soil zonation information from the input file  ---
!
      ELSE
        ISTART = 1
        VARB = 'Number of Zonation Lines'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
        NROCK = 0
        NSCALE = 0
        NULLIFY( ROCK_PTR )
        NULLIFY( SCALING_PTR )
        DO 480 NL = 1, NLIN
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          ADUM(1:) = ' '
          VARB = 'Rock/Soil Name: '
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Empty rock list  ---
!
          IF( .NOT.ASSOCIATED(ROCK_PTR) ) THEN
            ALLOCATE( ROCK_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            ROCK_PTR%LIST_NAME = ADUM
            NULLIFY(ROCK_PTR%NEXT)
            NROCK = NROCK + 1
!
!---        Initialize scaling pointer  ---
!
            IF( ISLC(19).EQ.1 ) THEN
              ALLOCATE( SCALING_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: SCALING_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              SCALING_PTR%ROCK_NAME = ADUM
              SCALING_PTR%ROCK_NUM = NROCK
              NULLIFY(SCALING_PTR%NEXT)
              NSCALE = NSCALE + 1
            ENDIF
          ELSE
            LOC_PTR => ROCK_PTR
!
!---        Check for repeated rock/soil name  ---
!
            DO
              IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
              IF( LOC_PTR%LIST_NAME == ADUM ) GOTO 460
              LOC_PTR => LOC_PTR%NEXT
            ENDDO
!
!---        Add rock/soil name to rock list  ---
!
            NROCK = NROCK + 1
            ALLOCATE( TMP_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            TMP_PTR%LIST_NAME = ADUM
            TMP_PTR%NEXT => ROCK_PTR
            ROCK_PTR => TMP_PTR
!
!---        Add to scaling pointer  ---
!
            IF( ISLC(19).EQ.1 ) THEN
              SC_LOC_PTR => SCALING_PTR
              ALLOCATE( SC_TMP_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: SCALING_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              SC_TMP_PTR%ROCK_NAME = ADUM
              SC_TMP_PTR%ROCK_NUM = NROCK
              SC_TMP_PTR%NEXT => SCALING_PTR
              SCALING_PTR => SC_TMP_PTR
            ENDIF
          ENDIF
  460     CONTINUE
          LRC = NROCK
!
!---      Read rock/soil domain  ---
!
          VARB = 'Rock/Soil Domain Index: '
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I1)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I2)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J1)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J2)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K1)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K2)
!
!---      Read scaling group associations  ---
!
          IF( ISLC(19).EQ.1 ) THEN
            ADUM(1:) = ' '
            VARB = 'Scaling Group Name: '
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            SCALING_PTR%SCALING_NAME = ADUM
!
!---        Check for repeated scaling group name  ---
!
            SC_LOC_PTR => SCALING_PTR
            DO
              IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
              IF( SC_LOC_PTR%SCALING_NAME == ADUM ) GOTO 470
              SC_LOC_PTR => SC_LOC_PTR%NEXT
            ENDDO
            NSCALE = NSCALE + 1
  470       CONTINUE
            SCALING_PTR%SCALING_NUM = NSCALE
          ENDIF
  480   CONTINUE
!
!---    Assign scaling index  ---
!
        IF( ISLC(19).EQ.1 ) THEN
!
!---      Allocate memory for the rock/soil zonation index array  ---
!
          ALLOCATE( ISCALE(1:LRC),STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: ISCALE'
            CALL WRMSGP( INDX )
          ENDIF
          SC_LOC_PTR => SCALING_PTR
          DO
            IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
            IROCK = SC_LOC_PTR%ROCK_NUM
            ISCALE(IROCK) = SC_LOC_PTR%SCALING_NUM
            SC_LOC_PTR => SC_LOC_PTR%NEXT
          ENDDO
        ENDIF
      ENDIF
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_ROCK group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_ROCK_FRAC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Fracture Zonation Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 21 November 2002.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PORMED
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM
      CHARACTER*512 CHDUM
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
      TYPE(LIST_SCALING), POINTER :: SC_LOC_PTR,SC_TMP_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_ROCK_FRAC'
!
!---  Assign card string  ---
!
      CARD = 'Fracture Zonation Card'
!
!---  Rock/soil zonation input option  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Input Option [File, Zonation_File, Integer, Indexing]'
      CALL RD_CHR(ISTART,ICOMMA,NCHA,CHDUM,ADUM)
!
!---  Read rock/soil zonation information from the input file  ---
!
      IF( INDEX(ADUM,'indexing').EQ.0.AND.INDEX(ADUM,'file').EQ.0 ) THEN
        ISTART = 1
        VARB = 'Number of Zonation Lines'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
        NROCK = LRC  ! = 0 !rss start with values from RD_ROCK
        NSCALE = 0
        IF( ISLC(19).EQ.1 ) NSCALE = SCALING_PTR%SCALING_NUM + 1
        DO 480 NL = 1, NLIN
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          ADUM(1:) = ' '
          VARB = 'Rock/Soil Name: '
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---      Empty rock list  ---
!
          IF( .NOT.ASSOCIATED(ROCK_PTR) ) THEN
            NULLIFY( ROCK_PTR )
            ALLOCATE( ROCK_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            ROCK_PTR%LIST_NAME = ADUM
            NULLIFY(ROCK_PTR%NEXT)
            NROCK = NROCK + 1
          ELSE
            LOC_PTR => ROCK_PTR
!
!---        Check for repeated rock/soil name  ---
!
            DO
              IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
              IF( LOC_PTR%LIST_NAME == ADUM ) GOTO 460
              LOC_PTR => LOC_PTR%NEXT
            ENDDO
!
!---        Add rock/soil name to rock list  ---
!
            NROCK = NROCK + 1
            ALLOCATE( TMP_PTR,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: ROCK_PTR'
              CALL WRMSGP( INDX )
            ENDIF
            TMP_PTR%LIST_NAME = ADUM
            TMP_PTR%NEXT => ROCK_PTR
            ROCK_PTR => TMP_PTR
!
!---        Add to scaling pointer  ---
!
            IF( ISLC(19).EQ.1 ) THEN
              SC_LOC_PTR => SCALING_PTR
              ALLOCATE( SC_TMP_PTR,STAT=ISTAT )
              IF( ISTAT.NE.0 ) THEN
                INDX = 3
                CHMSG = 'Allocation Error: SCALING_PTR'
                CALL WRMSGP( INDX )
              ENDIF
              SC_TMP_PTR%ROCK_NAME = ADUM
              SC_TMP_PTR%ROCK_NUM = NROCK
              SC_TMP_PTR%NEXT => SCALING_PTR
              SCALING_PTR => SC_TMP_PTR
            ENDIF
          ENDIF
  460     CONTINUE
          LRC = NROCK !rss LRC should now include both ROCKs and FRACs
!
!---      Read rock/soil domain  ---
!
          VARB = 'Fracture Domain Index: '
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NFX)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I1)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I2)
!
!---      Read scaling group associations  ---
!
          IF( ISLC(19).EQ.1 ) THEN
            ADUM(1:) = ' '
            VARB = 'Scaling Group Name: '
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            SCALING_PTR%SCALING_NAME = ADUM
!
!---        Check for repeated scaling group name  ---
!
            SC_LOC_PTR => SCALING_PTR
            DO
              IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
              IF( SC_LOC_PTR%SCALING_NAME == ADUM ) GOTO 470
              SC_LOC_PTR => SC_LOC_PTR%NEXT
            ENDDO
            NSCALE = NSCALE + 1
  470       CONTINUE
            SCALING_PTR%SCALING_NUM = NSCALE
          ENDIF
  480   CONTINUE
!
!---    Assign scaling index  ---
!
        IF( ISLC(19).EQ.1 ) THEN
!
!---      Allocate memory for the rock/soil zonation index array  ---
!
          IF( ALLOCATED(ISCALE) ) DEALLOCATE(ISCALE) !rss reallocate
          ALLOCATE( ISCALE(1:LRC),STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: ISCALE'
            CALL WRMSGP( INDX )
          ENDIF
          SC_LOC_PTR => SCALING_PTR
          DO
            IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
            IROCK = SC_LOC_PTR%ROCK_NUM
            ISCALE(IROCK) = SC_LOC_PTR%SCALING_NUM
            SC_LOC_PTR => SC_LOC_PTR%NEXT
          ENDDO
        ENDIF
      ENDIF
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_ROCK group
!
      RETURN
      END

!-------------------------Disclaimer-----------------------------------!
!
      SUBROUTINE RD_SFCOV
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Surface Cover Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by SK White, PNNL, 10 September 2015.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PLT_ATM
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM
      CHARACTER*512 CHDUM,UNTS
      REAL*8, DIMENSION(:), ALLOCATABLE :: XSPX,YSPX
      INTEGER ITMP(LFX,LFY),NTMP(LFX,LFY)
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SFCOV'
!
!---  Assign card string  ---
!
      CARD = 'Surface Cover Card'
!
!---  Initialize arrays  ---
!
      DO J = 1,LFY
        DO I = 1,LFX
          ITMP(I,J) = 0
        ENDDO
      ENDDO
!
!---  Read number of surface cover areas  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Surface Cover Areas'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSFCA)
      LSFCA = MAX( LSFCA,NSFCA )
      L_SFC = 1
!
!---  Loop over number of surface cover areas  ---
!
      NULLIFY( SFC_PTR )
      DO 480 NSC = 1, NSFCA
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        ADUM(1:) = ' '
        VARB = 'Surface Cover Area Name'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---    Empty surface cover area list  ---
!
        IF( .NOT.ASSOCIATED(SFC_PTR) ) THEN
          ALLOCATE( SFC_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: SFC_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          SFC_PTR%LIST_NAME = ADUM
          NULLIFY(SFC_PTR%NEXT)
        ELSE
          LOC_PTR => SFC_PTR
!
!---     Check for repeated surface cover area name  ---
!
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IF( LOC_PTR%LIST_NAME == ADUM ) THEN
              INDX = 4
              CHMSG = 'Duplicate Surface Area Name'
              CALL WRMSGP( INDX )
            ENDIF
            LOC_PTR => LOC_PTR%NEXT
          ENDDO
!
!---      Add surface cover name to surface cover list  ---
!
          ALLOCATE( TMP_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: SFC_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          TMP_PTR%LIST_NAME = ADUM
          TMP_PTR%NEXT => SFC_PTR
          SFC_PTR => TMP_PTR
        ENDIF
!
!---    Read number of surface cover polygons corresponding to 
!       surface cover area  ---
!
        VARB = 'Number of Surface Cover Polygons'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NPLYX)
        IF( NPLYX.EQ.0 ) NPLYX = 1
!
!---    Loop over number of surface cover polyons  ---
!
        DO 400 NP = 1, NPLYX
!
!---      Read number of surface cover polygon definition x,y pairs  ---
!
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          VARB = 'Number of Surface Cover Polygon Definition Pairs'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NSFCPX)
          LSFCP = MAX( LSFCP,(NSFCPX+1) )            
!
!---      Read units for surface cover polygon coordinate units  ---
!
          VARB = 'Surface Cover Polygon Coordinate Units'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          VARX = 1.D+0
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,VARX,INDX)
!
!---      Allocate memory for polygon point arrays  ---
!
          IF( .NOT.ALLOCATED(XSPX) ) THEN
            ALLOCATE( XSPX(LSFCP),STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: XSPX'
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
!
          IF( .NOT.ALLOCATED(YSPX) ) THEN
            ALLOCATE( YSPX(LSFCP),STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Allocation Error: YSPX'
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
!
!---      Read surface cover polygon coordinates  ---
!
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          VARB = 'Surface Cover Polygon Points'
          DO 300 I = 1,NSFCPX   
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,XSPX(I))
            XSPX(I) = XSPX(I)*VARX
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,YSPX(I))
            YSPX(I) = YSPX(I)*VARX
  300     CONTINUE
!
!---      Check to make sure polygon is closed. If not, close it.  ---
!         
          IF ( XSPX(1).NE.XSPX(NSFCPX) .OR. 
     &      YSPX(1).NE.YSPX(NSFCPX) ) THEN
            NSFCPX = NSFCPX + 1
            XSPX(NSFCPX) = XSPX(1)
            YSPX(NSFCPX) = YSPX(1)
          ENDIF          
!
!---      Loop over nodes from top down to determine how many nodes are 
!         active surface nodes. If the top node is inactive, find the  
!         top most active node. If node is an active surface node check  
!         to see if it is within the surface cover area polygon     
!   
          DO J = 1,LFY
          DO I = 1,LFX
            DO 310 K = LFZ,1,-1
              N = ND(I,J,K)           
              IF( IXP(N).NE.0 ) THEN
                XPT = 2.5D-1*(XE(5,N)+XE(6,N)+XE(7,N)+XE(8,N))
                YPT = 2.5D-1*(YE(5,N)+YE(6,N)+YE(7,N)+YE(8,N))             
                CALL LOC_PT( XPT,YPT,XSPX,YSPX,NSFCPX,IINOUT,IPATH )
                IF ( IINOUT.GE.0 ) THEN
                  ITMP(I,J) = NSC
                  NTMP(I,J) = N
                ENDIF     
                EXIT
              ENDIF
  310      CONTINUE
          ENDDO
          ENDDO
  400   CONTINUE
!
!---    Read number of surface cover times  ---
!
        ISTART = 1
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        VARB = 'Number of Surface Cover Times'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,ISFCTX)
        IF( ISFCTX.EQ.0 ) THEN
          INDX = 4
          CHMSG = 'No Surface Cover Times'
          CALL WRMSGP( INDX )
        ENDIF
        LSFCT = MAX( LSFCT,ISFCTX )
!
!---    Skip over the surface cover variables and units  ---
!
        DO 450 NTM = 1,ISFCTX
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
  450   CONTINUE
!
  480 CONTINUE
!
!---  Loop over nodes in xy plane and count number of nodes 
!     within surface cover areas.
!   
      NC = 0        
      DO 550 NSC = 1,NSFCA
        DO J = 1,LFY
        DO I = 1,LFX
          IF( ITMP(I,J).EQ.NSC ) NC = NC + 1
        ENDDO
        ENDDO
  550 CONTINUE
      IF( NC.EQ.0 ) THEN
        INDX = 4
        CHMSG = 'No Nodes Within Surface Cover Areas'
        CALL WRMSGP( INDX )
      ENDIF
      NSFCN = NC
      LSFCN = MAX( LSFCN,NSFCN )
!
!---  Allocate memory for surface cover connection map array  ---
!
      ALLOCATE( ICM_SFC(1:1,1:LSFCN),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: ICM_SFC'
        CALL WRMSGP( INDX )
      ENDIF
!
!---  Loop over nodes in xy plane and fill top node for surface
!     cover connection map index
! 
      NC = 0        
      DO 650 NSC = 1,NSFCA
        DO J = 1,LFY
        DO I = 1,LFX
          IF( ITMP(I,J).EQ.NSC ) THEN
            NC = NC + 1
            ICM_SFC(1,NC) = NTMP(I,J)
          ENDIF
        ENDDO
        ENDDO
  650 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SFCOV group
!
      RETURN
      END
      
!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SDSP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read aqueous reaction species.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 8 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE REACT
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SDSP'
!
!---  Assign card string  ---
!
      CARD = 'Solid Species Card'
!
!---  Read number of aqueous species  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Solid Species'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSPS)
      LSPS = MAX( LSPS,NSPS )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SDSP group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SF
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Surface Flux Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 27 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM,ADUM,BDUM,FDUM,GDUM
      LOGICAL FLG_CHK
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SF'
!
!---  Assign card string  ---
!
      CARD = 'Surface Flux Card'
!
!---  Read surface flux card information  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Surface Flux Inputs'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSF)
      LSF = MAX( LSF,NSF )
      NS = 0
      NSFF = 0
      DO
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        CALL CHK_INT(ISTART,ICOMMA,CHDUM,INDX)
        IF( INDX == 1 ) THEN
          NSFF = NSFF+1
          CYCLE
        ENDIF
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'solute') /= 0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
        END IF
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        IF( INDEX(ADUM(1:),'file') /= 0 ) THEN
          CALL RD_CHR(ISTART,ICOMMA,NCHF,CHDUM,FDUM)
          NCHF = INDEX(FDUM,'  ')-1
!
!---      Check that surface flux domain file exists  ---
!
          INQUIRE( FILE=FDUM(1:NCHF), FORM=GDUM, EXIST=FLG_CHK )
          IF( .NOT.FLG_CHK ) THEN
            INDX = 4
            CHMSG = 'Surface-Flux-Domain File: '
     &        // FDUM(1:NCHF)
            CALL WRMSGP( INDX )
          ELSEIF( GDUM.EQ.'UNFORMATTED' ) THEN
            INDX = 4
            CHMSG = 'Unformatted Surface-Flux-Domain File: '
     &        // FDUM(1:NCHF)
            CALL WRMSGP( INDX )
          ENDIF
          OPEN(UNIT=27,FILE=FDUM(1:NCHF),STATUS='OLD',FORM='FORMATTED')
          NC = 0
   30     CONTINUE
          READ(27,*,END=40) IX,JX,KX,ISFDX
          NC = NC + 1
          GOTO 30
   40     CONTINUE
          CLOSE(27)
          LSFDOM = MAX( LSFDOM,NC )
        END IF
        NS = NS+1
        IF( NS >= NSF ) EXIT
      END DO
!
!---  All surface flux files are named  ---
!
      IF( NSFF.EQ.NSF ) LSF = LSF+1
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SF group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SIMU
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Simulation Title Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 1 October 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SIMU'
!
!---  Assign card string  ---
!
      CARD = 'Simulation Title Card'
!
!---  Skip over six input lines  ---
!
      LSKIP = 6
      DO 100 L = 1,LSKIP
        CALL RD_INPL( CHDUM )
  100 CONTINUE
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Simulation Note Lines: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LNOTES)
      LNOTES = MAX( 1,LNOTES )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SIMU group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SOLU
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Solution Control Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 21 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,BDUM
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SOLU'
!
!---  Assign card string  ---
!
      CARD = 'Solution Control Card'
!
!---  Read Execution Option  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Execution Option'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      IF( INDEX(ADUM(1:),'normal').NE.0 ) THEN
        IF( INDEX(ADUM(1:),'no flow').NE.0 ) THEN
          IEO = 21
        ELSEIF( INDEX(ADUM(1:),'dynamic').NE.0 ) THEN
          IEO = 11
        ELSE
          IEO = 1
        ENDIF
      ELSEIF( INDEX(ADUM(1:),'restart').NE.0 ) THEN
        IF( INDEX(ADUM(1:),'no flow').NE.0 ) THEN
          IF( INDEX(ADUM(1:),'zero solutes').NE.0 ) THEN
            IEO = 24
          ELSE
            IEO = 22
          ENDIF
        ELSEIF( INDEX(ADUM(1:),'dynamic').NE.0 ) THEN
          IF( INDEX(ADUM(1:),'zero solutes').NE.0 ) THEN
            IEO = 14
          ELSE
            IEO = 12
          ENDIF
        ELSE
          IF( INDEX(ADUM(1:),'zero solutes').NE.0 ) THEN
            IEO = 4
          ELSE
            IEO = 2
          ENDIF
        ENDIF
      ELSEIF( INDEX(ADUM(1:),'initial').NE.0 ) THEN
        IEO = 3
      ENDIF
      IF( INDEX(ADUM(1:),'mpi').NE.0 .AND.
     &  INDEX(ADUM(1:),'preprocess').NE.0 ) THEN
        ISLC(67) = 1
      ENDIF
!
!---  Scaling Factor Option  ---
!
      IF( INDEX(ADUM(1:),'scaling factors').NE.0 ) ISLC(19) = 1
!
!---  Inverse (UCode) Option  ---
!
      IF( INDEX(ADUM(1:),'inverse').NE.0 .OR.
     &  INDEX(ADUM(1:),'ucode').NE.0 ) ISLC(20) = 1
!
!---  KSPSetFromOptions line read  ---
!
      IF( INDEX(ADUM(1:),'kspsetfromoptions').NE.0 ) THEN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
      ENDIF

!
!---  Set solver option  ---
!

      LSP = 0
      LBD = 0
      LPT = 0
      LIS = 1







!
!---  Equation switch parameters  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Operational Mode'
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      IF( INDEX(ADUM(1:),'transport').NE.0 ) LC = 1
      IF( INDEX(ADUM(1:),'geomechanics').NE.0 ) LM = 1
      IF( INDEX(ADUM(1:),'eckechem').NE.0 )  LR = 1
      IF( INDEX(ADUM(1:),'5512').NE.0 ) LC = 1
      IF( INDEX(ADUM(1:),'ice').NE.0 ) LFW = 1
      IF( INDEX(ADUM(1:),'surface spill').NE.0 )  LSPILL = 1
      IF( INDEX(ADUM(1:),'fracture flow').NE.0 )  L_FRC = 1
      IF( INDEX(ADUM(1:),'fault flow').NE.0 )  L_FRC = 1
      IF( INDEX(ADUM(1:),'borehole flow').NE.0 )  L_BH = 1
!
!---  Water-NComponent-NaCl-Energy (H2O-NComponent-Nacl-E) Operational Mode  ---
!
      IF( INDEX(ADUM(1:),'stomp-comp').NE.0 ) THEN
        IOM = 40
        LUK = 3
        LFW = 1
        LGC = 1
        LG = 1
        LT = 1
        LS = 1
        LPTA = 1 
!
!---  H2O-CO2-CH4-NaCl-E Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'hyd1').NE.0 ) THEN
        IOM = 36
        LUK = 5
        LT = 1
        LS = 1
        LG = 1
        LNGC = 3
        LNNGC = 3
        LHYD = 1
        LPTA = 1
!
!---  EOR Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'eor').NE.0 ) THEN
        LPF_EOR = 73
        IOM = 43
        LUK = 3
        LT = 1
        LS = 1
        LN = 1
        LG = 1
        LPTA = 1
        LGC = 1
        LNNGC = 1
!
!---    Read equation of state  ---
!
        VARB = 'Cubic Equation of State'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
        IF( INDEX(BDUM(1:),'black').NE.0 .AND.
     &    INDEX(BDUM(1:),'oil').NE.0 ) THEN
          ISLC(68) = 0
          NGC = 0
          LNGC = MAX( LNGC,NGC ) + 2
          LUK = 2
          LT = 0
          LUK = LUK + LNGC
        ELSE
          IF( INDEX(BDUM(1:),'peng').NE.0 .AND.
     &      INDEX(BDUM(1:),'robinson').NE.0 ) THEN
            ISLC(68) = 1
          ELSEIF( INDEX(BDUM(1:),'soave').NE.0 .AND.
     &      INDEX(BDUM(1:),'redlich').NE.0 .AND.
     &      INDEX(BDUM(1:),'kwong').NE.0 ) THEN
            ISLC(68) = 2
          ENDIF
!
!---      Read number of petroleum components  ---
!
          VARB = 'Number of Petroleum Components'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NGC)
          IF( INDEX(ADUM(1:),'iso-co2').NE.0 ) THEN
            ISLC(45) = 1
          ENDIF
          IF( INDEX(ADUM(1:),'iso-ch4').NE.0 ) THEN
            ISLC(64) = 1
          ENDIF
          LNGC = MAX( LNGC,NGC ) + 2
          LUK = LUK + LNGC
        ENDIF
        IF( INDEX(ADUM(1:),'isotherm').NE.0 ) THEN
          ISLC(30) = 1
        ELSEIF( ISLC(68).EQ.0 ) THEN
          INDX = 4
          CHMSG = 'Option Conflict: Black-Oil without Isothermal'
          CALL WRMSGP( INDX )        
        ENDIF
        IF( INDEX(ADUM(1:),'isobrine').NE.0 ) THEN
          ISLC(32) = 1
        ENDIF
!
!---    Dual Porosity Model Option  ---
!
        IF( INDEX(ADUM(1:),'dual porosity').NE.0 .OR.
     &    INDEX(ADUM(1:),'dual-porosity').NE.0 ) THEN
          ISLC(11) = 1
          L_DP = 1
        ENDIF
!
!---    Equivalent Continuum Model Option  ---
!
        IF( INDEX(ADUM(1:),'equivalent continuum').NE.0 .OR.
     &    INDEX(ADUM(1:),'equivalent-continuum').NE.0 ) THEN
          ISLC(11) = 2
          L_EC = 1
        ENDIF
!
!---  HYD-O2-CH4-N2 Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'hyd').NE.0 .AND.
     &  INDEX(ADUM(1:),'o2').NE.0 .AND. INDEX(ADUM(1:),'ch4').NE.0 .AND.
     &  INDEX(ADUM(1:),'n2').NE.0 ) THEN
        IOM = 39
        LUK = 9
        LT = 1
        LS = 1
        LN = 1
        LG = 1
        LHYD = 1
        LN2 = 1
        LNHC = 4
        LNNGC = 3
        LPTA = 1
        IF( INDEX(ADUM(1:),'iso-o2').NE.0 ) THEN
          ISLC(45) = 1
          LUK = LUK - 2
        ENDIF
        IF( INDEX(ADUM(1:),'iso-ch4').NE.0 ) THEN
          ISLC(64) = 1
          LUK = LUK - 2
        ENDIF
        IF( INDEX(ADUM(1:),'iso-n2').NE.0 ) THEN
          ISLC(65) = 1
          LUK = LUK - 2
        ENDIF
        IF( INDEX(ADUM(1:),'isobrine').NE.0 ) THEN
          ISLC(32) = 1
          LUK = LUK - 1
        ENDIF
!
!---  HYDT-KE Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'hydt-ke').NE.0 ) THEN
        IOM = 39
        LUK = 9
        LT = 1
        LS = 1
        LN = 1
        LG = 1
        LHYD = 1
        LN2 = 1
        LNHC = 4
        LNNGC = 3
        LPTA = 1
        IF( INDEX(ADUM(1:),'iso-co2').NE.0 ) THEN
          ISLC(45) = 1
          LUK = LUK - 2
        ENDIF
        IF( INDEX(ADUM(1:),'iso-ch4').NE.0 ) THEN
          ISLC(64) = 1
          LUK = LUK - 2
        ENDIF
        IF( INDEX(ADUM(1:),'iso-n2').NE.0 ) THEN
          ISLC(65) = 1
          LUK = LUK - 2
        ENDIF
        IF( INDEX(ADUM(1:),'isobrine').NE.0 ) THEN
          ISLC(32) = 1
          LUK = LUK - 1
        ENDIF
!
!---  HYD-KE Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'hyd-ke').NE.0 ) THEN
        IOM = 38
        LUK = 7
        LT = 1
        LS = 1
        LG = 1
        LNNGC = 3
        LNGC = 3
        LHYD = 1
        LPTA = 1
!
!---  HYD Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'hyd').NE.0 ) THEN
        IOM = 37
        LUK = 5
        LT = 1
        LS = 1
        LG = 1
        LN = 1
        LNGC = 3
        LNNGC = 3
        LHYD = 1
        LPTA = 1
!
!---  STOMP-SEQ Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-seq').NE.0 ) THEN
        IOM = 34
        LUK = 5
        LT = 1
        LS = 1
        LG = 1
        LN = 1
        LPTA = 1
        LGC = 1
        LNGC = 3
        LNNGC = 3
        IF( INDEX(ADUM(1:),'isobrine').NE.0 ) ISLC(32) = 1
        IF( INDEX(ADUM(1:),'isotherm').NE.0 ) ISLC(30) = 1
!
!---  STOMP-CO2e Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-co2e').NE.0 ) THEN
        IOM = 33
        LUK = 4
        LT = 1
        LS = 1
        LG = 1
        LPTA = 1
        IF( INDEX(ADUM(1:),'isobrine').NE.0 ) ISLC(32) = 1
        IF( INDEX(ADUM(1:),'isotherm').NE.0 ) ISLC(30) = 1
!
!---  STOMP-CO2 Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-co2').NE.0 ) THEN
        IOM = 32
        LUK = 3
        LS = 1
        LG = 1
        LPTA = 1
        IF( INDEX(ADUM(1:),'isobrine').NE.0 ) ISLC(32) = 1
!
!---  Water-Air-Oil Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-woa').NE.0 ) THEN
        IOM = 5
        LUK = 3
        LG = 1
        LN = 1
        IF( INDEX(ADUM(1:),'kinetic').NE.0 .AND.
     &    INDEX(ADUM(1:),'volatil').NE.0 ) THEN
          LUK = 4
          LD = 1
          ISLC(46) = 1
        ENDIF
!
!---  Water-Oil Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-wo').NE.0 ) THEN
        IOM = 4
        LUK = 2
        LN = 1
!
!---  Water-Air-Energy (H2O-Air-E) Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-wae').NE.0 ) THEN
        IOM = 3
        LUK = 3
        LFW = 1
        LT = 1
        LG = 1
!
!---  Geothermal (GT) Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-gt').NE.0 .OR.
     &  INDEX(ADUM(1:),'geothermal').NE.0 ) THEN
        IOM = 3
        LUK = 4
        LFW = 1
        LT = 1
        LG = 1
        LS = 1
        IF( INDEX(ADUM(1:),'isobrine').NE.0 ) ISLC(32) = 1
        IF( INDEX(ADUM(1:),'isothermal').NE.0 ) ISLC(30) = 1
!
!---  Water (H2O) Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'stomp-w').NE.0 ) THEN
        IOM = 1
        LUK = 1
!
!---  Fluid Operational Mode  ---
!
      ELSEIF( INDEX(ADUM(1:),'fluid').NE.0 ) THEN
        IOM = 1
        LUK = 1
      ENDIF
!
!---  Number of execution periods parameter  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Execution Periods'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LEPD)
      LEPD = MAX( 1,LEPD )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SOLU group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Saturation Function Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 25 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TABL
      USE SOLTN
      USE PORMED
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,RDUM
      CHARACTER*512 CHDUM
      TYPE(LIST_NODE), POINTER :: LOC_PTR
      TYPE(LIST_SCALING), POINTER :: SC_LOC_PTR
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SP'
!
!---  Assign card string  ---
!
      CARD = 'Saturation Function Card'
!
!---  Skip fluid-pair interfacial tension line  ---
!
      IF( (IOM.GE.4 .AND. IOM.LE.9) .OR. IOM.EQ.24 
     &  .OR. (IOM.GE.35 .AND. IOM.LE.39) 
     &  .OR. IOM.EQ.44 .OR. IOM.EQ.45 ) 
     &  CALL RD_INPL( CHDUM )
!
!---  Loop over the rock/soil saturation information lines  ---
!
      N = 0
      IJK = 0
   10 CONTINUE
      IF( N.GE.NROCK .OR. IJK.GT.0 ) GOTO 500
      ISTART = 1
      VARB = 'Saturation Function: Rock Name: '
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,RDUM)
!
!---  IJK, KIJ, or JKI indexing  ---
!
      IF( INDEX(RDUM(1:),'indexing').NE.0 ) THEN
        IF( INDEX(RDUM,'ijk').NE.0 ) THEN
          IJK = 1
        ELSEIF( INDEX(RDUM,'jki').NE.0 ) THEN
          IJK = 2
        ELSEIF( INDEX(RDUM,'kij').NE.0 ) THEN
          IJK = 3
        ELSE
          INDX = 4
          CHMSG = 'Unrecognized Indexing Option' // RDUM(1:NCH)
          CALL WRMSGP( INDX )
        ENDIF
        GOTO 220
      ENDIF
!
!---  Search known rock types for a matching type  ---
!
        LOC_PTR => ROCK_PTR
        IROCK = 0
        DO
          IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
          IROCK = IROCK + 1
          IF( LOC_PTR%LIST_NAME == RDUM ) THEN
            GOTO 200
          ELSE
            LOC_PTR => LOC_PTR%NEXT
          ENDIF
        ENDDO
!
!---  Search known scaling groups for a matching type  ---
!
      IF( ISLC(19).EQ.1 ) THEN
        SC_LOC_PTR => SCALING_PTR
        ISGRP = 0
        DO
          IF( .NOT.ASSOCIATED(SC_LOC_PTR) ) EXIT
          IF( SC_LOC_PTR%SCALING_NAME == RDUM ) THEN
            ISGRP = SC_LOC_PTR%SCALING_NUM
            IROCK = 1
            GOTO 200
          ELSE
            SC_LOC_PTR => SC_LOC_PTR%NEXT
          ENDIF
        ENDDO
        INDX = 2
        CHMSG = 'Unrecognized Rock/Soil Type or Scaling Group: '
     &    // RDUM(1:NCH)
        CALL WRMSGP( INDX )
        GOTO 10
      ENDIF
      INDX = 2
      CHMSG = 'Unrecognized Rock/Soil Type: ' // RDUM(1:NCH)
      CALL WRMSGP( INDX )
      GOTO 10
  200 CONTINUE
!
!---  Loop over rock/soils within scaling group  ---
!
      IF( ISLC(19).EQ.1 .AND. ISGRP.NE.0 ) THEN
        DO 202 M = IROCK,NROCK
          IF( ISCALE(M).EQ.ISGRP ) THEN
            IROCK = M
            GOTO 204
          ENDIF
  202   CONTINUE
      ENDIF
  204 CONTINUE
!
!---  End rock/soil or scaling group input  ---
!
  220 CONTINUE
      N = N + 1
!
!---  Read saturation/capillary pressure function for
!     tabular forms  ---
!
      VARB = 'Saturation Function Type: '
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
      ISCHRX = 0
      IF( INDEX(ADUM(1:),'tabular').NE.0 ) THEN
        IF( INDEX( ADUM(1:),'spline' ).NE.0 ) THEN
          IF( INDEX( ADUM(1:),'hysteretic' ).NE.0 ) THEN
            ISCHRX = 13
          ELSE
            ISCHRX = 11
          ENDIF
        ELSE
          IF( INDEX( ADUM(1:),'hysteretic' ).NE.0 ) THEN
            ISCHRX = 12
          ELSE
            ISCHRX = 10
          ENDIF
        ENDIF
      ELSEIF( INDEX(ADUM(1:),'polynomial').NE.0 ) THEN
        ISCHRX = 19
      ENDIF
!
!---  Tabular non-hysteretic  ---
!
      IF( ISCHRX.EQ.10 .OR. ISCHRX.EQ.11 ) THEN
!
!---    IJK Indexing  ---
!
        IF( IJK.GT.0 ) THEN
          VARB = 'Number of Tables'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NTABX)
          NTBL = 0
          DO 272 NTX = 1,NTABX
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            VARB = 'Number of Table Entries'
            CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
            IF( NLIN.LT.2 ) THEN
              INDX = 4
              CHMSG = 'Invalid Saturation Function Table'
              CALL WRMSGP( INDX )
            ENDIF
            NTBL = NTBL + NLIN
            DO 270 NLX = 1,NLIN
              CALL RD_INPL( CHDUM )
  270       CONTINUE
  272     CONTINUE
          LTBL = LTBL + NTBL
        ELSE
          VARB = 'Number of Table Entries'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
          IF( NLIN.LT.2 ) THEN
            INDX = 4
            CHMSG = 'Invalid Saturation Function Table'
            CALL WRMSGP( INDX )
          ENDIF
          DO 274 NL = 1,NLIN
            CALL RD_INPL( CHDUM )
  274     CONTINUE
          NTBL = NLIN
          LTBL = LTBL + NTBL
        ENDIF
!
!---  Tabular hysteretic  ---
!
      ELSEIF( ISCHRX.EQ.12 .OR. ISCHRX.EQ.13 ) THEN
!
!---    IJK Indexing  ---
!
        IF( IJK.GT.0 ) THEN
          VARB = 'Number of Drainage Saturation Tables'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NDTABLX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          VARB = 'Number of Imbibition Saturation Tables'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NITABLX)
          NTBL = 0
          DO 282 NTX = 1,NDTABLX
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            VARB = 'Number of Drainage Table Entries'
            CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
            IF( NLIN.LT.2 ) THEN
              INDX = 4
              CHMSG = 'Invalid Saturation Drainage Table'
              CALL WRMSGP( INDX )
            ENDIF
            NTBL = NTBL + NLIN
            DO 280 NLX = 1,NLIN
              CALL RD_INPL( CHDUM )
  280       CONTINUE
  282     CONTINUE
          DO 286 NTX = 1,NITABLX
            ISTART = 1
            CALL RD_INPL( CHDUM )
            CALL L_CASE( CHDUM )
            VARB = 'Number of Imbibition Table Entries'
            CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
            IF( NLIN.LT.2 ) THEN
              INDX = 4
              CHMSG = 'Invalid Saturation Imbibition Table'
              CALL WRMSGP( INDX )
            ENDIF
            NTBL = NTBL + NLIN
            DO 284 NLX = 1,NLIN
              CALL RD_INPL( CHDUM )
  284       CONTINUE
  286     CONTINUE
          LTBL = LTBL + NTBL
        ELSE
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          VARB = 'Number of Drainage Table Entries'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
          IF( NLIN.LT.2 ) THEN
            INDX = 4
            CHMSG = 'Invalid Saturation Drainage Table'
            CALL WRMSGP( INDX )
          ENDIF
          DO 292 NL = 1,NLIN
            CALL RD_INPL( CHDUM )
  292     CONTINUE
          NTBL = NLIN
          LTBL = LTBL + NTBL
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          VARB = 'Number of Imbibition Table Entries'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
          IF( NLIN.LT.2 ) THEN
            INDX = 4
            CHMSG = 'Invalid Saturation Imbibition Table'
            CALL WRMSGP( INDX )
          ENDIF
          DO 294 NL = 1,NLIN
            CALL RD_INPL( CHDUM )
  294     CONTINUE
          NTBL = NLIN
          LTBL = LTBL + NTBL
        ENDIF
!
!---  Polynomial  ---
!
      ELSEIF( ISCHRX.EQ.19 ) THEN
!
!---    IJK Indexing  ---
!
        IF( IJK.GT.0 ) THEN
          INDX = 4
          CHMSG = 'Polynomial Coefficients not Available with ' // 
     &      'IJK Indexing'
          CALL WRMSGP( INDX )
        ENDIF
        VARB = 'Number of Polynomial Function Pieces'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NPOLY)
        LPOLYN = MAX( LPOLYN,NPOLY )
        DO 290 NP = 1,NPOLY
          ISTART = 1
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          VARB = 'Number of Polynomial Coefficients'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,NCOEF)
          LPOLYC = MAX( LPOLYC,NCOEF+4 )
  290   CONTINUE
      ENDIF
!
!---  Loop over remaining rock/soils within scaling group  ---
!
      IF( ISLC(19).EQ.1 .AND. IROCK.LT.NROCK ) THEN
        DO 490 M = IROCK+1,NROCK
          IF( ISCALE(M).EQ.ISGRP ) THEN
            N = N+1
          ENDIF
  490   CONTINUE
      ENDIF
!
!---  Read next rock/soil type or scaling group  ---
!
      GOTO 10
 500  CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SP group
!
      RETURN
      END
      
!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SPLK
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read reactive species link.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 22 December 2004.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SPLK'
!
!---  Assign card string  ---
!
      CARD = 'Reactive Species Link Card'
!
!---  Read number of component species  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Reactive Species Links'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSPX)
      LSPLK = MAX( LSPLK,NSPX )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SPLK group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Source Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 10 October 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM,BDUM
      CHARACTER*64 UNTS
      REAL*8 SRCPX(8)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SR'
      EPSLX = 1.D-12
!
!---  Assign card string  ---
!
      CARD = 'Source Card'
!
!---  Read number of source inputs  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Sources: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSR)
      NSRX = 0
      DO 200 NS = 1,NSR
!
!---    Read source type, domain, and number of times  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    Read source type  ---
!
        VARB = 'Source Type'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        ISRTX = 0
        IF( INDEX(ADUM(1:),'bioslurping').NE.0 .AND.
     &    INDEX(ADUM(1:),'well').NE.0 ) ISRTX = 30      
        IF( INDEX(ADUM(1:),'solute').NE.0 .AND.
     &    INDEX(ADUM(1:),'inventory').NE.0 ) ISRTX = -(3*LSOLU)
        IF( INDEX(ADUM(1:),'spill').NE.0 ) ISRTX = 40      
!
!---    Bioslurping well  ---
!
        IF( ISRTX == 30 ) THEN
!
!---      Read x,y,z-coordinate location of the bioslurping tube  ---
!
          VARB = 'Bioslurping Tube X-Direction Coordinate Location'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(1))
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,SRCPX(1),INDX)
          VARB = 'Bioslurping Tube Y-Direction Coordinate Location'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(2))
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,SRCPX(2),INDX)
!
!---      Cylindrical coordinates with azimuthal symmetry  ---
!
          IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1 ) THEN
            IF( ABS(SRCPX(1))/EPSL.GT.EPSL ) THEN
              INDX = 4
              CHMSG = 'Non-Zero Bioslurping Tube X-Direction ' // 
     &          'Coordinate Location for Radially Symmetric Domain'
              RLMSG = SRCPX(1)
              CALL WRMSGP( INDX )
            ENDIF
            IF( ABS(SRCPX(2))/EPSL.GT.EPSL ) THEN
              INDX = 9
              CHMSG = 'Non-Zero Bioslurping Tube Y-Direction ' // 
     &          'Coordinate Location for Radially Symmetric Domain'
              RLMSG = SRCPX(2)
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
          VARB = 'Bioslurping Tube Z-Direction Coordinate Location'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(3))
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,SRCPX(3),INDX)
          VARB = 'Bioslurping Well Screened Interval X-Component Length'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(4))
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          VARB = 'Bioslurping Well Screened Interval Y-Component Length'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(5))
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          VARB = 'Bioslurping Well Screened Interval Z-Component Length'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(6))
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          VARB = 'Bioslurping Well Radius'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(7))
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          VARB = 'Bioslurping Well Skin Factor'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,SRCPX(8))
!
!---      Loop over active nodes to find node number for the 
!         bioslurping tube location ---
!
          DO 70 N = 1,LFD
            IF( IXP(N).EQ.0 ) GOTO 70
            I = ID(N)
            J = JD(N)
            K = KD(N)
!
!---        Cylindrical coordinates with azimuthal symmetry,
!           centrally located wells  ---
!
            IF( (ICS.EQ.2 .OR. ICS.EQ.6) .AND. LFY.EQ.1
     &        .AND. I.EQ.1 ) THEN
!
!---          Node height greater than EPSLX  ---
!
              IF( ABS(ZE(1,N)-ZE(5,N)).GT.EPSLX ) THEN
                DZPX1 = SRCPX(3)-ZE(1,N)
                DZPX2 = ZE(5,N)-SRCPX(3)
                IF( ABS(DZPX1).LT.EPSLX ) DZPX1 = 0.D+0
                IF( ABS(DZPX2).LT.EPSLX ) DZPX2 = 0.D+0
!
!---            Transition point within vertical limits of node  ---
!
                IF( DZPX1.GE.0.D+0 .AND. DZPX2.GE.0.D+0 ) GOTO 80
              ENDIF
            ELSE
!
!---          Check for point within hexahedron  ---
!
              CALL WITH_IN( SRCPX(1),SRCPX(2),SRCPX(3),ICWX,N )
!
!---          Opposing rotations found, point outside hexahedron  ---
!
              IF( ICWX.EQ.0 ) GOTO 70
!
!---          No opposing rotations found, point inside hexahedron
!             store and record source node  ---
!
              GOTO 80
            ENDIF
   70     CONTINUE
          INDX = 4
          CHMSG = 'Bioslurping Point Outside Active Domain'
          CALL WRMSGP( INDX )
   80     CONTINUE
          NSRX = NSRX + 1
        ELSE
!
!---      Skip over character string inputs for
!         source type options and solute sources  ---
!
          DO
            CALL CHK_INT(ISTART,ICOMMA,CHDUM,INDX)
            IF( INDX == 1 ) EXIT
            VARB = 'Source Type Option'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,BDUM)
          END DO
!
!---      Read source domain indices  ---
!
          VARB = 'Source Domain Index: '
          ISX = ISTART
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,I2X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J1X)
          CALL RD_INT(ISTART,ICOMMA,CHDUM,J2X)
          IF( ISRTX.NE.40 ) THEN
            CALL RD_INT(ISTART,ICOMMA,CHDUM,K1X)
            CALL RD_INT(ISTART,ICOMMA,CHDUM,K2X)
          ENDIF
          ICX = ISTART
!
!---      Check for ill-defined source domains  ---
!
          IF( I1X.LT.1 .OR. I1X.GT.LFX .OR. I2X.LT.1 .OR.
     &      I2X.GT.LFX .OR. I2X.LT.I1X ) THEN
            INDX = 4
            CHMSG = 'Invalid Source Domain: ' // CHDUM(ISX:ICX)
            CALL WRMSGP( INDX )
          ENDIF
          IF( J1X.LT.1 .OR. J1X.GT.LFY .OR. J2X.LT.1 .OR.
     &      J2X.GT.LFY .OR. J2X.LT.J1X ) THEN
            INDX = 4
            CHMSG = 'Invalid Source Domain: ' // CHDUM(ISX:ICX)
            CALL WRMSGP( INDX )
          ENDIF
          IF( ISRTX.NE.40 ) THEN
          IF( K1X.LT.1 .OR. K1X.GT.LFZ .OR. K2X.LT.1 .OR.
     &        K2X.GT.LFZ .OR. K2X.LT.K1X ) THEN
              INDX = 4
              CHMSG = 'Invalid Source Domain: ' // CHDUM(ISX:ICX)
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
!
!---      Define a unique source input for each node 
!         in the domain for the solute inventory source  ---
!
          IF( ISRTX.EQ.-(3*LSOLU) ) THEN
            NSRX = NSRX+(I2X-I1X+1)*(J2X-J1X+1)*(K2X-K1X+1)
          ELSE
            NSRX = NSRX+1
          ENDIF
        ENDIF
!
!---    Read number of source times  ---
!
        VARB = 'Number of Source Times: '
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NSTM)
        LSTM = MAX( LSTM,NSTM )
!
!---    Solute injected with well gas  ---
!
        IF( ISRTX >= 22 .AND. ISRTX <= 27 .AND. LC.NE.0 ) THEN
          CALL CHK_CHR( ISTART,ICOMMA,CHDUM,INDX )
          IF( INDX.NE.0 ) THEN
            VARB = 'Solute Source Type'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IF( INDEX(ADUM(1:),'solute').NE.0 ) THEN          
              CALL RD_INPL( CHDUM )
              CALL L_CASE( CHDUM )
              ISTART = 1
              VARB = 'Number of Solutes'
              CALL RD_INT(ISTART,ICOMMA,CHDUM,NSOLSRX)
              LSOLSR = MAX( NSOLSRX,LSOLSR )
            ENDIF
          ENDIF
        ENDIF
!
!---    Skip over source variables  ---
!
        DO 100 NTM = 1,NSTM
          CALL RD_INPL( CHDUM )
  100   CONTINUE
  200 CONTINUE
      LSR = MAX( LSR,NSRX )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SR_FRC
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Fracture/Fault Source Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 10 October 2017.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GEOM_FRC
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
      CHARACTER*128 ADUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SR_FRC'
      EPSLX = 1.D-12
!
!---  Assign card string  ---
!
      CARD = 'Fracture/Fault Source Card'
!
!---  Read number of source inputs  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Fracture/Fault Sources: '
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NSR)
      NSRX = 0
      DO NS = 1,NSR
!
!---    Read fracture/fault source type, domain, and number of times  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
!
!---    Skip over character string inputs for fracture/fault 
!       source type options and fracture/fault solute sources  ---
!
        DO
          CALL CHK_INT(ISTART,ICOMMA,CHDUM,INDX)
          IF( INDX == 1 ) EXIT
          VARB = 'Fracture/Fault Source Type Option'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
        END DO
!
!---    Read fracture/fault source domain indices  ---
!
        VARB = 'Fracture/Fault Source Domain Index: '
        ISX = ISTART
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IF1X)
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IT1X)
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IF2X)
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IT2X)
        ICX = ISTART
!
!---    Check for ill-defined source domains  ---
!
        IF( IF1X.LT.1 .OR. IF1X.GT.NF_FRC .OR. IF2X.LT.1 .OR.
     &    IF2X.GT.NF_FRC .OR. IF2X.LT.IF1X ) THEN
          INDX = 4
          CHMSG = 'Invalid Source Domain: ' // CHDUM(ISX:ICX)
          CALL WRMSGP( INDX )
        ENDIF
        IF( IT1X.LT.1 .OR. IT1X.GT.NTP_FRC(IF1X) .OR. IT2X.LT.1 .OR.
     &    IT2X.GT.NTP_FRC(IF2X) .OR.
     &    ( IF1X.EQ.IF2X .AND. IT2X.LT.IT1X ) ) THEN
          INDX = 4
           CHMSG = 'Invalid Source Domain: ' // CHDUM(ISX:ICX)
          CALL WRMSGP( INDX )
        ENDIF
        NSRX = NSRX+1
!
!---    Read number of source times  ---
!
        VARB = 'Number of Source Times: '
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NSTM_FRC)
        LSTM_FRC = MAX( LSTM_FRC,NSTM_FRC )
!
!---    Skip over source variables  ---
!
        DO NTM = 1,NSTM_FRC
          CALL RD_INPL( CHDUM )
        ENDDO
        LSTM = MAX( LSTM,NSTM_FRC )
      ENDDO
      LSR_FRC = MAX( LSR_FRC,NSRX )
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SR_FRC group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SREL
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read SAC Release Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by WE Nichols, PNNL, 13 June 2003.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SREL'
!
!---  Assign card string  ---
!
      CARD = 'SAC Release Card'
!
!---  Grid dimension parameters  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of SAC Release Plane Time Changes'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LREL)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SREL group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_SREM
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read SAC Remediation Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by WE Nichols, PNNL, 13 June 2003.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_SREM'
!
!---  Assign card string  ---
!
      CARD = 'SAC Remediation Card'
!
!---  Grid dimension parameters  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of SAC Remediation Events'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,LREM)
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_SREM group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_TF
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read Solute/Fluid Interaction Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 26 November 2002.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TRNSPT
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*128 ADUM,CDUM,PDUM
      CHARACTER*512 CHDUM
      TYPE(LIST_NODE), POINTER :: LOC_PTR,TMP_PTR
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: ICDSX,JCDSX
      INTEGER, DIMENSION(:), ALLOCATABLE :: ICLX,ICHX,ISCX
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: IADJM,JADJM,KADJM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_TF'
!
!---  Assign card string  ---
!
      CARD = 'Solute/Fluid Interactions Card'
!
!---  Read number of different solutes  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Solutes'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
      NSOLU = 0
      NULLIFY( SOLUT_PTR )
      ALLOCATE( IEDL(1:NLIN),STAT=ISTAT )
      IF( ISTAT.NE.0 ) THEN
        INDX = 3
        CHMSG = 'Allocation Error: IEDL'
        CALL WRMSGP( INDX )
      ENDIF
      DO 200 NL = 1, NLIN
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        ADUM(1:) = ' '
        VARB = 'Solute Name'
        CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---    Empty solute name list  ---
!
        IF( .NOT.ASSOCIATED(SOLUT_PTR) ) THEN
          ALLOCATE( SOLUT_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: SOLUT_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          SOLUT_PTR%LIST_NAME = ADUM
          NULLIFY(SOLUT_PTR%NEXT)
          NSOLU = NSOLU + 1
!
!---    Established solute name list  ---
!
        ELSE
          LOC_PTR => SOLUT_PTR
!
!---      Check for repeated solute name  ---
!
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IF( LOC_PTR%LIST_NAME == ADUM ) GOTO 110
            LOC_PTR => LOC_PTR%NEXT
          ENDDO
!
!---      Add solute name to solute list  ---
!
          NSOLU = NSOLU + 1
          ALLOCATE( TMP_PTR,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: SOLUT_PTR'
            CALL WRMSGP( INDX )
          ENDIF
          TMP_PTR%LIST_NAME = ADUM
          TMP_PTR%NEXT => SOLUT_PTR
          SOLUT_PTR => TMP_PTR
        ENDIF
  110   CONTINUE
        LSOLU = MAX( LSOLU,NSOLU )
        IF( NSOLU.GT.0 ) LC = 1
!
!---    STOMP-W  ---
!
        IF( IOM.EQ.1 .OR. IOM.EQ.11 ) THEN
!
!---     Aqueous effective diffusion option  ---
!
          VARB = 'Aqueous Effective Diffusion Option: '
          ADUM = 'conventional'
          IDFLT = 1
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IF( INDEX(ADUM(1:),'conventional').NE.0 )  THEN
            IEDL(NSOLU) = 1
            VARB = 'Aqueous Molecular Diffusion Coefficient @ 20 C'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ELSEIF( INDEX(ADUM(1:),'constant').NE.0 )  THEN
            IEDL(NSOLU) = 3
            VARB = 'Aqueous Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ELSEIF( INDEX(ADUM(1:),'immobile').NE.0 .OR.
     &      INDEX(ADUM(1:),'stationary').NE.0 )  THEN
            IEDL(NSOLU) = 4
          ENDIF
          IF( IEDL(NSOLU).NE.4 ) THEN
!
!---        Solid-Aqueous Partition option  ---
!
            VARB = 'Solid-Aqueous Partition Option: '
            ADUM = 'continuous'
            IDFLT = 1
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ENDIF
!
!---    STOMP-WA  ---
!
        ELSEIF( IOM.EQ.2 .OR. IOM.EQ.12 .OR. IOM.EQ.13
     &    .OR. IOM.EQ.22 .OR. IOM.EQ.32 .OR. IOM.EQ.33
     &    .OR. IOM.EQ.34 .OR. IOM.EQ.35 .OR. IOM.EQ.36
     &    .OR. IOM.EQ.37 .OR. IOM.EQ.38 ) THEN
!
!---     Aqueous molecular diffusion coefficient  ---
!
          VARB = 'Aqueous Molecular Diffusion Coefficient'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IF( INDEX(ADUM(1:),'immobile').NE.0 .OR.
     &      INDEX(ADUM(1:),'stationary').NE.0 )  THEN
            IEDL(NSOLU) = 4
          ELSE
            IEDL(NSOLU) = 1
          ENDIF
          IF( IEDL(NSOLU).NE.4 ) THEN
!
!---        Gas molecular diffusion coefficient  ---
!
            VARB = 'Gas Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Gas-aqueous partition coefficient option  ---
!
            VARB = 'Gas-Aqueous Partition Function'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IF( INDEX(ADUM(1:),'constant').NE.0 )  THEN
              VARB = 'Gas-Aqueous Partition Coefficient'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ELSEIF( INDEX(ADUM(1:),'temperature').NE.0 )  THEN
              VARB = 'Gas-Aqueous Partition Function Coefficients'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            ENDIF
!
!---        Solid-Aqueous Partition option  ---
!
            VARB = 'Solid-Aqueous Partition Option: '
            ADUM = 'continuous'
            IDFLT = 1
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ENDIF
!
!---    STOMP-GT  ---
!
        ELSEIF( IOM.EQ.3 ) THEN
!
!---     Aqueous effective diffusion option  ---
!
          VARB = 'Aqueous Effective Diffusion Option: '
          ADUM = 'conventional'
          IDFLT = 1
          ISX = ISTART
          ICX = ICOMMA
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IF( INDEX(ADUM(1:),'empirical').NE.0 .OR.
     &      INDEX(ADUM(1:),'conventional').NE.0 .OR.
     &      INDEX(ADUM(1:),'constant').NE.0 .OR.
     &      INDEX(ADUM(1:),'immobile').NE.0 .OR.
     &      INDEX(ADUM(1:),'stationary').NE.0 ) THEN
            IF( INDEX(ADUM(1:),'conventional').NE.0 )  THEN
              IEDL(NSOLU) = 1
              VARB = 'Aqueous Molecular Diffusion Coefficient @ 20 C'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ELSEIF( INDEX(ADUM(1:),'constant').NE.0 )  THEN
              IEDL(NSOLU) = 3
              VARB = 'Aqueous Molecular Diffusion Coefficient'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ELSEIF( INDEX(ADUM(1:),'immobile').NE.0 .OR.
     &        INDEX(ADUM(1:),'stationary').NE.0 )  THEN
              IEDL(NSOLU) = 4
            ENDIF
          ELSE
            IEDL(NSOLU) = 1
            ISTART = ISX
            ICOMMA = ICX
            VARB = 'Aqueous Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ENDIF
          IF( IEDL(NSOLU).NE.4 ) THEN
!
!---        Gas molecular diffusion coefficient  ---
!
            VARB = 'Gas-Phase Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Gas-aqueous partition coefficient option  ---
!
            VARB = 'Gas-Aqueous Partition Function'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IF( INDEX(ADUM(1:),'constant').NE.0 )  THEN
              VARB = 'Gas-Aqueous Partition Coefficient'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ELSEIF( INDEX(ADUM(1:),'temperature').NE.0 )  THEN
              VARB = 'Gas-Aqueous Partition Function Coefficients'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            ENDIF
!
!---        Solid-Aqueous Partition option  ---
!
            VARB = 'Solid-Aqueous Partition Option: '
            ADUM = 'continuous'
            IDFLT = 1
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ENDIF
!
!---    STOMP-WO  ---
!
        ELSEIF( IOM.EQ.4 .OR. IOM.EQ.24 .OR. IOM.EQ.44 ) THEN
!
!---     Aqueous molecular diffusion coefficient  ---
!
          VARB = 'Aqueous Molecular Diffusion Coefficient'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IF( INDEX(ADUM(1:),'immobile').NE.0 .OR.
     &      INDEX(ADUM(1:),'stationary').NE.0 )  THEN
            IEDL(NSOLU) = 4
          ELSE
            IEDL(NSOLU) = 0
          ENDIF
          IF( IEDL(NSOLU).NE.4 ) THEN
!
!---        NAPL molecular diffusion coefficient  ---
!
            VARB = 'NAPL Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Aqueous-NAPL adsorption function  ---
!
            VARB = 'Aqueous-NAPL Adsorption Function'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IF( INDEX(ADUM(1:),'linear').NE.0 ) THEN
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            ELSEIF( INDEX(ADUM(1:),'freundlich').NE.0 ) THEN
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            ELSEIF( INDEX(ADUM(1:),'langmuir').NE.0 ) THEN
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ENDIF
          ENDIF
!
!---    STOMP-WOA, STOMP-WOAE  ---
!
        ELSEIF( IOM.EQ.5 .OR. IOM.EQ.6 .OR. IOM.EQ.45 ) THEN
!
!---     Aqueous molecular diffusion coefficient  ---
!
          VARB = 'Aqueous Molecular Diffusion Coefficient'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IF( INDEX(ADUM(1:),'immobile').NE.0 .OR.
     &      INDEX(ADUM(1:),'stationary').NE.0 )  THEN
            IEDL(NSOLU) = 4
          ELSE
            IEDL(NSOLU) = 0
          ENDIF
          IF( IEDL(NSOLU).NE.4 ) THEN
!
!---       Gas molecular diffusion coefficient  ---
!
            VARB = 'Gas Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        NAPL molecular diffusion coefficient  ---
!
            VARB = 'NAPL Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Gas-aqueous partition coefficient option  ---
!
            VARB = 'Gas-Aqueous Partition Function'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IF( INDEX(ADUM(1:),'constant').NE.0 )  THEN
              VARB = 'Gas-Aqueous Partition Coefficient'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ELSEIF( INDEX(ADUM(1:),'temperature').NE.0 )  THEN
              VARB = 'Gas-Aqueous Partition Function Coefficients'
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            ENDIF
!
!---        Aqueous-NAPL partition coefficient  ---
!
            VARB = 'Aqueous-NAPL partition coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          ENDIF
!
!---    STOMP-WOA, STOMP-WOD  ---
!
        ELSEIF( IOM.EQ.7 .OR. IOM.EQ.8 ) THEN
!
!---     Aqueous molecular diffusion coefficient  ---
!
          VARB = 'Aqueous Molecular Diffusion Coefficient'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
          IF( INDEX(ADUM(1:),'immobile').NE.0 .OR.
     &      INDEX(ADUM(1:),'stationary').NE.0 )  THEN
            IEDL(NSOLU) = 4
          ELSE
            IEDL(NSOLU) = 0
          ENDIF
          IF( IEDL(NSOLU).NE.4 ) THEN
!
!---        NAPL molecular diffusion coefficient  ---
!
            VARB = 'NAPL Molecular Diffusion Coefficient'
            CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
!
!---        Aqueous-NAPL adsorption function  ---
!
            VARB = 'Aqueous-NAPL Adsorption Function'
            CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            IF( INDEX(ADUM(1:),'linear').NE.0 ) THEN
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            ELSEIF( INDEX(ADUM(1:),'freundlich').NE.0 ) THEN
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
            ELSEIF( INDEX(ADUM(1:),'langmuir').NE.0 ) THEN
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
              CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,ADUM)
            ENDIF
          ENDIF
        ENDIF
  200 CONTINUE

!
!---  Read number of lines of chain decay information  ---
!
      NCDP = 1
      NCDS = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Chain Decay Lines'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NLIN)
      NC = 0
      IF( NLIN.GT.0 ) THEN
        ALLOCATE( ICDSX(1:2,1:NLIN),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ICDSX'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( JCDSX(1:2,1:NLIN),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: JCDSX'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( ICLX(1:NSOLU),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ICLX'
          CALL WRMSGP( INDX )
        ENDIF
        ALLOCATE( ICHX(1:NSOLU),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          INDX = 3
          CHMSG = 'Allocation Error: ICHX'
          CALL WRMSGP( INDX )
        ENDIF
        DO NL = 1,NLIN
          CALL RD_INPL( CHDUM )
          CALL L_CASE( CHDUM )
          ISTART = 1
          VARB = 'Parent Solute Name'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,PDUM)
          LOC_PTR => SOLUT_PTR
!
!---      Identify parent solute number  ---
!
          NP = NSOLU
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IF( LOC_PTR%LIST_NAME == PDUM ) EXIT
            NP = NP - 1
            LOC_PTR => LOC_PTR%NEXT
          ENDDO
          ICDSX(1,NL) = NP
          JCDSX(1,NL) = NP
          VARB = 'Daughter Solute Name'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,CDUM)
          LOC_PTR => SOLUT_PTR
!
!---      Identify daughter solute number  ---
!
          NC = NSOLU
          DO
            IF( .NOT.ASSOCIATED(LOC_PTR) ) EXIT
            IF( LOC_PTR%LIST_NAME == CDUM ) EXIT
            NC = NC - 1
            LOC_PTR => LOC_PTR%NEXT
          ENDDO
          ICDSX(2,NL) = NC
          JCDSX(2,NL) = NC
        ENDDO
        NCDC = 0
        DO
          DO NSL = 1,NSOLU
            ICLX(NSL) = 0
          ENDDO
!
!---      Find the lowest numbered parent  ---
!
          NP = NSOLU+1
          DO NL = 1,NLIN
            IF( ICDSX(1,NL).LE.NP ) THEN
              NP = ICDSX(1,NL)
            ENDIF
          ENDDO
          IF( NP.EQ.NSOLU+1 ) EXIT
          ICLX(NP) = 1
          NCDC = NCDC + 1
!
!---      Follow the chain decay from the parent  ---
!
          DO NP = 1,NSOLU
            IF( ICLX(NP).EQ.0 ) CYCLE
            DO NL = 1,NLIN
              IF( NP.EQ.ICDSX(1,NL) ) THEN
                ICHX(ICDSX(1,NL)) = NCDC
                ICLX(ICDSX(1,NL)) = 1
                ICDSX(1,NL) = NSOLU+2
                ICHX(ICDSX(2,NL)) = NCDC
                ICLX(ICDSX(2,NL)) = 1
                ICDSX(2,NL) = NSOLU+2
              ENDIF
            ENDDO
          ENDDO
        ENDDO
!
!---    Loop over chains  ---
!
        DO NC = 1,NCDC
!
!---      Count the number of solutes in the chain  ---
!
          NSC = 0
          DO NS = 1,NSOLU
            IF( ICHX(NS).EQ.NC ) NSC = NSC + 1
          ENDDO
          IF( NSC.EQ.1 ) CYCLE
          ALLOCATE( ISCX(1:NSC),STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: ISCX'
            CALL WRMSGP( INDX )
          ENDIF
          MC = 0
          DO NS = 1,NSOLU
            IF( ICHX(NS).EQ.NC ) THEN
              MC = MC + 1
              ISCX(MC) = NS
            ENDIF
          ENDDO
!
!---      Adjacency matrix  ---
!
          ALLOCATE( IADJM(1:NSC,1:NSC),STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: IADJM'
            CALL WRMSGP( INDX )
          ENDIF
          ALLOCATE( JADJM(1:NSC,1:NSC),STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: JADJM'
            CALL WRMSGP( INDX )
          ENDIF
          ALLOCATE( KADJM(1:NSC,1:NSC),STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Allocation Error: KADJM'
            CALL WRMSGP( INDX )
          ENDIF
          DO I = 1,NSC
            DO J = 1,NSC
              IADJM(I,J) = 0
              JADJM(I,J) = 0
              KADJM(I,J) = 0
            ENDDO
          ENDDO
          DO NL = 1,NLIN
            NC1 = 0
            NC2 = 0
            DO MC = 1,NSC
              IF( JCDSX(1,NL).EQ.ISCX(MC) ) NC1 = MC
              IF( JCDSX(2,NL).EQ.ISCX(MC) ) NC2 = MC
            ENDDO
            IF( NC1.NE.0 .AND. NC2.NE.0 ) THEN
              IADJM(NC1,NC2) = 1
              JADJM(NC1,NC2) = 1
            ENDIF
          ENDDO
          MCDP = JADJM(1,NSC)
          DO NSL = 2,NSC
            CALL IMAT_MUL(IADJM,JADJM,KADJM,NSC,NSC,NSC)
            DO I = 1,NSC
              DO J = 1,NSC
                JADJM(I,J) = KADJM(I,J)
                KADJM(I,J) = 0
              ENDDO
            ENDDO
            MCDP = MCDP + JADJM(1,NSC)
          ENDDO
          IF( MCDP.EQ.0 ) THEN
            INDX = 7
            IMSG = NC
            CHMSG = 'No Full Decay-Chain Path: Chain'
            CALL WRMSGP( INDX )
          ENDIF
          NCDP = MAX( NCDP,MCDP )
          NCDS = MAX( NCDS,NSC )
          IF( ALLOCATED(IADJM) ) THEN
            DEALLOCATE( IADJM,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Deallocation Error: IADJM'
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
          IF( ALLOCATED(JADJM) ) THEN
            DEALLOCATE( JADJM,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Deallocation Error: JADJM'
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
          IF( ALLOCATED(KADJM) ) THEN
            DEALLOCATE( KADJM,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Deallocation Error: KADJM'
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
          IF( ALLOCATED(ISCX) ) THEN
            DEALLOCATE( ISCX,STAT=ISTAT )
            IF( ISTAT.NE.0 ) THEN
              INDX = 3
              CHMSG = 'Deallocation Error: ISCX'
              CALL WRMSGP( INDX )
            ENDIF
          ENDIF
        ENDDO
        IF( ALLOCATED(ICHX) ) THEN
          DEALLOCATE( ICHX,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Deallocation Error: ICHX'
            CALL WRMSGP( INDX )
          ENDIF
        ENDIF
        IF( ALLOCATED(ICDSX) ) THEN
          DEALLOCATE( ICDSX,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Deallocation Error: ICDSX'
            CALL WRMSGP( INDX )
          ENDIF
        ENDIF
        IF( ALLOCATED(ICLX) ) THEN
          DEALLOCATE( ICLX,STAT=ISTAT )
          IF( ISTAT.NE.0 ) THEN
            INDX = 3
            CHMSG = 'Deallocation Error: ICLX'
            CALL WRMSGP( INDX )
          ENDIF
        ENDIF
      ENDIF
!
!---  Number of decay chains, plus one for individual decays
!     and number of chain decay paths  ---
!
      LCDC = MAX(1,NCDC+1)
      LCDP = MAX(1,NCDP)
      LCDS = MAX(1,NCDS)

!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_TF group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_UNFGRID
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read grids with variable spacing.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 30 November 2011.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*64 UNTS
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_UNFGRID'
!
!---  First coordinate direction ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      IF( ICS.EQ.6 ) THEN
        VARB = 'Radial Node Dimension'
      ELSE
        VARB = 'X Node Dimension'
      ENDIF
      CALL RD_DPR(ISTART,ICOMMA,CHDUM,XSPC)
      IF( ICS.EQ.6 ) THEN
        VARB = 'Radial Node Dimension Units'
      ELSE
        VARB = 'X Node Dimension Units'
      ENDIF
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      I = 1
      N = ND(I,1,1)
      XE(1,N) = 0.D+0
      IF( ICS.EQ.6 ) XE(1,N) = SMALL
      XE(2,N) = XSPC
      DO 100 I = 2,LFX
        N = ND(I,1,1)
        NW = N-1
        XE(1,N) = XE(2,NW)
        XE(2,N) = XE(1,N) + XSPC
 100  CONTINUE
      IF( ABS(XE(2,N))/EPSL.LT.EPSL ) THEN
        INDX = 4
        CHMSG = 'Zero X-Direction Domain'
        CALL WRMSGP( INDX )
      ENDIF
      INDX = 0
      DO 110 I = 1,LFX
        N = ND(I,1,1)
        IUNM = 1
        CALL RD_UNIT(UNTS,XE(1,N),INDX)
        IUNM = 1
        CALL RD_UNIT(UNTS,XE(2,N),INDX)
 110  CONTINUE
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        NI = ND(I,1,1)
        XE(1,N) = XE(1,NI)
        XE(3,N) = XE(1,NI)
        XE(5,N) = XE(1,NI)
        XE(7,N) = XE(1,NI)
        XE(2,N) = XE(2,NI)
        XE(4,N) = XE(2,NI)
        XE(6,N) = XE(2,NI)
        XE(8,N) = XE(2,NI)
      ENDDO
      ENDDO
      ENDDO
!
!---  Second coordinate direction  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      IF( ICS.EQ.6 ) THEN
        VARB = 'Azimuthal Node Dimension'
      ELSE
        VARB = 'Y Node Dimension'
      ENDIF
      CALL RD_DPR(ISTART,ICOMMA,CHDUM,YSPC)
      IF( ICS.EQ.6 ) THEN
        VARB = 'Azimuthal Node Dimension Units'
      ELSE
        VARB = 'Y Node Dimension Units'
      ENDIF
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      J = 1
      N = ND(1,J,1)
      YE(1,N) = 0.D+0
      YE(3,N) = YSPC
      DO 200 J = 2,LFY
        N = ND(1,J,1)
        NS = N-LFX
        YE(1,N) = YE(3,NS)
        YE(3,N) = YE(1,N) + YSPC
 200  CONTINUE
      IF( ABS(YE(3,N))/EPSL.LT.EPSL ) THEN
        INDX = 4
        CHMSG = 'Zero Y-Direction Domain'
        CALL WRMSGP( INDX )
      ENDIF
      INDX = 0
      DO 210 J = 1,LFY
        N = ND(1,J,1)
        IUNM = 1
        IF( ICS.EQ.6 ) IUNM = 0
        CALL RD_UNIT(UNTS,YE(1,N),INDX)
        IUNM = 1
        IF( ICS.EQ.6 ) IUNM = 0
        CALL RD_UNIT(UNTS,YE(3,N),INDX)
  210 CONTINUE
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        NJ = ND(1,J,1)
        YE(1,N) = YE(1,NJ)
        YE(2,N) = YE(1,NJ)
        YE(5,N) = YE(1,NJ)
        YE(6,N) = YE(1,NJ)
        YE(3,N) = YE(3,NJ)
        YE(4,N) = YE(3,NJ)
        YE(7,N) = YE(3,NJ)
        YE(8,N) = YE(3,NJ)
      ENDDO
      ENDDO
      ENDDO
!
!---  Third coordinate direction  ---
!
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      IF( ICS.EQ.6 ) THEN
        VARB = 'Vertical Node Dimension'
      ELSE
        VARB = 'Z Node Dimension'
      ENDIF
      CALL RD_DPR(ISTART,ICOMMA,CHDUM,ZSPC)
      IF( ICS.EQ.6 ) THEN
        VARB = 'Vertical Node Dimension Units'
      ELSE
        VARB = 'Z Node Dimension Units'
      ENDIF
      CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
      K = 1
      N = ND(1,1,K)
      ZE(1,N) = 0.D+0
      ZE(5,N) = ZSPC
      DO 300 K = 2,LFZ
        N = ND(1,1,K)
        NB = N-LFXY
        ZE(1,N) = ZE(5,NB)
        ZE(5,N) = ZE(1,N) + ZSPC
  300 CONTINUE
      IF( ABS(ZE(5,N))/EPSL.LT.EPSL ) THEN
        INDX = 4
        CHMSG = 'Zero Z-Direction Domain'
        CALL WRMSGP( INDX )
      ENDIF
      INDX = 0
      DO 310 K = 1,LFZ
        N = ND(1,1,K)
        IUNM = 1
        CALL RD_UNIT(UNTS,ZE(1,N),INDX)
        IUNM = 1
        CALL RD_UNIT(UNTS,ZE(5,N),INDX)
  310 CONTINUE
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        NK = ND(1,1,K)
        ZE(1,N) = ZE(1,NK)
        ZE(2,N) = ZE(1,NK)
        ZE(3,N) = ZE(1,NK)
        ZE(4,N) = ZE(1,NK)
        ZE(5,N) = ZE(5,NK)
        ZE(6,N) = ZE(5,NK)
        ZE(7,N) = ZE(5,NK)
        ZE(8,N) = ZE(5,NK)
      ENDDO
      ENDDO
      ENDDO
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_UNFGRID group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_UNIT( UNTS,VAR,INDX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Unit conversions for variable VAR.
!     INDX = 0 : Convert to SI Units.
!     INDX = 1 : Convert from SI Units.
!     INDX = 2 : Convert to SI Units without a units check.
!     INDX = 3 : Convert to SI Units for output.
!     INDX = 4 : Convert from SI Units for output.
!
!     Rules for expressing units:
!       Units may only contain one divisor.
!       Components within a units character string must be separated
!       with a blank space, colon, or a divisor.
!       No spaces between component name and divisor.
!       Units raised to powers are indicated with a '^' symbol.
!       Examples:
!         'btu:in/hr ft^2 F' converts to SI units of 'w/m k'
!         'lb/hr ft' converts to SI units of 'Pa s'
!         'g/l' converts to SI units of 'kg/m^3'
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, November 1992.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Parameter Statements----------------------------!
!
      PARAMETER (LUNS=121)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*4 FORM1
      CHARACTER*8 CHS(LUNS),CHD
      CHARACTER*64 UNTS
      REAL*8 CF(LUNS)
      INTEGER IUM(LUNS),IUKG(LUNS),IUS(LUNS),IUK(LUNS),IUMOL(LUNS)
!
!----------------------Data Statements---------------------------------!
!
      SAVE CHS,CF,IUM,IUKG,IUS,IUK,IUMOL,FORM1
      DATA CHS /'m','kg','s','j','c','pa','w','kgmol','rad',
     &  'solid','water','napl','gas','aqueous','oil','voc','sol',
     &  'ci','pci','liq','aqu','mi','mile','nm',
     &  'ft','dm','cm','mm','yd','in',
     &  'l','gal','liter','ml',
     &  'g','lb','slug','lbm','gm','gram','mg',
     &  'min','hr','d','wk','yr',
     &  'hour','day','week','year','sec',
     &  'btu','cal','hp','dynes','dyn','darcy',
     &  'k','f','r',
     &  'psi','bar','atm','wh','psf','lbf',
     &  'deg','degree','furlong','rod','rad','radian',
     &  'cp','p','hc','1','mol','mole','lbmol',
     &  'debyes','bd','n','newton','plant','langley',
     &  'kpa','mpa','gpa','upa','kmol','kmole','joule','kj','kjoule',
     &  'a','ao','ang','angstrom','bq',
     &  'tonne','mt','mmt','md','mdarcy','ton',
     &  'ffl','ffa','ffvh_m','ffvh_ft',
     &  'ffvh_in','ffvh_yd','ffvh_cm','st','cst',
     &  'bbl','stb','scf','mscf','mmscf','bscf','tscf'/
      DATA CHS /'m','kg','s','j','c','pa','w','kgmol','rad',
     &  'solid','water','napl','gas','aqueous','oil','voc','sol',
     &  'ci','pci','liq','aqu','mi','mile','nm',
     &  'ft','dm','cm','mm','yd','in',
     &  'l','gal','liter','ml',
     &  'g','lb','slug','lbm','gm','gram','mg',
     &  'min','hr','d','wk','yr',
     &  'hour','day','week','year','sec',
     &  'btu','cal','hp','dynes','dyn','darcy',
     &  'k','f','r',
     &  'psi','bar','atm','wh','psf','lbf',
     &  'deg','degree','furlong','rod','rad','radian',
     &  'cp','p','hc','1','mol','mole','lbmol',
     &  'debyes','bd','n','newton','plant','langley',
     &  'kpa','mpa','gpa','upa','kmol','kmole','joule','kj','kjoule',
     &  'a','ao','ang','angstrom','bq',
     &  'tonne','mt','mmt','md','mdarcy','ton',
     &  'ffl','ffa','ffvh_m','ffvh_ft',
     &  'ffvh_in','ffvh_yd','ffvh_cm','st','cst',
     &  'bbl','stb','scf','mscf','mmscf','bscf','tscf'/
      DATA CF  /1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,
     &  1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,
     &  1.D+0,1.D+0,1.D+0,1.D+0,1.609344D+3,1.609344D+3,1.D-9,
     &  3.048D-1,1.D-1,1.D-2,1.D-3,9.144D-1,2.54D-2,
     &  1.D-3,3.7854D-3,1.D-3,1.D-6,
     &  1.D-3,4.5359D-1,1.4594D+1,4.5359D-1,1.D-3,1.D-3,1.D-6,
     &  6.D+1,3.6D+3,8.64D+4,6.048D+5,3.15576D+7,
     &  3.6D+3,8.64D+4,6.048D+5,3.15576D+7,1.D+0,
     &  1.0544D+3,4.184D+0,7.457D+2,1.D-5,1.D-5,0.9869D-12,
     &  1.D+0,5.555556D-1,5.555556D-1,
     &  6.8948D+3,1.D+5,1.01325D+5,9.7935332D+03,4.7880556D+1,4.4482D+0,
     &  1.745329252D-2,1.745329252D-2,2.01168D+2,5.0292D+0,1.D+0,1.D+0,
     &  1.D-3,1.D-1,1.03910295199455D-07,1.D+0,1.D-3,1.D-3,4.5359D-1,
     &  1.D+0,1.D+0,1.D+0,1.D+0,1.D+0,4.186D+4,
     &  1.D+3,1.D+6,1.D+9,1.D-6,1.D+0,1.D+0,1.D+0,1.D+3,1.D+3,
     &  1.D-10,1.D-10,1.D-10,1.D-10,1.D+0,
     &  1.D+3,1.D+3,1.D+9,0.9869D-15,0.9869D-15,9.0718494D+2,
     &  109.728D+0,5351.215104D+0,5351.215104D+0,1631.050363699D+0,
     &  135.920863642D+0,4893.151091098D+0,53.51215104D+0,1.D-4,1.D-6,
     &  0.158987295D+0,0.158987295D+0,2.83168D-2,2.83168D+1,2.83168D+4,
     &  2.83168D+7,2.83168D+10/
      DATA IUM /1,0,0,2,0,-1,2,0,0,
     &  0,0,0,0,0,0,0,0,
     &  0,0,0,0,1,1,1,
     &  1,1,1,1,1,1,
     &  3,3,3,3,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,
     &  2,2,2,1,1,2,
     &  0,0,0,
     &  -1,-1,-1,-2,-1,1,
     &  0,0,1,1,0,0,
     &  -1,-1,0,0,0,0,0,
     &  0,-3,1,1,0,0,
     &  -1,-1,-1,-1,0,0,2,2,2,
     &  1,1,1,1,0,
     &  0,0,0,2,2,0,
     &  1,2,3,3,
     &  3,3,3,2,2,
     &  3,3,3,3,3,3,3/
      DATA IUKG /0,1,0,1,0,1,1,0,0,
     &  0,0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,
     &  1,1,1,1,1,1,1,
     &  0,0,0,0,0,
     &  0,0,0,0,0,
     &  1,1,1,1,1,0,
     &  0,0,0,
     &  1,1,1,1,1,1,
     &  0,0,0,0,0,0,
     &  1,1,0,0,0,0,0,
     &  0,1,1,1,0,1,
     &  1,1,1,1,0,0,1,1,1,
     &  0,0,0,0,0,
     &  1,1,1,0,0,1,
     &  0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,0/
      DATA IUS /0,0,1,-2,0,-2,-3,0,0,
     &  0,0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  1,1,1,1,1,
     &  1,1,1,1,1,
     &  -2,-2,-3,-2,-2,0,
     &  0,0,0,
     &  -2,-2,-2,-2,-2,-2,
     &  0,0,0,0,0,0,
     &  -1,-1,0,0,0,0,0,
     &  0,0,-2,-2,0,-2,
     &  -2,-2,-2,-2,0,0,-2,-2,-2,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,
     &  0,0,0,-1,-1,
     &  0,0,0,0,0,0,0/
      DATA IUK /0,0,0,0,1,0,0,0,0,
     &  0,0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  1,1,1,
     &  0,0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,0,0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,0/
      DATA IUMOL /0,0,0,0,0,0,0,1,0,
     &  0,0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,
     &  0,0,0,0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,1,1,1,
     &  0,0,0,0,0,0,
     &  0,0,0,0,1,1,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,
     &  0,0,0,0,
     &  0,0,0,0,0,
     &  0,0,0,0,0,0,0/     
      DATA FORM1 /'(I )'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_UNIT'
      NCH = INDEX( UNTS,'  ' ) - 1
      IF( UNTS(1:NCH).EQ.'null' .OR. UNTS(1:NCH).EQ.'none' ) THEN
        IUNM = 0
        IUNKG = 0
        IUNS = 0
        IUNK = 0
        IUNMOL = 0
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Intialize primary unit indices  ---
!
      IUMX = 0
      IUKGX = 0
      IUSX = 0
      IUKX = 0
      IUMOLX = 0
!
!---  Temperature units  --
!
      IF( UNTS(1:NCH) .EQ. 'c' ) THEN
        IUKX = 1
        GOTO 400
      ELSEIF( UNTS(1:NCH) .EQ. 'k' ) THEN
        IF( INDX.EQ.0 .OR. INDX.EQ.2 .OR. INDX.EQ.3 ) THEN
          VAR = VAR - 2.7315D+2
        ELSE
          VAR = VAR + 2.7315D+2
        ENDIF
        IUKX = 1
        GOTO 400
      ELSEIF( UNTS(1:NCH) .EQ. 'f' ) THEN
        IF( INDX.EQ.0 .OR. INDX.EQ.2 .OR. INDX.EQ.3 ) THEN
          VAR = (VAR-3.2D+1)/1.8D+0
        ELSE
          VAR = VAR*1.8D+0 + 3.2D+1
        ENDIF
        IUKX = 1
        GOTO 400
      ELSEIF( UNTS(1:NCH) .EQ. 'r' ) THEN
        IF( INDX.EQ.0 .OR. INDX.EQ.2 .OR. INDX.EQ.3 ) THEN
          VAR = (VAR-4.92D+2)/1.8D+0
        ELSE
          VAR = VAR*1.8D+0 + 4.92D+2
        ENDIF
        IUKX = 1
        GOTO 400
      ENDIF
!
!---  Decompose the units into components and convert individual
!     components  ---
!
      ISX = 1
      IDV = INDEX( UNTS(1:),'/' )-1
      IEX = INDEX( UNTS(1:),'  ' )-1
!
!---  Units without a divisor  ---
!
      IF( IDV .EQ. -1 ) THEN
  100 CONTINUE
        ISP = INDEX( UNTS(ISX:),' ' )+ISX-2
        ICO = INDEX( UNTS(ISX:),':' )+ISX-2
        IF( ICO .LT. ISX ) ICO = IEX
        IB = MIN( IEX,ISP,ICO )
        CHD = UNTS(ISX:IB)
        IC = INDEX( CHD(1:),'^' )
        IF( IC .EQ. 0 ) THEN
          IP = 1
        ELSE
          I1 = IC+1
          I2 = IB-ISX+1
          I3 = I2-I1+1
          WRITE( FORM1(3:3),'(I1)' ) I3
          READ(CHD(I1:I2),FORM1) IP
          I2 = IC-1
          CHD = CHD(1:I2)
        ENDIF
        DO 110 N = 1,LUNS
          IF( CHS(N) .EQ. CHD ) THEN
            IUMX = IUMX + IUM(N)*IP
            IUKGX = IUKGX + IUKG(N)*IP
            IUSX = IUSX + IUS(N)*IP
            IUKX = IUKX + IUK(N)*IP
            IUMOLX = IUMOLX + IUMOL(N)*IP
            IF( INDX.EQ.0 .OR. INDX.EQ.2 .OR. INDX.EQ.3 ) THEN
              VAR = VAR*(CF(N)**IP)
            ELSE
              VAR = VAR/(CF(N)**IP)
            ENDIF
            GOTO 120
          ENDIF
  110   CONTINUE
        INDX = 4
        CHMSG = 'Unrecognized Units: '//VARB(1:IVR)//': '//UNTS
        CALL WRMSGP( INDX )
  120   CONTINUE
        IF( IB .LT. IEX ) THEN
          ISX = IB+2
          GOTO 100
        ENDIF
!
!---  Units with a divisor  ---
!
      ELSE
!
!---  Components before the divisor  ---
!
  200 CONTINUE
        ISP = INDEX( UNTS(ISX:),' ' )+ISX-2
        ICO = INDEX( UNTS(ISX:),':' )+ISX-2
        IF( ICO .LT. ISX ) ICO = IEX
        IB = MIN( IDV,ISP,ICO )
        CHD = UNTS(ISX:IB)
        IC = INDEX( CHD(1:),'^' )
        IF( IC .EQ. 0 ) THEN
          IP = 1
        ELSE
          I1 = IC+1
          I2 = IB-ISX+1
          I3 = I2-I1+1
          WRITE( FORM1(3:3),'(I1)' ) I3
          READ(CHD(I1:I2),FORM1) IP
          I2 = IC-1
          CHD = CHD(1:I2)
        ENDIF
        DO 210 N = 1,LUNS
          IF( CHS(N) .EQ. CHD ) THEN
            IUMX = IUMX + IUM(N)*IP
            IUKGX = IUKGX + IUKG(N)*IP
            IUSX = IUSX + IUS(N)*IP
            IUKX = IUKX + IUK(N)*IP
            IUMOLX = IUMOLX + IUMOL(N)*IP
            IF( INDX.EQ.0 .OR. INDX.EQ.2 .OR. INDX.EQ.3 ) THEN
              VAR = VAR*(CF(N)**IP)
            ELSE
              VAR = VAR/(CF(N)**IP)
            ENDIF
            GOTO 220
          ENDIF
  210   CONTINUE
        INDX = 4
        CHMSG = 'Unrecognized Units: '//VARB(1:IVR)//': '//UNTS
        CALL WRMSGP( INDX )
  220   CONTINUE
        IF( IB .LT. IDV ) THEN
          ISX = IB+2
          GOTO 200
        ELSE
          ISX = IB+2
          GOTO 300
        ENDIF
!
!---  Components after the divisor  ---
!
  300   CONTINUE
        ISP = INDEX( UNTS(ISX:),' ' )+ISX-2
        ICO = INDEX( UNTS(ISX:),':' )+ISX-2
        IF( ICO .LT. ISX ) ICO = IEX
        IB = MIN( IEX,ISP,ICO )
        CHD = UNTS(ISX:IB)
        IC = INDEX( CHD(1:),'^' )
        IF( IC .EQ. 0 ) THEN
          IP = 1
        ELSE
          I1 = IC+1
          I2 = IB-ISX+1
          I3 = I2-I1+1
          WRITE( FORM1(3:3),'(I1)' ) I3
          READ(CHD(I1:I2),FORM1) IP
          I2 = IC-1
          CHD = CHD(1:I2)
        ENDIF
        DO 310 N = 1,LUNS
          IF( CHS(N) .EQ. CHD ) THEN
            IUMX = IUMX - IUM(N)*IP
            IUKGX = IUKGX - IUKG(N)*IP
            IUSX = IUSX - IUS(N)*IP
            IUKX = IUKX - IUK(N)*IP
            IUMOLX = IUMOLX - IUMOL(N)*IP
            IF( INDX.EQ.0 .OR. INDX.EQ.2 .OR. INDX.EQ.3 ) THEN
              VAR = VAR/(CF(N)**IP)
            ELSE
              VAR = VAR*(CF(N)**IP)
            ENDIF
            GOTO 320
          ENDIF
  310   CONTINUE
        INDX = 4
        CHMSG = 'Unrecognized Units: '//VARB(1:IVR)//': '//UNTS
        CALL WRMSGP( INDX )
  320   CONTINUE
        IF( IB .LT. IEX ) THEN
          ISX = IB+2
          GOTO 300
        ENDIF
      ENDIF
!
!---  Units Conversion Check  ---
!
  400 CONTINUE
      IF( INDX.EQ.2 ) THEN
        IUNM = 0
        IUNKG = 0
        IUNS = 0
        IUNK = 0
        IUNMOL = 0
      ELSEIF( IUMX.NE.IUNM .OR. IUKGX.NE.IUNKG .OR. IUSX.NE.IUNS .OR.
     &    IUKX.NE.IUNK .OR. IUMOLX.NE.IUNMOL ) THEN
        INDX = 4
        CHMSG = 'Incompatible Units: '//VARB(1:IVR)//': '//UNTS
        CALL WRMSGP( INDX )
      ELSE
        IUNM = 0
        IUNKG = 0
        IUNS = 0
        IUNK = 0
        IUNMOL = 0
      ENDIF
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_UNIT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_VBLGRID
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read grids with variable spacing.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 30 November 2011.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*64 UNTS
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_VBLGRID'
!
!---  First coordinate direction ---
!
      IC = 0
  100 CONTINUE
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      IR = LFX+1-IC
      DO 120 I = 1,IR
        ICMX = INDEX( CHDUM(ISTART:), ',' ) + ISTART - 1
        IF( ICMX.EQ.ISTART-1 ) GOTO 100
        IATX = INDEX( CHDUM(ISTART:), '@' ) + ISTART - 1
        IF( IATX.LT.ISTART .OR. IATX.GT.ICMX ) THEN
          IC = IC + 1
          N = ND(MIN(IC,LFX),1,1)
          VARB = 'X Dimension'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
          VARB = 'X Dimension Units'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          IF( IC.EQ.LFX+1 ) THEN
            XE(2,N) = VARX
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,XE(2,N),INDX)
            GOTO 130
          ELSE
            XE(1,N) = VARX
          ENDIF
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,XE(1,N),INDX)
          IF( IC.GT.1 ) THEN
            NW = N-1
            XE(2,NW) = XE(1,N)
          ENDIF
        ELSE
          CHDUM(IATX:IATX) = ','
          VARB = 'Count Integer'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,IATX )
          VARB = 'X Dimension'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,DXVAR )
          VARB = 'X Dimension Units'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,DXVAR,INDX)
          DO 110 II = 1,IATX
            IC = IC + 1
            N = ND(MIN(IC,LFX),1,1)
            IF( IC.EQ.1 ) THEN
              XE(1,N) = 0.D+0
              XVAR = XE(1,N)
            ELSEIF( IC.EQ.LFX+1 ) THEN
              XE(2,N) = XE(1,N) + DXVAR
              XVAR = XE(2,N)
            ELSE
              NW = N-1
              XE(1,N) = XE(1,NW) + DXVAR
              XVAR = XE(1,N)
            ENDIF
            INDX = 1
            IUNM = 1
            CALL RD_UNIT(UNTS,XVAR,INDX )
            IF( IC.EQ.LFX+1 ) GOTO 130
            IF( IC.GT.1 ) THEN
              NW = N-1
              XE(2,NW) = XE(1,N)
            ENDIF
  110     CONTINUE
        ENDIF
  120 CONTINUE
  130 CONTINUE
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        NI = ND(I,1,1)
        XE(1,N) = XE(1,NI)
        XE(3,N) = XE(1,NI)
        XE(5,N) = XE(1,NI)
        XE(7,N) = XE(1,NI)
        XE(2,N) = XE(2,NI)
        XE(4,N) = XE(2,NI)
        XE(6,N) = XE(2,NI)
        XE(8,N) = XE(2,NI)
      ENDDO
      ENDDO
      ENDDO
!
!---  Second coordinate direction  ---
!
      JC = 0
      JW = 0
  200 CONTINUE
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      JR = LFY+1-JC
      DO 220 J = 1,JR
        JCM = INDEX( CHDUM(ISTART:), ',' ) + ISTART - 1
        IF( JCM.EQ.ISTART-1 ) GOTO 200
        JAT = INDEX( CHDUM(ISTART:), '@' ) + ISTART - 1
        IF( JAT.LT.ISTART .OR. JAT.GT.JCM ) THEN
          JC = JC + 1
          N = ND(1,MIN(JC,LFY),1)
          VARB = 'Y Dimension'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
          VARB = 'Y Dimension Units'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          IF( JC.EQ.LFY+1 ) THEN
            YE(3,N) = VARX
            INDX = 0
            IUNM = 1
            IF( ICS.EQ.2 ) IUNM = 0
            CALL RD_UNIT(UNTS,YE(3,N),INDX)
            GOTO 230
          ELSE
            YE(1,N) = VARX
          ENDIF
          INDX = 0
          IUNM = 1
          IF( ICS.EQ.2 ) IUNM = 0
          CALL RD_UNIT(UNTS,YE(1,N),INDX)
          IF( JC.GT.1 ) THEN
            NS = N-LFX
            YE(3,NS) = YE(1,N)
          ENDIF
        ELSE
          CHDUM(JAT:JAT) = ','
          VARB = 'Count Integer'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,JAT )
          VARB = 'Y Dimension'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,DYVAR)
          VARB = 'Y Dimension Units'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          IF( ICS.EQ.2 ) IUNM = 0
          CALL RD_UNIT(UNTS,DYVAR,INDX)
          DO 210 JJ = 1,JAT
            JC = JC + 1
            N = ND(1,MIN(JC,LFY),1)
            IF( JC.EQ.1 ) THEN
              YE(1,N) = 0.D+0
              YVAR = YE(1,N)
            ELSEIF( JC.EQ.LFY+1 ) THEN
              YE(3,N) = YE(1,N) + DYVAR
              YVAR = YE(3,N)
            ELSE
              NS = N-LFX
              YE(1,N) = YE(1,NS) + DYVAR
              YVAR = YE(1,N)
            ENDIF
            INDX = 1
            IUNM = 1
            IF( ICS.EQ.2 ) IUNM = 0
            CALL RD_UNIT(UNTS,YVAR,INDX )
            IF( JC.EQ.LFY+1 ) GOTO 230
            IF( JC.GT.1 ) THEN
              NS = N-LFX
              YE(3,NS) = YE(1,N)
            ENDIF
  210     CONTINUE
        ENDIF
  220 CONTINUE
  230 CONTINUE
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        NJ = ND(1,J,1)
        YE(1,N) = YE(1,NJ)
        YE(2,N) = YE(1,NJ)
        YE(5,N) = YE(1,NJ)
        YE(6,N) = YE(1,NJ)
        YE(3,N) = YE(3,NJ)
        YE(4,N) = YE(3,NJ)
        YE(7,N) = YE(3,NJ)
        YE(8,N) = YE(3,NJ)
      ENDDO
      ENDDO
      ENDDO
!
!---  Third coordinate direction  ---
!
      KC = 0
  300 CONTINUE
      ISTART = 1
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      KR = LFZ+1-KC
      DO 320 K = 1,KR
        KCM = INDEX( CHDUM(ISTART:), ',' ) + ISTART - 1
        IF( KCM.EQ.ISTART-1 ) GOTO 300
        KAT = INDEX( CHDUM(ISTART:), '@' ) + ISTART - 1
        IF( KAT.LT.ISTART .OR. KAT.GT.KCM ) THEN
          KC = KC + 1
          N = ND(1,1,MIN(KC,LFZ))
          VARB = 'Z Dimension'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,VARX)
          VARB = 'Z Dimension Units'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          IF( KC.EQ.LFZ+1 ) THEN
            ZE(5,N) = VARX
            INDX = 0
            IUNM = 1
            CALL RD_UNIT(UNTS,ZE(5,N),INDX)
            GOTO 330
          ELSE
            ZE(1,N) = VARX
          ENDIF
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,ZE(1,N),INDX)
          IF( KC.GT.1 ) THEN
            NB = N-LFXY
            ZE(5,NB) = ZE(1,N)
          ENDIF
        ELSE
          CHDUM(KAT:KAT) = ','
          VARB = 'Count Integer'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,KAT )
          VARB = 'Z Dimension'
          CALL RD_DPR(ISTART,ICOMMA,CHDUM,DZVAR)
          VARB = 'Z Dimension Units'
          CALL RD_CHR(ISTART,ICOMMA,NCH,CHDUM,UNTS)
          INDX = 0
          IUNM = 1
          CALL RD_UNIT(UNTS,DZVAR,INDX)
          DO 310 KK = 1,KAT
            KC = KC + 1
            N = ND(1,1,MIN(KC,LFZ))
            IF( KC.EQ.1 ) THEN
              ZE(1,N) = 0.D+0
              ZVAR = ZE(1,N)
            ELSEIF( KC.EQ.LFZ+1 ) THEN
              ZE(5,N) = ZE(1,N) + DZVAR
              ZVAR = ZE(5,N)
            ELSE
              NB = N-LFXY
              ZE(1,N) = ZE(1,NB) + DZVAR
              ZVAR = ZE(1,N)
            ENDIF
            INDX = 1
            IUNM = 1
            CALL RD_UNIT(UNTS,ZVAR,INDX )
            IF( KC.EQ.LFZ+1 ) GOTO 330
            IF( KC.GT.1 ) THEN
              NB = N-LFXY
              ZE(5,NB) = ZE(1,N)
            ENDIF
  310     CONTINUE
        ENDIF
  320 CONTINUE
  330 CONTINUE
      DO K = 1,LFZ
      DO J = 1,LFY
      DO I = 1,LFX
        N = ND(I,J,K)
        NK = ND(1,1,K)
        ZE(1,N) = ZE(1,NK)
        ZE(2,N) = ZE(1,NK)
        ZE(3,N) = ZE(1,NK)
        ZE(4,N) = ZE(1,NK)
        ZE(5,N) = ZE(5,NK)
        ZE(6,N) = ZE(5,NK)
        ZE(7,N) = ZE(5,NK)
        ZE(8,N) = ZE(5,NK)
      ENDDO
      ENDDO
      ENDDO
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_VBLGRID group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RD_WELL4
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Read SAC Remediation Card for parameters.
!
!----------------------Authors-----------------------------------------!
!
!     Written by WE Nichols, PNNL, 13 June 2003.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE WELL_CL
      USE SOLTN
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*512 CHDUM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RD_WELL4'
!
!---  Assign card string  ---
!
      CARD = 'Well Card'
      LWELL = 1
!
!---  Minimum band width parameter according
!     to solver type; parameter LMNP will be reset
!     for coupled wells  ---
!






!
!---  Read number of wells  ---
!
      CALL RD_INPL( CHDUM )
      CALL L_CASE( CHDUM )
      ISTART = 1
      VARB = 'Number of Wells'
      CALL RD_INT(ISTART,ICOMMA,CHDUM,NWLS)
      LNW = MAX( LNW,NWLS )
      DO 1000 NWL = 1,NWLS
!
!---    Read well type  ---
!
        CALL RD_INPL( CHDUM )
!
!---    Read well domain  ---
!
        CALL RD_INPL( CHDUM )
        CALL L_CASE( CHDUM )
        ISTART = 1
        VARB = 'Well I Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,I)
        VARB = 'Well J Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,J)
        VARB = 'Well Lower K Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,K1X)
        VARB = 'Well Upper K Index'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,K2X)
!
!---    Read number of well screen intervals  ---
!
        CALL RD_INT(ISTART,ICOMMA,CHDUM,NWSI)
        LNWS = MAX( LNWS,NWSI )
!
!---    Read well screen intervals  ---
!
        DO 110 NWS = 1,NWSI
          VARB = 'Screen Lower K Index'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K1X)
          VARB = 'Screen Upper K Index'
          CALL RD_INT(ISTART,ICOMMA,CHDUM,K2X)
  110   CONTINUE
!
!---    Read number of well times  ---
!
        VARB = 'Number of Well Times'
        CALL RD_INT(ISTART,ICOMMA,CHDUM,IWMX)
        LNWT = MAX( LNWT,ABS(IWMX) )
 1000 CONTINUE
!
!---  Reset subroutine name  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RD_WELL4 group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SORT_V( AX,BX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Sort two real variables
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 14 August 2017.
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      IF( AX.GT.BX ) THEN
        CX = AX
        AX = BX
        BX = CX
      ENDIF
!
!---  End of SORT_V group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE WITH_IN( XX,YX,ZX,ICWX,NX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Determine whether an x,y,z coordinate location is within
!     the bounds of a node.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, PNNL, 28 March 2012.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 XPX(5),YPX(5),ZPX(5)
      REAL*8 PAX(3),PBX(3),PCX(3),PBCX(3)
      INTEGER MSX(4,6)
      INTEGER N1X(4),N2X(4)
!
!----------------------Data Statements---------------------------------!
!
      DATA MSX / 1,2,4,3,1,5,6,2,1,3,7,5,2,6,8,4,3,4,8,7,5,7,8,6 /
      DATA N1X / 2,3,4,1 /
      DATA N2X / 1,2,3,4 /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/WITH_IN'
!
!---  Loop over node surfaces,
!     (bottom,south,west,east,north,top)  ---
!
      ICWX = 0
      DO 180 NS = 1,6
!
!---    Define the five surface points, four corners
!       and one centroid---
!
        DO 110 NP = 1,4
          MX = MSX(NP,NS)
!
!---      Cylindrical coordinates  ---
!
          IF( ICS.EQ.2 .OR. ICS.EQ.6 ) THEN
            XPX(NP) = XE(MX,NX)*COS(YE(MX,NX))
            YPX(NP) = XE(MX,NX)*SIN(YE(MX,NX))
            ZPX(NP) = ZE(MX,NX)
          ELSE
            XPX(NP) = XE(MX,NX)
            YPX(NP) = YE(MX,NX)
            ZPX(NP) = ZE(MX,NX)
          ENDIF
  110   CONTINUE
        NP = 4
        CALL PGCNTRD( NP,XPX(1),YPX(1),ZPX(1),
     &    XPX(5),YPX(5),ZPX(5) )
!
!---    Loop over the four triangular planes on the 
!       surface face  ---
!
        DO 130 NT = 1,4
!
!---      Vectors between point and the surface centroid  ---
!
          PAX(1) = XPX(5)-XX
          PAX(2) = YPX(5)-YX
          PAX(3) = ZPX(5)-ZX
!
!---      Vectors between surface face vertices and surface 
!         centroid, such that normal vector points inward  ---
!
          PBX(1) = XPX(N1X(NT))-XPX(5)
          PBX(2) = YPX(N1X(NT))-YPX(5)
          PBX(3) = ZPX(N1X(NT))-ZPX(5)
          PCX(1) = XPX(N2X(NT))-XPX(5)
          PCX(2) = YPX(N2X(NT))-YPX(5)
          PCX(3) = ZPX(N2X(NT))-ZPX(5)
          CALL VCROSSP( PBX,PCX,PBCX )
          SX = VDOTP( PAX,PBCX )
!
!---      Clockwise rotation  ---
!
          IF( SX.GT.EPSL ) THEN
!
!---        Opposing rotations found, point outside hexahedron  ---
!
            IF( ICWX.EQ.-1 ) THEN
              ICWX = 0
              GOTO 200
!
!---        Similar rotations found, continue searching  ---
!
            ELSE
              ICWX = 1
            ENDIF
!
!---      Counterclockwise rotation  ---
!
          ELSEIF( SX.LT.-EPSL ) THEN
!
!---        Opposing rotations found, point outside hexahedron  ---
!
            IF( ICWX.EQ.1 ) THEN
              ICWX = 0
              GOTO 200
!
!---        Similar rotations found, continue searching  ---
!
            ELSE
              ICWX = -1
            ENDIF
          ENDIF
  130   CONTINUE
  180 CONTINUE
      ICWX = ABS( ICWX )
  200 CONTINUE            
!
!---  Reset subroutine character string ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of WITH_IN group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE WRMSGP( INDX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Write warnings and error messages to the screen and output file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by MD White, Battelle, PNL, September, 1994.
!     step.F https://stash.pnnl.gov/scm/stomp/stomp.git V3.0
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
      EXTERNAL I_COUNT
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*9 FORM1
      CHARACTER*9 FORM2
      CHARACTER*17 FORM3
      CHARACTER*19 FORM4
      CHARACTER*9 FORM5
      CHARACTER*9 FORM6
      CHARACTER*19 FORM14
      CHARACTER*19 FORM17
      CHARACTER*19 FORM21
!
!----------------------Data Statements---------------------------------!
!
      SAVE FORM1,FORM2,FORM3,FORM4,FORM5,FORM6
      DATA FORM1 / '(/,3A,I4)' /
      DATA FORM2 / '(/,2A,I6)' /
      DATA FORM3 / '(/,2A,I6,1PE11.4)' /
      DATA FORM4 / '(/,3A,I6,A,1PE11.4)' /
      DATA FORM5 / '(/,3A,I6)' /
      DATA FORM6 / '(/,2A,I6)' /
      DATA FORM14 / '(/,A,I6,2A,1PE11.4)' /
      DATA FORM17 / '(/,A,I6,2A,1PE11.4)' /
      DATA FORM21 / '(/,A,I6,2A,1PE11.4)' /
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/WRMSGP'
      NCH = INDEX( CHMSG(1:),'  ' )-1
      ICSN = INDEX( SUB_LOG(1)(1:),'  ' )-1
      SUBNM(1:ICSN) = SUB_LOG(1)(1:ICSN)
      DO 10 I = 2,ISUB_LOG
        ICSNX = INDEX( SUB_LOG(I)(1:),'  ' )-1
        SUBNM(ICSN+1:ICSN+ICSNX) = SUB_LOG(I)(1:ICSNX)
        ICSN = ICSN+ICSNX
   10 CONTINUE
      IF( INDX.EQ.0 ) THEN
        WRITE(6,'(/,A)') CHMSG(:NCH)
      ELSEIF( INDX.EQ.1 ) THEN
        WRITE(6,'(2A)') 'NOTE: ',CHMSG(:NCH)
      ELSEIF( INDX.EQ.2 ) THEN
        WRITE(6,'(/,2A)') 'INPUT WARNING: ',CHMSG(:NCH)
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
      ELSEIF( INDX.EQ.3 ) THEN
        WRITE(6,'(/,2A)') 'EXECUTION ERROR: ',CHMSG(:NCH)
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
        STOP
      ELSEIF( INDX.EQ.4 ) THEN
        WRITE(6,'(/,2A)') 'INPUT ERROR: ',CHMSG(:NCH)
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
        STOP
      ELSEIF( INDX.EQ.5 ) THEN
        WRITE(6,'(/,2A)') 'PARAMETER ERROR: ',CHMSG(:NCH)
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
        STOP
      ELSEIF( INDX.EQ.6 ) THEN
        WRITE(6,'(/,2A)') 'PARAMETER ERROR: ',CHMSG(:NCH)
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
      ELSEIF( INDX.EQ.7 ) THEN
        WRITE(FORM1(8:8),'(I1)') I_COUNT( IMSG )
        WRITE(6,FORM1) 'INPUT ERROR: ',CHMSG(:NCH),': ',IMSG
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
        STOP
      ELSEIF( INDX.EQ.8 ) THEN
        WRITE(6,'(/,2A)') 'PARAMETER ERROR: ',CHMSG(:NCH)
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
        STOP
      ELSEIF( INDX.EQ.9 ) THEN
        WRITE(6,'(/,3A,1PE11.4)') 'INPUT ERROR: ',CHMSG(:NCH),': ',
     &    RLMSG
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
        STOP
      ELSEIF( INDX.EQ.10 ) THEN
        WRITE(6,'(/,3A,1PE11.4)') 'STATE CONDITION ERROR: ',
     &    CHMSG(:NCH),': ',RLMSG
      ELSEIF( INDX.EQ.11 ) THEN
        WRITE(6,'(/,3A,1PE11.4)') 'STATE CONDITION ERROR: ',
     &    CHMSG(:NCH),': ',RLMSG
        STOP
      ELSEIF( INDX.EQ.12 ) THEN
        WRITE(FORM2(8:8),'(I1)') I_COUNT( IMSG )
        WRITE(6,FORM2) 'EXECUTION ERROR: ',CHMSG(:NCH),IMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
        STOP
      ELSEIF( INDX.EQ.13 ) THEN
        WRITE(FORM14(7:7),'(I1)') I_COUNT( N_DB )
        WRITE(6,FORM14) 'EXECUTION WARNING: NODE = ',
     &    N_DB,': ',CHMSG(:NCH),RLMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
      ELSEIF( INDX.EQ.14 ) THEN
        WRITE(FORM14(7:7),'(I1)') I_COUNT( N_DB )
        WRITE(6,FORM14) 'EXECUTION ERROR: NODE = ',
     &    N_DB,': ',CHMSG(:NCH),RLMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
        STOP
      ELSEIF( INDX.EQ.15 ) THEN
        WRITE(FORM3(8:8),'(I1)') I_COUNT( IMSG )
        WRITE(6,FORM3) 'EXECUTION ERROR: ',CHMSG(:NCH),IMSG,RLMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
        STOP
      ELSEIF( INDX.EQ.16 ) THEN
        WRITE(FORM4(8:8),'(I1)') I_COUNT( IMSG )
        WRITE(6,FORM4) 'INPUT ERROR: ',CHMSG(:NCH),
     &    ': ',IMSG,': ',RLMSG
        WRITE(6,'(2A)') 'INPUT CARD: ',CARD(:ICD)
        STOP
      ELSEIF( INDX.EQ.17 ) THEN
        WRITE(FORM17(7:7),'(I1)') I_COUNT( N_DB )
        WRITE(6,FORM17) 'STATE CONDIITON ERROR: NODE = ',
     &    N_DB,': ',CHMSG(:NCH),RLMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
        STOP
      ELSEIF( INDX.EQ.18 ) THEN
        WRITE(6,'(/,2A)') 'INPUT ERROR: ',CHMSG(:NCH)
        STOP
      ELSEIF( INDX.EQ.19 ) THEN
        WRITE(6,'(/,2A,1PE11.4)')'EXECUTION ERROR: ',CHMSG(:NCH),RLMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
        STOP
      ELSEIF( INDX.EQ.20 ) THEN
        WRITE(FORM6(8:8),'(I1)') I_COUNT( IMSG )
        WRITE(6,FORM6) 'EXECUTION ERROR: ',CHMSG(:NCH),IMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
        STOP
      ELSEIF( INDX.EQ.21 ) THEN
        WRITE(FORM21(7:7),'(I1)') I_COUNT( N_DB )
        WRITE(6,FORM21) 'STATE CONDIITON ERROR: NODE = ',
     &    N_DB,': ',CHMSG(:NCH),RLMSG
        WRITE(6,'(2A)') 'CALLING SEQUENCE: ',SUBNM(:ICSN)
      ENDIF
      ISUB_LOG = ISUB_LOG-1
!
!---  End of WRMSGP group
!
      RETURN
      END

