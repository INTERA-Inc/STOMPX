!----------------------Program-----------------------------------------!
!
      PROGRAM STOMP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------------------------------------------------------!
!
!     STOMPX: Subsurface Transport Over Multiple Phases Extensible
!
!     HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange) Mode
!
!     This engineering program numerically simulates the transport
!     of H2O, NaCl, CH4 and CO2 through multifluid subsurface 
!     environments under non-isothermal conditions, using MPI for 
!     parallel processing.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 15 June 2021
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE PROP
      USE OUTPU
      USE JACOB
      USE FLUX
      USE FILES
      USE FDVP
      USE GRID
      USE GLB_PAR
      USE GEO_MECH
      USE BCV
#ifdef lis
!
!----------------------Lis Modules-----------------------------------!
!
      USE LIS_STOMP
#endif
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
      LOGICAL HALT,PLOT,RESTART
#ifdef lis
      LIS_INTEGER :: IERR
#endif
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*132 CHMSGX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = 1
      SUB_LOG(1) = 'STOMPX-HYDT-KE'
!
!---  Initialize MPI  ---
!
      CALL MPI_INIT( IERR )
!
!---  Get the individual process ID  ---
!
      CALL MPI_COMM_RANK( MPI_COMM_WORLD,ID,IERR )
!
!---  Get the number of processes  ---
!
      CALL MPI_COMM_SIZE ( MPI_COMM_WORLD,NP,IERR )
#ifdef lis
!
!---  Initialize Lis ---
!
      CALL LIS_INITIALIZE( IERR )
#endif
!
!---  Print banner to screen ---
!
      IF( ID.EQ.0 ) THEN
      PRINT *,' Welcome to ...'
      PRINT *,' '
      PRINT *,'                     STOMPX-HYDT-KE'
      PRINT *,'        Subsurface Transport Over Multiple Phases'
      PRINT *,'                HYDT-KE Operational Mode'
      PRINT *,'               OpenMPI Extensible Version'
      PRINT *,' '
      PRINT *,' This screen echo was produced by STOMPX, a numerical '
      PRINT *,' simulator developed by the Pacific Northwest National '
      PRINT *,' Laboratory. The simulator additionally produces'
      PRINT *,' binary formatted output files: output.bin, plot_xxx.bin'
      PRINT *,' and surface.bin, which can be converted to text format'
      PRINT *,' with postprocessing utilities.'
      PRINT *,' '
      PRINT *,'                     Disclaimer'
      PRINT *,' This material was prepared as an account of work '
      PRINT *,' sponsored by an agency of the United States Government.'
      PRINT *,' Neither the United States Government nor the United '
      PRINT *,' States Department of Energy, nor Battelle, nor any of '
      PRINT *,' their employees, makes any warranty, express or '
      PRINT *,' implied, or assumes any legal liability or '
      PRINT *,' responsibility for the accuracy, completeness, or '
      PRINT *,' usefulness of any information, apparatus, product, '
      PRINT *,' software or process disclosed, or represents that its '
      PRINT *,' use would not infringe privately owned rights.'
      PRINT *,' '
      PRINT *,'                     Acknowledgement'
      PRINT *,' This software and its documentation were produced with '
      PRINT *,' Government support under Contract Number '
      PRINT *,' DE-AC06-76RLO-1830 awarded by the United Department of '
      PRINT *,' of Energy. The Government retains a paid-up '
      PRINT *,' non-exclusive, irrevocable worldwide license to'
      PRINT *,' implied, or assumes any legal liability or '
      PRINT *,' reproduce, prepare derivative works, perform publicly '
      PRINT *,' and display publicly by or for the Government, '
      PRINT *,' including the right to distribute to other Government '
      PRINT *,' contractors.'
      PRINT *,' '
      PRINT *,' For support:  Tel: 509.372.6070'
      PRINT *,'               E-mail:  mark.white@pnnl.gov'
      PRINT *,' '
      PRINT *,'                     Notice'
      PRINT *,' This screen echo only reports basic time stepping '
      PRINT *,' information to track the simulation progress. Expanded'
      PRINT *,' simulation results are reported in binary formatted '
      PRINT *,' output files: output.bin, plot_xxx.bin and '
      PRINT *,' surface.bin.'
      PRINT *,' '
      ENDIF
!
!---  Read binary files from preprocessor and allocate
!     memory for global arrays  ---
!
      CALL READ_BIN_HYDT_KE
!
!---  Initialize global arrays  ---
!
      CALL INTLZ_HYDT_KE
!
!---  For geomechanics set k iterate value of pore pressure  ---
!
      IF( ISLC(50).NE.0 ) THEN
        INDX = 2
        CALL PRESS_GM( INDX )
      ENDIF
!
!---  Configure the arrays for compressed sparse row matrix storage  ---
!
      CALL JCBP_HYDT_KE
!
!---  For geomechanics simulations compute Jacobian matrix pointers  --
!
      IF( ISLC(50).NE.0 ) CALL JCBP_GM
!
!---  Compute primary variable increments  ---
!
      CALL INCRM_HYDT_KE
!
!---  Hydrologic and thermodynamic properties  ---
!
      CALL PROP_HYDT_KE
      CALL BCP_HYDT_KE
!
!---  Compute initial fluxes on non-boundary and boundary surfaces  ---
!
      ISVF = 1
      CALL FLUX_HYDT_KE
      CALL BCF_HYDT_KE
      ISVF = 2*ISVC + 1
!
!---  Surface flux integrator for zero time step  ---
!
      DTX = DT
      DT = 0.D+0
      CALL SFIN_HYDT_KE
!      PRINT *,'Post SFIN_HYDT_KE: ID = ',ID
      DT = DTX
#ifdef lis
!
!---  Create Lis matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
!      PRINT *,'NUKFL(ID+1) = ',NUKFL(ID+1),' ID = ',ID
!      PRINT *,'NUKFO(ID+1) = ',NUKFO(ID+1),' ID = ',ID
!      PRINT *,'NUKFG = ',NUKFG,' ID = ',ID
      CALL STOMP_LIS_CREATE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,NUKFL(ID+1) )
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!        PRINT *,'NUKTL(ID+1) = ',NUKTL(ID+1),' ID = ',ID
!        PRINT *,'NUKTO(ID+1) = ',NUKTO(ID+1),' ID = ',ID
!        PRINT *,'NUKTG = ',NUKTG,' ID = ',ID
        CALL STOMP_LIS_CREATE( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC,NUKTL(ID+1) )
      ENDIF
#endif
!
!---  Check for fatal execution errors and stop simulation
!     if detected  ---
!
      CALL CHK_ERROR
!
!---  New Time Step ---
!
      IF( ID.EQ.0 ) ICNO = 10
      TSLOOP: DO
!
!---    Reference node(s) output  ---
!
        IF( MOD( (NSTEP-NRST),IFQO ).EQ.0 ) THEN
          CALL REFNOD_HYDT_KE
          IF( ID.EQ.0 ) THEN
            IF( ICNO.EQ.10 ) THEN
              ICNO = 0
              NCH = INDEX(UNTM(1:),'  ') - 1
              PRINT *,'       Step         Itr           Time' // 
     &          ' [',UNTM(1:NCH),']             Timestep [',
     &          UNTM(1:NCH),']'
            ENDIF
            ICNO = ICNO + 1
            PRINT *,NSTEP,NITER,TM*CNVTM,DT*CNVTM
          ENDIF
        ENDIF
!
!---    Load old time step arrays  ---
!
        CALL LDO_HYDT_KE
!
!---    Stop simulation if simulation time exceeds limit  ---
!
        IF( ABS(TMMX-TM).LE.1.D-6 ) THEN
          IF( ID.EQ.0 ) PRINT *,'Simulation Stopped:  ' // 
     &      'Simulation Time Limit'
          EXIT TSLOOP
        ENDIF
!
!---    Restart and plot file outputs  ---
!
        IF( ABS(TMPR-TM).LE.1.D-6 ) THEN
          CALL WRPLOT_HYDT_KE
          IF( ISLC(18).LT.1 ) CALL WRRST_HYDT_KE
        ENDIF
!
!---    Compute the next time step and increment time step counter  ---
!
        DTSO = DT
        CALL TMSTEP
        IF( NSTEP.EQ.0 ) DTSO = DT
        NSTEP = NSTEP + 1
        IF( NSTEP-NRST.GT.MXSTEP ) THEN
          IF( ID.EQ.0 ) PRINT *,'Simulation Stopped:  Time Step Limit'
          EXIT TSLOOP
        ENDIF
!
!---    New Newton-Raphson iteration ---
!
        NITER = 0
        NRLOOP: DO
          IF( ICNV.EQ.1 ) NITER = 0
          NITER = NITER + 1
!
!---      Compute boundary saturation, relative permeability, and
!         thermodynamic properties  ---
!
          CALL BCP_HYDT_KE
!
!---      Compute source contributions  ---
!
          CALL SORC_HYDT_KE
!
!---      Compute fluxes on non-boundary and boundary surfaces  ---
!
          CALL FLUX_HYDT_KE
          CALL BCF_HYDT_KE
!
!---      Zero Jacobian matrix  ---
!
          CALL JCBZ_HYDT_KE
!
!---      Load Jacobian matrix for the energy, water, mobile-CO2,
!         mobile-CH4, mobile-N2, hydrate-CO2, hydrate-CH4, hydrate-N2,
!         and salt equations (zero flux boundary)  ---
!
          CALL JCB_HYDT_KE
!
!---      Modify the Jacobian matrix for boundary conditions  ---
!
          CALL BCJ_HYDT_KE
!
!---      Set values of the Jacobian matrix  ---
!
          CALL JCB_SV
!
!---      Check for fatal execution errors and stop simulation
!         if detected  ---
!
          CALL CHK_ERROR
!
!---      Solve the linear system A x = b for coupled flow  ---
!
#ifdef lis
          INDX = 0
          CALL STOMP_LIS_SOLVE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &      NUKFO(ID+1),NUKFL(ID+1),INDX )
          IF( ICNV.EQ.4 ) EXIT TSLOOP 
#endif
!
!---      Check for fatal execution errors and stop simulation
!         if detected  ---
!
          CALL CHK_ERROR
!
!---      Update primary variables on field nodes w/o ghost cells  ---
!
          CALL UPDT_HYDT_KE
!
!---      Update primary variables on ghost cells  ---
!
          CALL UPDT_GC_HYDT_KE
!
!---      Compute convergence from maximum relative residuals  ---
!
          CALL RSDL_HYDT_KE
!
!---      Compute primary variable increments, saturation,
!         relative permeability, porosity, tortuosity,
!         thermodynamic properties for interior nodes,
!         except immediately after a new time step  ---
!
          CALL INCRM_HYDT_KE
          CALL PROP_HYDT_KE
!
!---      Convergence check  ---
!
!         ICNV = 1 - cut time step and restart Newton-Raphson loop
!         ICNV = 2 - next Newton-Raphson loop
!         ICNV = 3 - converged solution next time step
!         ICNV = 4 - total convergence failure stop simulation
!
!          IF( ID.EQ.0 ) THEN
!            PRINT *,'NSTEP = ',NSTEP,' NITER = ',NITER
!            DO M = 1,ISVC
!              PRINT *,'RSD(',M,') = ',RSD(M),
!     &          'NSD(',M,') = ',NSD(M),' ICNV = ',ICNV
!            ENDDO
!          ENDIF
          IF( ICNV.EQ.3 ) EXIT NRLOOP
          IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---    Proceed to new Newton-Raphson iteration  ---
!
        ENDDO NRLOOP
!
!---  Proceed to new time step  ---
!
      ENDDO TSLOOP
#ifdef lis
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
      CALL STOMP_LIS_DESTROY( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC )
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
        CALL STOMP_LIS_DESTROY( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC )
      ENDIF
!
!---  Finalize Lis execution  ---
!
      CALL LIS_FINALIZE(IERR)
#endif
!
!---  Write plot_xxx.bin file  ---
!
      CALL WRPLOT_HYDT_KE
!
!---  Write restart_xxx.bin file  ---
!
      CALL WRRST_HYDT_KE
!
!---  Close output.bin file, putting a closing -9 at the end
!     of the file  ---
!
      NVAR = 1
      IVARX = -9
      OFFSET = IOFFSET_REF
      IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &   MPI_INTEGER,STATUS,IERR)
      CALL MPI_FILE_CLOSE( IWR,IERR )
!
!---  Close surface.bin file(s), putting a closing -9.D+20 at the end
!     of the file  ---
!
      NSTART = 1
      IF( ISFGP(1).EQ.0 ) NSTART = 2
      DO NSG = NSTART,NSFGP
        NVAR = 1
        VARX = -9.D+20
        OFFSET = IOFFSET_SF(NSG)
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( ISF(NSG),OFFSET,VARX,
     &     NVAR,MPI_REAL8,STATUS,IERR)
        CALL MPI_FILE_CLOSE( ISF(NSG),IERR )
      ENDDO
!      PRINT *,'MPI_FINALIZE: ID = ',ID
      CALL MPI_FINALIZE(IERR)
!
!---  End of STOMP program  ---
!
      END


!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCF_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute boundary surface fluxes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE NAPL
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
      USE CONST
      USE BCVP
      USE BCVH
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 BCX(LBCV)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCF_HYDT_KE'
      DO NB = 1,NBC(ID+1)
        N = IBCN(NB)
        IF( IBCD(NB).EQ.-3 ) THEN
          DO M = 1,ISVF
            WL(M,1,N) = 0.D+0
            WG(M,1,N) = 0.D+0
            WN(M,1,N) = 0.D+0
            WLA(M,1,N) = 0.D+0
            WLN(M,1,N) = 0.D+0
            WLO(M,1,N) = 0.D+0
            WLW(M,1,N) = 0.D+0
            WGA(M,1,N) = 0.D+0
            WGN(M,1,N) = 0.D+0
            WGO(M,1,N) = 0.D+0
            WGW(M,1,N) = 0.D+0
            WNA(M,1,N) = 0.D+0
            WNN(M,1,N) = 0.D+0
            WNO(M,1,N) = 0.D+0
            WNW(M,1,N) = 0.D+0
            WDLA(M,1,N) = 0.D+0
            WDLN(M,1,N) = 0.D+0
            WDLO(M,1,N) = 0.D+0
            WDLW(M,1,N) = 0.D+0
            WDGA(M,1,N) = 0.D+0
            WDGN(M,1,N) = 0.D+0
            WDGO(M,1,N) = 0.D+0
            WDGW(M,1,N) = 0.D+0
            WDNA(M,1,N) = 0.D+0
            WDNO(M,1,N) = 0.D+0
            WDNN(M,1,N) = 0.D+0
            WDNW(M,1,N) = 0.D+0
            WQ(M,1,N) = 0.D+0
            WS(M,1,N) = 0.D+0
            WDS(M,1,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
          DO M = 1,ISVF
            VL(M,1,N) = 0.D+0
            VG(M,1,N) = 0.D+0
            VN(M,1,N) = 0.D+0
            VLA(M,1,N) = 0.D+0
            VLN(M,1,N) = 0.D+0
            VLO(M,1,N) = 0.D+0
            VLW(M,1,N) = 0.D+0
            VGA(M,1,N) = 0.D+0
            VGN(M,1,N) = 0.D+0
            VGO(M,1,N) = 0.D+0
            VGW(M,1,N) = 0.D+0
            VNA(M,1,N) = 0.D+0
            VNN(M,1,N) = 0.D+0
            VNO(M,1,N) = 0.D+0
            VNW(M,1,N) = 0.D+0
            VDLA(M,1,N) = 0.D+0
            VDLN(M,1,N) = 0.D+0
            VDLO(M,1,N) = 0.D+0
            VDLW(M,1,N) = 0.D+0
            VDGA(M,1,N) = 0.D+0
            VDGN(M,1,N) = 0.D+0
            VDGO(M,1,N) = 0.D+0
            VDGW(M,1,N) = 0.D+0
            VDNA(M,1,N) = 0.D+0
            VDNO(M,1,N) = 0.D+0
            VDNN(M,1,N) = 0.D+0
            VDNW(M,1,N) = 0.D+0
            VQ(M,1,N) = 0.D+0
            VS(M,1,N) = 0.D+0
            VDS(M,1,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
          DO M = 1,ISVF
            UL(M,1,N) = 0.D+0
            UG(M,1,N) = 0.D+0
            UN(M,1,N) = 0.D+0
            ULA(M,1,N) = 0.D+0
            ULN(M,1,N) = 0.D+0
            ULO(M,1,N) = 0.D+0
            ULW(M,1,N) = 0.D+0
            UGA(M,1,N) = 0.D+0
            UGN(M,1,N) = 0.D+0
            UGO(M,1,N) = 0.D+0
            UGW(M,1,N) = 0.D+0
            UNA(M,1,N) = 0.D+0
            UNN(M,1,N) = 0.D+0
            UNO(M,1,N) = 0.D+0
            UNW(M,1,N) = 0.D+0
            UDLA(M,1,N) = 0.D+0
            UDLN(M,1,N) = 0.D+0
            UDLO(M,1,N) = 0.D+0
            UDLW(M,1,N) = 0.D+0
            UDGA(M,1,N) = 0.D+0
            UDGN(M,1,N) = 0.D+0
            UDGO(M,1,N) = 0.D+0
            UDGW(M,1,N) = 0.D+0
            UDNA(M,1,N) = 0.D+0
            UDNO(M,1,N) = 0.D+0
            UDNN(M,1,N) = 0.D+0
            UDNW(M,1,N) = 0.D+0
            UQ(M,1,N) = 0.D+0
            US(M,1,N) = 0.D+0
            UDS(M,1,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.1 ) THEN
          DO M = 1,ISVF
            UL(M,2,N) = 0.D+0
            UG(M,2,N) = 0.D+0
            UN(M,2,N) = 0.D+0
            ULA(M,2,N) = 0.D+0
            ULN(M,2,N) = 0.D+0
            ULO(M,2,N) = 0.D+0
            ULW(M,2,N) = 0.D+0
            UGA(M,2,N) = 0.D+0
            UGN(M,2,N) = 0.D+0
            UGO(M,2,N) = 0.D+0
            UGW(M,2,N) = 0.D+0
            UNA(M,2,N) = 0.D+0
            UNN(M,2,N) = 0.D+0
            UNO(M,2,N) = 0.D+0
            UNW(M,2,N) = 0.D+0
            UDLA(M,2,N) = 0.D+0
            UDLN(M,2,N) = 0.D+0
            UDLO(M,2,N) = 0.D+0
            UDLW(M,2,N) = 0.D+0
            UDGA(M,2,N) = 0.D+0
            UDGN(M,2,N) = 0.D+0
            UDGO(M,2,N) = 0.D+0
            UDGW(M,2,N) = 0.D+0
            UDNA(M,2,N) = 0.D+0
            UDNO(M,2,N) = 0.D+0
            UDNN(M,2,N) = 0.D+0
            UDNW(M,2,N) = 0.D+0
            UQ(M,2,N) = 0.D+0
            US(M,2,N) = 0.D+0
            UDS(M,2,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.2 ) THEN
          DO M = 1,ISVF
            VL(M,2,N) = 0.D+0
            VG(M,2,N) = 0.D+0
            VN(M,2,N) = 0.D+0
            VLA(M,2,N) = 0.D+0
            VLN(M,2,N) = 0.D+0
            VLO(M,2,N) = 0.D+0
            VLW(M,2,N) = 0.D+0
            VGA(M,2,N) = 0.D+0
            VGN(M,2,N) = 0.D+0
            VGO(M,2,N) = 0.D+0
            VGW(M,2,N) = 0.D+0
            VNA(M,2,N) = 0.D+0
            VNN(M,2,N) = 0.D+0
            VNO(M,2,N) = 0.D+0
            VNW(M,2,N) = 0.D+0
            VDLA(M,2,N) = 0.D+0
            VDLN(M,2,N) = 0.D+0
            VDLO(M,2,N) = 0.D+0
            VDLW(M,2,N) = 0.D+0
            VDGA(M,2,N) = 0.D+0
            VDGN(M,2,N) = 0.D+0
            VDGO(M,2,N) = 0.D+0
            VDGW(M,2,N) = 0.D+0
            VDNA(M,2,N) = 0.D+0
            VDNO(M,2,N) = 0.D+0
            VDNN(M,2,N) = 0.D+0
            VDNW(M,2,N) = 0.D+0
            VQ(M,2,N) = 0.D+0
            VS(M,2,N) = 0.D+0
            VDS(M,2,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.3 ) THEN
          DO M = 1,ISVF
            WL(M,2,N) = 0.D+0
            WG(M,2,N) = 0.D+0
            WN(M,2,N) = 0.D+0
            WLA(M,2,N) = 0.D+0
            WLN(M,2,N) = 0.D+0
            WLO(M,2,N) = 0.D+0
            WLW(M,2,N) = 0.D+0
            WGA(M,2,N) = 0.D+0
            WGN(M,2,N) = 0.D+0
            WGO(M,2,N) = 0.D+0
            WGW(M,2,N) = 0.D+0
            WNA(M,2,N) = 0.D+0
            WNN(M,2,N) = 0.D+0
            WNO(M,2,N) = 0.D+0
            WNW(M,2,N) = 0.D+0
            WDLA(M,2,N) = 0.D+0
            WDLN(M,2,N) = 0.D+0
            WDLO(M,2,N) = 0.D+0
            WDLW(M,2,N) = 0.D+0
            WDGA(M,2,N) = 0.D+0
            WDGN(M,2,N) = 0.D+0
            WDGO(M,2,N) = 0.D+0
            WDGW(M,2,N) = 0.D+0
            WDNA(M,2,N) = 0.D+0
            WDNO(M,2,N) = 0.D+0
            WDNN(M,2,N) = 0.D+0
            WDNW(M,2,N) = 0.D+0
            WQ(M,2,N) = 0.D+0
            WS(M,2,N) = 0.D+0
            WDS(M,2,N) = 0.D+0
          ENDDO
        ENDIF
      ENDDO
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
!
!---  Assign local boundary condition variables  ---
!
        IF( IBCM(NB).EQ.1 ) THEN
          DO N = 1,LBCV
            BCX(N) = BC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,IBCM(NB)
            IF( TMZ.LE.BC(1,M,MB) ) THEN
             TDBC = (BC(1,M,MB)-BC(1,M-1,MB))
             DTBC = MIN( BC(1,M,MB)-TMZ,DT )
             TFBC = (TMZ-BC(1,M-1,MB))/TDBC
             DO N = 1,LBCV
               BCX(N) = BC(N,M-1,MB) + TFBC*(BC(N,M,MB)-BC(N,M-1,MB))
             ENDDO
!
!---         Energy boundary  ---
!
             IF( IBCT(1,NB).EQ.2 ) THEN
               BCX(2) = BCX(2)-5.D-1*DTBC*(BC(2,M,MB)-BC(2,M-1,MB))/TDBC
             ENDIF
!
!---         Flow boundary  ---
!
             IF( IBCT(2,NB).EQ.2 ) THEN
               BCX(3) = BCX(3)-5.D-1*DTBC*(BC(3,M,MB)-BC(3,M-1,MB))/TDBC
             ENDIF
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
        N = IBCN(NB)
!
!---    Bottom boundary  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
!
!---      Neumann flow boundary  ---
!
          IF( IBCT(2,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              WG(M,1,N) = BCX(3)*SGB(2,NB)
              WL(M,1,N) = BCX(3)*SLB(2,NB)
              WN(M,1,N) = BCX(3)*SNB(2,NB)
            ENDDO
            IF( ISLC(45).EQ.0 ) CALL DFFLAB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNB( N,NB )
            CALL DFFLWB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOB( N,NB )
            CALL DFFGWB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNB( N,NB )
            CALL DFFNWB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAB( N,NB )
!
!---      Aqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.21 .OR. IBCT(2,NB).EQ.27 ) THEN
            CALL DRCVLB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNB( N,NB )
            CALL DFFLWB( N,NB )
!
!---      Gas-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.31 .OR. IBCT(2,NB).EQ.37 ) THEN
            CALL DRCVGB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOB( N,NB )
            CALL DFFGWB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNB( N,NB )
!
!---      Nonaqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.41 .OR. IBCT(2,NB).EQ.47 ) THEN
            CALL DRCVNB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNB( N,NB )
            CALL DFFNWB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAB( N,NB )
!
!---      Non zero-flux flow boundary  ---
!
          ELSEIF( IBCT(2,NB).NE.3 ) THEN
            CALL DRCVLB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNB( N,NB )
            CALL DFFLWB( N,NB )
            CALL DRCVGB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOB( N,NB )
            CALL DFFGWB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNB( N,NB )
            CALL DRCVNB( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOB( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNB( N,NB )
            CALL DFFNWB( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAB( N,NB )
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Salt not zero flux boundary  ---
!
            IF( IBCT(3,NB).NE.3 ) THEN
              CALL DFFLSB( N,NB )
            ENDIF
          ENDIF
!
!---      Energy Neumann  ---
!
          IF( IBCT(1,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              WQ(M,1,N) = BCX(2)
            ENDDO
!
!---      Energy outflow, inflow, or inflow-outflow  ---
!
          ELSEIF( IBCT(1,NB).EQ.7 .OR. IBCT(1,NB).EQ.13
     &      .OR. IBCT(1,NB).EQ.14  ) THEN
            CALL THLB_HYDT_KE( N,NB )
            CALL THGB_HYDT_KE( N,NB )
            CALL THNB_HYDT_KE( N,NB )
!
!---      Energy zero flux  ---
!
          ELSEIF( IBCT(1,NB).NE.3 ) THEN
            CALL THDB_HYDT_KE( N,NB )
            CALL THLB_HYDT_KE( N,NB )
            CALL THGB_HYDT_KE( N,NB )
            CALL THNB_HYDT_KE( N,NB )
          ENDIF
!
!---    South boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
!
!---      Neumann flow boundary  ---
!
          IF( IBCT(2,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              VG(M,1,N) = BCX(3)*SGB(2,NB)
              VL(M,1,N) = BCX(3)*SLB(2,NB)
              VN(M,1,N) = BCX(3)*SNB(2,NB)
            ENDDO
            IF( ISLC(45).EQ.0 ) CALL DFFLAS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNS( N,NB )
            CALL DFFLWS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOS( N,NB )
            CALL DFFGWS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNS( N,NB )
            CALL DFFNWS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAS( N,NB )
!
!---      Aqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.21 .OR. IBCT(2,NB).EQ.27 ) THEN
            CALL DRCVLS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNS( N,NB )
            CALL DFFLWS( N,NB )
!
!---      Gas-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.31 .OR. IBCT(2,NB).EQ.37 ) THEN
            CALL DRCVGS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOS( N,NB )
            CALL DFFGWS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNS( N,NB )
!
!---      Nonaqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.41 .OR. IBCT(2,NB).EQ.47 ) THEN
            CALL DRCVNS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNS( N,NB )
            CALL DFFNWS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAS( N,NB )
!
!---      Non zero-flux flow boundary  ---
!
          ELSEIF( IBCT(2,NB).NE.3 ) THEN
            CALL DRCVLS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNS( N,NB )
            CALL DFFLWS( N,NB )
            CALL DRCVGS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOS( N,NB )
            CALL DFFGWS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNS( N,NB )
            CALL DRCVNS( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOS( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNS( N,NB )
            CALL DFFNWS( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAS( N,NB )
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Salt not zero flux boundary  ---
!
            IF( IBCT(3,NB).NE.3 ) THEN
              CALL DFFLSS( N,NB )
            ENDIF
          ENDIF
!
!---      Energy Neumann  ---
!
          IF( IBCT(1,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              VQ(M,1,N) = BCX(2)
            ENDDO
!
!---      Energy outflow, inflow, or inflow-outflow  ---
!
          ELSEIF( IBCT(1,NB).EQ.7 .OR. IBCT(1,NB).EQ.13
     &      .OR. IBCT(1,NB).EQ.14  ) THEN
            CALL THLS_HYDT_KE( N,NB )
            CALL THGS_HYDT_KE( N,NB )
            CALL THNS_HYDT_KE( N,NB )
!
!---      Energy not zero flux  ---
!
          ELSEIF( IBCT(1,NB).NE.3 ) THEN
            CALL THDS_HYDT_KE( N,NB )
            CALL THLS_HYDT_KE( N,NB )
            CALL THGS_HYDT_KE( N,NB )
            CALL THNS_HYDT_KE( N,NB )
          ENDIF
!
!---    West boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
!
!---     Neumann flow boundary  ---
!
          IF( IBCT(2,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              UG(M,1,N) = BCX(3)*SGB(2,NB)
              UL(M,1,N) = BCX(3)*SLB(2,NB)
              UN(M,1,N) = BCX(3)*SNB(2,NB)
            ENDDO
            IF( ISLC(45).EQ.0 ) CALL DFFLAW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNW( N,NB )
            CALL DFFLWW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOW( N,NB )
            CALL DFFGWW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNW( N,NB )
            CALL DFFNWW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAW( N,NB )
!
!---      Aqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.21 .OR. IBCT(2,NB).EQ.27 ) THEN
            CALL DRCVLW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNW( N,NB )
            CALL DFFLWW( N,NB )
!
!---      Gas-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.31 .OR. IBCT(2,NB).EQ.37 ) THEN
            CALL DRCVGW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOW( N,NB )
            CALL DFFGWW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNW( N,NB )
!
!---      Nonaqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.41 .OR. IBCT(2,NB).EQ.47 ) THEN
            CALL DRCVNW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNW( N,NB )
            CALL DFFNWW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAW( N,NB )
!
!---      Non zero-flux flow boundary  ---
!
          ELSEIF( IBCT(2,NB).NE.3 ) THEN
            CALL DRCVLW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNW( N,NB )
            CALL DFFLWW( N,NB )
            CALL DRCVGW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOW( N,NB )
            CALL DFFGWW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNW( N,NB )
            CALL DRCVNW( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOW( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNW( N,NB )
            CALL DFFNWW( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAW( N,NB )
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Salt not zero flux boundary  ---
!
            IF( IBCT(3,NB).NE.3 ) THEN
              CALL DFFLSW( N,NB )
            ENDIF
          ENDIF
!
!---      Energy Neumann  ---
!
          IF( IBCT(1,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              UQ(M,1,N) = BCX(2)
            ENDDO
!
!---      Energy outflow, inflow, or inflow-outflow  ---
!
          ELSEIF( IBCT(1,NB).EQ.7 .OR. IBCT(1,NB).EQ.13
     &      .OR. IBCT(1,NB).EQ.14  ) THEN
            CALL THLW_HYDT_KE( N,NB )
            CALL THGW_HYDT_KE( N,NB )
            CALL THNW_HYDT_KE( N,NB )
!
!---      Energy not zero flux  ---
!
          ELSEIF( IBCT(1,NB).NE.3 ) THEN
            CALL THDW_HYDT_KE( N,NB )
            CALL THLW_HYDT_KE( N,NB )
            CALL THGW_HYDT_KE( N,NB )
            CALL THNW_HYDT_KE( N,NB )
          ENDIF
!
!---    East boundary  ---
!
        ELSEIF( IBCD(NB).EQ.1 ) THEN
!
!---      Neumann flow boundary  ---
!
          IF( IBCT(2,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              UG(M,2,N) = BCX(3)*SGB(2,NB)
              UL(M,2,N) = BCX(3)*SLB(2,NB)
              UN(M,2,N) = BCX(3)*SNB(2,NB)
            ENDDO
            IF( ISLC(45).EQ.0 ) CALL DFFLAE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNE( N,NB )
            CALL DFFLWE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOE( N,NB )
            CALL DFFGWE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNE( N,NB )
            CALL DFFNWE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAE( N,NB )
!
!---      Aqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.21 .OR. IBCT(2,NB).EQ.27 ) THEN
            CALL DRCVLE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNE( N,NB )
            CALL DFFLWE( N,NB )
!
!---      Gas-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.31 .OR. IBCT(2,NB).EQ.37 ) THEN
            CALL DRCVGE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOE( N,NB )
            CALL DFFGWE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNE( N,NB )
!
!---      Nonaqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.41 .OR. IBCT(2,NB).EQ.47 ) THEN
            CALL DRCVNE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNE( N,NB )
            CALL DFFNWE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAE( N,NB )
!
!---      Non zero-flux flow boundary  ---
!
          ELSEIF( IBCT(2,NB).NE.3 ) THEN
            CALL DRCVLE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNE( N,NB )
            CALL DFFLWE( N,NB )
            CALL DRCVGE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOE( N,NB )
            CALL DFFGWE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNE( N,NB )
            CALL DRCVNE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNE( N,NB )
            CALL DFFNWE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAE( N,NB )
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Salt not zero flux boundary  ---
!
            IF( IBCT(3,NB).NE.3 ) THEN
              CALL DFFLSE( N,NB )
            ENDIF
          ENDIF
!
!---      Energy Neumann  ---
!
          IF( IBCT(1,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              UQ(M,2,N) = BCX(2)
            ENDDO
!
!---      Energy outflow, inflow, or inflow-outflow  ---
!
          ELSEIF( IBCT(1,NB).EQ.7 .OR. IBCT(1,NB).EQ.13
     &       .OR. IBCT(1,NB).EQ.14  ) THEN
            CALL THLE_HYDT_KE( N,NB )
            CALL THGE_HYDT_KE( N,NB )
            CALL THNE_HYDT_KE( N,NB )
!
!---      Energy not zero flux  ---
!
          ELSEIF( IBCT(1,NB).NE.3 ) THEN
            CALL THDE_HYDT_KE( N,NB )
            CALL THLE_HYDT_KE( N,NB )
            CALL THGE_HYDT_KE( N,NB )
            CALL THNE_HYDT_KE( N,NB )
          ENDIF
!
!---    North boundary
!
        ELSEIF( IBCD(NB).EQ.2 ) THEN
!
!---      Neumann flow boundary  ---
!
          IF( IBCT(2,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              VG(M,2,N) = BCX(3)*SGB(2,NB)
              VL(M,2,N) = BCX(3)*SLB(2,NB)
              VN(M,2,N) = BCX(3)*SNB(2,NB)
            ENDDO
            IF( ISLC(45).EQ.0 ) CALL DFFLAN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLON( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNN( N,NB )
            CALL DFFLWN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGON( N,NB )
            CALL DFFGWN( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNON( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNN( N,NB )
            CALL DFFNWN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAN( N,NB )
!
!---      Aqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.21 .OR. IBCT(2,NB).EQ.27 ) THEN
            CALL DRCVLN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLON( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNN( N,NB )
            CALL DFFLWN( N,NB )
!
!---      Gas-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.31 .OR. IBCT(2,NB).EQ.37 ) THEN
            CALL DRCVGN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGON( N,NB )
            CALL DFFGWN( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNN( N,NB )
!
!---      Nonaqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.41 .OR. IBCT(2,NB).EQ.47 ) THEN
            CALL DRCVNN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNON( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNN( N,NB )
            CALL DFFNWN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAN( N,NB )
!
!---      Non zero-flux flow boundary  ---
!
          ELSEIF( IBCT(2,NB).NE.3 ) THEN
            CALL DRCVLN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLON( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNN( N,NB )
            CALL DFFLWN( N,NB )
            CALL DRCVGN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGON( N,NB )
            CALL DFFGWN( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNN( N,NB )
            CALL DRCVNN( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNON( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNN( N,NB )
            CALL DFFNWN( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAN( N,NB )
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Salt not zero flux boundary  ---
!
            IF( IBCT(3,NB).NE.3 ) THEN
              CALL DFFLSN( N,NB )
            ENDIF
          ENDIF
!
!---      Energy Neumann  ---
!
          IF( IBCT(1,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              VQ(M,2,N) = BCX(2)
            ENDDO
!
!---      Energy outflow, inflow, or inflow-outflow  ---
!
          ELSEIF( IBCT(1,NB).EQ.7 .OR. IBCT(1,NB).EQ.13
     &      .OR. IBCT(1,NB).EQ.14  ) THEN
            CALL THLN_HYDT_KE( N,NB )
            CALL THGN_HYDT_KE( N,NB )
            CALL THNN_HYDT_KE( N,NB )
!
!---      Energy not zero flux  ---
!
          ELSEIF( IBCT(1,NB).NE.3 ) THEN
            CALL THDN_HYDT_KE( N,NB )
            CALL THLN_HYDT_KE( N,NB )
            CALL THGN_HYDT_KE( N,NB )
            CALL THNN_HYDT_KE( N,NB )
          ENDIF
!
!---    Top boundary  ---
!
        ELSEIF( IBCD(NB).EQ.3 ) THEN
!
!---      Neumann flow boundary  ---
!
          IF( IBCT(2,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              WG(M,2,N) = BCX(3)*SGB(2,NB)
              WL(M,2,N) = BCX(3)*SLB(2,NB)
              WN(M,2,N) = BCX(3)*SNB(2,NB)
            ENDDO
            IF( ISLC(45).EQ.0 ) CALL DFFLAT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNT( N,NB )
            CALL DFFLWT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOT( N,NB )
            CALL DFFGWT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNT( N,NB )
            CALL DFFNWT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAT( N,NB )
!
!---      Aqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.21 .OR. IBCT(2,NB).EQ.27 ) THEN
            CALL DRCVLT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNT( N,NB )
            CALL DFFLWT( N,NB )
!
!---      Gas-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.31 .OR. IBCT(2,NB).EQ.37 ) THEN
            CALL DRCVGT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOT( N,NB )
            CALL DFFGWT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNT( N,NB )
!
!---      Nonaqueous-only Dirichlet boundary  ---
!
          ELSEIF( IBCT(2,NB).EQ.41 .OR. IBCT(2,NB).EQ.47 ) THEN
            CALL DRCVNT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNT( N,NB )
            CALL DFFNWT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAT( N,NB )
!
!---      Non zero-flux flow boundary  ---
!
          ELSEIF( IBCT(2,NB).NE.3 ) THEN
            CALL DRCVLT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFLAT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFLOT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFLNT( N,NB )
            CALL DFFLWT( N,NB )
            CALL DRCVGT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFGAT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFGOT( N,NB )
            CALL DFFGWT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFGNT( N,NB )
            CALL DRCVNT( N,NB )
            IF( ISLC(64).EQ.0 ) CALL DFFNOT( N,NB )
            IF( ISLC(65).EQ.0 ) CALL DFFNNT( N,NB )
            CALL DFFNWT( N,NB )
            IF( ISLC(45).EQ.0 ) CALL DFFNAT( N,NB )
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Salt not zero flux boundary  ---
!
            IF( IBCT(3,NB).NE.3 ) THEN
              CALL DFFLST( N,NB )
            ENDIF
          ENDIF
!
!---      Energy Neumann  ---
!
          IF( IBCT(1,NB).EQ.2 ) THEN
            DO M = 1,ISVF
              WQ(M,2,N) = BCX(2)
            ENDDO
!
!---      Energy outflow, inflow, or inflow-outflow  ---
!
          ELSEIF( IBCT(1,NB).EQ.7 .OR. IBCT(1,NB).EQ.13
     &      .OR. IBCT(1,NB).EQ.14  ) THEN
            CALL THLT_HYDT_KE( N,NB )
            CALL THGT_HYDT_KE( N,NB )
            CALL THNT_HYDT_KE( N,NB )
!
!---      Energy not zero flux  ---
!
          ELSEIF( IBCT(1,NB).NE.3 ) THEN
            CALL THDT_HYDT_KE( N,NB )
            CALL THLT_HYDT_KE( N,NB )
            CALL THGT_HYDT_KE( N,NB )
            CALL THNT_HYDT_KE( N,NB )
          ENDIF
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCF_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCJ_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Modify the Jacobian matrix for boundary conditions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 17 August 2021
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE NAPL
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
      USE CONST
      USE BCVP
      USE BCVH
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCJ_HYDT_KE'
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
        IF( IBCM(NB).GT.1 .AND. TMZ.GT.BC(1,IBCM(NB),MB) ) CYCLE
        N = IBCN(NB)
        N_DB = -NB
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    Bottom boundary  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
!
!---      Flow  ---
!
          IF( IBCT(2,NB).NE.3 ) THEN
             CALL JCBLWB_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBLAB_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBLOB_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBLNB_HYDT_KE( N,NB )
            CALL JCBGWB_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBGAB_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBGOB_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBGNB_HYDT_KE( N,NB )
            CALL JCBNWB_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBNAB_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBNOB_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBNNB_HYDT_KE( N,NB )
          ENDIF
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            CALL JCBTB_HYDT_KE( N,NB )
          ENDIF
!
!---      Salt  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            IF( IBCT(3,NB).NE.3 ) CALL JCBSB_HYDT_KE( N,NB )
          ENDIF
!
!---    South boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
!
!---      Flow  ---
!
          IF( IBCT(2,NB).NE.3 ) THEN
            CALL JCBLWS_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBLAS_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBLOS_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBLNS_HYDT_KE( N,NB )
            CALL JCBGWS_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBGAS_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBGOS_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBGNS_HYDT_KE( N,NB )
            CALL JCBNWS_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBNAS_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBNOS_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBNNS_HYDT_KE( N,NB )
          ENDIF
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            CALL JCBTS_HYDT_KE( N,NB )
          ENDIF
!
!---      Salt  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            IF( IBCT(3,NB).NE.3 ) CALL JCBSS_HYDT_KE( N,NB )
          ENDIF
!
!---    West boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
!
!---      Flow  ---
!
          IF( IBCT(2,NB).NE.3 ) THEN
            CALL JCBLWW_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBLAW_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBLOW_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBLNW_HYDT_KE( N,NB )
            CALL JCBGWW_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBGAW_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBGOW_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBGNW_HYDT_KE( N,NB )
            CALL JCBNWW_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBNAW_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBNOW_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBNNW_HYDT_KE( N,NB )
          ENDIF
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
             CALL JCBTW_HYDT_KE( N,NB )
          ENDIF
!
!---      Salt  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            IF( IBCT(3,NB).NE.3 ) CALL JCBSW_HYDT_KE( N,NB )
          ENDIF
!
!---    East boundary  ---
!
        ELSEIF( IBCD(NB).EQ.1 ) THEN
!
!---      Flow  ---
!
          IF( IBCT(2,NB).NE.3 ) THEN
            CALL JCBLWE_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBLAE_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBLOE_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBLNE_HYDT_KE( N,NB )
            CALL JCBGWE_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBGAE_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBGOE_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBGNE_HYDT_KE( N,NB )
            CALL JCBNWE_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBNAE_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBNOE_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBNNE_HYDT_KE( N,NB )
          ENDIF
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            CALL JCBTE_HYDT_KE( N,NB )
          ENDIF
!
!---      Salt  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            IF( IBCT(3,NB).NE.3 ) CALL JCBSE_HYDT_KE( N,NB )
          ENDIF
!
!---    North boundary
!
        ELSEIF( IBCD(NB).EQ.2 ) THEN
!
!---      Flow  ---
!
          IF( IBCT(2,NB).NE.3 ) THEN
            CALL JCBLWN_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBLAN_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBLON_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBLNN_HYDT_KE( N,NB )
            CALL JCBGWN_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBGAN_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBGON_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBGNN_HYDT_KE( N,NB )
            CALL JCBNWN_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBNAN_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBNON_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBNNN_HYDT_KE( N,NB )
         ENDIF
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            CALL JCBTN_HYDT_KE( N,NB )
          ENDIF
!
!---      Salt  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            IF( IBCT(3,NB).NE.3 ) CALL JCBSN_HYDT_KE( N,NB )
          ENDIF
!
!---    Top boundary  ---
!
        ELSEIF( IBCD(NB).EQ.3 ) THEN
!
!---      Flow  ---
!
          IF( IBCT(2,NB).NE.3 ) THEN
            CALL JCBLWT_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBLAT_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBLOT_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBLNT_HYDT_KE( N,NB )
            CALL JCBGWT_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBGAT_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBGOT_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBGNT_HYDT_KE( N,NB )
            CALL JCBNWT_HYDT_KE( N,NB )
            IF( ISLC(45).EQ.0 ) CALL JCBNAT_HYDT_KE( N,NB )
            IF( ISLC(64).EQ.0 ) CALL JCBNOT_HYDT_KE( N,NB )
            IF( ISLC(65).EQ.0 ) CALL JCBNNT_HYDT_KE( N,NB )
         ENDIF
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            CALL JCBTT_HYDT_KE( N,NB )
          ENDIF
!
!---      Salt  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            IF( IBCT(3,NB).NE.3 ) CALL JCBST_HYDT_KE( N,NB )
          ENDIF
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCJ_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCP_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute saturation, relative permeability and thermodynamic
!     properties for boundary surfaces.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE NAPL
      USE GRID
      USE FDVP
      USE FDVH
      USE CONST
      USE BCVP
      USE BCVH
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 BCX(LBCV)
      REAL*8 PHIX(LHF_HT+1,LHF_HT+1)
      REAL*8 ZMCX(LHF_HT)
      REAL*8 HIDX(LHF_HT),HRESX(LHF_HT),XMGX(LHF_HT),XMNX(LHF_HT)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCP_HYDT_KE'
!
!---  Assign values for initial condition type boundary conditions  ---
!
      IF( NSTEP-NRST.LE.1 .AND. NITER.LE.1 ) THEN
        DO NB = 1,NBC(ID+1)
          N = IBCN(NB)
          IF( IBCT(2,NB).EQ.12 .OR. IBCT(2,NB).EQ.14 .OR.
     &      IBCT(2,NB).EQ.15 ) THEN
            IF( IBCD(NB).EQ.-3 ) THEN
              DB = DZGP(1,N)
              GB = GRVZ(1,N)*DB
            ELSEIF( IBCD(NB).EQ.-2 ) THEN
              DB = DYGP(1,N)*RP(N)
              GB = GRVY(1,N)*DB
            ELSEIF( IBCD(NB).EQ.-1 ) THEN
              DB = DXGP(1,N)
              GB = GRVX(1,N)*DB
            ELSEIF( IBCD(NB).EQ.1 ) THEN
              DB = -DXGP(2,N)
              GB = GRVX(2,N)*DB
            ELSEIF( IBCD(NB).EQ.2 ) THEN
              DB = -DYGP(2,N)*RP(N)
              GB = GRVY(2,N)*DB
            ELSEIF( IBCD(NB).EQ.3 ) THEN
              DB = -DZGP(2,N)
              GB = GRVZ(2,N)*DB
            ENDIF
          ENDIF
          IF( IBCT(1,NB).EQ.12 ) TB(1,NB) = T(2,N)
          IF( IBCT(2,NB).EQ.12 .OR. IBCT(2,NB).EQ.14 .OR.
     &      IBCT(2,NB).EQ.15 ) THEN
            IF( SG(2,N).GT.EPSL ) THEN
              PGB(1,NB) = PG(2,N) + RHOG(2,N)*GB
              IF( SN(2,N).GT.EPSL ) THEN
                PNB(1,NB) = PN(2,N) + RHON(2,N)*GB
                IF( SL(2,N).GT.EPSL ) THEN
                  PLB(1,NB) = PL(2,N) + RHOL(2,N)*GB
                ELSE
                  PLB(1,NB) = PNB(1,NB) + PL(2,N) - PN(2,N)
                ENDIF
              ELSE
                IF( SL(2,N).GT.EPSL ) THEN
                  PLB(1,NB) = PL(2,N) + RHOL(2,N)*GB
                ELSE
                  PLB(1,NB) = PGB(1,NB) + PL(2,N) - PG(2,N)
                  PNB(1,NB) = PGB(1,NB) + PN(2,N) - PG(2,N)
                ENDIF
              ENDIF
            ELSE
              IF( SN(2,N).GT.EPSL ) THEN
                PNB(1,NB) = PN(2,N) + RHON(2,N)*GB
                PGB(1,NB) = PNB(1,NB) + PG(2,N) - PN(2,N)
                IF( SL(2,N).GT.EPSL ) THEN
                  PLB(1,NB) = PL(2,N) + RHOL(2,N)*GB
                ELSE
                  PLB(1,NB) = PNB(1,NB) + PL(2,N) - PN(2,N)
                ENDIF
              ELSE
                PLB(1,NB) = PL(2,N) + RHOL(2,N)*GB
                PNB(1,NB) = PLB(1,NB) + PN(2,N) - PL(2,N)
                PGB(1,NB) = PLB(1,NB) + PG(2,N) - PL(2,N)
              ENDIF
            ENDIF
            PSOB(1,NB) = MAX( PGB(1,NB),PLB(1,NB),PNB(1,NB) )
            SLB(1,NB) = SL(2,N)
            SHB(1,NB) = SH(2,N)
            SGB(1,NB) = SG(2,N)
            SNB(1,NB) = SN(2,N)
            XMLAB(1,NB) = ZMCA(2,N)
            XMLOB(1,NB) = ZMCO(2,N)
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 )  THEN
            IF( IBCT(3,NB).EQ.12 ) YLSB(1,NB) = YLS(2,N)
          ENDIF
        ENDDO
      ENDIF
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
!
!---  Assign local boundary condition variables  ---
!
        IF( IBCM(NB).EQ.1 ) THEN
          DO N = 1,LBCV
            BCX(N) = BC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,IBCM(NB)
            IF( TMZ.LE.BC(1,M,MB) ) THEN
             TDBC = (BC(1,M,MB)-BC(1,M-1,MB))
             DTBC = MIN( BC(1,M,MB)-TMZ,DT )
             TFBC = (TMZ-BC(1,M-1,MB))/TDBC
             DO N = 1,LBCV
               BCX(N) = BC(N,M-1,MB) + TFBC*(BC(N,M,MB)-BC(N,M-1,MB))
             ENDDO
!
!---         Energy boundary  ---
!
             IF( IBCT(1,NB).EQ.2 ) THEN
               BCX(2) = BCX(2)-5.D-1*DTBC*(BC(2,M,MB)-BC(2,M-1,MB))/TDBC
             ENDIF
!
!---         Flow boundary  ---
!
             IF( IBCT(2,NB).EQ.2 ) THEN
               BCX(3) = BCX(3)-5.D-1*DTBC*(BC(3,M,MB)-BC(3,M-1,MB))/TDBC
             ENDIF
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
!
!---    Initial condition boundary condition  ---
!
        IF( IBCT(1,NB).EQ.12 ) BCX(2) = TB(1,NB)
        IF( IBCT(2,NB).EQ.12 .OR. IBCT(2,NB).EQ.14 .OR.
     &      IBCT(2,NB).EQ.15 ) THEN
          BCX(3) = PSOB(1,NB)
          BCX(4) = SLB(1,NB)
          BCX(5) = SHB(1,NB)
          BCX(6) = SIB(1,NB)
          BCX(10) = XMLAB(1,NB)
          BCX(11) = XMLOB(1,NB)
          BCX(12) = 1.D+0
          BCX(8) = 1.D+0
        ENDIF
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 )  THEN
          IF( IBCT(3,NB).EQ.12 ) BCX(6) = YLSB(1,NB)
        ENDIF
        N = IBCN(NB)
        IBD = ABS(IBCD(NB))
!
!---    Boundary Direction  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
          DB = 0.5D+0*DZGF(N)
          GB = GRVZ(1,N)*DB
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
          DB = 0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(1,N)*DB
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
          DB = 0.5D+0*DXGF(N)
          GB = GRVX(1,N)*DB
        ELSEIF( IBCD(NB).EQ.1 ) THEN
          DB = -0.5D+0*DXGF(N)
          GB = GRVX(2,N)*DB
        ELSEIF( IBCD(NB).EQ.2 ) THEN
          DB = -0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(2,N)*DB
        ELSEIF( IBCD(NB).EQ.3 ) THEN
          DB = -0.5D+0*DZGF(N)
          GB = GRVZ(2,N)*DB
        ENDIF
!
!---    Loop over secondary variable indices  ---
!
        DO M = 2,ISVC+2
!
!---      Energy: Dirichlet, initial conditions, inflow, outflow,
!         or inflow-outflow  ---
!
          IF( IBCT(1,NB).EQ.1 .OR. IBCT(1,NB).EQ.12 .OR. 
     &      IBCT(1,NB).EQ.13 .OR. IBCT(1,NB).EQ.14 ) THEN
            TB(M,NB) = BCX(2)
!
!---      Energy: Neumann  ---
!
          ELSEIF( IBCT(1,NB).EQ.2 ) THEN
            TB(M,NB) = T(M,N)
!
!---      Energy: zero flux  ---
!
          ELSEIF( IBCT(1,NB).EQ.3 ) THEN
            TB(M,NB) = T(M,N)
!
!---      Energy: outflow  ---
!
          ELSEIF( IBCT(1,NB).EQ.7 ) THEN
            TB(M,NB) = T(M,N)
          ENDIF
!
!---      Flow: Dirichlet or Dirichlet inflow  ---
!
          IF( MOD(IBCT(2,NB),10).EQ.1.OR.MOD(IBCT(2,NB),10).EQ.7 ) THEN
            PSOB(M,NB) = BCX(3)
            SLB(M,NB) = BCX(4)
            SHB(M,NB) = 0.D+0
            SIB(M,NB) = 0.D+0
            ZMCX(1) = BCX(10)
            ZMCX(2) = BCX(11)
            ZMCX(3) = MAX( 1.D+0-ZMCX(1)-ZMCX(2),0.D+0 )
            WSGWX = BCX(12)
            WSLCX = BCX(8)
!
!---      Flow: initial conditions or initial conditions inflow  ---
!
          ELSEIF( IBCT(2,NB).EQ.12 .OR. IBCT(2,NB).EQ.14 ) THEN
            PSOB(M,NB) = BCX(3)
            SLB(M,NB) = BCX(4)
            SHB(M,NB) = BCX(5)
            SIB(M,NB) = BCX(6)
            ZMCX(1) = BCX(10)
            ZMCX(2) = BCX(11)
            ZMCX(3) = MAX( 1.D+0-ZMCX(1)-ZMCX(2),0.D+0 )
            WSGWX = BCX(12)
            WSLCX = BCX(8)
!
!---      Flow: hydrostatic, hydrostatic inflow  ---
!
          ELSEIF( IBCT(2,NB).EQ.28 .OR. IBCT(2,NB).EQ.29 ) THEN
            PSOB(M,NB) = BCX(3) + BCX(5)*(ZPBC(NB)-BCX(6))
            SLB(M,NB) = BCX(4)
            SHB(M,NB) = 0.D+0
            SIB(M,NB) = 0.D+0
            ZMCX(1) = BCX(10)
            ZMCX(2) = BCX(11)
            ZMCX(3) = MAX( 1.D+0-ZMCX(1)-ZMCX(2),0.D+0 )
            WSGWX = BCX(12)
            WSLCX = BCX(8)
!
!---      Flow: initial condition outflow, Dirichlet outflow  ---
!
          ELSEIF( IBCT(2,NB).EQ.15 .OR. IBCT(2,NB).EQ.26 ) THEN
            PSOB(M,NB) = BCX(3)
            SLB(M,NB) = SL(M,N)
            SGB(M,NB) = SG(M,N)
            SNB(M,NB) = SN(M,N)
            SHB(M,NB) = SH(M,N)
            SIB(M,NB) = SI(M,N)
            ZMCX(1) = ZMCA(M,N)
            ZMCX(2) = ZMCO(M,N)
            ZMCX(3) = ZMCN(M,N)
            WSGWX = 1.D+0
            WSLCX = 1.D+0
!
!---      Flow: hydrostatic outflow  ---
!
          ELSEIF( IBCT(2,NB).EQ.30 ) THEN
            PSOB(M,NB) = BCX(3) + BCX(5)*(ZPBC(NB)-BCX(6))
            SLB(M,NB) = SL(M,N)
            SGB(M,NB) = SG(M,N)
            SNB(M,NB) = SN(M,N)
            SHB(M,NB) = SH(M,N)
            SIB(M,NB) = SI(M,N)
            ZMCX(1) = ZMCA(M,N)
            ZMCX(2) = ZMCO(M,N)
            ZMCX(3) = ZMCN(M,N)
            WSGWX = 1.D+0
            WSLCX = 1.D+0
!
!---      Flow: Neumann  ---
!
          ELSEIF( IBCT(2,NB).EQ.2 ) THEN
            PSOB(M,NB) = PSO(M,N)
            SLB(M,NB) = BCX(4)
            SHB(M,NB) = 0.D+0
            SIB(M,NB) = 0.D+0
            ZMCX(1) = BCX(10)
            ZMCX(2) = BCX(11)
            ZMCX(3) = MAX( 1.D+0-ZMCX(1)-ZMCX(2),0.D+0 )
            WSGWX = BCX(12)
            WSLCX = BCX(8)
!
!---      Flow: zero flux ---
!
          ELSEIF( IBCT(2,NB).EQ.3 ) THEN
            PGBX = PG(M,N)
            PLBX = PL(M,N)
            PNBX = PN(M,N)
            IF( SG(M,N).GT.EPSL ) THEN
              PGBX = PG(M,N) + RHOG(M,N)*GB
              IF( SN(M,N).GT.EPSL ) THEN
                PNBX = PN(M,N) + RHON(M,N)*GB
                IF( SL(M,N).GT.EPSL ) THEN
                  PLBX = PL(M,N) + RHOL(M,N)*GB
                ELSE
                  PLBX = PNBX + PL(M,N) - PN(M,N)
                ENDIF
              ELSE
                IF( SL(M,N).GT.EPSL ) THEN
                  PLBX = PL(M,N) + RHOL(M,N)*GB
                ELSE
                  PLBX = PGBX + PL(M,N) - PG(M,N)
                  PNBX = PGBX + PN(M,N) - PG(M,N)
                ENDIF
              ENDIF
            ELSE
              IF( SN(M,N).GT.EPSL ) THEN
                PNBX = PN(M,N) + RHON(M,N)*GB
                PGBX = PNBX + PG(M,N) - PN(M,N)
                IF( SL(M,N).GT.EPSL ) THEN
                  PLBX = PL(M,N) + RHOL(M,N)*GB
                ELSE
                  PLBX = PNBX + PL(M,N) - PN(M,N)
                ENDIF
              ELSE
                PLBX = PL(M,N) + RHOL(M,N)*GB
                PNBX = PLBX + PN(M,N) - PL(M,N)
                PGBX = PLBX + PG(M,N) - PL(M,N)
              ENDIF
            ENDIF
            PSOB(M,NB) = MAX( PGBX,PLBX,PNBX )
            SLB(M,NB) = SL(M,N)
            SGB(M,NB) = SG(M,N)
            SNB(M,NB) = SN(M,N)
            SHB(M,NB) = SH(M,N)
            SIB(M,NB) = SI(M,N)
            ZMCX(1) = ZMCA(M,N)
            ZMCX(2) = ZMCO(M,N)
            ZMCX(3) = MAX( 1.D+0-ZMCX(1)-ZMCX(2),0.D+0 )
            WSGWX = 1.D+0
            WSLCX = 1.D+0
          ENDIF
!
!---      Salt concentration  ---
!
          CALL SOL_LS( TB(M,NB),XLSMX )
          IF( ISLC(32).EQ.0 ) THEN
            IF( IBCT(3,NB).EQ.34 .OR. IBCT(3,NB).EQ.35 ) THEN
              YLSB(M,NB) = BCX(6)*XLSMX
              XLSB(M,NB) = MIN( YLSB(M,NB),XLSMX )
            ELSEIF( IBCT(3,NB).EQ.36 .OR. IBCT(3,NB).EQ.37 ) THEN
              YLSB(M,NB) = BCX(6)
              XLSB(M,NB) = MIN( YLSB(M,NB),XLSMX )
            ENDIF
          ELSE
            YLSB(M,NB) = 0.D+0
            XLSB(M,NB) = MIN( YLSB(M,NB),XLSMX )
          ENDIF
!
!---      Phase equilibria for boundary surface  ---
!
          CALL FLH_BC( PGB(M,NB),PLB(M,NB),PNB(M,NB),PPELX,PPEUX,PSBX,
     &      PSOB(M,NB),PVAB(M,NB),PVNB(M,NB),PVOB(M,NB),PVWB(M,NB),
     &      RHOGB(M,NB),RHONB(M,NB),RKGB(M,NB),RKLB(M,NB),
     &      RKNB(M,NB),SGB(M,NB),SHB(M,NB),SIB(M,NB),SLB(M,NB),
     &      SNB(M,NB),TB(M,NB),TCRX,TCTX,WSGWX,WSLCX,XGAB(M,NB),
     &      XGNB(M,NB),XGOB(M,NB),XGWB(M,NB),XNAB(M,NB),XNNB(M,NB),
     &      XNOB(M,NB),XNWB(M,NB),XMLAB(M,NB),XMLNB(M,NB),XMLOB(M,NB),
     &      XLSB(M,NB),YLSB(M,NB),YMGAX,YMGNX,YMGOX,YMNAX,YMNNX,YMNOX,
     &      ZMCX(1),ZMCX(2),ZMCX(3),N,NP_HT )
!
!---      Absolute pressures  ---
!
          PX = PSOB(M,NB) + PATM
!
!---      Aqueous component fractions and density  ---
!
          WTMLX = (XMLAB(M,NB)*WTMA + XMLOB(M,NB)*WTMO + 
     &      XMLNB(M,NB)*WTMN + 
     &      WTMW*(1.D+0-XMLAB(M,NB)-XMLOB(M,NB)-XMLNB(M,NB)))/
     &      (1.D+0-XLSB(M,NB)+WTMW*XLSB(M,NB)/WTMS)
          XLAB(M,NB) = XMLAB(M,NB)*WTMA/WTMLX
          XLOB(M,NB) = XMLOB(M,NB)*WTMO/WTMLX
          XLNB(M,NB) = XMLNB(M,NB)*WTMN/WTMLX
          CALL DENS_B( TB(M,NB),PX,XLSB(M,NB),RHOBX )
          CALL DENS_L( TB(M,NB),RHOBX,XLAB(M,NB),XLOB(M,NB),XLNB(M,NB),
     &      RHOLB(M,NB) )
          XLWB(M,NB) = 1.D+0-XLAB(M,NB)-XLOB(M,NB)-XLNB(M,NB)-XLSB(M,NB)
          IF( XLWB(M,NB).LT.EPSL ) XLWB(M,NB) = 0.D+0
          XMLSB(M,NB) = WTMLX*XLSB(M,NB)/WTMS
          XMLWB(M,NB) = WTMLX*XLWB(M,NB)/WTMW
!
!---      Aqueous molar density  ---
!
          RHOMLB(M,NB) = RHOLB(M,NB)/WTMLX
!
!---      Porous-media porosity  ---
!
          PPX = MAX( PGB(M,NB),PLB(M,NB),PNB(M,NB) ) + PATM
          CALL PORSTY( N,PPX,PCMP(N),PORDB(M,NB),PORTB(M,NB),
     &      SHB(M,NB) )
          PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
          PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
!
!---      Gas molar fractions and density  ---
!
          RHOGAX = XGAB(M,NB)*RHOGB(M,NB)
          RHOGOX = XGOB(M,NB)*RHOGB(M,NB)
          RHOGNX = XGNB(M,NB)*RHOGB(M,NB)
          RHOGWX = XGWB(M,NB)*RHOGB(M,NB)
          WTMGX = 1.D+0/(XGAB(M,NB)/WTMA + XGOB(M,NB)/WTMO
     &      + XGNB(M,NB)/WTMN + XGWB(M,NB)/WTMW)
          XMGAB(M,NB) = XGAB(M,NB)*WTMGX/WTMA
          XMGOB(M,NB) = XGOB(M,NB)*WTMGX/WTMO
          XMGNB(M,NB) = XGNB(M,NB)*WTMGX/WTMN
          XMGWB(M,NB) = XGWB(M,NB)*WTMGX/WTMW
          RHOMGB(M,NB) = RHOGB(M,NB)/WTMGX
!
!---      Gas viscosity, Pa s  ---
!
          RHOGAX = RHOMGB(M,NB)*WTMA
          CALL VISC_CO2( TB(M,NB),RHOGAX,VISGAX )
          RHOGOX = RHOMGB(M,NB)*WTMO
          CALL VISC_CH4( TB(M,NB),RHOGOX,VISGOX )
          RHOGNX = RHOMGB(M,NB)*WTMN
          CALL VISC_N2( TB(M,NB),RHOGNX,VISGNX )
          RHOGWX = RHOMGB(M,NB)*WTMW
          CALL VISC_W( TB(M,NB),PX,RHOGWX,VISGWX )
          CALL VISC_G( PHIX,VISGAX,VISGOX,VISGNX,VISGWX,XMGAB(M,NB),
     &      XMGOB(M,NB),XMGNB(M,NB),XMGWB(M,NB),VISGB(M,NB) )
!
!---      Gas diffusion coefficients  ---
!
          IF( ISLC(2).EQ.1 ) THEN
            DFGAB(M,NB) = DFGAC
            DFGOB(M,NB) = DFGOC
            DFGNB(M,NB) = DFGNC
            DFGWB(M,NB) = DFGWC
          ELSEIF( ISLC(2).EQ.2 ) THEN
            CALL DIFC_G( TB(M,NB),PX,DFGAB(M,NB),DFGOB(M,NB),
     &        DFGNB(M,NB),DFGWB(M,NB),XMGAB(M,NB),XMGOB(M,NB),
     &        XMGNB(M,NB),XMGWB(M,NB) )
          ENDIF
!
!---      Aqueous viscosity  ---
!
          ISRX = 1
          CALL DENS_W( TB(M,NB),PX,RHOLWX,RHOX,ISRX )
          CALL VISC_W( TB(M,NB),PX,RHOLWX,VISLWX )
          CALL VISC_B( TB(M,NB),XLSB(M,NB),VISLWX,VISBX )
          CALL VISC_L( XMLAB(M,NB),XMLOB(M,NB),XMLNB(M,NB),
     &      VISBX,VISGAX,VISGOX,VISGNX,VISLB(M,NB) )
!
!---      Aqueous diffusion coefficients  ---
!
          IF( ISLC(4).EQ.1 ) THEN
            DFLAB(M,NB) = DFLAC
            DFLOB(M,NB) = DFLOC
            DFLNB(M,NB) = DFLNC
            DFLSB(M,NB) = DFLSC
          ELSEIF( ISLC(4).EQ.2 ) THEN
            CALL DIFC_LA( TB(M,NB),VISLB(M,NB),VISGAX,DFLAB(M,NB) )
            CALL DIFC_LO( TB(M,NB),VISLB(M,NB),DFLOB(M,NB) )
            CALL DIFC_LN( TB(M,NB),VISLB(M,NB),DFLNB(M,NB) )
            CALL DIFC_LS( TB(M,NB),XLSB(M,NB),VISLB(M,NB),DFLSB(M,NB) )
          ENDIF
!
!---      Nonaqueous-liquid molar fractions and density  ---
!
          RHONAX = XNAB(M,NB)*RHONB(M,NB)
          RHONOX = XNOB(M,NB)*RHONB(M,NB)
          RHONNX = XNNB(M,NB)*RHONB(M,NB)
          RHONWX = XNWB(M,NB)*RHONB(M,NB)
          WTMNX = 1.D+0/(XNAB(M,NB)/WTMA + XNOB(M,NB)/WTMO
     &       + XNNB(M,NB)/WTMN + XNWB(M,NB)/WTMW)
          XMNAB(M,NB) = XNAB(M,NB)*WTMNX/WTMA
          XMNOB(M,NB) = XNOB(M,NB)*WTMNX/WTMO
          XMNNB(M,NB) = XNNB(M,NB)*WTMNX/WTMN
          XMNWB(M,NB) = XNWB(M,NB)*WTMNX/WTMW
          RHOMNB(M,NB) = RHONB(M,NB)/WTMNX
!
!---      Nonaqueous-liquid viscosity, Pa s  ---
!
          RHONAX = RHOMNB(M,NB)*WTMA
          CALL VISC_CO2( TB(M,NB),RHONAX,VISNAX )
          RHONOX = RHOMNB(M,NB)*WTMO
          CALL VISC_CH4( TB(M,NB),RHONOX,VISNOX )
          RHONNX = RHOMNB(M,NB)*WTMN
          CALL VISC_N2( TB(M,NB),RHONNX,VISNNX )
          RHONWX = RHOMNB(M,NB)*WTMW
          CALL VISC_W( TB(M,NB),PX,RHONWX,VISNWX )
          CALL VISC_G( PHIX,VISNAX,VISNOX,VISNNX,VISNWX,XMNAB(M,NB),
     &      XMNOB(M,NB),XMNNB(M,NB),XMNWB(M,NB),VISNB(M,NB) )
!
!---      Nonaqueous-liquid diffusion coefficients  ---
!
          IF( ISLC(2).EQ.1 ) THEN
            DFNAB(M,NB) = DFNAC
            DFNOB(M,NB) = DFNOC
            DFNNB(M,NB) = DFNNC
            DFNWB(M,NB) = DFNWC
          ELSEIF( ISLC(2).EQ.2 ) THEN
            CALL DIFC_G( TB(M,NB),PX,DFNAB(M,NB),DFNOB(M,NB),
     &        DFNNB(M,NB),DFNWB(M,NB),XMNAB(M,NB),XMNOB(M,NB),
     &        XMNNB(M,NB),XMNWB(M,NB) )
          ENDIF
!
!---      Gas thermal conductivity, W/m K  ---
!
          RHOGAX = RHOMGB(M,NB)*WTMA
          CALL THK_CO2( TB(M,NB),PX,RHOGAX,THKGAX )
          RHOGOX = RHOMGB(M,NB)*WTMO
          CALL THK_CH4( TB(M,NB),RHOGOX,THKGOX )
          RHOGNX = RHOMGB(M,NB)*WTMN
          CALL THK_N2( TB(M,NB),RHOGNX,THKGNX )
          RHOGWX = RHOMGB(M,NB)*WTMW
          CALL THK_W( TB(M,NB),PX,RHOGWX,THKGWX )
          CALL THK_G( PHIX,THKGAX,THKGOX,THKGNX,THKGWX,XMGAB(M,NB),
     &      XMGOB(M,NB),XMGNB(M,NB),XMGWB(M,NB),THKGB(M,NB) )
!  
!---      Aqueous thermal conductivity  ---
!
          CALL THK_W( TB(M,NB),PX,RHOLWX,THKLWX )
          CALL THK_B( TB(M,NB),XLSB(M,NB),THKLWX,THKLB(M,NB) )
!
!---      Nonaqueous thermal conductivity, W/m K  ---
!
          RHONAX = RHOMNB(M,NB)*WTMA
          CALL THK_CO2( TB(M,NB),PX,RHONAX,THKNAX )
          RHONOX = RHOMNB(M,NB)*WTMO
          CALL THK_CH4( TB(M,NB),RHONOX,THKNOX )
          RHONNX = RHOMNB(M,NB)*WTMN
          CALL THK_N2( TB(M,NB),RHONNX,THKNNX )
          RHONWX = RHOMNB(M,NB)*WTMW
          CALL THK_W( TB(M,NB),PX,RHONWX,THKNWX )
          CALL THK_G( PHIX,THKNAX,THKNOX,THKNNX,THKNWX,XMNAB(M,NB),
     &      XMNOB(M,NB),XMNNB(M,NB),XMNWB(M,NB),THKNB(M,NB) )
!
!---      Pure water vapor enthalpy and internal energy  ---
!
          CALL SP_W( TB(M,NB),PSWX )
          PEX = MIN( PSWX,PX )
          ISRX = 2
          CALL ENTH_W( TB(M,NB),PEX,HLWX,HGWB(M,NB),ISRX )
!
!---      Gas enthalpy and internal energy  ---
!
          XMGX(1) = YMGAX
          XMGX(2) = YMGOX
          XMGX(3) = YMGNX
          CALL ENTH_ID( TB(M,NB),HIDX )
          INDX = 1
          CALL ENTH_RES( PX,TB(M,NB),HRESX,XMGX,INDX )
          HGAB(M,NB) = (HIDX(1) + HRESX(1))/WTMA
          HGOB(M,NB) = (HIDX(2) + HRESX(2))/WTMO
          HGNX = (HIDX(3) + HRESX(3))/WTMN
          HGB(M,NB) = XGAB(M,NB)*HGAB(M,NB) + XGOB(M,NB)*HGOB(M,NB) + 
     &      XGNB(M,NB)*HGNX + XGWB(M,NB)*HGWB(M,NB)
!
!---      Nonaqueous-liquid enthalpy and internal energy  ---
!
          XMNX(1) = YMNAX
          XMNX(2) = YMNOX
          XMNX(3) = YMNNX
          CALL ENTH_ID( TB(M,NB),HIDX )
          INDX = 2
          CALL ENTH_RES( PX,TB(M,NB),HRESX,XMNX,INDX )
          HNAX = (HIDX(1) + HRESX(1))/WTMA
          HNOX = (HIDX(2) + HRESX(2))/WTMO
          HNNX = (HIDX(3) + HRESX(3))/WTMN
          HNB(M,NB) = XNAB(M,NB)*HNAX + XNOB(M,NB)*HNOX + 
     &      XNNB(M,NB)*HNNX + XNWB(M,NB)*HGWB(M,NB)
!
!---      Pure water liquid enthalpy  ---
!
          CALL SP_W( TB(M,NB),PSWX )
          PEX = MAX( PSWX,PX )
          ISRX = 1
          CALL ENTH_W( TB(M,NB),PEX,HLWB(M,NB),HGWX,ISRX )
!
!---      Aqueous enthalpy  ---
!
          CALL ENTH_B( TB(M,NB),XLSB(M,NB),HLWB(M,NB),HBX )
          FGAX = SGB(M,NB)*RHOGB(M,NB)*XGAB(M,NB)
          FNAX = SNB(M,NB)*RHONB(M,NB)*XNAB(M,NB)
          IF( (FGAX+FNAX)/EPSL.LT.EPSL ) THEN
            HGNAX = 0.D+0
          ELSE
            HGNAX = (HGAB(M,NB)*FGAX + HNAX*FNAX)/(FGAX + FNAX)
          ENDIF
          FGOX = SGB(M,NB)*RHOGB(M,NB)*XGOB(M,NB)
          FNOX = SNB(M,NB)*RHONB(M,NB)*XNOB(M,NB)
          IF( (FGOX+FNOX)/EPSL.LT.EPSL ) THEN
            HGNOX = 0.D+0
          ELSE
            HGNOX = (HGOB(M,NB)*FGOX + HNOX*FNOX)/(FGOX + FNOX)
          ENDIF
          FGNX = SGB(M,NB)*RHOGB(M,NB)*XGNB(M,NB)
          FNNX = SNB(M,NB)*RHONB(M,NB)*XNNB(M,NB)
          IF( (FGNX+FNNX)/EPSL.LT.EPSL ) THEN
            HGNNX = 0.D+0
          ELSE
            HGNNX = (HGNX*FGNX + HNNX*FNNX)/(FGNX + FNNX)
          ENDIF
          CALL ENTH_L( TB(M,NB),XLSB(M,NB),XLAB(M,NB),XLOB(M,NB),
     &      XLNB(M,NB),HBX,HGNAX,HGNOX,HGNNX,HLB(M,NB) )
!
!---      Aqueous, gas, and nonaqueous-liquid tortuosity  ---
!
          PORDX = PORDB(M,NB)*(1.D+0-SHB(M,NB)-SIB(M,NB))
          IF( ISLC(3).EQ.1 ) CALL TORTU( SLB(M,NB),SGB(M,NB),
     &      SNB(M,NB),PORDX,TORLB(M,NB),TORGB(M,NB),TORNB(M,NB),N )
!
!---      NaCl volumetric concentration  ---
!
          TMSB(M,NB) = YLSB(M,NB)*RHOLB(M,NB)*SLB(M,NB)*PORDB(M,NB)
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCP_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CAP_HYDT_KE( CPGLX,CPGNX,CPNLX,SHX,SLIX,SNX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute the gas-aqueous and hydrate aqueous capillary pressures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 23 June 2021
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE HYST
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CAP_HYDT_KE'
!
!---  Hydrate saturation independent ksp or sp  ---
!
      SHZ = SHX
      IF( ISLC(82).EQ.2 .OR. ISLC(82).EQ.3 ) SHZ = 0.D+0 
!
!---  van Genuchten saturation function
!
      IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 .OR. 
     &  ISCHR(N).EQ.13 ) THEN
        CNX = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CMX = 1.D+0 - 2.D+0/CNX
          ELSE
            CMX = 1.D+0 - 1.D+0/CNX
          ENDIF
        ELSE
          CMX = SCHR(14,N)
        ENDIF
        SRX = SCHR(4,N)
!
!---    Effective saturations  ---
!
        ESLX = SLIX/(1.D+0-SHZ)
        ESNX = SNX/(1.D+0-SHZ)
        ESTX = ESLX+ESNX
!
!---    Webb extension  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HMPX = SCHR(17,N)
          SMPX = SCHR(16,N)
!
!---      Total-liquid saturation below the matching point,
!         use Webb extension  ---
!
          IF( ESTX.LT.SMPX ) THEN
            DMPX = -(LOG10(HDOD)-LOG10(HMPX))/SMPX
            HDGN = 1.D+1**(DMPX*(ESTX-SMPX) + LOG10(HMPX))
!
!---      Total-liquid saturation at or above the matching point,
!         use van Genuchten function
!
          ELSE
            ASTX = (ESTX-SRX)/(1.D+0-SRX)
            VARX = (1.D+0/ASTX)**(1.D+0/CMX) - 1.D+0
            IF( VARX.LT.EPSL ) VARX = 0.D+0
            HDGN = (VARX**(1.D+0/CNX))/SCHR(1,N)
          ENDIF
!
!---      Aqueous saturation below the matching point,
!         use Webb extension  ---
!
          IF( ESLX.LT.SMPX ) THEN
            DMPX = -(LOG10(HDOD)-LOG10(HMPX))/SMPX
            HDNL = 1.D+1**(DMPX*(ESLX-SMPX) + LOG10(HMPX))
!
!---      Aqueous saturation at or above the matching point,
!         use van Genuchten function
!
          ELSE
            ASLX = (ESLX-SRX)/(1.D+0-SRX)
            VARX = (1.D+0/ASLX)**(1.D+0/CMX) - 1.D+0
            IF( VARX.LT.EPSL ) VARX = 0.D+0
            HDNL = (VARX**(1.D+0/CNX))/SCHR(1,N)
          ENDIF
!
!---    No extension  ---
!
        ELSE
          ASLX = (ESLX-SRX)/(1.D+0-SRX)
          ASNX = ESNX/(1.D+0-SRX)
          ASTX = ASLX+ASNX
          IF( ASTX.GT.EPSL ) THEN
            VARX = (1.D+0/ASTX)**(1.D+0/CMX) - 1.D+0
            IF( VARX.LT.EPSL ) VARX = 0.D+0
            HDGN = (VARX**(1.D+0/CNX))/SCHR(1,N)
          ELSE
            HDGN = 0.D+0
          ENDIF
          IF( ASLX.GT.EPSL ) THEN
            VARX = (1.D+0/ASLX)**(1.D+0/CMX) - 1.D+0
            IF( VARX.LT.EPSL ) VARX = 0.D+0
            HDNL = (VARX**(1.D+0/CNX))/SCHR(1,N)
          ELSE
            HDNL = 0.D+0
          ENDIF
        ENDIF
        HCPBFX = 1.D+0
!
!---    Entry pressure with hydrate barrier adjustment  ---
!
        IF( ISCHR(N).EQ.11 ) THEN
          HCPBFX = MAX( 1.D+0,SCHR(10,N) + SCHR(11,N)*
     &      SIN(SCHR(12,N)*SHZ + SCHR(13,N)) )
!
!---    Entry pressure with hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          HCPBFX = (1.D+0-SHZ)**(-(SCHR(10,N)-1.D+0)/SCHR(10,N))
        ENDIF
        CPGNX = HCPBFX*HDGN*RHORL*GRAV/BGN
        CPNLX = HCPBFX*HDNL*RHORL*GRAV/BNL
        CPGLX = CPGNX+CPNLX
!
!---  Brooks and Corey saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 .OR. 
     &  ISCHR(N).EQ.14 ) THEN
        CLX = MAX( SCHR(3,N),SMALL )
        SRX = SCHR(4,N)
!
!---    Effective saturations  ---
!
        ESLX = SLIX/(1.D+0-SHZ)
        ESNX = SNX/(1.D+0-SHZ)
        ESTX = ESLX+ESNX
!
!---    Webb extension  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HMPX = SCHR(17,N)
          SMPX = SCHR(16,N)
!
!---      Total-liquid saturation below the matching point,
!         use Webb extension  ---
!
          IF( ESTX.LT.SMPX ) THEN
            DMPX = -(LOG10(HDOD)-LOG10(HMPX))/SMPX
            HDGN = 1.D+1**(DMPX*(ESTX-SMPX) + LOG10(HMPX))
!
!---      Total-liquid saturation at or above the matching point,
!         use Brooks and Corey function
!
          ELSE
            ASTX = (ESTX-SRX)/(1.D+0-SRX)
            IF( ASTX.GT.EPSL ) THEN
              HDGN = SCHR(2,N)*(1.D+0/ASTX)**(1.D+0/CLX)
            ELSE
              HDGN = 0.D+0
            ENDIF
          ENDIF
!
!---      Aqueous saturation below the matching point,
!         use Webb extension  ---
!
          IF( ESLX.LT.SMPX ) THEN
            DMPX = -(LOG10(HDOD)-LOG10(HMPX))/SMPX
            HDNL = 1.D+1**(DMPX*(ESLX-SMPX) + LOG10(HMPX))
!
!---      Aqueous saturation at or above the matching point,
!         use Brooks and Corey function
!
          ELSE
            ASLX = (ESLX-SRX)/(1.D+0-SRX)
            IF( ASLX.GT.EPSL ) THEN
              HDNL = SCHR(2,N)*(1.D+0/ASLX)**(1.D+0/CLX)
            ELSE
              HDNL = 0.D+0
            ENDIF
          ENDIF
!
!---    No extension  ---
!
        ELSE
          ASLX = (ESLX-SRX)/(1.D+0-SRX)
          ASNX = ESNX/(1.D+0-SRX)
          ASTX = ASLX+ASNX
          IF( ASTX.GT.EPSL ) THEN
            HDGN = SCHR(2,N)*(1.D+0/ASTX)**(1.D+0/CLX)
          ELSE
            HDGN = 0.D+0
          ENDIF
          IF( ASLX.GT.EPSL ) THEN
            HDNL = SCHR(2,N)*(1.D+0/ASLX)**(1.D+0/CLX)
          ELSE
            HDNL = 0.D+0
          ENDIF
        ENDIF
        HCPBFX = 1.D+0
!
!---    Entry pressure with hydrate barrier adjustment  ---
!
        IF( ISCHR(N).EQ.12 ) THEN
          HCPBFX = MAX( 1.D+0,SCHR(10,N) + SCHR(11,N)*
     &      SIN(SCHR(12,N)*SHZ + SCHR(13,N)) )
!
!---    Entry pressure with hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          HCPBFX = (1.D+0-SHZ)**(-(SCHR(10,N)-1.D+0)/SCHR(10,N))
        ENDIF
        CPGNX = HCPBFX*HDGN*RHORL*GRAV/BGN
        CPNLX = HCPBFX*HDNL*RHORL*GRAV/BNL
        CPGLX = CPGNX+CPNLX
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CAP_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE FLUX_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute fluxes on internal and boundary surfaces.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 30 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE HYST
      USE HYDT
      USE GLB_PAR
      USE GRID
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/FLUX_HYDT_KE'
!
!---  Gas volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVG
!
!---  Aqueous volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVL
!
!---  Non-aqueous volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVN
!
!---  Mobile CO2 diffusive flux through gas (non-boundary surfaces)
!     inactive for iso-CO2 option  ---
!
      IF( ISLC(45).EQ.0 ) CALL DFFGA
!
!---  Mobile CH4 diffusive flux through gas (non-boundary surfaces)
!     inactive for iso-CH4 option  ---
!
      IF( ISLC(64).EQ.0 ) CALL DFFGO
!
!---  Water diffusive flux through gas (non-boundary surfaces)  ---
!
      CALL DFFGW
!
!---  Mobile N2 diffusive flux through gas (non-boundary surfaces)
!     inactive for iso-N2 option (last in gas diffusion order as
!     molar N2 diffusion in gas phase equal to minus the sum of the 
!     molar diffusion of H2O, CH4, and CO2)  ---
!
      IF( ISLC(65).EQ.0 ) CALL DFFGN
!
!---  Mobile CO2 diffusive flux through aqueous (non-boundary surfaces)
!     inactive for iso-CO2 option  ---
!
      IF( ISLC(45).EQ.0 ) CALL DFFLA
!
!---  Mobile CH4 diffusive flux through aqueous (non-boundary surfaces)
!     inactive for iso-Ch4 option  ---
!
      IF( ISLC(64).EQ.0 ) CALL DFFLO
!
!---  Mobile N2 diffusive flux through aqueous (non-boundary surfaces)
!     inactive for iso-N2 option  ---
!
      IF( ISLC(65).EQ.0 ) CALL DFFLN
!
!---  Salt diffusive flux through aqueous (non-boundary surfaces)
!     inactive for iso-brine option  ---
!
      IF( ISLC(32).EQ.0 ) CALL DFFLS
!
!---  Water diffusive flux through aqueous (non-boundary surfaces)
!     (last in aqueous diffusion order as molar H2O diffusion 
!     in aqueous phase equal to minus the sum of the 
!     molar diffusion of salt, N2, CH4, and CO2)  ---
!
      CALL DFFLW
!
!---  Mobile CH4 diffusive flux through nonaqueous liquid 
!     (non-boundary surfaces) inactive for iso-CH4 option  ---
!
      IF( ISLC(64).EQ.0 ) CALL DFFNO
!
!---  Mobile N2 diffusive flux through nonaqueous liquid 
!     (non-boundary surfaces) inactive for iso-N2 option  ---
!
      IF( ISLC(65).EQ.0 ) CALL DFFNN
!
!---  Water diffusive flux through nonaqueous liquid 
!     (non-boundary surfaces)  ---
!
      CALL DFFNW
!
!---  Mobile CO2 diffusive flux through nonaqueous liquid 
!     (non-boundary surfaces) inactive for iso-CO2 option
!     (last in non-aqueous diffusion order as molar CO2 diffusion 
!     in non-aqueous phase equal to minus the sum of the 
!     molar diffusion of H2O, N2, and CH4)  ---
!
      IF( ISLC(45).EQ.0 ) CALL DFFNA

!---  Thermal diffusive flux (non-boundary surfaces)  ---
!
      CALL THD_HYDT_KE
!
!---  Thermal advective flux for gas, aqueous, and nonaqueous
!      liquid (non-boundary surfaces)  ---

      CALL THA_HYDT_KE
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of FLUX_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE INCRM_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute primary variable increments.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE HYST
      USE HYDT
      USE GLB_PAR
      USE GRID
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/INCRM_HYDT_KE'
      TOLX = 1.D-4
      DO N = 1,NFCGC(ID+1)
        IF( IXP(N).EQ.0 ) CYCLE
        IF( NITER.LE.3 ) THEN
          ZMIH_HT(1) = YMHGA(2,N)
          ZMIH_HT(2) = YMHGO(2,N)
          ZMIH_HT(3) = YMHGN(2,N)
          SNR(1,N) = YMHGA(2,N)
          SNR(2,N) = YMHGO(2,N)
          SNR(3,N) = YMHGN(2,N)
        ELSE
          ZMIH_HT(1) = SNR(1,N)
          ZMIH_HT(2) = SNR(2,N)
          ZMIH_HT(3) = SNR(3,N)
        ENDIF
!
!---    Absolute temperature and pressure  ---
!
        TKX = T(2,N) + TABS
        PX = PSO(2,N) + PATM
!
!---    Core phase condition  ---
!
        NPHZX = MOD(NPHAZ(2,N),100)
!
!---    Phase condition #10 (10 series)  ---
!
!       SH = 0, SG + SN = 0, SL+SI = 1
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        IF( NPHZX.EQ.10 ) THEN
          CALL FLH_PC10( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &      PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),PVN(2,N),
     &      PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),RHOG(2,N),RHOH(2,N),
     &      RHON(2,N),RKG(2,N),RKL(2,N),RKN(2,N),
     &      SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,SN(2,N),T(2,N),TCR(N),
     &      TCT(N),TEQHX,XGA(2,N),
     &      XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),XHN(2,N),XHO(2,N),
     &      XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),XNW(2,N),XMLA(2,N),
     &      XMLN(2,N),XMLO(2,N),XLS(2,N),YLS(2,N),YMGA(2,N),YMGN(2,N),
     &      YMGO(2,N),YMHGA(2,N),YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,
     &      YMNOX,ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
          POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      Absolute total vapor pressure, mobile component 
!         vapor pressure, hydrate component vapor pressure,
!         gas pressure, and nonaqueous-liquid pressure  ---
!
          PVX = PVA(2,N) + PVO(2,N) + PVN(2,N) + PVW(2,N)
          PVMX = PVA(2,N) + PVO(2,N) + PVN(2,N)
          PVHX = PVHA(2,N) + PVHO(2,N) + PVHN(2,N)
          PGX = PG(2,N) + PATM
          PNX = PN(2,N) + PATM
!
!---      Transition to hydrate conditions with nonaqueous phases
!         (10 series -> 30 series)  ---
!
          IF( PVHX.GE.PH(2,N) .AND. PVX.GT.(PX*(1.D+0+TOLX)) ) THEN
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 31 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 32 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 33 + (100*NP_HT)
              ENDIF
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 34 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 35 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 36 + (100*NP_HT)
              ENDIF
            ELSE
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 37 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 38 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 39 + (100*NP_HT)
              ENDIF
            ENDIF
            SH(2,N) = 1.D-7
            POSM(2,N) = POSM(2,N) - 1.D-4*POSM(2,N)
            SLIX = POSM(2,N)
            CALL FLH_PC30( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),
     &        SLIX,SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,TMHA(2,N),
     &        TMHN(2,N),TMHO(2,N),XGA(2,N),XGN(2,N),XGO(2,N),
     &        XGW(2,N),XHA(2,N),XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),
     &        XNN(2,N),XNO(2,N),XNW(2,N),XMLA(2,N),XMLN(2,N),
     &        XMLO(2,N),XLS(2,N),YLS(2,N),YMGA(2,N),YMGN(2,N),
     &        YMGO(2,N),YMHGA(2,N),YMHGN(2,N),YMHGO(2,N),YMNAX,
     &        YMNNX,YMNOX,ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),
     &        N,NP_HT )
!
!---      Transition to hydrate conditions with no nonaqueous phases
!         (10 series -> 40 series)  ---
!
          ELSEIF( PVHX.GE.PH(2,N) ) THEN
            IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
              NPHAZ(2,N) = 41 + (100*NP_HT)
            ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
              NPHAZ(2,N) = 42 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 43 + (100*NP_HT)
            ENDIF
            SH(2,N) = 1.D-7
            CALL FLH_PC40( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,TMHA(2,N),TMHN(2,N),
     &        TMHO(2,N),XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
            POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      Transition to no hydrate conditions with nonaqueous phases
!         (10 series -> 20 series)  ---
!
          ELSEIF( PVX.GT.(PX*(1.D+0+TOLX)) ) THEN
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              NPHAZ(2,N) = 21 + (100*NP_HT)
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              NPHAZ(2,N) = 22 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 23 + (100*NP_HT)
            ENDIF
            POSM(2,N) = POSM(2,N) - 1.D-4*POSM(2,N)
            SLIX = POSM(2,N)
            CALL FLH_PC20( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,
     &        XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
          ENDIF
!
!---    Phase conditions 21 through 23 (20 series)  ---
!
!       SH = 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation - POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CO2 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.21 .AND. NPHZX.LE.23  ) THEN
          IF( NPHZX.EQ.21 ) THEN
            ZMCA(2,N) = MIN( 1.D+0-ZMCO(2,N)-ZMCN(2,N),1.D+0 )
            IF( ZMCA(2,N).LT.EPSL ) ZMCA(2,N) = 0.D+0
          ELSEIF( NPHZX.EQ.22 ) THEN
            ZMCO(2,N) = MIN( 1.D+0-ZMCA(2,N)-ZMCN(2,N),1.D+0 )
            IF( ZMCO(2,N).LT.EPSL ) ZMCO(2,N) = 0.D+0
          ELSE
            ZMCN(2,N) = MIN( 1.D+0-ZMCA(2,N)-ZMCO(2,N),1.D+0 )
            IF( ZMCN(2,N).LT.EPSL ) ZMCN(2,N) = 0.D+0
          ENDIF
          SLIX = POSM(2,N)
          CALL FLH_PC20( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &      PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),PVN(2,N),
     &      PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),RHOG(2,N),RHOH(2,N),
     &      RKG(2,N),RKL(2,N),RKN(2,N),SH(2,N),
     &      SI(2,N),SG(2,N),SL(2,N),SLIX,SN(2,N),T(2,N),TCR(N),
     &      TCT(N),TEQHX,XGA(2,N),
     &      XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),XHN(2,N),XHO(2,N),
     &      XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),XNW(2,N),XMLA(2,N),
     &      XMLN(2,N),XMLO(2,N),XLS(2,N),YLS(2,N),YMGA(2,N),YMGN(2,N),
     &      YMGO(2,N),YMHGA(2,N),YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,
     &      YMNOX,ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT ) 
!
!---      Absolute total vapor pressure, mobile component 
!         vapor pressure, hydrate component vapor pressure,
!         gas pressure, and nonaqueous-liquid pressure  ---
!
          PVX = PVA(2,N) + PVO(2,N) + PVN(2,N) + PVW(2,N)
          PVMX = PVA(2,N) + PVO(2,N) + PVN(2,N)
          PVHX = PVHA(2,N) + PVHO(2,N) + PVHN(2,N)
          PGX = PG(2,N) + PATM
          PNX = PN(2,N) + PATM
!
!---      Transition to hydrate conditions with nonaqueous phases
!         (20 series -> 30 series)  ---
!
          IF( PVHX.GE.PH(2,N) .AND. (SG(2,N)+SN(2,N)).GT.EPSL ) THEN
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 31 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 32 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 33 + (100*NP_HT)
              ENDIF
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 34 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 35 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 36 + (100*NP_HT)
              ENDIF
            ELSE
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 37 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 38 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 39 + (100*NP_HT)
              ENDIF
            ENDIF
            SH(2,N) = 1.D-7
            SLIX = POSM(2,N)
            CALL FLH_PC30( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),
     &        SLIX,SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,TMHA(2,N),
     &        TMHN(2,N),TMHO(2,N),XGA(2,N),XGN(2,N),XGO(2,N),
     &        XGW(2,N),XHA(2,N),XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),
     &        XNN(2,N),XNO(2,N),XNW(2,N),XMLA(2,N),XMLN(2,N),
     &        XMLO(2,N),XLS(2,N),YLS(2,N),YMGA(2,N),YMGN(2,N),
     &        YMGO(2,N),YMHGA(2,N),YMHGN(2,N),YMHGO(2,N),YMNAX,
     &        YMNNX,YMNOX,ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),
     &        N,NP_HT )
!
!---      Transition to hydrate conditions with no nonaqueous phases
!         (20 series -> 40 series)  ---
!
          ELSEIF( PVHX.GE.PH(2,N) .AND. (SG(2,N)+SN(2,N)).LE.EPSL ) THEN
            IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
              NPHAZ(2,N) = 41 + (100*NP_HT)
            ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
              NPHAZ(2,N) = 42 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 43 + (100*NP_HT)
            ENDIF
            SH(2,N) = 1.D-7
            CALL FLH_PC40( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,TMHA(2,N),TMHN(2,N),
     &        TMHO(2,N),XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
            POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      Transition to no hydrate conditions with no nonaqueous phases
!         (20 series -> 10 series)  ---
!
          ELSEIF( (SG(2,N)+SN(2,N)).LE.EPSL ) THEN
            NPHAZ(2,N) = 10 + (100*NP_HT)
            CALL FLH_PC10( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,
     &        XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
            POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      No transition from no hydrate with nonaqueous phases  ---
!
          ELSE
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              NPHAZ(2,N) = 21 + (100*NP_HT)
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              NPHAZ(2,N) = 22 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 23 + (100*NP_HT)
            ENDIF
          ENDIF
!
!---    Phase conditions #31 through #39 (30 series)  ---
!
!       SH > 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #34
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #35
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #36
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #37
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #38
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #39
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation, POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CO2 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.39 ) THEN
          IF( NPHZX.GE.31 .AND. NPHZX.LE.33 ) THEN
            ZMCA(2,N) = MIN( 1.D+0-ZMCO(2,N)-ZMCN(2,N),1.D+0 )
            IF( ZMCA(2,N).LT.EPSL ) ZMCA(2,N) = 0.D+0
          ELSEIF( NPHZX.GE.34 .AND. NPHZX.LE.36 ) THEN
            ZMCO(2,N) = MIN( 1.D+0-ZMCA(2,N)-ZMCN(2,N),1.D+0 )
            IF( ZMCO(2,N).LT.EPSL ) ZMCO(2,N) = 0.D+0
          ELSE
            ZMCN(2,N) = MIN( 1.D+0-ZMCA(2,N)-ZMCO(2,N),1.D+0 )
            IF( ZMCN(2,N).LT.EPSL ) ZMCN(2,N) = 0.D+0
          ENDIF
          IF( NPHZX.EQ.31 .OR. NPHZX.EQ.34 .OR. NPHZX.EQ.37 ) THEN
            YMHGA(2,N) = MIN( 1.D+0-YMHGO(2,N)-YMHGN(2,N),1.D+0 )
            IF( YMHGA(2,N).LT.EPSL ) YMHGA(2,N) = 0.D+0
          ELSEIF( NPHZX.EQ.32 .OR. NPHZX.EQ.35 .OR. NPHZX.EQ.38 )THEN
            YMHGO(2,N) = MIN( 1.D+0-YMHGA(2,N)-YMHGN(2,N),1.D+0 )
            IF( YMHGO(2,N).LT.EPSL ) YMHGO(2,N) = 0.D+0
          ELSE
            YMHGN(2,N) = MIN( 1.D+0-YMHGA(2,N)-YMHGO(2,N),1.D+0 )
            IF( YMHGN(2,N).LT.EPSL ) YMHGN(2,N) = 0.D+0
          ENDIF
          SLIX = POSM(2,N)
          CALL FLH_PC30( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &      PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),PVN(2,N),
     &      PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),RHOG(2,N),RHOH(2,N),
     &      RHON(2,N),RKG(2,N),RKL(2,N),RKN(2,N),
     &      SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,SN(2,N),T(2,N),TCR(N),
     &      TCT(N),TEQHX,TMHA(2,N),TMHN(2,N),TMHO(2,N),XGA(2,N),
     &      XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),XHN(2,N),XHO(2,N),
     &      XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),XNW(2,N),XMLA(2,N),
     &      XMLN(2,N),XMLO(2,N),XLS(2,N),YLS(2,N),YMGA(2,N),YMGN(2,N),
     &      YMGO(2,N),YMHGA(2,N),YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,
     &      YMNOX,ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT ) 
!
!---      Absolute total vapor pressure, mobile component 
!         vapor pressure, hydrate component vapor pressure,
!         gas pressure, and nonaqueous-liquid pressure  ---
!
          PVX = PVA(2,N) + PVO(2,N) + PVN(2,N) + PVW(2,N)
          PVMX = PVA(2,N) + PVO(2,N) + PVN(2,N)
          PVHX = PVHA(2,N) + PVHO(2,N) + PVHN(2,N)
          PGX = PG(2,N) + PATM
          PNX = PN(2,N) + PATM
!
!---      Transition to no-hydrate conditions + nonaqueous phases 
!         (30 series -> 20 series)  ---
!
          IF( SH(2,N).LE.EPSL  ) THEN
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              NPHAZ(2,N) = 21 + (100*NP_HT)
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              NPHAZ(2,N) = 22 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 23 + (100*NP_HT)
            ENDIF
            SLIX = POSM(2,N)
            CALL FLH_PC20( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,
     &        XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
!
!---      Transition to no-hydrate conditions + no nonaqueous phases 
!         (30 series -> 10 series)  ---
!
          ELSEIF( SH(2,N).LE.EPSL .AND. 
     &      (SG(2,N)+SN(2,N)).LT.EPSL  ) THEN
            NPHAZ(2,N) = 10 + (100*NP_HT)
            CALL FLH_PC10( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,
     &        XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
            POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      Transition to hydrate conditions + no nonaqueous phases 
!         (30 series -> 40 series)  ---
!
          ELSEIF( (SG(2,N)+SN(2,N)).LT.EPSL  ) THEN
            IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
              NPHAZ(2,N) = 41 + (100*NP_HT)
            ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
              NPHAZ(2,N) = 42 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 43 + (100*NP_HT)
            ENDIF
            CALL FLH_PC40( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,TMHA(2,N),TMHN(2,N),
     &        TMHO(2,N),XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
            POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      No transition from hydrate conditions + nonaqueous phases  ---
!
          ELSE
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 31 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 32 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 33 + (100*NP_HT)
              ENDIF
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 34 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 35 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 36 + (100*NP_HT)
              ENDIF
            ELSE
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 37 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 38 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 39 + (100*NP_HT)
              ENDIF
            ENDIF
          ENDIF
!
!---    Phase conditions #41 through #43 (40 series)  ---
!
!       SH > 0, SG + SN = 0, SL+SI < 1
!       YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!       YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!       YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
          IF( NPHZX.EQ.41 ) THEN
            YMHGA(2,N) = MIN( 1.D+0-YMHGO(2,N)-YMHGN(2,N),1.D+0 )
            IF( YMHGA(2,N).LT.EPSL ) YMHGA(2,N) = 0.D+0
          ELSEIF( NPHZX.EQ.42 )THEN
            YMHGO(2,N) = MIN( 1.D+0-YMHGA(2,N)-YMHGN(2,N),1.D+0 )
            IF( YMHGO(2,N).LT.EPSL ) YMHGO(2,N) = 0.D+0
          ELSE
            YMHGN(2,N) = MIN( 1.D+0-YMHGA(2,N)-YMHGO(2,N),1.D+0 )
            IF( YMHGN(2,N).LT.EPSL ) YMHGN(2,N) = 0.D+0
          ENDIF
          CALL FLH_PC40( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &      PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &      PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &      RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &      RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &      SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,TMHA(2,N),TMHN(2,N),
     &      TMHO(2,N),XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &      XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &      XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &      YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &      YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &      ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
          POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      Absolute total vapor pressure, mobile component 
!         vapor pressure, hydrate component vapor pressure,
!         gas pressure, and nonaqueous-liquid pressure  ---
!
          PVX = PVA(2,N) + PVO(2,N) + PVN(2,N) + PVW(2,N)
          PVMX = PVA(2,N) + PVO(2,N) + PVN(2,N)
          PVHX = PVHA(2,N) + PVHO(2,N) + PVHN(2,N)
          PGX = PG(2,N) + PATM
          PNX = PN(2,N) + PATM
!
!---      Transition to no hydrate conditions + nonaqueous phases 
!         (40 series -> 20 series)  ---
!
          IF( SH(2,N).LE.EPSL .AND.
     &       PVX.GT.(PX*(1.D+0+TOLX)) ) THEN
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              NPHAZ(2,N) = 21 + (100*NP_HT)
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              NPHAZ(2,N) = 22 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 23 + (100*NP_HT)
            ENDIF
            POSM(2,N) = POSM(2,N) - 1.D-4*POSM(2,N)
            SLIX = POSM(2,N)
            CALL FLH_PC20( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,
     &        XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
!
!---      Transition to no hydrate conditions + no nonaqueous phases 
!         (40 series -> 10 series)  ---
!
          ELSEIF( SH(2,N).LE.EPSL  ) THEN
            NPHAZ(2,N) = 10 + (100*NP_HT)
            CALL FLH_PC10( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,
     &        XGA(2,N),XGN(2,N),XGO(2,N),XGW(2,N),XHA(2,N),
     &        XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),XNN(2,N),XNO(2,N),
     &        XNW(2,N),XMLA(2,N),XMLN(2,N),XMLO(2,N),XLS(2,N),
     &        YLS(2,N),YMGA(2,N),YMGN(2,N),YMGO(2,N),YMHGA(2,N),
     &        YMHGN(2,N),YMHGO(2,N),YMNAX,YMNNX,YMNOX,
     &        ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),N,NP_HT )
            POSM(2,N) = SL(2,N) + SI(2,N)
!
!---      Transition to hydrate conditions + nonaqueous phases 
!         (40 series -> 30 series)  ---
!
          ELSEIF( PVHX.GE.PH(2,N) .AND. PVX.GT.(PX*(1.D+0+TOLX)) ) THEN
            IF( ZMCA(2,N).GE.MAX( ZMCO(2,N),ZMCN(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 31 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 32 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 33 + (100*NP_HT)
              ENDIF
            ELSEIF( ZMCO(2,N).GE.MAX( ZMCN(2,N),ZMCA(2,N) ) ) THEN
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 34 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 35 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 36 + (100*NP_HT)
              ENDIF
            ELSE
              IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
                NPHAZ(2,N) = 37 + (100*NP_HT)
              ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
                NPHAZ(2,N) = 38 + (100*NP_HT)
              ELSE
                NPHAZ(2,N) = 39 + (100*NP_HT)
              ENDIF
            ENDIF
            POSM(2,N) = POSM(2,N) - 1.D-4*POSM(2,N)
            SLIX = POSM(2,N)
            CALL FLH_PC30( PH(2,N),PG(2,N),PI(2,N),PL(2,N),PN(2,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(2,N),PVA(2,N),PVHA(2,N),
     &        PVN(2,N),PVHN(2,N),PVO(2,N),PVHO(2,N),PVW(2,N),
     &        RHOG(2,N),RHOH(2,N),RHON(2,N),RKG(2,N),
     &        RKL(2,N),RKN(2,N),SH(2,N),SI(2,N),SG(2,N),SL(2,N),SLIX,
     &        SN(2,N),T(2,N),TCR(N),TCT(N),TEQHX,TMHA(2,N),
     &        TMHN(2,N),TMHO(2,N),XGA(2,N),XGN(2,N),XGO(2,N),
     &        XGW(2,N),XHA(2,N),XHN(2,N),XHO(2,N),XHW(2,N),XNA(2,N),
     &        XNN(2,N),XNO(2,N),XNW(2,N),XMLA(2,N),XMLN(2,N),
     &        XMLO(2,N),XLS(2,N),YLS(2,N),YMGA(2,N),YMGN(2,N),
     &        YMGO(2,N),YMHGA(2,N),YMHGN(2,N),YMHGO(2,N),YMNAX,
     &        YMNNX,YMNOX,ZMCA(2,N),ZMCO(2,N),ZMCN(2,N),
     &        N,NP_HT )
!
!---      No transition from hydrate conditions + no nonaqueous phases 
!         (40 series -> 40 series)  ---
!
          ELSE
            IF( YMHGA(2,N).GE.MAX( YMHGO(2,N),YMHGN(2,N) ) ) THEN
              NPHAZ(2,N) = 41 + (100*NP_HT)
            ELSEIF( YMHGO(2,N).GE.MAX( YMHGN(2,N),YMHGA(2,N) ) ) THEN
              NPHAZ(2,N) = 42 + (100*NP_HT)
            ELSE
              NPHAZ(2,N) = 43 + (100*NP_HT)
            ENDIF
          ENDIF
        ENDIF
      ENDDO
!
!--- Compute increments  ---
!
      DO N = 1,NFCGC(ID+1)
        IF( IXP(N).EQ.0 ) CYCLE
!
!---    Core phase condition  ---
!
        NPHZX = MOD(NPHAZ(2,N),100)
!
!---    Energy (temperature)  ---
!
        DNR(IEQT,N) = -1.D-7
!
!---    Assign dissolved-salt mass fraction increments,
!       isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          CALL SOL_LS( T(2,N),XLSMX )
          XLSX = MIN( YLS(2,N),XLSMX )
          DNR(IEQS,N) = 1.D-6*XLSMX
        ENDIF
!
!---    Phase condition #10 (10 series)  ---
!
!       SH = 0, SG + SN = 0, SL+SI = 1
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        IF( NPHZX.EQ.10 ) THEN
!
!---      Water mass (pressure), increment  ---
!
          DNR(IEQW,N) = MAX( 1.D-2,1.D-6*PSO(2,N) )
!
!---      Mobile CO2 mass (CO2 vapor pressure), increment  ---
!
          IF( ISLC(45).EQ.0 ) DNR(IEQA,N) = MAX( 1.D-2,1.D-6*PVA(2,N) )
!
!---      Mobile CH4 mass (CH4 vapor pressure), increment  ---
!
          IF( ISLC(64).EQ.0 ) DNR(IEQO,N) = MAX( 1.D-2,1.D-6*PVO(2,N) )
!
!---      Mobile N2 mass (N2 vapor pressure), increment  ---
!
          IF( ISLC(65).EQ.0 ) DNR(IEQN,N) = MAX( 1.D-2,1.D-6*PVN(2,N) )
!
!---      Hydrate CO2 mass (hydrate CO2 mass)  ---
!
          IF( ISLC(45).EQ.0 ) DNR(IEQHA,N) = 1.D-6
!
!---      Hydrate CH4 mass (hydrate CH4 mass)  ---
!
          IF( ISLC(64).EQ.0 ) DNR(IEQHO,N) = 1.D-6
!
!---      Hydrate N2 mass (hydrate N2 mass)  ---
!
          IF( ISLC(65).EQ.0 ) DNR(IEQHN,N) = 1.D-6
!
!---    Phase conditions 21 through 23 (20 series)  ---
!
!       SH = 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation - POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.21 .AND. NPHZX.LE.23  ) THEN
!
!---      Water mass (aqueous + ice saturation), decrement for
!         high saturation, increment for low saturation  ---
!
          DNR(IEQW,N) = SIGN( 1.D-6,(5.D-1-POSM(2,N)) )
!
!---      Mobile CO2 mass (pressure), increment  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( NPHZX.EQ.21 ) THEN
              DNRX = MAX( 1.D-2,1.D-6*ABS(PG(2,N)-PL(2,N)),
     &          1.D-6*ABS(PG(2,N)-PN(2,N)) )
              DNR(IEQA,N) = DNRX
!
!---        Mobile CO2 mass (nonaqueous CO2 mole fraction), increment  ---
!
            ELSE
              DNR(IEQA,N) = SIGN(1.D-7,5.D-1-ZMCA(2,N))
            ENDIF
          ENDIF
!
!---      Mobile CH4 mass (pressure), increment  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( NPHZX.EQ.22 ) THEN
              DNRX = MAX( 1.D-2,1.D-6*ABS(PG(2,N)-PL(2,N)),
     &          1.D-6*ABS(PG(2,N)-PN(2,N)) )
              DNR(IEQO,N) = DNRX
!
!---        Mobile CH4 mass (nonaqueous CH4 mole fraction), increment  ---
!
            ELSE
              DNR(IEQO,N) = SIGN(1.D-7,5.D-1-ZMCO(2,N))
            ENDIF
          ENDIF
!
!---      Mobile N2 mass (pressure), increment  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( NPHZX.EQ.23  ) THEN
              DNRX = MAX( 1.D-2,1.D-6*ABS(PG(2,N)-PL(2,N)),
     &          1.D-6*ABS(PG(2,N)-PN(2,N)) )
              DNR(IEQN,N) = DNRX
!
!---        Mobile N2 mass (nonaqueous N2 mole fraction), increment  ---
!
            ELSE
              DNR(IEQN,N) = SIGN(1.D-7,5.D-1-ZMCN(2,N))
            ENDIF
          ENDIF
!
!---      Hydrate CO2 mass (hydrate CO2 mass)  ---
!
          IF( ISLC(45).EQ.0 ) DNR(IEQHA,N) = 1.D-6
!
!---      Hydrate CH4 mass (hydrate CH4 mass)  ---
!
          IF( ISLC(64).EQ.0 ) DNR(IEQHO,N) = 1.D-6
!
!---      Hydrate N2 mass (hydrate N2 mass)  ---
!
          IF( ISLC(65).EQ.0 ) DNR(IEQHN,N) = 1.D-6
!
!---    Phase conditions #31 through #39 (30 series)  ---
!
!       SH > 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #34
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #35
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #36
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #37
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #38
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #39
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation, POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.39 ) THEN
!
!---      Water mass (aqueous saturation), decrement for
!         high saturation, increment for low saturation  ---
!
          DNR(IEQW,N) = SIGN( 1.D-6,(5.D-1*(1.D+0-SH(2,N))-POSM(2,N)) )
!
!---      Mobile CO2 mass (pressure), increment  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( NPHZX.GE.31 .AND. NPHZX.LE.33  ) THEN
              DNRX = MAX( 1.D-2,1.D-7*ABS(PG(2,N)-PL(2,N)),
     &          1.D-6*ABS(PG(2,N)-PN(2,N)) )
              DNR(IEQA,N) = DNRX
!
!---        Mobile CO2 mass (nonaqueous CO2 mole fraction), increment  ---
!
            ELSE
              DZMCX = MAX( MIN( 1.D-7,1.D-4*ZMCA(2,N) ),1.D-14 )
              DNR(IEQA,N) = SIGN(DZMCX,5.D-1-ZMCA(2,N))
            ENDIF
          ENDIF
!
!---      Mobile CH4 mass (pressure), increment  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( NPHZX.GE.34 .AND. NPHZX.LE.36  ) THEN
              DNRX = MAX( 1.D-2,1.D-7*ABS(PG(2,N)-PL(2,N)),
     &          1.D-6*ABS(PG(2,N)-PN(2,N)) )
              DNR(IEQO,N) = DNRX
!
!---        Mobile CH4 mass (nonaqueous CH4 mole fraction), increment  ---
!
            ELSE
              DZMCX = MAX( MIN( 1.D-7,1.D-4*ZMCO(2,N) ),1.D-14 )
              DNR(IEQO,N) = SIGN(DZMCX,5.D-1-ZMCO(2,N))
            ENDIF
          ENDIF
!
!---      Mobile N2 mass (pressure), increment  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( NPHZX.GE.37 .AND. NPHZX.LE.39  ) THEN
              DNRX = MAX( 1.D-2,1.D-7*ABS(PG(2,N)-PL(2,N)),
     &          1.D-6*ABS(PG(2,N)-PN(2,N)) )
              DNR(IEQN,N) = DNRX
!
!---        Mobile N2 mass (nonaqueous N2 mole fraction), increment  ---
!
            ELSE
              DZMCX = MAX( MIN( 1.D-7,1.D-4*ZMCN(2,N) ),1.D-14 )
              DNR(IEQN,N) = SIGN(DZMCX,5.D-1-ZMCN(2,N))
            ENDIF
          ENDIF
!
!---      Hydrate CO2 mass (hydrate saturation)  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( NPHZX.EQ.31 .OR. NPHZX.EQ.34 .OR. NPHZX.EQ.37 ) THEN
              DSHX = MAX( MIN( 1.D-7,1.D-4*SH(2,N) ),1.D-14 )
              DNR(IEQHA,N) = SIGN(DSHX,5.D-1-SH(2,N))
!
!---        Hydrate CO2 mass (hydrate CO2 mole fraction of formers)  ---
!
            ELSE
              DYMHX = MAX( MIN( 1.D-7,1.D-4*YMHGA(2,N) ),1.D-14 )
              DNR(IEQHA,N) = SIGN(DYMHX,5.D-1-YMHGA(2,N))
            ENDIF
          ENDIF
!
!---      Hydrate CH4 mass (hydrate saturation)  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( NPHZX.EQ.32 .OR. NPHZX.EQ.35 .OR. NPHZX.EQ.38 ) THEN
              DSHX = MAX( MIN( 1.D-7,1.D-4*SH(2,N) ),1.D-14 )
              DNR(IEQHO,N) = SIGN(DSHX,5.D-1-SH(2,N))
!
!---        Hydrate CH4 mass (hydrate CO2 mole fraction of formers)  ---
!
            ELSE
              DYMHX = MAX( MIN( 1.D-7,1.D-4*YMHGO(2,N) ),1.D-14 )
              DNR(IEQHO,N) = SIGN(DYMHX,5.D-1-YMHGO(2,N))
            ENDIF
          ENDIF
!
!---      Hydrate N2 mass (hydrate saturation)  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( NPHZX.EQ.33 .OR. NPHZX.EQ.36 .OR. NPHZX.EQ.39 ) THEN
              DSHX = MAX( MIN( 1.D-7,1.D-4*SH(2,N) ),1.D-14 )
              DNR(IEQHN,N) = SIGN(DSHX,5.D-1-SH(2,N))
!
!---        Hydrate N2 mass (hydrate CO2 mole fraction of formers)  ---
!
            ELSE
              DYMHX = MAX( MIN( 1.D-7,1.D-4*YMHGN(2,N) ),1.D-14 )
              DNR(IEQHN,N) = SIGN(DYMHX,5.D-1-YMHGN(2,N))
            ENDIF
          ENDIF
!
!---    Phase conditions #41 through #43 (40 series)  ---
!
!       SH > 0, SG + SN = 0, SL + SI < 1
!       YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!       YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!       YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
!
!---      Water mass (pressure), increment  ---
!
          DNR(IEQW,N) = MAX( 1.D-2,1.D-8*PSO(2,N) )
!
!---      Mobile CO2 mass (CO2 vapor pressure), increment  ---
!
          IF( ISLC(45).EQ.0 ) DNR(IEQA,N) = MAX( 1.D-2,1.D-8*PVA(2,N) )
!
!---      Mobile CH4 mass (CH4 vapor pressure), increment  ---
!
          IF( ISLC(64).EQ.0 ) DNR(IEQO,N) = MAX( 1.D-2,1.D-8*PVO(2,N) )
!
!---      Mobile N2 mass (N2 vapor pressure), increment  ---
!
          IF( ISLC(65).EQ.0 ) DNR(IEQN,N) = MAX( 1.D-2,1.D-8*PVN(2,N) )
!
!---      Hydrate CO2 mass (hydrate saturation)  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( NPHZX.EQ.41 ) THEN
              DSHX = MAX( MIN( 1.D-7,1.D-4*SH(2,N) ),1.D-14 )
              DNR(IEQHA,N) = SIGN(DSHX,5.D-1-SH(2,N))
!
!---        Hydrate CO2 mass (hydrate CO2 mole fraction of formers)  ---
!
            ELSE
              DYMHX = MAX( MIN( 1.D-7,1.D-4*YMHGA(2,N) ),1.D-14 )
              DNR(IEQHA,N) = SIGN(DYMHX,5.D-1-YMHGA(2,N))
            ENDIF
          ENDIF
!
!---      Hydrate CH4 mass (hydrate saturation)  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( NPHZX.EQ.42 ) THEN
              DSHX = MAX( MIN( 1.D-7,1.D-4*SH(2,N) ),1.D-14 )
              DNR(IEQHO,N) = SIGN(DSHX,5.D-1-SH(2,N))
!
!---        Hydrate CH4 mass (hydrate CO2 mole fraction of formers)  ---
!
            ELSE
              DYMHX = MAX( MIN( 1.D-7,1.D-4*YMHGO(2,N) ),1.D-14 )
              DNR(IEQHO,N) = SIGN(DYMHX,5.D-1-YMHGO(2,N))
            ENDIF
          ENDIF
!
!---      Hydrate N2 mass (hydrate saturation)  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( NPHZX.EQ.43 ) THEN
              DSHX = MAX( MIN( 1.D-7,1.D-4*SH(2,N) ),1.D-14 )
              DNR(IEQHN,N) = SIGN(DSHX,5.D-1-SH(2,N))
!
!---        Hydrate N2 mass (hydrate CO2 mole fraction of formers)  ---
!
            ELSE
              DYMHX = MAX( MIN( 1.D-7,1.D-4*YMHGN(2,N) ),1.D-14 )
              DNR(IEQHN,N) = SIGN(DYMHX,5.D-1-YMHGN(2,N))
            ENDIF
          ENDIF
        ENDIF
!
!---    Increment the primary variables  ---
!
        DO M = 3,ISVC+2
          T(M,N) = T(2,N)
          PL(M,N) = PL(2,N)
          PSO(M,N) = PSO(2,N)
          PVO(M,N) = PVO(2,N)
          PVA(M,N) = PVA(2,N)
          PVN(M,N) = PVN(2,N)
          SH(M,N) = SH(2,N)
          SL(M,N) = SL(2,N)
          POSM(M,N) = POSM(2,N)
          YLS(M,N) = YLS(2,N)
          YMHGA(M,N) = YMHGA(2,N)
          YMHGO(M,N) = YMHGO(2,N)
          YMHGN(M,N) = YMHGN(2,N)
          TMHA(M,N) = TMHA(2,N)
          TMHO(M,N) = TMHO(2,N)
          TMHN(M,N) = TMHN(2,N)
          ZMCA(M,N) = ZMCA(2,N)
          ZMCO(M,N) = ZMCO(2,N)
          ZMCN(M,N) = ZMCN(2,N)
!
!---      Phase condition #10 (10 series)  ---
!
!         SH = 0, SG + SN = 0, SL + SI = 1
!
!         energy - temperature, C - T
!         water mass - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!         mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!         mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!         hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!         hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!         hydrate N2 mass - hydrate N2 mass, kg - TMHN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          IF( NPHZX.EQ.10 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQA+2 ) THEN
              PVA(M,N) = PVA(M,N) + DNR(IEQA,N)
            ELSEIF( M.EQ.IEQO+2 ) THEN
              PVO(M,N) = PVO(M,N) + DNR(IEQO,N)
            ELSEIF( M.EQ.IEQN+2  ) THEN
              PVN(M,N) = PVN(M,N) + DNR(IEQN,N)
            ELSEIF( M.EQ.IEQHA+2 ) THEN
              TMHA(M,N) = TMHA(M,N) + DNR(IEQHA,N)
            ELSEIF( M.EQ.IEQHO+2 ) THEN
              TMHO(M,N) = TMHO(M,N) + DNR(IEQHO,N)
            ELSEIF( M.EQ.IEQHN+2 ) THEN
              TMHN(M,N) = TMHN(M,N) + DNR(IEQHN,N)
            ELSEIF( M.EQ.IEQS+2 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Phase conditions 21 through 23 (20 series)  ---
!
!         SH = 0, SG + SN > 0, SL + SI < 1
!         ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!         ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!         ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
!         energy - temperature, C - T
!         water mass - aqueous + ice saturation - POSM
!         maximum mobile mass component - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!         mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!         mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!         hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!         hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!         hydrate N2 mass - hydrate N2 mass, kg - TMHN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.21 .AND. NPHZX.LE.23  ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              POSM(M,N) = POSM(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQA+2 ) THEN
              IF( NPHZX.EQ.21 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQA,N)
              ELSE
                ZMCA(M,N) = ZMCA(M,N) + DNR(IEQA,N)
              ENDIF
            ELSEIF( M.EQ.IEQO+2 ) THEN
              IF( NPHZX.EQ.22 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQO,N)
              ELSE
                ZMCO(M,N) = ZMCO(M,N) + DNR(IEQO,N)
              ENDIF
            ELSEIF( M.EQ.IEQN+2 ) THEN
              IF( NPHZX.EQ.23 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQN,N)
              ELSE
                ZMCN(M,N) = ZMCN(M,N) + DNR(IEQN,N)
              ENDIF
            ELSEIF( M.EQ.IEQHA+2 ) THEN
              TMHA(M,N) = TMHA(M,N) + DNR(IEQHA,N)
            ELSEIF( M.EQ.IEQHO+2 ) THEN
              TMHO(M,N) = TMHO(M,N) + DNR(IEQHO,N)
            ELSEIF( M.EQ.IEQHN+2 ) THEN
              TMHN(M,N) = TMHN(M,N) + DNR(IEQHN,N)
            ELSEIF( M.EQ.IEQS+2 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Phase conditions #31 through #39 (30 series)  ---
!
!         SH > 0, SG + SN > 0, SL + SI < 1
!         ZMCA = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33
!         ZMCO = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #34
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #35
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #36
!         ZMCN = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #37
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #38
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #39
!
!         energy - temperature, C - T
!         water mass - aqueous + ice saturation, POSM
!         maximum mobile mass component - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!         mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!         mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!         maximum hydrate mass component - hydrate saturation - SH
!         hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!         hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!         hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.39 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              POSM(M,N) = POSM(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQA+2 ) THEN
              IF( NPHZX.GE.31 .AND. NPHZX.LE.33 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQA,N)
              ELSE
                ZMCA(M,N) = ZMCA(M,N) + DNR(IEQA,N)
              ENDIF
            ELSEIF( M.EQ.IEQO+2 ) THEN
              IF( NPHZX.GE.34 .AND. NPHZX.LE.36 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQO,N)
              ELSE
                ZMCO(M,N) = ZMCO(M,N) + DNR(IEQO,N)
              ENDIF
            ELSEIF( M.EQ.IEQN+2 ) THEN
              IF( NPHZX.GE.37 .AND. NPHZX.LE.39 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQN,N)
              ELSE
                ZMCN(M,N) = ZMCN(M,N) + DNR(IEQN,N)
              ENDIF
            ELSEIF( M.EQ.IEQHA+2 ) THEN
              IF( NPHZX.EQ.31 .OR. NPHZX.EQ.34 .OR. NPHZX.EQ.37 ) THEN
                SH(M,N) = SH(M,N) + DNR(IEQHA,N)
              ELSE
                YMHGA(M,N) = YMHGA(M,N) + DNR(IEQHA,N)
              ENDIF
            ELSEIF( M.EQ.IEQHO+2 ) THEN
              IF( NPHZX.EQ.32 .OR. NPHZX.EQ.35 .OR. NPHZX.EQ.38 ) THEN
                SH(M,N) = SH(M,N) + DNR(IEQHO,N)
              ELSE
                YMHGO(M,N) = YMHGO(M,N) + DNR(IEQHO,N)
              ENDIF
            ELSEIF( M.EQ.IEQHN+2 ) THEN
              IF( NPHZX.EQ.33 .OR. NPHZX.EQ.36 .OR. NPHZX.EQ.39 ) THEN
                SH(M,N) = SH(M,N) + DNR(IEQHN,N)
              ELSE
                YMHGN(M,N) = YMHGN(M,N) + DNR(IEQHN,N)
              ENDIF           
            ELSEIF( M.EQ.IEQS+2 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Phase conditions #41 through #43 (40 series)  ---
!
!         SH > 0, SG + SN = 0, SL + SI < 1
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
!         energy - temperature, C - T
!         water mass - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!         mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!         mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!         maximum hydrate mass component - hydrate saturation - SH
!         hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!         hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!         hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQA+2 ) THEN
              PVA(M,N) = PVA(M,N) + DNR(IEQA,N)
            ELSEIF( M.EQ.IEQO+2 ) THEN
              PVO(M,N) = PVO(M,N) + DNR(IEQO,N)
            ELSEIF( M.EQ.IEQN+2  ) THEN
              PVN(M,N) = PVN(M,N) + DNR(IEQN,N)
            ELSEIF( M.EQ.IEQHA+2 ) THEN
              IF( NPHZX.EQ.41 ) THEN
                SH(M,N) = SH(M,N) + DNR(IEQHA,N)
              ELSE
                YMHGA(M,N) = YMHGA(M,N) + DNR(IEQHA,N)
              ENDIF
            ELSEIF( M.EQ.IEQHO+2 ) THEN
              IF( NPHZX.EQ.42 ) THEN
                SH(M,N) = SH(M,N) + DNR(IEQHO,N)
              ELSE
                YMHGO(M,N) = YMHGO(M,N) + DNR(IEQHO,N)
              ENDIF
            ELSEIF( M.EQ.IEQHN+2 ) THEN
              IF( NPHZX.EQ.43 ) THEN
                SH(M,N) = SH(M,N) + DNR(IEQHN,N)
              ELSE
                YMHGN(M,N) = YMHGN(M,N) + DNR(IEQHN,N)
              ENDIF           
            ELSEIF( M.EQ.IEQS+2 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of INCRM_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LDO_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Load the current time step values into the old time step
!     variables.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE HYST
      USE GRID
      USE FDVP
      USE FDVH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LDO_HYDT_KE'
!
!---  Assign old time step values  ---
!
      DO N = 1,NFCGC(ID+1)
        DFGA(1,N) = DFGA(2,N)
        DFGO(1,N) = DFGO(2,N)
        DFGW(1,N) = DFGW(2,N)
        DFLA(1,N) = DFLA(2,N)
        DFLO(1,N) = DFLO(2,N)
        DFLN(1,N) = DFLN(2,N)
        DFNO(1,N) = DFNO(2,N)
        DFNN(1,N) = DFNN(2,N)
        DFNW(1,N) = DFNW(2,N)
        NPHAZ(1,N) = NPHAZ(2,N)
        PSO(1,N) = PSO(2,N)
        PG(1,N) = PG(2,N)
        PH(1,N) = PH(2,N)
        PI(1,N) = PI(2,N)
        PL(1,N) = PL(2,N)
        PN(1,N) = PN(2,N)
        PORD(1,N) = PORD(2,N)
        PORT(1,N) = PORT(2,N)
        PVA(1,N) = PVA(2,N)
        PVO(1,N) = PVO(2,N)
        PVN(1,N) = PVN(2,N)
        PVW(1,N) = PVW(2,N)
        PVHA(1,N) = PVHA(2,N)
        PVHO(1,N) = PVHO(2,N)
        PVHN(1,N) = PVHN(2,N)
        TMHA(1,N) = TMHA(2,N)
        TMHO(1,N) = TMHO(2,N)
        TMHN(1,N) = TMHN(2,N)
        TMBP_A(1,N) = TMBP_A(2,N)
        TMBP_O(1,N) = TMBP_O(2,N)
        TMBP_N(1,N) = TMBP_N(2,N)
        RHOG(1,N) = RHOG(2,N)
        RHOH(1,N) = RHOH(2,N)
        RHOI(1,N) = RHOI(2,N)
        RHOL(1,N) = RHOL(2,N)
        RHON(1,N) = RHON(2,N)
        RHOSP(1,N) = RHOSP(2,N)
        RKG(1,N) = RKG(2,N)
        RKL(1,N) = RKL(2,N)
        RKN(1,N) = RKN(2,N)
        TMS(1,N) = TMS(2,N)
        SH(1,N) = SH(2,N)
        SI(1,N) = SI(2,N)
        SG(1,N) = SG(2,N)
        SL(1,N) = SL(2,N)
        POSM(1,N) = POSM(2,N)
        SS(1,N) = SS(2,N)
        SN(1,N) = SN(2,N)
        T(1,N) = T(2,N)
        TORG(1,N) = TORG(2,N)
        TORL(1,N) = TORL(2,N)
        TORN(1,N) = TORN(2,N)
        VISG(1,N) = VISG(2,N)
        VISL(1,N) = VISL(2,N)
        VISN(1,N) = VISN(2,N)
        XGA(1,N) = XGA(2,N)
        XGO(1,N) = XGO(2,N)
        XGN(1,N) = XGN(2,N)
        XGW(1,N) = XGW(2,N)
        XHA(1,N) = XHA(2,N)
        XHO(1,N) = XHO(2,N)
        XHN(1,N) = XHN(2,N)
        XHW(1,N) = XHW(2,N)
        XLA(1,N) = XLA(2,N)
        XLO(1,N) = XLO(2,N)
        XLN(1,N) = XLN(2,N)
        XLS(1,N) = XLS(2,N)
        XLW(1,N) = XLW(2,N)
        XNA(1,N) = XNA(2,N)
        XNN(1,N) = XNN(2,N)
        XNO(1,N) = XNO(2,N)
        XNW(1,N) = XNW(2,N)
        XMGA(1,N) = XMGA(2,N)
        XMGO(1,N) = XMGO(2,N)
        XMGN(1,N) = XMGN(2,N)
        XMGW(1,N) = XMGW(2,N)
        XMLA(1,N) = XMLA(2,N)
        XMLO(1,N) = XMLO(2,N)
        XMLN(1,N) = XMLN(2,N)
        XMLW(1,N) = XMLW(2,N)
        XMNA(1,N) = XMNA(2,N)
        XMNN(1,N) = XMNN(2,N)
        XMNO(1,N) = XMNO(2,N)
        XMNW(1,N) = XMNW(2,N)
        YLS(1,N) = YLS(2,N)
        YMGA(1,N) = YMGA(2,N)
        YMGO(1,N) = YMGO(2,N)
        YMGN(1,N) = YMGN(2,N)
        YMHGA(1,N) = YMHGA(2,N)
        YMHGO(1,N) = YMHGO(2,N)
        YMHGN(1,N) = YMHGN(2,N)
        HGA(1,N) = HGA(2,N)
        HGO(1,N) = HGO(2,N)
        HGW(1,N) = HGW(2,N)
        HG(1,N) = HG(2,N)
        HLW(1,N) = HLW(2,N)
        HL(1,N) = HL(2,N)
        HH(1,N) = HH(2,N)
        HI(1,N) = HI(2,N)
        HN(1,N) = HN(2,N)
        HSP(1,N) = HSP(2,N)
        THKL(1,N) = THKL(2,N)
        THKG(1,N) = THKG(2,N)
        THKN(1,N) = THKN(2,N)
        THKH(1,N) = THKH(2,N)
        THKI(1,N) = THKI(2,N)
        UEG(1,N) = UEG(2,N)
        UEL(1,N) = UEL(2,N)
        UEN(1,N) = UEN(2,N)
        ZMCA(1,N) = ZMCA(2,N)
        ZMCO(1,N) = ZMCO(2,N)
        ZMCN(1,N) = ZMCN(2,N)
        DO NSL = 1,NSOLU+NEQC+NEQK
          CO(N,NSL) = C(N,NSL)
        ENDDO
        DO NEQ = 1,NEQC+NEQK
          NSL = NEQ + NSOLU 
          CO(N,NSL) = C(N,NSL)
        ENDDO
        DO NSP = 1,NSPR
          SP_CO(N,NSP) = SP_C(N,NSP)
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LDO_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE PROP_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute primary variable increments.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE PROP
      USE NAPL
      USE MPI
      USE HYST
      USE HYDT
      USE GLB_PAR
      USE GRID
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 PHIX(LHF_HT+1,LHF_HT+1)
      REAL*8 HIDX(LHF_HT),HRESX(LHF_HT),XMGX(LHF_HT),XMNX(LHF_HT)
      REAL*8 SP_AREAX,RDMX
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/PROP_HYDT_KE'
!
!---  Loop over all nodes, skipping inactive nodes  ---
!
      DO N = 1,NFCGC(ID+1)
        IF( IXP(N).EQ.0 ) CYCLE
        IF( NITER.LE.3 ) THEN
          ZMIH_HT(1) = YMHGA(2,N)
          ZMIH_HT(2) = YMHGO(2,N)
          ZMIH_HT(3) = YMHGN(2,N)
          SNR(1,N) = YMHGA(2,N)
          SNR(2,N) = YMHGO(2,N)
          SNR(3,N) = YMHGN(2,N)
        ELSE
          ZMIH_HT(1) = SNR(1,N)
          ZMIH_HT(2) = SNR(2,N)
          ZMIH_HT(3) = SNR(3,N)
        ENDIF
!
!---    Core phase condition  ---
!
        NPHZX = MOD(NPHAZ(2,N),100)
!
!---    Loop over increment indices  ---
!
        DO M = 2,ISVC+2
          TKX = T(M,N) + TABS
!
!---      Phase condition #10 (10 series)  ---
!
!         SH = 0, SG + SN = 0, SL + SI = 1
!
!         energy - temperature, C - T
!         water mass - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!         mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!         mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!         hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!         hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!         hydrate N2 mass - hydrate N2 mass, kg - TMHN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          IF( NPHZX.EQ.10 ) THEN
            CALL FLH_PC10( PH(M,N),PG(M,N),PI(M,N),PL(M,N),PN(M,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(M,N),PVA(M,N),PVHA(M,N),PVN(M,N),
     &        PVHN(M,N),PVO(M,N),PVHO(M,N),PVW(M,N),RHOG(M,N),RHOH(M,N),
     &        RHON(M,N),RKG(M,N),RKL(M,N),RKN(M,N),SH(M,N),
     &        SI(M,N),SG(M,N),SL(M,N),SLIX,SN(M,N),T(M,N),TCR(N),
     &        TCT(N),TEQHX,XGA(M,N),
     &        XGN(M,N),XGO(M,N),XGW(M,N),XHA(M,N),XHN(M,N),XHO(M,N),
     &        XHW(M,N),XNA(M,N),XNN(M,N),XNO(M,N),XNW(M,N),XMLA(M,N),
     &        XMLN(M,N),XMLO(M,N),XLS(M,N),YLS(M,N),YMGA(M,N),
     &        YMGN(M,N),YMGO(M,N),YMHGA(M,N),YMHGN(M,N),YMHGO(M,N),
     &        YMNAX,YMNNX,YMNOX,ZMCA(M,N),ZMCO(M,N),ZMCN(M,N),
     &        N,NP_HT )
            POSM(M,N) = SL(M,N) + SI(M,N)
!
!---      Phase conditions 21 through 23 (20 series)  ---
!
!         SH = 0, SG + SN > 0, SL + SI < 1
!         ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!         ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!         ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
!         energy - temperature, C - T
!         water mass - aqueous + ice saturation - POSM
!         maximum mobile mass component - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!         mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!         mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!         hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!         hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!         hydrate N2 mass - hydrate N2 mass, kg - TMHN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.21 .AND. NPHZX.LE.23  ) THEN
            IF( NPHZX.EQ.21 ) THEN
              ZMCA(M,N) = MIN( 1.D+0-ZMCO(M,N)-ZMCN(M,N),1.D+0 )
              IF( ZMCA(M,N).LT.EPSL ) ZMCA(M,N) = 0.D+0
            ELSEIF( NPHZX.EQ.22 ) THEN
              ZMCO(M,N) = MIN( 1.D+0-ZMCA(M,N)-ZMCN(M,N),1.D+0 )
              IF( ZMCO(M,N).LT.EPSL ) ZMCO(M,N) = 0.D+0
            ELSE
              ZMCN(M,N) = MIN( 1.D+0-ZMCA(M,N)-ZMCO(M,N),1.D+0 )
              IF( ZMCN(M,N).LT.EPSL ) ZMCN(M,N) = 0.D+0
            ENDIF
            SLIX = POSM(M,N)
            CALL FLH_PC20( PH(M,N),PG(M,N),PI(M,N),PL(M,N),PN(M,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(M,N),PVA(M,N),PVHA(M,N),PVN(M,N),
     &        PVHN(M,N),PVO(M,N),PVHO(M,N),PVW(M,N),RHOG(M,N),RHOH(M,N),
     &        RKG(M,N),RKL(M,N),RKN(M,N),SH(M,N),
     &        SI(M,N),SG(M,N),SL(M,N),SLIX,SN(M,N),T(M,N),TCR(N),
     &        TCT(N),TEQHX,XGA(M,N),
     &        XGN(M,N),XGO(M,N),XGW(M,N),XHA(M,N),XHN(M,N),XHO(M,N),
     &        XHW(M,N),XNA(M,N),XNN(M,N),XNO(M,N),XNW(M,N),XMLA(M,N),
     &        XMLN(M,N),XMLO(M,N),XLS(M,N),YLS(M,N),YMGA(M,N),
     &        YMGN(M,N),YMGO(M,N),YMHGA(M,N),YMHGN(M,N),YMHGO(M,N),
     &        YMNAX,YMNNX,YMNOX,ZMCA(M,N),ZMCO(M,N),ZMCN(M,N),
     &        N,NP_HT )
!
!---      Phase conditions #31 through #39 (30 series)  ---
!
!         SH > 0, SG + SN > 0, SL + SI < 1
!         ZMCA = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33
!         ZMCO = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #34
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #35
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #36
!         ZMCN = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #37
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #38
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #39
!
!         energy - temperature, C - T
!         water mass - aqueous + ice saturation, POSM
!         maximum mobile mass component - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!         mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!         mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!         maximum hydrate mass component - hydrate saturation - SH
!         hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!         hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!         hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.39 ) THEN
            IF( NPHZX.GE.31 .AND. NPHZX.LE.33 ) THEN
              ZMCA(M,N) = MIN( 1.D+0-ZMCO(M,N)-ZMCN(M,N),1.D+0 )
              IF( ZMCA(M,N).LT.EPSL ) ZMCA(M,N) = 0.D+0
            ELSEIF( NPHZX.GE.34 .AND. NPHZX.LE.36 ) THEN
              ZMCO(M,N) = MIN( 1.D+0-ZMCA(M,N)-ZMCN(M,N),1.D+0 )
              IF( ZMCO(M,N).LT.EPSL ) ZMCO(M,N) = 0.D+0
            ELSE
              ZMCN(M,N) = MIN( 1.D+0-ZMCA(M,N)-ZMCO(M,N),1.D+0 )
              IF( ZMCN(M,N).LT.EPSL ) ZMCN(M,N) = 0.D+0
            ENDIF
            IF( NPHZX.EQ.31 .OR. NPHZX.EQ.34 .OR. NPHZX.EQ.37 ) THEN
              YMHGA(M,N) = MIN( 1.D+0-YMHGO(M,N)-YMHGN(M,N),1.D+0 )
              IF( YMHGA(M,N).LT.EPSL ) YMHGA(M,N) = 0.D+0
            ELSEIF( NPHZX.EQ.32 .OR. NPHZX.EQ.35 .OR. NPHZX.EQ.38 )THEN
              YMHGO(M,N) = MIN( 1.D+0-YMHGA(M,N)-YMHGN(M,N),1.D+0 )
              IF( YMHGO(M,N).LT.EPSL ) YMHGO(M,N) = 0.D+0
            ELSE
              YMHGN(M,N) = MIN( 1.D+0-YMHGA(M,N)-YMHGO(M,N),1.D+0 )
              IF( YMHGN(M,N).LT.EPSL ) YMHGN(M,N) = 0.D+0
            ENDIF
            SLIX = POSM(M,N)
            CALL FLH_PC30( PH(M,N),PG(M,N),PI(M,N),PL(M,N),PN(M,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(M,N),PVA(M,N),PVHA(M,N),PVN(M,N),
     &        PVHN(M,N),PVO(M,N),PVHO(M,N),PVW(M,N),RHOG(M,N),RHOH(M,N),
     &        RHON(M,N),RKG(M,N),RKL(M,N),RKN(M,N),SH(M,N),
     &        SI(M,N),SG(M,N),SL(M,N),SLIX,SN(M,N),T(M,N),TCR(N),
     &        TCT(N),TEQHX,TMHA(M,N),TMHN(M,N),TMHO(M,N),XGA(M,N),
     &        XGN(M,N),XGO(M,N),XGW(M,N),XHA(M,N),XHN(M,N),XHO(M,N),
     &        XHW(M,N),XNA(M,N),XNN(M,N),XNO(M,N),XNW(M,N),XMLA(M,N),
     &        XMLN(M,N),XMLO(M,N),XLS(M,N),YLS(M,N),YMGA(M,N),
     &        YMGN(M,N),YMGO(M,N),YMHGA(M,N),YMHGN(M,N),YMHGO(M,N),
     &        YMNAX,YMNNX,YMNOX,ZMCA(M,N),ZMCO(M,N),ZMCN(M,N),
     &        N,NP_HT )
!
!---      Phase conditions #41 through #43 (40 series)  ---
!
!         SH > 0, SG + SN = 0, SL + SI < 1
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
!         energy - temperature, C - T
!         water mass - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!         mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!         mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!         maximum hydrate mass component - hydrate saturation - SH
!         hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!         hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!         hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
            IF( NPHZX.EQ.41 ) THEN
              YMHGA(M,N) = MIN( 1.D+0-YMHGO(M,N)-YMHGN(M,N),1.D+0 )
              IF( YMHGA(M,N).LT.EPSL ) YMHGA(M,N) = 0.D+0
            ELSEIF( NPHZX.EQ.42 )THEN
              YMHGO(M,N) = MIN( 1.D+0-YMHGA(M,N)-YMHGN(M,N),1.D+0 )
              IF( YMHGO(M,N).LT.EPSL ) YMHGO(M,N) = 0.D+0
            ELSE
              YMHGN(M,N) = MIN( 1.D+0-YMHGA(M,N)-YMHGO(M,N),1.D+0 )
              IF( YMHGN(M,N).LT.EPSL ) YMHGN(M,N) = 0.D+0
            ENDIF
            CALL FLH_PC40( PH(M,N),PG(M,N),PI(M,N),PL(M,N),PN(M,N),
     &        PPEL(N),PPEU(N),PSBX,PSO(M,N),PVA(M,N),PVHA(M,N),PVN(M,N),
     &        PVHN(M,N),PVO(M,N),PVHO(M,N),PVW(M,N),RHOG(M,N),RHOH(M,N),
     &        RHON(M,N),RKG(M,N),RKL(M,N),RKN(M,N),SH(M,N),
     &        SI(M,N),SG(M,N),SL(M,N),SLIX,SN(M,N),T(M,N),TCR(N),
     &        TCT(N),TEQHX,TMHA(M,N),TMHN(M,N),TMHO(M,N),XGA(M,N),
     &        XGN(M,N),XGO(M,N),XGW(M,N),XHA(M,N),XHN(M,N),XHO(M,N),
     &        XHW(M,N),XNA(M,N),XNN(M,N),XNO(M,N),XNW(M,N),XMLA(M,N),
     &        XMLN(M,N),XMLO(M,N),XLS(M,N),YLS(M,N),YMGA(M,N),
     &        YMGN(M,N),YMGO(M,N),YMHGA(M,N),YMHGN(M,N),YMHGO(M,N),
     &        YMNAX,YMNNX,YMNOX,ZMCA(M,N),ZMCO(M,N),ZMCN(M,N),
     &        N,NP_HT )
            POSM(M,N) = SL(M,N) + SI(M,N)
          ENDIF
!
!---      Absolute system and gas pressure  ---
!
          PX = PSO(M,N) + PATM
          PVX = PVA(M,N)+PVO(M,N)+PVN(M,N)+PVW(M,N)
          PVMX = PVA(M,N)+PVO(M,N)+PVN(M,N)
          PVHX = PVHA(M,N)+PVHO(M,N)+PVHN(M,N)
!
!---      Aqueous component fractions and density  ---
!
          WTMLX = (XMLA(M,N)*WTMA + XMLO(M,N)*WTMO + XMLN(M,N)*WTMN +
     &      WTMW*(1.D+0-XMLA(M,N)-XMLO(M,N)-XMLN(M,N)))/
     &      (1.D+0-XLS(M,N)+WTMW*XLS(M,N)/WTMS)
          XLA(M,N) = XMLA(M,N)*WTMA/WTMLX
          XLO(M,N) = XMLO(M,N)*WTMO/WTMLX
          XLN(M,N) = XMLN(M,N)*WTMN/WTMLX
          CALL DENS_B( T(M,N),PX,XLS(M,N),RHOBX )
          CALL DENS_L( T(M,N),RHOBX,XLA(M,N),XLO(M,N),XLN(M,N),
     &      RHOL(M,N) )
          XLW(M,N) = 1.D+0-XLA(M,N)-XLO(M,N)-XLN(M,N)-XLS(M,N)
          IF( XLW(M,N).LT.EPSL ) XLW(M,N) = 0.D+0
          XMLS(M,N) = WTMLX*XLS(M,N)/WTMS
          XMLW(M,N) = WTMLX*XLW(M,N)/WTMW
!
!---      Aqueous molar density  ---
!
          RHOML(M,N) = RHOL(M,N)/WTMLX
!
!---      Ice density kg/m^3  ---
!
          CALL DENS_I( T(M,N),RHOI(M,N) )
!
!---      Porous-media porosity  ---
!
          PPX = MAX( PG(M,N),PL(M,N),PN(M,N) ) + PATM
          CALL PORSTY( N,PPX,PCMP(N),PORD(M,N),
     &      PORT(M,N),SH(M,N) )
          PORD(M,N) = MAX( PORD(M,N),EPSL )
          PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---      Gas molar fractions and density  ---
!
          RHOGAX = XGA(M,N)*RHOG(M,N)
          RHOGOX = XGO(M,N)*RHOG(M,N)
          RHOGNX = XGN(M,N)*RHOG(M,N)
          RHOGWX = XGW(M,N)*RHOG(M,N)
          WTMGX = 1.D+0/(XGA(M,N)/WTMA + XGO(M,N)/WTMO + XGN(M,N)/WTMN
     &      + XGW(M,N)/WTMW)
          XMGA(M,N) = XGA(M,N)*WTMGX/WTMA
          XMGO(M,N) = XGO(M,N)*WTMGX/WTMO
          XMGN(M,N) = XGN(M,N)*WTMGX/WTMN
          XMGW(M,N) = XGW(M,N)*WTMGX/WTMW
          RHOMG(M,N) = RHOG(M,N)/WTMGX
!
!---      Gas viscosity, Pa s  ---
!
          RHOGAX = RHOMG(M,N)*WTMA
          CALL VISC_CO2( T(M,N),RHOGAX,VISGAX )
          RHOGOX = RHOMG(M,N)*WTMO
          CALL VISC_CH4( T(M,N),RHOGOX,VISGOX )
          RHOGNX = RHOMG(M,N)*WTMN
          CALL VISC_N2( T(M,N),RHOGNX,VISGNX )
          RHOGWX = RHOMG(M,N)*WTMW
          CALL VISC_W( T(M,N),PX,RHOGWX,VISGWX )
          CALL VISC_G( PHIX,VISGAX,VISGOX,VISGNX,VISGWX,XMGA(M,N),
     &      XMGO(M,N),XMGN(M,N),XMGW(M,N),VISG(M,N) )
!
!---      Gas diffusion coefficients  ---
!
          IF( ISLC(2).EQ.1 ) THEN
            DFGA(M,N) = DFGAC
            DFGO(M,N) = DFGOC
            DFGN(M,N) = DFGNC
            DFGW(M,N) = DFGWC
          ELSEIF( ISLC(2).EQ.2 ) THEN
            CALL DIFC_G( T(M,N),PX,DFGA(M,N),DFGO(M,N),DFGN(M,N),
     &        DFGW(M,N),XMGA(M,N),XMGO(M,N),XMGN(M,N),XMGW(M,N) )
          ENDIF
!
!---      Aqueous viscosity  ---
!
          ISRX = 1
          CALL DENS_W( T(M,N),PX,RHOLWX,RHOX,ISRX )
          CALL VISC_W( T(M,N),PX,RHOLWX,VISLWX )
          CALL VISC_B( T(M,N),XLS(M,N),VISLWX,VISBX )
          CALL VISC_L( XMLA(M,N),XMLO(M,N),XMLN(M,N),
     &      VISBX,VISGAX,VISGOX,VISGNX,VISL(M,N) )
!
!---      Aqueous diffusion coefficients  ---
!
          IF( ISLC(4).EQ.1 ) THEN
            DFLA(M,N) = DFLAC
            DFLO(M,N) = DFLOC
            DFLN(M,N) = DFLNC
            DFLS(M,N) = DFLSC
          ELSEIF( ISLC(4).EQ.2 ) THEN
            CALL DIFC_LA( T(M,N),VISL(M,N),VISGAX,DFLA(M,N) )
            CALL DIFC_LO( T(M,N),VISL(M,N),DFLO(M,N) )
            CALL DIFC_LN( T(M,N),VISL(M,N),DFLN(M,N) )
            CALL DIFC_LS( T(M,N),XLS(M,N),VISL(M,N),DFLS(M,N) )
          ENDIF
!
!---      Nonaqueous-liquid molar fractions and density  ---
!
          RHONAX = XNA(M,N)*RHON(M,N)
          RHONOX = XNO(M,N)*RHON(M,N)
          RHONNX = XNN(M,N)*RHON(M,N)
          RHONWX = XNW(M,N)*RHON(M,N)
          WTMNX = 1.D+0/(XNA(M,N)/WTMA + XNO(M,N)/WTMO + XNN(M,N)/WTMN
     &      + XNW(M,N)/WTMW)
          XMNA(M,N) = XNA(M,N)*WTMNX/WTMA
          XMNO(M,N) = XNO(M,N)*WTMNX/WTMO
          XMNN(M,N) = XNN(M,N)*WTMNX/WTMN
          XMNW(M,N) = XNW(M,N)*WTMNX/WTMW
          RHOMN(M,N) = RHON(M,N)/WTMNX
!
!---      Nonaqueous-liquid viscosity, Pa s  ---
!
          RHONAX = RHOMN(M,N)*WTMA
          CALL VISC_CO2( T(M,N),RHONAX,VISNAX )
          RHONOX = RHOMN(M,N)*WTMO
          CALL VISC_CH4( T(M,N),RHONOX,VISNOX )
          RHONNX = RHOMN(M,N)*WTMN
          CALL VISC_N2( T(M,N),RHONNX,VISNNX )
          RHONWX = RHOMN(M,N)*WTMW
          CALL VISC_W( T(M,N),PX,RHONWX,VISNWX )
          CALL VISC_G( PHIX,VISNAX,VISNOX,VISNNX,VISNWX,XMNA(M,N),
     &      XMNO(M,N),XMNN(M,N),XMNW(M,N),VISN(M,N) )
!
!---      Nonaqueous-liquid diffusion coefficients  ---
!
          IF( ISLC(2).EQ.1 ) THEN
            DFNA(M,N) = DFNAC
            DFNO(M,N) = DFNOC
            DFNN(M,N) = DFNNC
            DFNW(M,N) = DFNWC
          ELSEIF( ISLC(2).EQ.2 ) THEN
            CALL DIFC_G( T(M,N),PX,DFNA(M,N),DFNO(M,N),DFNN(M,N),
     &        DFNW(M,N),XMNA(M,N),XMNO(M,N),XMNN(M,N),XMNW(M,N) )
          ENDIF
!
!---      Gas thermal conductivity, W/m K  ---
!
          RHOGAX = RHOMG(M,N)*WTMA
          CALL THK_CO2( T(M,N),PX,RHOGAX,THKGAX )
          RHOGOX = RHOMG(M,N)*WTMO
          CALL THK_CH4( T(M,N),RHOGOX,THKGOX )
          RHOGNX = RHOMG(M,N)*WTMN
          CALL THK_N2( T(M,N),RHOGNX,THKGNX )
          RHOGWX = RHOMG(M,N)*WTMW
          CALL THK_W( T(M,N),PX,RHOGWX,THKGWX )
          CALL THK_G( PHIX,THKGAX,THKGOX,THKGNX,THKGWX,
     &      XMGA(M,N),XMGO(M,N),XMGN(M,N),XMGW(M,N),THKG(M,N) )
!  
!---      Aqueous thermal conductivity  ---
!
          CALL THK_W( T(M,N),PX,RHOLWX,THKLWX )
          CALL THK_B( T(M,N),XLS(M,N),THKLWX,THKL(M,N) )
!
!---      Nonaqueous thermal conductivity, W/m K  ---
!
          RHONAX = RHOMN(M,N)*WTMA
          CALL THK_CO2( T(M,N),PX,RHONAX,THKNAX )
          RHONOX = RHOMN(M,N)*WTMO
          CALL THK_CH4( T(M,N),RHONOX,THKNOX )
          RHONNX = RHOMN(M,N)*WTMN
          CALL THK_N2( T(M,N),RHONNX,THKNNX )
          RHONWX = RHOMN(M,N)*WTMW
          CALL THK_W( T(M,N),PX,RHONWX,THKNWX )
          CALL THK_G( PHIX,THKNAX,THKNOX,THKNNX,THKNWX,
     &      XMNA(M,N),XMNO(M,N),XMNN(M,N),XMNW(M,N),THKN(M,N) )
!
!---      Ice thermal conductivity  ---
!
          CALL THK_I( T(M,N),THKI(M,N) )
!
!---      Hydrate thermal conductivity  ---
!
          CALL THK_H( T(M,N),THKH(M,N) )
!
!---      Pure water vapor enthalpy and internal energy  ---
!
          CALL SP_W( T(M,N),PSWX )
          PEX = MIN( PSWX,PX )
          ISRX = 2
          CALL ENTH_W( T(M,N),PEX,HLWX,HGW(M,N),ISRX )
          UGWX = HGW(M,N) - PX/(RHOGWX+SMALL)
!
!---      Gas enthalpy and internal energy  ---
!
          XMGX(1) = YMGA(M,N)
          XMGX(2) = YMGO(M,N)
          XMGX(3) = YMGN(M,N)
          CALL ENTH_ID( T(M,N),HIDX )
          INDX = 1
          CALL ENTH_RES( PX,T(M,N),HRESX,XMGX,INDX )
          HGA(M,N) = (HIDX(1) + HRESX(1))/WTMA
          HGO(M,N) = (HIDX(2) + HRESX(2))/WTMO
          HGNX = (HIDX(3) + HRESX(3))/WTMN
          HG(M,N) = XGA(M,N)*HGA(M,N) + XGO(M,N)*HGO(M,N) + 
     &      XGN(M,N)*HGNX + XGW(M,N)*HGW(M,N)
          UEG(M,N) = HG(M,N) - PX/(RHOG(M,N)+SMALL)
!
!---      Nonaqueous-liquid enthalpy and internal energy  ---
!
          XMNX(1) = YMNAX
          XMNX(2) = YMNOX
          XMNX(3) = YMNNX
          CALL ENTH_ID( T(M,N),HIDX )
          INDX = 2
          CALL ENTH_RES( PX,T(M,N),HRESX,XMNX,INDX )
          HNAX = (HIDX(1) + HRESX(1))/WTMA
          HNOX = (HIDX(2) + HRESX(2))/WTMO
          HNNX = (HIDX(3) + HRESX(3))/WTMN
          HN(M,N) = XNA(M,N)*HNAX + XNO(M,N)*HNOX + 
     &      XNN(M,N)*HNNX + XNW(M,N)*HGW(M,N)
          UEN(M,N) = HN(M,N) - PX/(RHON(M,N)+SMALL)
!
!---      Pure water liquid enthalpy  ---
!
          CALL SP_W( T(M,N),PSWX )
          PEX = MAX( PSWX,PX )
          ISRX = 1
          CALL ENTH_W( T(M,N),PEX,HLW(M,N),HGWX,ISRX )
!
!---      Aqueous enthalpy  ---
!
          CALL ENTH_B( T(M,N),XLS(M,N),HLW(M,N),HBX )
          FGAX = SG(M,N)*RHOG(M,N)*XGA(M,N)
          FNAX = SN(M,N)*RHON(M,N)*XNA(M,N)
          IF( (FGAX+FNAX)/EPSL.LT.EPSL ) THEN
            HGNAX = 0.D+0
          ELSE
            HGNAX = (HGA(M,N)*FGAX + HNAX*FNAX)/(FGAX + FNAX)
          ENDIF
          FGOX = SG(M,N)*RHOG(M,N)*XGO(M,N)
          FNOX = SN(M,N)*RHON(M,N)*XNO(M,N)
          IF( (FGOX+FNOX)/EPSL.LT.EPSL ) THEN
            HGNOX = 0.D+0
          ELSE
            HGNOX = (HGO(M,N)*FGOX + HNOX*FNOX)/(FGOX + FNOX)
          ENDIF
          FGNX = SG(M,N)*RHOG(M,N)*XGN(M,N)
          FNNX = SN(M,N)*RHON(M,N)*XNN(M,N)
          IF( (FGNX+FNNX)/EPSL.LT.EPSL ) THEN
            HGNNX = 0.D+0
          ELSE
            HGNNX = (HGNX*FGNX + HNNX*FNNX)/(FGNX + FNNX)
          ENDIF
          CALL ENTH_L( T(M,N),XLS(M,N),XLA(M,N),XLO(M,N),XLN(M,N),HBX,
     &      HGNAX,HGNOX,HGNNX,HL(M,N) )
          UEL(M,N) = HL(M,N) - PX/RHOL(M,N)
!
!---      Ice enthalpy  ---
!
          CALL ENTH_I( T(M,N),HI(M,N) )
!
!---      Hydrate enthalpy  ---
!
          XMGX(1) = YMHGA(M,N)
          XMGX(2) = YMHGO(M,N)
          XMGX(3) = YMHGN(M,N)
          INDX = 1
          CALL ENTH_RES( PX,T(M,N),HRESX,XMGX,INDX )
          HGAX = (HIDX(1) + HRESX(1))/WTMA
          HGOX = (HIDX(2) + HRESX(2))/WTMO
          HGNX = (HIDX(3) + HRESX(3))/WTMN
          CALL ENTH_H( T(M,N),XHA(M,N),XHO(M,N),XHN(M,N),XHW(M,N),
     &      HGAX,HGOX,HGNX,HH(M,N),HLW(M,N) )
!
!---      Precipitated NaCl density, saturation, and enthalpy  ---
!
          CALL DENS_S( T(M,N),PX,RHOSP(M,N) )
          SS(M,N) = MAX(YLS(M,N)-XLS(M,N),0.D+0)*RHOL(M,N)*SL(M,N)/
     &      RHOSP(M,N)
!
!---      Precipitated NaCl enthalpy  ---
!
          CALL ENTH_S( T(M,N),HSP(M,N) )
!
!---      Civan model for permeability reduction
!         Civan, F.C., Scale effect on porosity and permeability: 
!         kinetics, model and correlation, AIChE Journal, 
!         2001, 47(2), 271-287.  ---
!
          IF( IPRF(N).EQ.3 ) THEN
            PORDX = PORD(M,N)*(1.D+0-SH(M,N))
            PERMRF(M,N) = (PORDX/PORD(M,N))*(((PORDX*(1.D+0-PORD(M,N)))/
     &        (PORD(M,N)*(1.D+0-PORDX)))**(2.D+0*PERM(6,N)))
!
!---      Hydrate-porosity permeability reduction model from 
!         IGHCCS2 Benchmark Problem 2  ---
!
          ELSEIF( IPRF(N).EQ.4 ) THEN
            VARX = (5.D+0*PERM(4,N) + 4.D+0)/(2.D+0*PERM(4,N))
            PERMRF1X = (1.D+0-SH(M,N))**VARX
            VARX = (1.D+0-PORD(M,N))/(1.D+0-PERM(6,N))
            PERMRF2X = (1.D+0/(VARX**PERM(5,N)))**2
            PERMRF(M,N) = PERMRF1X*PERMRF2X
!
!---      Hydrate-porosity permeability reduction model from 
!         IGHCCS2 Benchmark Problem 5  ---
!
          ELSEIF( IPRF(N).EQ.5 ) THEN
            VARX = PERM(6,N)*((PORD(M,N)/PERM(5,N))-1.D+0)
            PERMRF(M,N) = EXP(VARX)*(1.D+0-SH(M,N))**PERM(4,N)
          ENDIF
!
!---      Change in porosity as a function of precipitated salt  ---
!
          PORD(M,N) = PORD(M,N)*(1.D+0-SS(M,N))
!
!---      Aqueous, gas, and nonaqueous-liquid tortuosity  ---
!
          PORDX = PORD(M,N)*(1.D+0-SH(M,N)-SI(M,N))
          IF( ISLC(3).EQ.1 ) CALL TORTU( SL(M,N),SG(M,N),SN(M,N),
     &      PORDX,TORL(M,N),TORG(M,N),TORN(M,N),N )
!
!---      NaCl volumetric concentration  ---
!
          TMS(M,N) = YLS(M,N)*RHOL(M,N)*SL(M,N)*PORD(M,N)
!
!---      Zero net mass transfer of formers into hydrate  ---
!
          TMBP_A(M,N) = 0.D+0
          TMBP_O(M,N) = 0.D+0
          TMBP_N(M,N) = 0.D+0
!
!---      Effective porosity and specific surface area of hydrate
!
!         Sun, X., Nanchary, N., Mohanty, K.K., 2005. 1-D modeling 
!         of hydrate depressurization in porous media. 
!         Transp. Porous Media 58, 315e338. 
!         http://dx.doi.org/10.1007/s11242-004-1410-x ---
!
          PORDX = PORD(M,N)*(1.D+0-SH(M,N))
          PERMX = MAX( PERM(1,N),PERM(2,N),PERM(3,N) )
          SP_AREAX = SQRT((PORDX**3.D+0)/(2.D+0*PERMX))
          ASL(N) = SP_AREAX*VOL(N)
!
!---      Activation energy for hydrate dissociation, J/kmol  ---
!
          EAX = 81.D+6
!
!---      Hydrate dissociation rate coefficient, kmol/m^2 Pa s ---
!
          CHKND = CHKN(3)*EXP(-(EAX/RCU)/(T(M,N)+273.15D+0))
!
!---      Bound-water saturation ---
!
          SLBX = MIN( SCHR(15,N),0.99999D+0 )  
!
!---      Total mobile and hydrate equilibriumn pressures  ---
!
          PVMX = PVA(M,N) + PVO(M,N) + PVN(M,N)
          PVHX = PVHA(M,N) + PVHO(M,N) + PVHN(M,N)
!
!---      Hydrate formation rate, limited by bound water, kmol/s  ---
!
          RFMX = CHKN(2)*PORD(M,N)*VOL(N)*SP_AREAX*(PVMX-PVHX)
          IF( SL(M,N).GT.SLBX ) THEN
            RFMX = RFMX*(SL(M,N)-SLBX)/(1.D+0-SLBX)
          ELSE
            RFMX = 0.D+0
          ENDIF
!
!---      Hydrate dissociation rate, kmol/s  ---
!
          IF( SH(2,N).GT.EPSL ) THEN
            RDMX = CHKND*PORD(M,N)*VOL(N)*SP_AREAX*(PVMX-PVHX)
          ELSE
            RDMX = 0.D+0
          ENDIF
!
!---      Total mobile pressure greater than total hydrate 
!         equilibrium pressure toward hydrate formation  ---
!
          IF(PVMX-PVHX.GE.0.D+0) THEN
            TMBP_A(M,N) = RFMX*YMGA(M,N)
            TMBP_O(M,N) = RFMX*YMGO(M,N)
            TMBP_N(M,N) = RFMX*YMGN(M,N)
            AST(N) = RFMX/(VOL(N)*SP_AREAX)
!
!---      Total mobile pressure less than total hydrate 
!         equilibrium pressure toward hydrate dissociation  ---
!
          ELSE 
            TMBP_A(M,N) = RDMX*YMHGA(M,N)
            TMBP_O(M,N) = RDMX*YMHGO(M,N)
            TMBP_N(M,N) = RDMX*YMHGN(M,N)  
            AST(N) = RDMX/(VOL(N)*SP_AREAX)   
          ENDIF              
!
!---      Exchange of hydrate formers driven by difference in 
!         mobile and hydrate equilibrium mole fractions  ---
!
          IF( ISLC(73).EQ.0 ) THEN
            IF( SH(2,N).GT.EPSL ) THEN
              PVMHX = 5.D-1*(PVMX+PVHX)
              REMX = CHKN(4)*PVMHX*PORD(M,N)*VOL(N)*SP_AREAX
            ELSE
              REMX = 0.D+0
            ENDIF
!
!---        Total molar rate from mobile to hydrate  ---
!
            TMH_AX = REMX*MAX( (YMGA(M,N)-YMHGA(M,N)),0.D+0 )
            TMH_OX = REMX*MAX( (YMGO(M,N)-YMHGO(M,N)),0.D+0 )
            TMH_NX = REMX*MAX( (YMGN(M,N)-YMHGN(M,N)),0.D+0 )
            TMH_X = TMH_AX + TMH_OX + TMH_NX
!
!---        Factored total molar rate from mobile to hydrate  ---
!
            FMH_AX = CHKN(6)*TMH_AX
            FMH_OX = TMH_OX
            FMH_NX = CHKN(7)*TMH_NX
            FMH_X = FMH_AX + FMH_OX + FMH_NX
!
!---        Total molar rate from hydrate to mobile  ---
!
            THM_AX = REMX*MAX( (YMHGA(M,N)-YMGA(M,N)),0.D+0 )
            THM_OX = REMX*MAX( (YMHGO(M,N)-YMGO(M,N)),0.D+0 )
            THM_NX = REMX*MAX( (YMHGN(M,N)-YMGN(M,N)),0.D+0 )
            THM_X = THM_AX + THM_OX + THM_NX
!
!---        Factored total molar rate from mobile to hydrate  ---
!
            FHM_AX = CHKN(6)*THM_AX
            FHM_OX = THM_OX
            FHM_NX = CHKN(7)*THM_NX
            FHM_X = FHM_AX + FHM_OX + FHM_NX
!
!---        Molar exchange rates  ---
!
            TMBP_AX = 0.D+0
            TMBP_OX = 0.D+0
            TMBP_NX = 0.D+0
            IF( FMH_X/EPSL.GT.EPSL ) THEN
              TMBP_AX = TMBP_AX + FMH_AX*TMH_X/FMH_X
              TMBP_OX = TMBP_OX + FMH_OX*TMH_X/FMH_X
              TMBP_NX = TMBP_NX + FMH_NX*TMH_X/FMH_X
            ENDIF
            IF( FHM_X/EPSL.GT.EPSL ) THEN
              TMBP_AX = TMBP_AX - FHM_AX*THM_X/FHM_X
              TMBP_OX = TMBP_OX - FHM_OX*THM_X/FHM_X
              TMBP_NX = TMBP_NX - FHM_NX*THM_X/FHM_X
            ENDIF
!            TMBP_AX = REMX*(YMGA(M,N)-YMHGA(M,N))
!            TMBP_OX = REMX*(YMGO(M,N)-YMHGO(M,N))
!!
!!---        Balance molar exchange rates  ---
!!
!            TMBP_NX = -(TMBP_AX+TMBP_OX)
!
!---      Exchange of hydrate formers driven by difference in 
!         mobile and hydrate equilibrium partial pressures  ---
!
          ELSEIF( ISLC(73).EQ.1 ) THEN
            IF( SH(2,N).GT.EPSL ) THEN
              TMBP_AX = CHKN(4)*(PVA(M,N)-PVHA(M,N))*
     &          PORD(M,N)*VOL(N)*SP_AREAX
              TMBP_NX = CHKN(4)*(PVN(M,N)-PVHN(M,N))*
     &          PORD(M,N)*VOL(N)*SP_AREAX
              TMBP_OX = CHKN(4)*(PVO(M,N)-PVHO(M,N))*
     &          PORD(M,N)*VOL(N)*SP_AREAX
            ELSE
              TMBP_AX = 0.D+0
              TMBP_NX = 0.D+0
              TMBP_OX = 0.D+0
            ENDIF
!
!---        Balance molar exchange rates  ---
!
            AX = 0.D+0
            BX = 0.D+0
            IF( TMBP_AX.GE.0.D+0 ) THEN
              AX = AX + TMBP_AX
            ELSE
              BX = BX - TMBP_AX
            ENDIF
            IF( TMBP_NX.GE.0.D+0 ) THEN
              AX = AX + TMBP_NX
            ELSE
              BX = BX - TMBP_NX
            ENDIF
            IF( TMBP_OX.GE.0.D+0 ) THEN
              AX = AX + TMBP_OX
            ELSE
              BX = BX - TMBP_OX
            ENDIF
            FX = (1.D+0/AX)*SQRT(AX*BX)
            IF( TMBP_AX.GE.0.D+0 ) THEN
              TMBP_AX = TMBP_AX*FX
            ELSE
              TMBP_AX = TMBP_AX/FX
            ENDIF
            IF( TMBP_NX.GE.0.D+0 ) THEN
              TMBP_NX = TMBP_NX*FX
            ELSE
              TMBP_NX = TMBP_NX/FX
            ENDIF
            IF( TMBP_OX.GE.0.D+0 ) THEN
              TMBP_OX = TMBP_OX*FX
            ELSE
              TMBP_OX = TMBP_OX/FX
            ENDIF
          ENDIF
!
!---      Combined formation/dissocation and exchange  ---
!
          TMBP_A(M,N) = (TMBP_A(M,N)+TMBP_AX)*WTMA
          TMBP_O(M,N) = (TMBP_O(M,N)+TMBP_OX)*WTMO
          TMBP_N(M,N) = (TMBP_N(M,N)+TMBP_NX)*WTMN
!
!---      Rate limits for CO2  ---
!
          IF(TMBP_A(M,N).GT.0.D+0) THEN
!
!---        Initial mass of mobile CO2
!
            TMMAX0 = PORD(M,N)*VOL(N)*(SG(M,N)*RHOG(M,N)*XGA(M,N)
     &        + SN(M,N)*RHON(M,N)*XNA(M,N) 
     &        + SL(M,N)*RHOL(M,N)*XLA(M,N))
!
!---        Estimate the mass of mobile CO2 at the end of the time
!           step, assuming a closed grid cell, with the formulation
!           of Kim et al. 1987. "Kinetics of methane hydrate
!           decomposition," Chemical Engineering Science,
!           42(7):1645-1653  ---
!
            IF( TMMAX0.GT.0.D+0 ) THEN
              TMMAX = TMMAX0*((1.D+0-(TMBP_A(M,N)*DT)/(3.D+0*
     &          TMMAX0))**3.D+0)
!
!---          Limit mass transfer to zero
!
              IF (TMMAX.LT.0.D+0) TMMAX = 0.D+0
!
!---          Convert to linear rate
!
              TMBP_A(M,N) = (TMMAX0-TMMAX)*DTI
            ENDIF
          ELSEIF( TMBP_A(M,N).LT.0.D+0 ) THEN
!
!---        Initial kmol of hydrate CO2
!
            TMHAX0 = TMHA(M,N)*PORD(M,N)*VOL(N)
!
!---        Estimate the mass of hydrate CO2 at the end of the time
!           step, assuming a closed grid cell, with the formulation
!           of Kim et al. 1987. "Kinetics of methane hydrate
!           decomposition," Chemical Engineering Science,
!           42(7):1645-1653  ---
!
            IF( TMHAX0.GT.0.D+0 ) THEN
              TMHAX = TMHAX0*((1.D+0+(TMBP_A(M,N)*DT)/(3.D+0*
     &          TMHAX0))**3.D+0)
!
!---          Limit mole transfer to zero
!
              IF( TMHAX.LT.0.D+0 ) TMHAX= 0.D+0
!
!---          Convert to linear rate
!
              TMBP_A(M,N)=(TMHAX-TMHAX0)*DTI
            ENDIF
          ENDIF
!
!---      Rate limits for CH4  ---
!
          IF(TMBP_O(M,N).GT.0.D+0) THEN
!
!---        Initial mass of mobile CH4
!
            TMMOX0 = PORD(M,N)*VOL(N)*(SG(M,N)*RHOG(M,N)*XGO(M,N)
     &        + SN(M,N)*RHON(M,N)*XNO(M,N) 
     &        + SL(M,N)*RHOL(M,N)*XLO(M,N))
!
!---        Estimate the mass of mobile CH4 at the end of the time
!           step, assuming a closed grid cell, with the formulation
!           of Kim et al. 1987. "Kinetics of methane hydrate
!           decomposition," Chemical Engineering Science,
!           42(7):1645-1653  ---
!
            IF( TMMOX0.GT.0.D+0 ) THEN
              TMMOX = TMMOX0*((1.D+0-(TMBP_O(M,N)*DT)/(3.D+0*
     &          TMMOX0))**3.D+0)
!
!---          Limit mass transfer to zero
!
              IF (TMMOX.LT.0.D+0) TMMOX = 0.D+0
!
!---          Convert to linear rate
!
              TMBP_O(M,N) = (TMMOX0-TMMOX)*DTI
            ENDIF
          ELSEIF( TMBP_O(M,N).LT.0.D+0 ) THEN
!
!---        Initial kmol of hydrate CH4
!
            TMHOX0 = TMHO(M,N)*PORD(M,N)*VOL(N)
!
!---        Estimate the mass of hydrate CH4 at the end of the time
!           step, assuming a closed grid cell, with the formulation
!           of Kim et al. 1987. "Kinetics of methane hydrate
!           decomposition," Chemical Engineering Science,
!           42(7):1645-1653  ---
!
            IF( TMHOX0.GT.0.D+0 ) THEN
              TMHOX = TMHOX0*((1.D+0+(TMBP_O(M,N)*DT)/(3.D+0*
     &          TMHOX0))**3.D+0)
!
!---          Limit mole transfer to zero
!
              IF( TMHOX.LT.0.D+0 ) TMHOX= 0.D+0
!
!---          Convert to linear rate
!
              TMBP_O(M,N)=(TMHOX-TMHOX0)*DTI
            ENDIF
          ENDIF
!
!---      Rate limits for N2  ---
!
          IF(TMBP_N(M,N).GT.0.D+0) THEN
!
!---        Initial mass of mobile N2
!
            TMMNX0 = PORD(M,N)*VOL(N)*(SG(M,N)*RHOG(M,N)*XGN(M,N)
     &        + SN(M,N)*RHON(M,N)*XNN(M,N) 
     &        + SL(M,N)*RHOL(M,N)*XLN(M,N))
!
!---        Estimate the mass of mobile N2 at the end of the time
!           step, assuming a closed grid cell, with the formulation
!           of Kim et al. 1987. "Kinetics of methane hydrate
!           decomposition," Chemical Engineering Science,
!           42(7):1645-1653  ---
!
            IF( TMMNX0.GT.0.D+0 ) THEN
              TMMNX = TMMNX0*((1.D+0-(TMBP_N(M,N)*DT)/(3.D+0*
     &          TMMNX0))**3.D+0)
!
!---          Limit mass transfer to zero
!
              IF (TMMNX.LT.0.D+0) TMMNX = 0.D+0
!
!---          Convert to linear rate
!
              TMBP_N(M,N) = (TMMNX0-TMMNX)*DTI
            ENDIF
          ELSEIF( TMBP_N(M,N).LT.0.D+0 ) THEN
!
!---        Initial kmol of hydrate N2
!
            TMHNX0 = TMHN(M,N)*PORD(M,N)*VOL(N)
!
!---        Estimate the mass of hydrate N2 at the end of the time
!           step, assuming a closed grid cell, with the formulation
!           of Kim et al. 1987. "Kinetics of methane hydrate
!           decomposition," Chemical Engineering Science,
!           42(7):1645-1653  ---
!
            IF( TMHNX0.GT.0.D+0 ) THEN
              TMHNX = TMHNX0*((1.D+0+(TMBP_N(M,N)*DT)/(3.D+0*
     &          TMHNX0))**3.D+0)
!
!---          Limit mole transfer to zero
!
              IF( TMHNX.LT.0.D+0 ) TMHNX= 0.D+0
!
!---          Convert to linear rate
!
              TMBP_N(M,N)=(TMHNX-TMHNX0)*DTI
            ENDIF
          ENDIF
        ENDDO
!
!---    Aqueous and gas compressibility  ---
!
        IF( NPHZX.EQ.10 ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(4,N)-1.D+0/RHOL(2,N))/(PL(4,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(5,N)-1.D+0/RHOG(2,N))/(PG(5,N)-PG(2,N)+SMALL)
        ELSEIF( NPHZX.EQ.21  ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(5,N)-1.D+0/RHOL(2,N))/(PL(5,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(5,N)-1.D+0/RHOG(2,N))/(PG(5,N)-PG(2,N)+SMALL)
        ELSEIF( NPHZX.EQ.22  ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(6,N)-1.D+0/RHOL(2,N))/(PL(6,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(6,N)-1.D+0/RHOG(2,N))/(PG(6,N)-PG(2,N)+SMALL)
        ELSEIF( NPHZX.EQ.23  ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(7,N)-1.D+0/RHOL(2,N))/(PL(7,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(7,N)-1.D+0/RHOG(2,N))/(PG(7,N)-PG(2,N)+SMALL)
        ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.33 ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(5,N)-1.D+0/RHOL(2,N))/(PL(5,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(5,N)-1.D+0/RHOG(2,N))/(PG(5,N)-PG(2,N)+SMALL)
        ELSEIF( NPHZX.GE.34 .AND. NPHZX.LE.36 ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(6,N)-1.D+0/RHOL(2,N))/(PL(6,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(6,N)-1.D+0/RHOG(2,N))/(PG(6,N)-PG(2,N)+SMALL)
        ELSEIF( NPHZX.GE.37 .AND. NPHZX.LE.39 ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(7,N)-1.D+0/RHOL(2,N))/(PL(7,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(7,N)-1.D+0/RHOG(2,N))/(PG(7,N)-PG(2,N)+SMALL)
        ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
          TORL(1,N) = -RHOL(2,N)*
     &     (1.D+0/RHOL(4,N)-1.D+0/RHOL(2,N))/(PL(4,N)-PL(2,N)+SMALL)
          TORG(1,N) = -RHOG(2,N)*
     &     (1.D+0/RHOG(5,N)-1.D+0/RHOG(2,N))/(PG(5,N)-PG(2,N)+SMALL)
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of PROP_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_BIN_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary files from processor.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 16 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE NAPL
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_BIN_HYDT_KE'
!
!---  Read solu.bin  ---
!
      CALL READ_SOLU_HYDT_KE
!      PRINT *,'Post READ_SOLU_HYDT_KE: ID = ',ID
!
!---  Read grid.bin  ---
!
      CALL READ_GRID_HYDT_KE
!      PRINT *,'Post READ_GRID_HYDT_KE: ID = ',ID
!
!---  Read prop.bin  ---
!
      CALL READ_PROP_HYDT_KE
!      PRINT *,'Post READ_PROP_HYDT_KE: ID = ',ID
!
!---  Read state.bin  ---
!
      CALL READ_STATE_HYDT_KE
!      PRINT *,'Post READ_STATE_HYDT_KE: ID = ',ID
!
!---  Read boco.bin  ---
!
      CALL READ_BOCO_HYDT_KE
!      PRINT *,'Post READ_BOCO_HYDT_KE: ID = ',ID
!
!---  Read sorc.bin  ---
!
      CALL READ_SORC_HYDT_KE
!      PRINT *,'Post READ_SORC_HYDT_KE: ID = ',ID
!
!---  Read geomechanics binary files  ---
!
      IF( ISLC(50).NE.0 ) CALL READ_BIN_GM
!      PRINT *,'Post READ_BIN_GM: ID = ',ID
!
!---  Read co2_ch4_n2_pe.bin  ---
!
      CALL READ_PE_HYDT_KE
!      PRINT *,'Post READ_PE_HYDT_KE: ID = ',ID
!
!---  Read hyd_co2_ch4_n2_eq.bin  ---
!
      CALL READ_HE_HYDT_KE
!      PRINT *,'Post READ_HE_HYDT_KE: ID = ',ID
!
!---  Read inhibitor.bin  ---
!
      CALL READ_IH_HYDT_KE
!      PRINT *,'Post READ_IH_HYDT_KE: ID = ',ID
!
!---  Component name  ---
!
      HCNM(1) = 'co2'
      HCNM(2) = 'ch4'
      HCNM(3) = 'n2'
      HCNM(4) = 'h2o'
!
!---  Component molecular weight, kg/kmol  ---
!
      HCPP(1,1) = 44.0098D+0
      HCPP(1,2) = 16.0428D+0
      HCPP(1,3) = 28.01348D+0
      HCPP(1,4) = 18.015D+0
      WTMA = HCPP(1,1)
      WTMO = HCPP(1,2)
      WTMN = HCPP(1,3)
      WTMW = HCPP(1,4)
!
!---  Component normal boiling point, K  ---
!
      HCPP(2,1) = 194.686D+0
      HCPP(2,2) = 111.667D+0
      HCPP(2,3) = 77.355D+0
      HCPP(2,4) = 373.2D+0
!
!---  Component critical temperature, K  ---
!
      HCPP(3,1) = 304.1282D+0
      HCPP(3,2) = 190.564D+0
      HCPP(3,3) = 126.192D+0
      HCPP(3,4) = 647.3D+0
!
!---  Component critical pressure, Pa  ---
!
      HCPP(4,1) = 7377.3D+3
      HCPP(4,2) = 4599.2D+3
      HCPP(4,3) = 3395.8D+3
      HCPP(4,4) = 221.2D+5
!
!---  Component triple-point temperature, K  ---
!
      HCPP(16,1) = 216.592D+0
      HCPP(16,2) = 90.694D+0
      HCPP(16,3) = 63.1526D+0
      HCPP(16,4) = 273.16D+0
!
!---  Component triple-point pressure, Pa  ---
!
      HCPP(17,1) = 517.95D+3
      HCPP(17,2) = 11.696D+3
      HCPP(17,3) = 12.523D+3
      HCPP(17,4) = 0.6117D+3
!
!---  Component critical molar volume, m^3/kmol ---
!
      HCPP(5,1) = 1.D+0/10.6249063D+0
      HCPP(5,2) = 1.D+0/10.139128D+0
      HCPP(5,3) = 1.D+0/11.1839D+0
      HCPP(5,4) = 57.1D-3
!
!---  Component critical compressibility  ---
!
      HCPP(6,1) = 0.274D+0
      HCPP(6,2) = 0.288D+0
      HCPP(6,3) = 0.292D+0
      HCPP(6,4) = 0.235D+0
!
!---  Component Pitzer acentric factor  ---
!
      HCPP(7,1) = 0.22394D+0
      HCPP(7,2) = 0.01142D+0
      HCPP(7,3) = 0.0372D+0
      HCPP(7,4) = 0.344D+0
!
!---  Component dipole moment, debyes  ---
!
      HCPP(8,1) = 0.D+0
      HCPP(8,2) = 0.D+0
      HCPP(8,3) = 0.D+0
      HCPP(8,4) = 1.8D+0
!
!---  Liquid molar volume, m^3/kmol  ---
!
      HCPP(9,1) = 57.156D-3
      HCPP(9,2) = 24.429D-3
      HCPP(9,3) = 17.335D-3
      HCPP(9,4) = 18.016D-3
!
!---  Ideal gas heat capacity coefficient A  ---
!
      HCPP(18,1) = 1.980D+4
      HCPP(18,2) = 1.925D+4
      HCPP(18,3) = 3.115D+4
      HCPP(18,4) = 3.224D+4
!
!---  Ideal gas heat capacity coefficient B  ---
!
      HCPP(19,1) = 7.344D+1
      HCPP(19,2) = 5.213D+1
      HCPP(19,3) = -1.357D+1
      HCPP(19,4) = 1.924D+1
!
!---  Ideal gas heat capacity coefficient C  ---
!
      HCPP(20,1) = -5.602D-2
      HCPP(20,2) = 1.197D-2
      HCPP(20,3) = 2.680D-2
      HCPP(20,4) = 1.055D-2
!
!---  Ideal gas heat capacity coefficient D  ---
!
      HCPP(21,1) = 1.715D-5
      HCPP(21,2) = -1.132D-5
      HCPP(21,3) = -1.168D-5
      HCPP(21,4) = -3.596D-6
!
!---  Peng-Robinson pure component parameters (a, b, fw)  ---
!
      DO I = 1,4
        HCPP(13,I) = 0.45724D+0*(RCU**2)*(HCPP(3,I)**2)/HCPP(4,I)
        HCPP(14,I) = 0.07780D+0*RCU*HCPP(3,I)/HCPP(4,I)
        HCPP(15,I) = 0.37464D+0 + 1.54226D+0*HCPP(7,I) -
     &    0.26992D+0*(HCPP(7,I)**2)
      ENDDO
!
!---  Check for fatal execution errors and stop simulation
!     if detected  ---
!
      CALL CHK_ERROR
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_BIN_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_BOCO_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary boco.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE PROP
      USE GRID
      USE GLB_PAR
      USE FILES
      USE BCV
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_BOCO_HYDT_KE'
!
!---  Open boco.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'boco.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate memory for NBC  ---
!
      ALLOCATE( NBC(1:NP),STAT=ISTAT )
      CHMSG = 'NBC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of boundary condition surfaces on each
!     processor  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NBC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for boundary condition arrays  ---
!
      CALL ALLOC_BCV
      CALL ALLOC_BCVP
      CALL ALLOC_BCVH
!
!---  Initialize boundary condition variables  ---
!
      CALL INTLZ_BCV
      CALL INTLZ_BCVP
      CALL INTLZ_BCVH
!
!---  Read boundary condition variables 
!     (duplicated across processors)  ---
!
      NVAR = LBCV*LBTM*LBCIN
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,BC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Assign offsets for reading boundary condition indices
!     on processors  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NBC(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NBC(N)
      ENDDO
!
!---  Index array of boundary condition field nodes  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCN: ID = ',ID
!
!---  Index array of boundary condition directions  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCD,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCD: ID = ',ID
!
!---  Index array of boundary condition number of time points  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCM: ID = ',ID
!
!---  Index array of boundary condition input links  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCIN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCIN: ID = ',ID
!
!---  Index array of boundary condition cycling options  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCC: ID = ',ID
!
!---  Index array of boundary condition types  ---
!
      LX = LUK+LSOLU*LC
      NVAR = NBC(ID+1)*LX
      OFFSET = IOFFSET + NC*LX*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*LX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCT: ID = ',ID
!
!---  Index array of boundary condition reactive species  ---
!
      NVAR = NBC(ID+1)*(LSPBC+1)
      OFFSET = IOFFSET + NC*(LSPBC+1)*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*(LSPBC+1)*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCSP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'IBCSP = ',((IBCSP(K,L),K=1,(LSPBC+1)),L=1,NBC(ID+1)),
!     &  ' ID = ',ID
!
!---  Array of x-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post XPBC: ID = ',ID
!
!---  Array of y-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post YPBC: ID = ',ID
!
!---  Array of z-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post ZPBC: ID = ',ID
!      DO NB = 1,NBC(ID+1)
!        PRINT *,'XPBC(',NB,') = ',XPBC(NB),' ID = ',ID
!        PRINT *,'YPBC(',NB,') = ',YPBC(NB),' ID = ',ID
!        PRINT *,'ZPBC(',NB,') = ',ZPBC(NB),' ID = ',ID
!      ENDDO
!
!---  Close the boco.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_BOCO_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_GRID_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary grid.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE JACOB
      USE GRID
      USE GLB_PAR
      USE FILES
      USE CONST
#ifdef lis
!
!----------------------Lis Modules-----------------------------------!
!
      USE LIS_STOMP
#endif
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER IVARX(10)
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_GRID_HYDT_KE'
!
!---  Allocate memory for NFCGC, number of field cells and ghost
!     cells on each processor  ---
!
      ALLOCATE( NFCGC(1:NP),STAT=ISTAT )
      CHMSG = 'NFCGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NFC, number of field cells on each
!     processor  ---
!
      ALLOCATE( NFC(1:NP),STAT=ISTAT )
      CHMSG = 'NFC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for IDP  ---
!
      ALLOCATE( IDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'IDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for JDP  ---
!
      ALLOCATE( JDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'JDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for KDP  ---
!
      ALLOCATE( KDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'KDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKFL ---
!
      ALLOCATE( NUKFL(1:NP),STAT=ISTAT )
      CHMSG = 'NUKFL'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKFO ---
!
      ALLOCATE( NUKFO(1:NP),STAT=ISTAT )
      CHMSG = 'NUKFO'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKTL ---
!
      ALLOCATE( NUKTL(1:NP),STAT=ISTAT )
      CHMSG = 'NUKTL'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKTO ---
!
      ALLOCATE( NUKTO(1:NP),STAT=ISTAT )
      CHMSG = 'NUKTO'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Open grid1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read NFCGC array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NFCGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NFCGC_G = 0
      DO N = 1,NP
        NFCGC_G = NFCGC_G + NFCGC(N)
      ENDDO
!
!---  Allocate memory for geometry arrays (including ghost cells)  ---
!
      CALL ALLOC_GRID
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Read IDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read JDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,JDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read KDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,KDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of XE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XE,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of YE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YE,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid3.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid3.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ZE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZE,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid3.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid4.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid4.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of XP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Read local copies of YP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Read local copies of ZP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Read local copies of RP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid4.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid5.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid5.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of DXGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DXGF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DYGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DYGF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DZGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DZGF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid5.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid6.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid6.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of DXGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DXGP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DYGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DYGP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DZGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DZGP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid6.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid7.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid7.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of AFX array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of AFY array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFY,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of AFZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFZ,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid7.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid8.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid8.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of VOL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VOL,NVAR,MPI_REAL8,STATUS,
     &  IERR)
!
!---  Read local copies of GRVX array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of GRVY array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVY,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of GRVZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVZ,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid8.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid9.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid9.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of IXP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IXP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of INBS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,INBS,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of ND array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ND,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKFL (local flow equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKFO (local flow equation offsets)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFO,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKFG (global flow equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFG,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKTL (local transport equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKTO (local transport equation offsets)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTO,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKTG  (global transport equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTG,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read IFLD, JFLD, KFLD, NFLD (global field limits)
!     IPFLD, JPFLD, KPFLD, NPFLD (processor field limits)
!     (duplicated across processors)  ---
!
      NVAR = 10
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IFLD = IVARX(1)
      JFLD = IVARX(2)
      KFLD = IVARX(3)
      NFLD = IVARX(4)
      NXP = IVARX(5)
      ICS = IVARX(6)
      IPFLD = IVARX(7)
      JPFLD = IVARX(8)
      KPFLD = IVARX(9)
      NPFLD = IVARX(10)
      IF( NP.NE.NPFLD ) THEN
        IF( ID.EQ.0 ) PRINT *,'Processor Count Error: Number of ' //
     &    'Processors Requested ≠ Input File Processor Count'
        CALL MPI_FINALIZE(IERR)
        STOP
      ENDIF
!
!---  Allocate memory for NGHC ---
!
      ALLOCATE( NGHC(1:NP),STAT=ISTAT )
      CHMSG = 'NGHC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NGHC array total number of ghost cells on a processor,
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NGHC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NCGC ---
!
      ALLOCATE( NCGC(1:6,1:NP),STAT=ISTAT )
      CHMSG = 'NCGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NCGC array, number of ghost cells to be sent in the
!     stencil directions, (duplicated across processors)  ---
!
      NVAR = 6*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NCGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NPGC ---
!
      ALLOCATE( NPGC(1:6,1:NP),STAT=ISTAT )
      CHMSG = 'NPGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NPGC array, receiving processors in the
!     stencil directions, (duplicated across processors)  ---
!
      NVAR = 6*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NPGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NLSGC ---
!
      ALLOCATE( NLSGC(1:NGHC(ID+1)),STAT=ISTAT )
      CHMSG = 'NLSGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      NCX = 0
      DO I = 1,ID
        NCX = NCX + NGHC(I)
      ENDDO
      NCSX = 0
      DO I = 1,NP
        NCSX = NCSX + NGHC(I)
      ENDDO
!
!---  Read local copies of NLSGC array  ---
!
      NVAR = NGHC(ID+1)
      OFFSET = IOFFSET + NBYTB + NCX*NBYTI
      IOFFSET = IOFFSET + NCSX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NLSGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NLRGC ---
!
      ALLOCATE( NLRGC(1:NGHC(ID+1)),STAT=ISTAT )
      CHMSG = 'NLRGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local copies of NLRGC array  ---
!
      NVAR = NGHC(ID+1)
      OFFSET = IOFFSET + NBYTB + NCX*NBYTI
      IOFFSET = IOFFSET + NCSX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NLRGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the grid9.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Load ITAG, sending/receiving tags
!     (duplicated across processors)  ---
!
      NC = 0
      DO NPRX = 1,NP
        DO NPSX = 1,NP
          NC = NC + 1
          ITAG(NPSX,NPRX) = NC
        ENDDO
      ENDDO
!
!---  Number of ghost-cell primary variables for STOMP-HYDT-KE  ---
!
      NPVX = 17
!
!---  Allocate memory for ghost-cell send buffers in the six
!     stencil directions  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        PRINT *,'SBFB(',NPVX*NCGC(1,ID+1),' ID = ',ID
        ALLOCATE( SBFB(1:NPVX*NCGC(1,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFB on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(1,ID+1)
          SBFB(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        PRINT *,'SBFS(',NPVX*NCGC(2,ID+1),' ID = ',ID
        ALLOCATE( SBFS(1:NPVX*NCGC(2,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFS on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(2,ID+1)
          SBFS(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        PRINT *,'SBFW(',NPVX*NCGC(3,ID+1),' ID = ',ID
        ALLOCATE( SBFW(1:NPVX*NCGC(3,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFW on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(3,ID+1)
          SBFW(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        PRINT *,'SBFE(',NPVX*NCGC(4,ID+1),' ID = ',ID
        ALLOCATE( SBFE(1:NPVX*NCGC(4,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFE on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(4,ID+1)
          SBFE(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        PRINT *,'SBFN(',NPVX*NCGC(5,ID+1),' ID = ',ID
        ALLOCATE( SBFN(1:NPVX*NCGC(5,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFN on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(5,ID+1)
          SBFN(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        PRINT *,'SBFT(',NPVX*NCGC(6,ID+1),' ID = ',ID
        ALLOCATE( SBFT(1:NPVX*NCGC(6,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFT on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(6,ID+1)
          SBFT(M) = 0.D+0
        ENDDO
      ENDIF
!
!---  Allocate memory for ghost-cell receive buffers in the six
!     stencil directions  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        PRINT *,'RBFB(',NPVX*NCGC(6,ID+1),' ID = ',ID
        ALLOCATE( RBFB(1:NPVX*NCGC(6,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFB on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(6,ID+1)
          RBFB(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        PRINT *,'RBFS(',NPVX*NCGC(5,ID+1),' ID = ',ID
        ALLOCATE( RBFS(1:NPVX*NCGC(5,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFS on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(5,ID+1)
          RBFS(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        PRINT *,'RBFW(',NPVX*NCGC(4,ID+1),' ID = ',ID
        ALLOCATE( RBFW(1:NPVX*NCGC(4,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFW on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(4,ID+1)
          RBFW(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        PRINT *,'RBFE(',NPVX*NCGC(3,ID+1),' ID = ',ID
        ALLOCATE( RBFE(1:NPVX*NCGC(3,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFE on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(3,ID+1)
          RBFE(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        PRINT *,'RBFN(',NPVX*NCGC(2,ID+1),' ID = ',ID
        ALLOCATE( RBFN(1:NPVX*NCGC(2,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFN on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(2,ID+1)
          RBFN(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        PRINT *,'RBFT(',NPVX*NCGC(1,ID+1),' ID = ',ID
        ALLOCATE( RBFT(1:NPVX*NCGC(1,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFT on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(1,ID+1)
          RBFT(M) = 0.D+0
        ENDDO
      ENDIF
!
!---  Initialize ghost cell map  ---
!
      DO L = 1,NFCGC(ID+1)
        IGHC(L) = 0
      ENDDO
!
!---  Create a local node connection map and identify ghost cells  ---
!
      KFLD_L = KDP(2,ID+1)-KDP(1,ID+1)+1
      JFLD_L = JDP(2,ID+1)-JDP(1,ID+1)+1
      IFLD_L = IDP(2,ID+1)-IDP(1,ID+1)+1
      DO K = KDP(1,ID+1),KDP(2,ID+1)
        DO J = JDP(1,ID+1),JDP(2,ID+1)
          DO I = IDP(1,ID+1),IDP(2,ID+1)
            KX = K - KDP(1,ID+1) + 1
            JX = J - JDP(1,ID+1) + 1
            IX = I - IDP(1,ID+1) + 1
            N = (KX-1)*IFLD_L*JFLD_L + (JX-1)*IFLD_L + IX
!
!---        Bottom connection  ---
!
            ICM(1,N) = 0
            IF( KX.GT.1 ) THEN
              NB = N-IFLD_L*JFLD_L
              IF( IXP(NB).GT.0 .AND. INBS(1,N).EQ.0 ) ICM(1,N) = NB
            ENDIF
!
!---        Bottom ghost cells  ---
!
            IF( KX.EQ.1 .AND. K.GT.1 ) IGHC(N) = 1
!
!---        South connection  ---
!
            ICM(2,N) = 0
            IF( JX.GT.1 ) THEN
              NS = N-IFLD_L
              IF( IXP(NS).GT.0 .AND. INBS(2,N).EQ.0 ) ICM(2,N) = NS
            ENDIF
!
!---        South ghost cells  ---
!
            IF( JX.EQ.1 .AND. J.GT.1 ) IGHC(N) = 1
!
!---        West connection  ---
!
            ICM(3,N) = 0
            IF( IX.GT.1 ) THEN
              NW = N-1
              IF( IXP(NW).GT.0 .AND. INBS(3,N).EQ.0 ) ICM(3,N) = NW
            ENDIF
!
!---        West ghost cells  ---
!
            IF( IX.EQ.1 .AND. I.GT.1 ) IGHC(N) = 1
!
!---        East connection  ---
!
            ICM(4,N) = 0
            IF( IX.LT.IFLD_L ) THEN
              NE = N+1
              IF( IXP(NE).GT.0 .AND. INBS(4,N).EQ.0 ) ICM(4,N) = NE
            ENDIF
!
!---        East ghost cells  ---
!
            IF( IX.EQ.IFLD_L .AND. I.LT.IDP(2,NP) ) IGHC(N) = 1
!
!---        North connection  ---
!
            ICM(5,N) = 0
            IF( JX.LT.JFLD_L ) THEN
              NN = N+IFLD_L
              IF( IXP(NN).GT.0 .AND. INBS(5,N).EQ.0 ) ICM(5,N) = NN
            ENDIF
!
!---        North ghost cells  ---
!
            IF( JX.EQ.JFLD_L .AND. J.LT.JDP(2,NP) ) IGHC(N) = 1
!
!---        Top connection  ---
!
            ICM(6,N) = 0
            IF( KX.LT.KFLD_L ) THEN
              NT = N+IFLD_L*JFLD_L
              IF( IXP(NT).GT.0 .AND. INBS(6,N).EQ.0 ) ICM(6,N) = NT
            ENDIF
!
!---        Top ghost cells  ---
!
            IF( KX.EQ.KFLD_L .AND. K.LT.KDP(2,NP) ) IGHC(N) = 1
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_GRID_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_HE_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary hyd_co2_ch4_n2_eq.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 21 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE HYDT
      USE GRID
      USE GLB_PAR
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: V1X,V2X
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_HE_HYDT_KE'
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'hyd_co2_ch4_n2_eq.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IFILE,IERR )
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
      ALLOCATE( V1X(1:NHF_HT),STAT=ISTAT )
      CHMSG = 'V1X'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( V2X(1:16),STAT=ISTAT )
      CHMSG = 'V2X'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Loop over the number of hydrate former compositions  ---
!
      DO NC = 1,LCH_HT
!
!---    Read hydrate former mole fractions, ZHC_HT array 
!       (duplicated across processors)  ---
!
        NVAR = NHF_HT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V1X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO NF = 1,NHF_HT
          ZHC_HT(NF,NC) = V1X(NF)
!          PRINT *,'ZHC_HT(',NF,',',NC,') = ',ZHC_HT(NF,NC),' ID = ',ID
        ENDDO
!
!---    Read number of hydrate equilibrium table points  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,NHEP_HT(NC),NVAR,
     &    MPI_INTEGER,STATUS,IERR)
!
!---    Loop over the number of phase envelope table points  ---
!
        DO NE = 1,NHEP_HT(NC)
!
!---      Read temperature for the lower phase envelope,
!         pressure for the lower phase envelope,
!         second derivative of pressure for lower phase envelope
!         K-factors for the lower phase envelope,
!         second derivative of K-factors for lower phase envelope arrays 
!         (duplicated across processors)  ---
!
          NVAR = 16
          OFFSET = IOFFSET + NBYTB
          IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IFILE,OFFSET,V2X,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          THE_HT(NE,NC) = V2X(1)
          THE2P_HT(NE,NC) = V2X(2)
          PHE_HT(NE,NC) = V2X(3)
          PHE2T_HT(NE,NC) = V2X(4)
          XSCA_HT(NE,NC) = V2X(5)
          XSCA2T_HT(NE,NC) = V2X(6)
          XSCO_HT(NE,NC) = V2X(7)
          XSCO2T_HT(NE,NC) = V2X(8)
          XSCN_HT(NE,NC) = V2X(9)
          XSCN2T_HT(NE,NC) = V2X(10)
          XLCA_HT(NE,NC) = V2X(11)
          XLCA2T_HT(NE,NC) = V2X(12)
          XLCO_HT(NE,NC) = V2X(13)
          XLCO2T_HT(NE,NC) = V2X(14)
          XLCN_HT(NE,NC) = V2X(15)
          XLCN2T_HT(NE,NC) = V2X(16)
        ENDDO
      ENDDO
!
!---  Read hydrate equilibrium table indices  ---
!
      NZH_HT = 11
      DO L = 1,LCN_HT
        NVAR = LCN_HT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,IZH_HT(1,L),NVAR,
     &    MPI_INTEGER,STATUS,IERR)
      ENDDO
      CALL MPI_FILE_CLOSE( IFILE,IERR )
!
!---  Deallocate temporary arrays  ---
!
      DEALLOCATE( V1X,STAT=ISTAT )
      CHMSG = 'V1X'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( V2X,STAT=ISTAT )
      CHMSG = 'V2X'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_HE_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_IH_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary inhibitor.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 25 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE HYDT
      USE GRID
      USE GLB_PAR
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: V1X
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_IH_HYDT_KE'
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'inhibitor.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IFILE,IERR )
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
      ALLOCATE( V1X(1:7),STAT=ISTAT )
      CHMSG = 'V1X'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Loop over the number of inhibitors  ---
!
      DO INHX = 1,LINH
!
!---    Read inhibitor names, INHNM array 
!       (duplicated across processors)  ---
!
        NVAR = 64
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*1 + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,INHNM(INHX),NVAR,MPI_CHAR,
     &    STATUS,IERR)
        NVAR = 7
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V1X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO M = 1,6
          CINH(M,INHX) = V1X(M)
        ENDDO
        XLIMX(INHX) = V1X(7)
      ENDDO
      CALL MPI_FILE_CLOSE( IFILE,IERR )
!
!---  Deallocate temporary arrays  ---
!
      DEALLOCATE( V1X,STAT=ISTAT )
      CHMSG = 'V1X'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_IH_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_PE_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary co2_ch4_n2_pe.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 21 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE HYDT
      USE GRID
      USE GLB_PAR
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: V1X,V2X,V3X,V4X,V5X,V6X,V7X
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_PE_HYDT_KE'
!
!---  Allocate memory for ternary hydrate variables  ---
!
      CALL ALLOC_HYDT
      CALL INTLZ_HYDT
!
!---  Open co2_ch4_n2_pe.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'co2_ch4_n2_pe.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IFILE,IERR )
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
!
!---  Number of hydrate formers  ---
!
      NHF_HT = 3
!
!---  Allocate temporary memory  ---
!
      ALLOCATE( V1X(1:NHF_HT),STAT=ISTAT )
      CHMSG = 'V1X'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( V2X(1:6),STAT=ISTAT )
      CHMSG = 'V2X'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( V3X(1:3+2*NHF_HT),STAT=ISTAT )
      CHMSG = 'V3X'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Loop over the number of phase equilibria table compositions  ---
!
      DO NC = 1,LCP_HT
!
!---  Read hydrate former mole fractions, ZPC_HT array 
!     (duplicated across processors)  ---
!
        NVAR = NHF_HT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V1X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO NF = 1,NHF_HT
          ZPC_HT(NF,NC) = V1X(NF)
        ENDDO
!
!---    Read composition critical temperature, critical pressure,
!       cricondenbar temperature, cricondenbar pressure,
!       cricondenterm temperature, and cricondenterm pressure arrays 
!       (duplicated across processors)  ---
!
        NVAR = 6
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V2X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        TCR_HT(NC) = V2X(1)
        PCR_HT(NC) = V2X(2)
        TCB_HT(NC) = V2X(3)
        PCB_HT(NC) = V2X(4)
        TCT_HT(NC) = V2X(5)
        PCT_HT(NC) = V2X(6)
!
!---    Read number of phase envelope table points  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,NPEP_HT(NC),NVAR,
     &    MPI_INTEGER,STATUS,IERR)
!
!---    Loop over the number of phase envelope table points  ---
!
        DO NE = 1,NPEP_HT(NC)
!
!---      Read temperature for the lower phase envelope,
!         pressure for the lower phase envelope,
!         second derivative of pressure for lower phase envelope
!         K-factors for the lower phase envelope,
!         second derivative of K-factors for lower phase envelope arrays 
!         (duplicated across processors)  ---
!
          NVAR = (3+2*NHF_HT)
          OFFSET = IOFFSET + NBYTB
          IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IFILE,OFFSET,V3X,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          TLE_HT(NE,NC) = V3X(1)
          PLE_HT(NE,NC) = V3X(2)
          D2PLE_HT(NE,NC) = V3X(3)
          DO NF = 1,NHF_HT
            FKLE_HT(NE,NC,NF) = V3X(3+NF)
          ENDDO
          DO NF = 1,NHF_HT
            D2FKLE_HT(NE,NC,NF) = V3X(3+NHF_HT+NF)
          ENDDO
        ENDDO
        NE = NPEP_HT(NC)
!
!---    Read number of phase envelope table points  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,NPEP_HT(NC),NVAR,
     &    MPI_INTEGER,STATUS,IERR)
!
!---    Loop over the number of phase envelope table points  ---
!
        DO NE = 1,NPEP_HT(NC)
!
!---      Read temperature for the upper phase envelope,
!         pressure for the upper phase envelope,
!         second derivative of pressure for upper phase envelope
!         K-factors for the upper phase envelope,
!         second derivative of K-factors for upper phase envelope arrays 
!         (duplicated across processors)  ---
!
          NVAR = (3+2*NHF_HT)
          OFFSET = IOFFSET + NBYTB
          IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IFILE,OFFSET,V3X,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          TUE_HT(NE,NC) = V3X(1)
          PUE_HT(NE,NC) = V3X(2)
          D2PUE_HT(NE,NC) = V3X(3)
          DO NF = 1,NHF_HT
            FKUE_HT(NE,NC,NF) = V3X(3+NF)
          ENDDO
          DO NF = 1,NHF_HT
            D2FKUE_HT(NE,NC,NF) = V3X(3+NHF_HT+NF)
          ENDDO
        ENDDO
        NE = NPEP_HT(NC)
!
!---    Read number of two-phase temperature points  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,NTP_HT(NC),NVAR,
     &    MPI_INTEGER,STATUS,IERR)
!
!---    Read two-phase temperature points  ---
!
        ALLOCATE( V4X(1:NTP_HT(NC)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for V4X on ID = ',ID
        ENDIF
        NVAR = NTP_HT(NC)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V4X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO NTX = 1,NTP_HT(NC)
          T2P_HT(NTX,NC) = V4X(NTX)
        ENDDO
        NTX = NTP_HT(NC)
!
!---    Read number of two-phase pressure points  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,NPP_HT(NC),NVAR,
     &    MPI_INTEGER,STATUS,IERR)
!
!---    Read two-phase pressure points  ---
!
        ALLOCATE( V5X(1:NPP_HT(NC)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for V5X on ID = ',ID
        ENDIF
        NVAR = NPP_HT(NC)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V5X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO NPX = 1,NPP_HT(NC)
          P2P_HT(NP,NC) = V5X(NP)
        ENDDO
        NPX = NPP_HT(NC)
!
!---    Read two-phase beta values at temperature and 
!       pressure points  ---
!
        ALLOCATE( V6X(1:NTP_HT(NC)*NPP_HT(NC)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for V6X on ID = ',ID
        ENDIF
        NVAR = NTP_HT(NC)*NPP_HT(NC)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V6X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        MC = 0
        DO NPX = 1,NPP_HT(NC)
          DO NTX = 1,NTP_HT(NC)
            MC = MC + 1
            B2P_HT(NTX,NPX,NC) = V6X(MC)
          ENDDO
        ENDDO
        NPX = NPP_HT(NC)
        NTX = NTP_HT(NC)
!
!---    Read two-phase second derivative beta values at temperature and 
!       pressure points  ---
!
        NVAR = NTP_HT(NC)*NPP_HT(NC)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V6X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        MC = 0
        DO NPX = 1,NPP_HT(NC)
          DO NTX = 1,NTP_HT(NC)
            MC = MC + 1
            D2B2P_HT(NTX,NPX,NC) = V6X(MC)
          ENDDO
        ENDDO
        NPX = NPP_HT(NC)
        NTX = NTP_HT(NC)
!
!---    Read two-phase K-factor values at temperature and 
!       pressure points for each hydrate former  ---
!
        ALLOCATE( V7X(1:NTP_HT(NC)*NPP_HT(NC)*NHF_HT),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for V7X on ID = ',ID
        ENDIF
        NVAR = NTP_HT(NC)*NPP_HT(NC)*NHF_HT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V7X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        MC = 0
        DO NF = 1,NHF_HT
          DO NPX = 1,NPP_HT(NC)
            DO NTX = 1,NTP_HT(NC)
              MC = MC + 1
              FK2P_HT(NTX,NPX,NC,NF) = V7X(MC)
            ENDDO
          ENDDO
        ENDDO
        NF = NHF_HT
        NPX = NPP_HT(NC)
        NTX = NTP_HT(NC)
!
!---    Read two-phase second derivative K-factor values at 
!       temperature and pressure points  ---
!
        NVAR = NTP_HT(NC)*NPP_HT(NC)*NHF_HT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,V7X,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        MC = 0
        DO NF = 1,NHF_HT
          DO NPX = 1,NPP_HT(NC)
            DO NTX = 1,NTP_HT(NC)
              MC = MC + 1
              D2FK2P_HT(NTX,NPX,NC,NF) = V7X(MC)
            ENDDO
          ENDDO
        ENDDO
        NF = NHF_HT
        NPX = NPP_HT(NC)
        NTX = NTP_HT(NC)
        DEALLOCATE( V4X,STAT=ISTAT )
        CHMSG = 'V4X'
        CALL DEALLOC_ERROR( CHMSG,ISTAT )
        DEALLOCATE( V5X,STAT=ISTAT )
        CHMSG = 'V5X'
        CALL DEALLOC_ERROR( CHMSG,ISTAT )
        DEALLOCATE( V6X,STAT=ISTAT )
        CHMSG = 'V6X'
        CALL DEALLOC_ERROR( CHMSG,ISTAT )
        DEALLOCATE( V7X,STAT=ISTAT )
        CHMSG = 'V7X'
        CALL DEALLOC_ERROR( CHMSG,ISTAT )
      ENDDO
!
!---  Write hydrate equilibrium table indices  ---
!
      NZP_HT = 9
      DO L = 1,LCN_HT
        NVAR = LCN_HT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,IZP_HT(1,L),NVAR,
     &    MPI_INTEGER,STATUS,IERR)
      ENDDO
!
!---  Close the co2_ch4_n2_pe.bin file  ---
!
      CALL MPI_FILE_CLOSE( IFILE,IERR )
!
!---  Deallocate temporary arrays  ---
!
      DEALLOCATE( V1X,STAT=ISTAT )
      CHMSG = 'V1X'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( V2X,STAT=ISTAT )
      CHMSG = 'V2X'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( V3X,STAT=ISTAT )
      CHMSG = 'V3X'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_PE_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_PROP_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary prop.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE PROP
      USE GRID
      USE GLB_PAR
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_PROP_HYDT_KE'
!
!---  Allocate local memory geometry arrays (including ghost cells)  ---
!
      CALL ALLOC_PROP
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Open mech.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'mech.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of IZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IZ,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RHOS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RHOS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of CPS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CPS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of CMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*4
      OFFSET = IOFFSET + NBYTB + NC*4*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*4*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of POR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,POR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TOR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TOR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of ITOR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ITOR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the mech.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open hydr.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'hydr.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of PERM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*9
      OFFSET = IOFFSET + NBYTB + NC*9*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*9*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PERM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of IPRF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IPRF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the hydr.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open satu.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'satu.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of SCHR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LSCHR
      OFFSET = IOFFSET + NBYTB + NC*LSCHR*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LSCHR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,SCHR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of ISCHR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISCHR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of ISM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the satu.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open perm.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'perm.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of RPGC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPGC
      OFFSET = IOFFSET + NBYTB + NC*LRPGC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPGC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPGC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of IRPG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPG,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RPLC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPLC
      OFFSET = IOFFSET + NBYTB + NC*LRPLC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPLC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPLC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of IRPL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RPNC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPNC
      OFFSET = IOFFSET + NBYTB + NC*LRPNC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPNC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPNC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of IRPN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the perm.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open comp.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'comp.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of PCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PCMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TCMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the comp.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open ther.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'ther.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of THKS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*9
      OFFSET = IOFFSET + NBYTB + NC*9*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*9*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,THKS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of ITHK array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ITHK,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the ther.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_PROP_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_SOLU_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary input.bin file for solution control and output data
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 September 2021
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE OUTPU
      USE GRID
      USE GLB_PAR
      USE FDVP
      USE FDVH
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
      CHARACTER(64), DIMENSION(2) :: FNSFX
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_SOLU_HYDT_KE'
!
!---  Open solu.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'solu.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Initialize rror messaging variables  ---
!
      DO M = 1,4
        I_ERR(M) = 0
        M_ERR(M) = ''
      ENDDO
      I_ERR(4) = NP + 1
      R_ERR = 0.D+0
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
!
!---  Read parameter variables (duplicated across processors)  ---
!
      NVAR = 341
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      L_BH = IVARX(1)
      L_CW = IVARX(2)
      L_DP = IVARX(3)
      L_EC = IVARX(4)
      L_FRC = IVARX(5)
      L_LV = IVARX(6)
      L_LW = IVARX(7)
      L_SFC = IVARX(8)
      LAD = IVARX(9)
      LALC = IVARX(10)
      LAN = IVARX(11)
      LANI = IVARX(12)
      LANW = IVARX(13)
      LATM = IVARX(14)
      LBAL = IVARX(15)
      LBC = IVARX(16)
      LBC_BH = IVARX(17)
      LBC_EC = IVARX(18)
      LBC_FRC = IVARX(19)
      LBC_GM = IVARX(20)
      LBCA = IVARX(21)
      LBCC = IVARX(22)
      LBCG = IVARX(23)
      LBCGC = IVARX(24)
      LBCH = IVARX(25)
      LBCI = IVARX(26)
      LBCIN = IVARX(27)
      LBCIN_GM = IVARX(28)
      LBCL = IVARX(29)
      LBCN = IVARX(30)
      LBCN2 = IVARX(31)
      LBCS = IVARX(32)
      LBCT = IVARX(33)
      LBCU = IVARX(34)
      LBCV = IVARX(35)
      LBCV_GM = IVARX(36)
      LBD = IVARX(37)
      LBN_BH = IVARX(38)
      LBN_BHC = IVARX(39)
      LBR = IVARX(40)
      LBTM = IVARX(41)
      LBTM_GM = IVARX(42)
      LC = IVARX(43)
      LCAT = IVARX(44)
      LCDC = IVARX(45)
      LCDP = IVARX(46)
      LCDS = IVARX(47)
      LCH_HT = IVARX(48)
      LCHEM = IVARX(49)
      LCKN = IVARX(50)
      LCMP = IVARX(51)
      LCN = IVARX(52)
      LCN_HT = IVARX(53)
      LCOAX_BH = IVARX(54)
      LCP_HT = IVARX(55)
      LD = IVARX(56)
      LDCO2 = IVARX(57)
      LEPD = IVARX(58)
      LEQC = IVARX(59)
      LEQE = IVARX(60)
      LEQK = IVARX(61)
      LESITE = IVARX(62)
      LF_FRC = IVARX(63)
      LF_FRCC = IVARX(64)
      LFC_BH = IVARX(65)
      LFC_FRC = IVARX(66)
      LFD = IVARX(67)
      LFD_DP = IVARX(68)
      LFD_EC = IVARX(69)
      LFDA = IVARX(70)
      LFDC = IVARX(71)
      LFDCR = IVARX(72)
      LFDD = IVARX(73)
      LFDG = IVARX(74)
      LFDGC = IVARX(75)
      LFDH = IVARX(76)
      LFDI = IVARX(77)
      LFDL = IVARX(78)
      LFDM = IVARX(79)
      LFDN = IVARX(80)
      LFDN2 = IVARX(81)
      LFDNH = IVARX(82)
      LFDR = IVARX(83)
      LFDRG = IVARX(84)
      LFDRL = IVARX(85)
      LFDRN = IVARX(86)
      LFDS = IVARX(87)
      LFDT = IVARX(88)
      LFEN = IVARX(89)
      LFILES = IVARX(90)
      LFW = IVARX(91)
      LFX = IVARX(92)
      LFX_MPI = IVARX(93)
      LFXY = IVARX(94)
      LFY = IVARX(95)
      LFY_MPI = IVARX(96)
      LFYZ = IVARX(97)
      LFZ = IVARX(98)
      LFZ_MPI = IVARX(99)
      LFZX = IVARX(100)
      LG = IVARX(101)
      LGC = IVARX(102)
      LHBW = IVARX(103)
      LHE_HT = IVARX(104)
      LHF_HT = IVARX(105)
      LHYD = IVARX(106)
      LI_BH = IVARX(107)
      LINC = IVARX(108)
      LINH = IVARX(109)
      LIS = IVARX(110)
      LJA = IVARX(111)
      LJB = IVARX(112)
      LJC = IVARX(113)
      LJC_BH = IVARX(114)
      LJC_GM = IVARX(115)
      LJD = IVARX(116)
      LJE = IVARX(117)
      LJF = IVARX(118)
      LJG = IVARX(119)
      LJG_BCF = IVARX(120)
      LJG_BCM = IVARX(121)
      LJG_BH = IVARX(122)
      LJG_FCB = IVARX(123)
      LJG_FCM = IVARX(124)
      LJG_FRC = IVARX(125)
      LJG_GM = IVARX(126)
      LJG_MCB = IVARX(127)
      LJG_MCF = IVARX(128)
      LJH = IVARX(129)
      LJH_BCF = IVARX(130)
      LJH_BCM = IVARX(131)
      LJH_BH = IVARX(132)
      LJH_FCB = IVARX(133)
      LJH_FCM = IVARX(134)
      LJH_FRC = IVARX(135)
      LJH_GM = IVARX(136)
      LJH_MCB = IVARX(137)
      LJH_MCF = IVARX(138)
      LJI = IVARX(139)
      LJJ = IVARX(140)
      LJK = IVARX(141)
      LJK_BCF = IVARX(142)
      LJK_BCM = IVARX(143)
      LJK_BH = IVARX(144)
      LJK_FCB = IVARX(145)
      LJK_FCM = IVARX(146)
      LJK_FRC = IVARX(147)
      LJK_MCB = IVARX(148)
      LJK_MCF = IVARX(149)
      LJL = IVARX(150)
      LJL_BCF = IVARX(151)
      LJL_BCM = IVARX(152)
      LJL_BH = IVARX(153)
      LJL_FCB = IVARX(154)
      LJL_FCM = IVARX(155)
      LJL_FRC = IVARX(156)
      LJL_MCB = IVARX(157)
      LJL_MCF = IVARX(158)
      LJM = IVARX(159)
      LJN = IVARX(160)
      LJN_BH = IVARX(161)
      LJO = IVARX(162)
      LJO_GM = IVARX(163)
      LL = IVARX(164)
      LM = IVARX(165)
      LMC = IVARX(166)
      LMCG = IVARX(167)
      LMNP = IVARX(168)
      LMPH = IVARX(169)
      LN = IVARX(170)
      LN_BH = IVARX(171)
      LN_BHC = IVARX(172)
      LN_CW = IVARX(173)
      LN_LW = IVARX(174)
      LN2 = IVARX(175)
      LNAF = IVARX(176)
      LNC_FRC = IVARX(177)
      LNCF = IVARX(178)
      LNEU = IVARX(179)
      LNGC = IVARX(180)
      LNHC = IVARX(181)
      LNNF = IVARX(182)
      LNNGC = IVARX(183)
      LNOTES = IVARX(184)
      LNW = IVARX(185)
      LNWN = IVARX(186)
      LNWS = IVARX(187)
      LNWT = IVARX(188)
      LNWV = IVARX(189)
      LO_PH = IVARX(190)
      LO_TH = IVARX(191)
      LOBDS = IVARX(192)
      LOBDT = IVARX(193)
      LOUPV = IVARX(194)
      LP_MPI = IVARX(195)
      LP_TA = IVARX(196)
      LPC = IVARX(197)
      LPCF = IVARX(198)
      LPE_HT = IVARX(199)
      LPF_EOR = IVARX(200)
      LPH = IVARX(201)
      LPLANT = IVARX(202)
      LPOLYC = IVARX(203)
      LPOLYN = IVARX(204)
      LPP_HT = IVARX(205)
      LPT = IVARX(206)
      LPTA = IVARX(207)
      LPTM = IVARX(208)
      LPX_MPI = IVARX(209)
      LPY_MPI = IVARX(210)
      LPZ_MPI = IVARX(211)
      LR = IVARX(212)
      LRC = IVARX(213)
      LRCE = IVARX(214)
      LRCG = IVARX(215)
      LRCK = IVARX(216)
      LRCL = IVARX(217)
      LRCN = IVARX(218)
      LRCS = IVARX(219)
      LRCT = IVARX(220)
      LREF = IVARX(221)
      LREK = IVARX(222)
      LREL = IVARX(223)
      LREM = IVARX(224)
      LRFN = IVARX(225)
      LRK = IVARX(226)
      LRPGC = IVARX(227)
      LRPL = IVARX(228)
      LRPLC = IVARX(229)
      LRPNC = IVARX(230)
      LS = IVARX(231)
      LSALC = IVARX(232)
      LSCHR = IVARX(233)
      LSEC = IVARX(234)
      LSEE = IVARX(235)
      LSEK = IVARX(236)
      LSF = IVARX(237)
      LSFCA = IVARX(238)
      LSFCC = IVARX(239)
      LSFCN = IVARX(240)
      LSFCP = IVARX(241)
      LSFCT = IVARX(242)
      LSFDOM = IVARX(243)
      LSFV = IVARX(244)
      LSFVGC = IVARX(245)
      LSOLSR = IVARX(246)
      LSOLU = IVARX(247)
      LSOLU_BH = IVARX(248)
      LSOLU_CW = IVARX(249)
      LSP = IVARX(250)
      LSPBC = IVARX(251)
      LSPC_CW = IVARX(252)
      LSPE = IVARX(253)
      LSPG = IVARX(254)
      LSPILL = IVARX(255)
      LSPK = IVARX(256)
      LSPL = IVARX(257)
      LSPLK = IVARX(258)
      LSPN = IVARX(259)
      LSPR = IVARX(260)
      LSPS = IVARX(261)
      LSPT = IVARX(262)
      LSR = IVARX(263)
      LSR_BH = IVARX(264)
      LSR_FRC = IVARX(265)
      LSRX = IVARX(266)
      LSRY = IVARX(267)
      LSRZ = IVARX(268)
      LSTC = IVARX(269)
      LSTM = IVARX(270)
      LSTM_BH = IVARX(271)
      LSTM_FRC = IVARX(272)
      LSU = IVARX(273)
      LSV = IVARX(274)
      LSW = IVARX(275)
      LSX = IVARX(276)
      LSXC = IVARX(277)
      LSXG = IVARX(278)
      LSXGC = IVARX(279)
      LSXL = IVARX(280)
      LSXLC = IVARX(281)
      LSXN = IVARX(282)
      LSXN2 = IVARX(283)
      LSXNC = IVARX(284)
      LSXS = IVARX(285)
      LSXT = IVARX(286)
      LSY = IVARX(287)
      LSYC = IVARX(288)
      LSYG = IVARX(289)
      LSYGC = IVARX(290)
      LSYL = IVARX(291)
      LSYLC = IVARX(292)
      LSYN = IVARX(293)
      LSYN2 = IVARX(294)
      LSYNC = IVARX(295)
      LSYS = IVARX(296)
      LSYT = IVARX(297)
      LSZ = IVARX(298)
      LSZC = IVARX(299)
      LSZG = IVARX(300)
      LSZGC = IVARX(301)
      LSZL = IVARX(302)
      LSZLC = IVARX(303)
      LSZN = IVARX(304)
      LSZN2 = IVARX(305)
      LSZNC = IVARX(306)
      LSZS = IVARX(307)
      LSZT = IVARX(308)
      LSZW = IVARX(309)
      LT = IVARX(310)
      LT_BH = IVARX(311)
      LT_FRC = IVARX(312)
      LT_FRCC = IVARX(313)
      LT_PH = IVARX(314)
      LT_TA = IVARX(315)
      LT_TH = IVARX(316)
      LTBL = IVARX(317)
      LTC_FRC = IVARX(318)
      LTP_HT = IVARX(319)
      LUGR = IVARX(320)
      LUK = IVARX(321)
      LUK_BH = IVARX(322)
      LUK_CW = IVARX(323)
      LUK_SFC = IVARX(324)
      LUKW = IVARX(325)
      LVIC_FRC = IVARX(326)
      LVPLOT = IVARX(327)
      LVREF = IVARX(328)
      LWELL = IVARX(329)
      LWF_CW = IVARX(330)
      LWF_LW = IVARX(331)
      LWI_CW = IVARX(332)
      LWI_LW = IVARX(333)
      LWN_CW = IVARX(334)
      LWN_LW = IVARX(335)
      LWSI = IVARX(336)
      LWT_CW = IVARX(337)
      LWTI = IVARX(338)
      LWTP_CW = IVARX(339)
      LXP_FRC = IVARX(340)
      LXYZG = IVARX(341)
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read time variables (duplicated across processors)  ---
!
      NVAR = 18
      ALLOCATE( VARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      TM = VARX(1)
      TMMX = VARX(2)
      TMPR = VARX(3)
      DT = VARX(4)
      DTI = VARX(5)
      DTMX = VARX(6)
      DTMN = VARX(7)
      DTAF = VARX(8)
      DTCF = VARX(9)
      DTO = VARX(10)
      DTSO = VARX(11)
      RSDMX = VARX(12)
      RLXF = VARX(13)
      CRNTMXC = VARX(14)
      RTOL_PETSC = VARX(15)
      ATOL_PETSC = VARX(16)
      DTOL_PETSC = VARX(17)
      MAXITS_PETSC = INT(VARX(18))
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for solution control variables  ---
!
      CALL ALLOC_SOLTN
!
!---  Initialize solution control variables  ---
!
      CALL INTLZ_SOLTN
!
!---  Read time stepping variables (duplicated across processors)  ---
!
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPE,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPD,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPA,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RSDM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LUK*(1+LWELL+LSPILL)
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RSD,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = 20
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,WFMN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read solution control integers (duplicated across processors)  ---
!
      NVAR = 39
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IVRSN = IVARX(1)
      ISIC = IVARX(2)
      ICNV = IVARX(3)
      IEO = IVARX(4)
      ILES = IVARX(5)
      IOM = IVARX(6)
      ICODE = IVARX(7)
      IEQT = IVARX(8)
      IEQW = IVARX(9)
      IEQA = IVARX(10)
      IEQN = IVARX(11)
      IEQO = IVARX(12)
      IEQC = IVARX(13)
      IEQS = IVARX(14)
      IEQD = IVARX(15)
      IEQDO = IVARX(16)
      IEQHA = IVARX(17)
      IEQHN = IVARX(18)
      IEQHO = IVARX(19)
      IEQDA = IVARX(20)
      IAQU = IVARX(21)
      IGAS = IVARX(22)
      INAPL = IVARX(23)
      NEPD = IVARX(24)
      MEPD = IVARX(25)
      IEPD = IVARX(26)
      NRIMX = IVARX(27)
      NSTEP = IVARX(28)
      NRST = IVARX(29)
      NITER = IVARX(30)
      NTSR = IVARX(31)
      NGC = IVARX(32)
      MXSTEP = IVARX(33)
      IUNM = IVARX(34)
      IUNKG = IVARX(35)
      IUNS = IVARX(36)
      IUNK = IVARX(37)
      IUNMOL = IVARX(38)
      ISVC = IVARX(39)
      ISVF = 2*ISVC + 1
      DO M = 1,4
        M_ERR(M) = ''
      ENDDO
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read solution control integers (duplicated across processors)  ---
!
      NVAR = 100
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISLC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IEDLS = 1
      IF( ISLC(4).EQ.1 ) IEDLS = 3
!
!---  Read interfacial averaging indices
!     (duplicated across processors)  ---
!
      NVAR = 20
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IDMN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for output control variables  ---
!
      CALL ALLOC_OUTPU
!
!---  Read output unit conversions
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVTM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVLN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVPLOT,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVREF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = 2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVSF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read output units
!     (duplicated across processors)  ---
!
      NVAR = 64
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNTM,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNLN,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64*LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNPLOT,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64*LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNREF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64*2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNSF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!
!---  Read output control variables
!     (duplicated across processors)  ---
!
      NVAR = LPTM
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PRTM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read output control integer arrays
!     (duplicated across processors)  ---
!
      NVAR = LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IPLOT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IPLOTGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IREF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IREFGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NDREF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFD,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFGP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read output control integers (duplicated across processors)  ---
!
      NVAR = 14
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NPRTM = IVARX(1)
      NVPLOT = IVARX(2)
      NREF = IVARX(3)
      NVREF = IVARX(4)
      ICNO = IVARX(5)
      ICNS = IVARX(6)
      NSF = IVARX(7)
      NSFGP = IVARX(8)
      IHSF = IVARX(9)
      IHSF = 0
      IFQS = IVARX(10)
      IFQO = IVARX(11)
      ISGNS = IVARX(12)
      ISGNO = IVARX(13)
      ISGNP = IVARX(14)
!      PRINT *,'NSF = ',NSF,' ID = ',ID
!
!---  Read output character strings, duplicated over all processors  ---
!
      NVAR = 64*LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CHREF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!
!---  Read surface flux file names, duplicated over all processors  ---
!
      NVAR = 64*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,FNSF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!      PRINT *,'FNSF = ',(FNSF(M),M=1,NSF),' ID = ',ID
!
!---  Read surface flux header character strings, 
!     duplicated over all processors  ---
!
      NVAR = 64*2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CHSF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!      PRINT *,'CHSF = ',((CHSF(L,M),L=1,2),M=1,NSF),' ID = ',ID
!
!---  Allocate memory for NSFN  ---
!
      ALLOCATE( NSFN(1:NP),STAT=ISTAT )
      CHMSG = 'NSFN'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local number of surface flux nodes on each processor, 
!     duplicated over all processors  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSFN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      DO M = 1,NP
!        PRINT *,'NSFN(',M,') = ',NSFN(M),' ID = ',ID
!      ENDDO
!
!---  Determine offsets for reading ISFN and ISFS  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NSFN(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NSFN(N)
      ENDDO
!      PRINT *,'NC = ',NC,' NCP = ',NCP,' ID = ',ID
!
!---  Allocate memory for ISFN  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFN(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFN'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for ISFS  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFS(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFS'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for ISFB  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFB(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFB'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local surface-flux node number  ---
!
      NVAR = NSFN(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'ISFN = ',(ISFN(M),M=1,NSFN(ID+1)),' ID = ',ID
!
!---  Read local surface-flux number  ---
!
      NVAR = NSFN(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFS,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'ISFS = ',(ISFS(M),M=1,NSFN(ID+1)),' ID = ',ID
!
!---  Allocate memory for hydrate kinetic variables  ---
!
      ALLOCATE( CHKN(1:10),STAT=ISTAT )
      CHMSG = 'CHKN'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read hydrate kinetic variables (duplicated across processors)  ---
!
      NVAR = 10
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CHKN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the solu.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_SOLU_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_SORC_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary sorc.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOURC
      USE SOLTN
      USE PROP
      USE OUTPU
      USE GRID
      USE GLB_PAR
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_SORC_HYDT_KE'
!
!---  Open sorc.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'sorc.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate memory for NSR  ---
!
      ALLOCATE( NSR(1:NP),STAT=ISTAT )
      CHMSG = 'NSR'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of source nodes on each processor  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate local source arrays  ---
!
      CALL ALLOC_SOURC
!
!---  Initialize source variables  ---
!
      CALL INTLZ_SOURC
!
!---  Read source variables (duplicated across processors)  ---
!
      LX = 8+LSOLU+LSPT+LNGC
      NVAR = LX*LSTM*LSR
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,SRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read array of source nodes  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NSR(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NSR(N)
      ENDDO
!
!---  Index array of source field nodes  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source number of time points  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source inputs  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRIN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source types  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      DO N = 1,NSR(ID+1)
!        PRINT *,'ISRT(',N,') = ',ISRT(N),' ID = ',ID
!      ENDDO
!
!---  Close the sorc.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_SORC_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_STATE_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary state.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 07 June 2012
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE PROP
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_STATE_HYDT_KE'
!
!---  Open state1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate local memory for general field variables 
!     (including ghost cells)  ---
!
      CALL ALLOC_FDVP
!
!---  Initialize global array memory for general field variables  ---
!
      CALL INTLZ_FDVP
!
!---  Allocate local memory for hydrate field variables
!     (including ghost cells)  ---
!
      CALL ALLOC_FDVH
!
!---  Initialize global array memory for hydrate field variables  ---
!
      CALL INTLZ_FDVH
!
!---  Allocate array memory for hysteretic k-s-P function 
!     variables  ---
!
      CALL ALLOC_HYST
!
!---  Initialize global array memory for Hysteretic k-s-P function 
!     variables  ---
!
      CALL INTLZ_HYST
!
!---  Allocate local temporary state condition arrays 
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Read local copies of T array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        T(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PL(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PG(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PSO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PSO(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of POSM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        POSM(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of ZMCA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        ZMCA(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of ZMCO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        ZMCO(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of ZMCN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        ZMCN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SG(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SL(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SH array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SH(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SI array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SI(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of YLS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YLS(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of YMGA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YMGA(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of YMGO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YMGO(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of YMGN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YMGN(2,N) = VARX(N)
      ENDDO
!
!---  Close the state1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open state2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of YMHGA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YMHGA(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of YMHGO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YMHGO(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of YMHGN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YMHGN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of TMHA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        TMHA(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of TMHO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        TMHO(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of TMHN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        TMHN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PVA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PVA(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PVO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PVO(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PVN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PVN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PVW array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PVW(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of XHA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        XHA(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of XHO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        XHO(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of XHN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        XHN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of XHW array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        XHW(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PORD array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PORD(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PORT array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PORT(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of NPHAZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        NPHAZ(2,N) = IVARX(N)
      ENDDO
!
!---  Close the state2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_STATE_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_TPORT_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Read binary input.bin file for solute transport data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 26 April 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE PROP
      USE HYST
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_TPORT_HYDT_KE'
!
!---  Allocate and initialize memory, global and local, for 
!     solute transport arrays  ---
!
      CALL ALLOC_TRNSPT
      CALL INTLZ_TRNSPT
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Allocate local temporary real and integer nodal arrays 
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of solutes (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSOLU,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'NSOLU = ',NSOLU,' ID = ',ID
!
!---  Read solute parameters, indices, and variables
!     if solutes are modeled  ---
!
      IF( NSOLU.GT.0 ) THEN
!
!---    Read solute names (duplicated across processors)  ---
!
        NVAR = 64*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SOLUT,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SOLUT = ',(SOLUT(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Loop over the number of solutes  ---
!
        DO NSL = 1,NSOLU
!
!---      Read local copies of C array (including ghost cells)  ---
!
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            C(N,NSL) = VARX(N)
          ENDDO
!          PRINT *,'C(2,',NSL,') = ',C(2,NSL),'C(3,',NSL,') = ',C(3,NSL),
!     &      'C(4,',NSL,') = ',C(4,NSL),' ID = ',ID
        ENDDO
!
!---    Read solute aqueous diffusion coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SMDL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SMDL = ',(SMDL(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute gas diffusion coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SMDG,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SMDG = ',(SMDG(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read index for solute gas-aqueous partition coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IPCGL,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IPCGL = ',(IPCGL(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute gas-aqueous partition coefficient parameters
!       (duplicated across processors)  ---
!
        NVAR = 5*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PCGL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!
!---    Read solute half-life, s
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,HLF,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'HLF = ',(HLF(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute chain-decay fraction
!       (duplicated across processors)  ---
!
        NVAR = NSOLU*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CHDF,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'CHDF = ',((CHDF(MSL,NSL),MSL=1,NSOLU),NSL=1,NSOLU),
!     &    ' ID = ',ID
!
!---    Read number of Bateman chain decay series
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,NBCDS,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'NBCDS = ',NBCDS,' ID = ',ID
!
!---    Read Bateman chain decay series index
!       (duplicated across processors)  ---
!
        NVAR = LCDC+LSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCDS,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IBCDS = ',(IBCDS(M),M=1,LCDC+LSOLU),' ID = ',ID
!
!---    Read Bateman number of solutes in chain decay path
!       (duplicated across processors)  ---
!
        NVAR = LCDC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,NBCDP,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'NBCDP = ',(NBCDP(M),M=1,LCDC),' ID = ',ID
!
!---    Read Bateman chain decay path indices
!       (duplicated across processors)  ---
!
        NVAR = LCDS*LCDP*LCDC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCDP,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IBCDP = ',
!     &    (((IBCDP(K,L,M),K=1,LCDS),L=1,LCDP),M=1,LCDC),' ID = ',ID
!
!---    Read Courant number calculation index
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ICRNT,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ICRNT = ',ICRNT,' ID = ',ID
!        PRINT *,'IBCDS = ',(IBCDS(M),M=1,NSOLU+NBCDS),' ID = ',ID
!
!---    Read maximum Courant number
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CRNTMXT,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'CRNTMXT = ',CRNTMXT,' ID = ',ID
!
!---    Loop over the number of solutes  ---
!
        DO NSL = 1,NSOLU
!
!---      Loop over the number of solid-aqueous partition
!         coefficient indices  ---
!
          DO M = 1,5
!
!---        Read local copies of solute solid-aqueous partition 
!           coefficient (including ghost cells)  ---
!
            NVAR = NFCGC(ID+1)
            OFFSET = IOFFSET + NC*NBYTR + NBYTB
            IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
            CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &        STATUS,IERR)
            DO N = 1,NFCGC(ID+1)
              PCSL(M,N,NSL) = VARX(N)
            ENDDO
!            PRINT *,'PCSL(',M,',',ND(11),',',NSL,') = ',
!     &        PCSL(M,11,NSL),' ID = ',ID
          ENDDO
        ENDDO
!
!---    Read local copies of longitudinal dispersivity
!       (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTR + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,DISPL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'DISPL(1) = ',DISPL(1),' ID = ',ID
!
!---    Read local copies of transverse dispersivity
!       (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTR + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,DISPT,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'DISPT(1) = ',DISPT(1),' ID = ',ID
      ENDIF
!
!---  Loop over the number of solutes and reactive species  ---
!
      DO M = 1,LSOLU+LSPT
!
!---    Read local copies of solute or reactive species initial
!       condition indices (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTI + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
        DO N = 1,NFCGC(ID+1)
          ICT(N,M) = IVARX(N)
        ENDDO
!        PRINT *,'ICT(',ND(11),',',M,') = ',ICT(11,M),' ID = ',ID
      ENDDO
!
!---  Deallocate local temporary real and integer nodal arrays 
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_TPORT_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKG_HYDT_KE( RKGX,SGX,SHX,SLX,SNX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Gas relative permeability
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 15 January 2013
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RKG_HYDT_KE'
!
!---  Hydrate saturation independent ksp or ks  ---
!
      SHZ = SHX
      IF( ISLC(82).EQ.1 .OR. ISLC(82).EQ.3 ) THEN
        SHZ = 0.D+0 
!
!---    Effective saturations for relative permeability
!       calculations  ---
!
        IF( SHX.LT.1.D+0 ) THEN
          SLZ = SLX/(1.D+0-SHX)
          SNZ = SNX/(1.D+0-SHX)
          SGZ = SGX/(1.D+0-SHX)
        ELSE
          SLZ = 0.D+0
          SNZ = 0.D+0
          SGZ = 0.D+0
        ENDIF
      ELSE
        SLZ = SLX
        SNZ = SNX
        SGZ = SGX
      ENDIF
      SLRX = SCHR(4,N)
      ASLX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASNX = MIN( MAX( SNZ/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASGX = MIN( MAX( SGZ/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASTX = MIN( MAX( ASLX+ASNX,0.D+0 ),1.D+0 )
!
!---  Constant aqueous relative permeability  ---
!
      IF( IRPG(N).EQ.0 ) THEN
        RKGX = RPGC(3,N)
!
!---  Mualem aqueous relative permeability  ---
!
      ELSEIF( IRPG(N).EQ.1 ) THEN
!
!---    van Genuchten saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 ) THEN
          CMX = RPGC(3,N)
          RKGX = SQRT(ASGX)*((1.D+0-ASTX**(1.D+0/CMX))**CMX)**2
!
!---    Brooks and Corey saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 ) THEN
          CLX = RPGC(3,N)
          RKGX = SQRT(ASGX)*(1.D+0-ASTX**(1.D+0+1.D+0/CLX))**2
!
!---    van Genuchten saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          CMX = RPGC(3,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SGPX = MIN( MAX( SGZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKGX = SQRT(SGPX)*((1.D+0-(SLPX+SNPX)**(1.D+0/CMX))**CMX)**2
!
!---    Brooks and Corey saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          CLX = RPGC(3,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SGPX = MIN( MAX( SGZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKGX = SQRT(SGPX)*(1.D+0-(SLPX+SNPX)**(1.D+0+1.D+0/CLX))**2
        ENDIF
!
!---  Burdine aqueous relative permeability  ---
!
      ELSEIF( IRPG(N).EQ.2 ) THEN
!
!---    van Genuchten saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 ) THEN
          CMX = RPGC(3,N)
          RKGX = (ASGX**2)*((1.D+0-ASTX**(1.D+0/CMX))**CMX)
!
!---    Brooks and Corey saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 ) THEN
          CLX = RPGC(3,N)
          RKGX = (ASGX**2)*(1.D+0-ASTX**(1.D+0 + 2.D+0/CLX))
!
!---    van Genuchten saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          CMX = RPGC(3,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SGPX = MIN( MAX( SGZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKGX = (SGPX**2)*((1.D+0-(SLPX+SNPX)**(1.D+0/CMX))**CMX)
!
!---    Brooks and Corey saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          CLX = RPGC(3,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SGPX = MIN( MAX( SGZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKGX = (SGPX**2)*(1.D+0-(SLPX+SNPX)**(1.D+0 + 2.D+0/CLX))
        ENDIF
!
!---  Free Corey relative permeability function,
!     modified from STOMP-CO2 for the Moridis
!     code comparison problem  ---
!
      ELSEIF( IRPG(N).EQ.7 ) THEN
        SLRX = RPGC(3,N)
        SGRX = RPGC(4,N)
        SGPX = MIN( MAX( (SGZ-SGRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        RKGX = RPGC(1,N)*(SGPX**(RPGC(2,N)))
!
!---  Unrecognized aqueous relative permeability  ---
!
      ELSE
        PRINT *,'Unrecognized Gas Relative Permeability' //
     &      ' Function: IRPG(N) = ',IRPG(N),' ID = ',ID
      ENDIF
      RKGX = MAX( RKGX,0.D+0 )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKG_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKL_HYDT_KE( RKLX,SGX,SHX,SLX,SNX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Aqueous relative permeability
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 January 2013
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RKL_HYDT_KE'
!
!---  Hydrate saturation independent ksp or ks  ---
!
      SHZ = SHX
      IF( ISLC(82).EQ.1 .OR. ISLC(82).EQ.3 ) THEN
        SHZ = 0.D+0 
!
!---    Effective saturations for relative permeability
!       calculations  ---
!
        IF( SHX.LT.1.D+0 ) THEN
          SLZ = SLX/(1.D+0-SHX)
          SNZ = SNX/(1.D+0-SHX)
          SGZ = SGX/(1.D+0-SHX)
        ELSE
          SLZ = 0.D+0
          SNZ = 0.D+0
          SGZ = 0.D+0
        ENDIF
      ELSE
        SLZ = SLX
        SNZ = SNX
        SGZ = SGX
      ENDIF
      SLRX = SCHR(4,N)
      ASLX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASNX = MIN( MAX( SNZ/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASGX = MIN( MAX( SGZ/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASTX = MIN( MAX( ASLX+ASNX,0.D+0 ),1.D+0 )
!
!---  Constant aqueous relative permeability  ---
!
      IF( IRPL(N).EQ.0 ) THEN
        RKLX = RPLC(2,N)
!
!---  Mualem aqueous relative permeability  ---
!
      ELSEIF( IRPL(N).EQ.1 ) THEN
!
!---    van Genuchten saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 ) THEN
          CMX = RPLC(2,N)
          RKLX = SQRT(ASLX)*(1.D+0 -
     &    (1.D+0-ASLX**(1.D+0/CMX))**CMX)**2
!
!---    Brooks and Corey saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 ) THEN
          CLX = RPLC(2,N)
          RKLX = ASLX**(2.5D+0 + 2.D+0/CLX)
!
!---    van Genuchten saturation function w/ the
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          CMX = RPLC(2,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKLX = SQRT(SLPX)*(1.D+0 -
     &    (1.D+0-SLPX**(1.D+0/CMX))**CMX)**2
!
!---    Brooks and Corey saturation function w/ the
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          CLX = RPLC(2,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKLX = SLPX**(2.5D+0 + 2.D+0/CLX)
        ENDIF
!
!---  Burdine aqueous relative permeability  ---
!
      ELSEIF( IRPL(N).EQ.2 ) THEN
!
!---    van Genuchten saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 ) THEN
          CMX = RPLC(2,N)
          RKLX = (ASLX**2)*(1.D+0 -
     &      (1.D+0-ASLX**(1.D+0/CMX))**CMX)
!
!---    Brooks and Corey saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 ) THEN
          CLX = RPLC(2,N)
          RKLX = ASLX**(3.0D+0 + 2.D+0/CLX)
!
!---    van Genuchten saturation function w/ the
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          CMX = RPLC(2,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKLX = (SLPX**2)*(1.D+0 -
     &      (1.D+0-SLPX**(1.D+0/CMX))**CMX)
!
!---    Brooks and Corey saturation function w/ the
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          CLX = RPLC(2,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKLX = SLPX**(3.0D+0 + 2.D+0/CLX)
        ENDIF
!
!---  Free Corey relative permeability function,
!     modified from STOMP-CO2 for the Moridis
!     code comparison problem  ---
!
      ELSEIF( IRPL(N).EQ.7 ) THEN
        SLRX = RPLC(3,N)
        SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        RKLX = RPLC(1,N)*(SLPX**(RPLC(2,N)))
!
!---  Modified Mualem aqueous relative permeability  ---
!
      ELSEIF( IRPL(N).EQ.22 ) THEN
!
!---    van Genuchten saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 ) THEN
          RKLX = (ASLX**RPLC(1,N))*((1.D+0-(1.D+0-ASLX**
     &      (1.D+0/RPLC(2,N)))**RPLC(2,N))**2)
!
!---    Brooks and Corey saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 ) THEN
          RKLX = (ASLX**RPLC(1,N))*
     &      ASLX**(2.D+0 + 2.0D+0/RPLC(2,N))
!
!---    van Genuchten saturation function w/ the
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKLX = (SLPX**RPLC(1,N))*((1.D+0-(1.D+0-SLPX**
     &      (1.D+0/RPLC(2,N)))**RPLC(2,N))**2)
!
!---    Brooks and Corey saturation function w/ the
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKLX = (SLPX**RPLC(1,N))*
     &      SLPX**(2.D+0 + 2.0D+0/RPLC(2,N))
        ENDIF
!
!---  Unrecognized aqueous relative permeability  ---
!
      ELSE
        PRINT *,'Unrecognized Aqueous Relative Permeability' //
     &    ' Function: IRPL(N) = ',IRPL(N),' ID = ',ID
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKL_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKN_HYDT_KE( RKNX,SGX,SHX,SLX,SNX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Nonaqueous-liquid relative permeability
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 15 January 2013
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RKN_HYDT_KE'
!
!---  Hydrate saturation independent ksp or ks  ---
!
      SHZ = SHX
      IF( ISLC(82).EQ.1 .OR. ISLC(82).EQ.3 ) THEN
        SHZ = 0.D+0 
!
!---    Effective saturations for relative permeability
!       calculations  ---
!
        IF( SHX.LT.1.D+0 ) THEN
          SLZ = SLX/(1.D+0-SHX)
          SNZ = SNX/(1.D+0-SHX)
          SGZ = SGX/(1.D+0-SHX)
        ELSE
          SLZ = 0.D+0
          SNZ = 0.D+0
          SGZ = 0.D+0
        ENDIF
      ELSE
        SLZ = SLX
        SNZ = SNX
        SGZ = SGX
      ENDIF
      SLRX = SCHR(4,N)
      ASLX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASNX = MIN( MAX( SNZ/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASGX = MIN( MAX( SGZ/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ASTX = MIN( MAX( ASLX+ASNX,0.D+0 ),1.D+0 )
!
!---  Constant aqueous relative permeability  ---
!
      IF( IRPN(N).EQ.0 ) THEN
        RKNX = RPNC(1,N)
!
!---  Mualem aqueous relative permeability  ---
!
      ELSEIF( IRPN(N).EQ.1 ) THEN
!
!---    van Genuchten saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 ) THEN
          CMX = RPNC(1,N)
          RKNX = SQRT(ASNX)*((1.D+0 - (ASTX-ASNX)**(1.D+0/CMX))**CMX -
     &      (1.D+0 - (ASTX)**(1.D+0/CMX))**CMX)**2
!
!---    Brooks and Corey saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 ) THEN
          CLX = RPNC(1,N)
          RKNX = SQRT(ASNX)*( ASTX**(2.0D+0 + 2.D+0/CLX) -
     &        (ASTX-ASNX)**(2.0D+0 + 2.D+0/CLX) )
!
!---    van Genuchten saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          CMX = RPNC(1,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKNX = SQRT(SNPX)*((1.D+0 - (SLPX)**(1.D+0/CMX))**CMX -
     &      (1.D+0 - (SLPX+SNPX)**(1.D+0/CMX))**CMX)**2
!
!---    Brooks and Corey saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          CLX = RPNC(1,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKNX = SQRT(SNPX)*( (SLPX+SNPX)**(2.0D+0 + 2.D+0/CLX) -
     &      SLPX**(2.0D+0 + 2.D+0/CLX) )
        ENDIF
!
!---  Burdine aqueous relative permeability  ---
!
      ELSEIF( IRPN(N).EQ.2 ) THEN
!
!---    van Genuchten saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 ) THEN
          CMX = RPNC(1,N)
          RKNX = (ASNX**2)*((1.D+0 - (ASTX-ASNX)**(1.D+0/CMX))**CMX -
     &      (1.D+0 - (ASTX)**(1.D+0/CMX))**CMX)
!
!---    Brooks and Corey saturation function w/o or w/ the
!       hydrate capillary pressure barrier  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 ) THEN
          CLX = RPNC(1,N)
          RKNX = (ASNX**2)*( ASTX**(1.0D+0 + 2.D+0/CLX) -
     &      (ASTX-ASNX)**(1.0D+0 + 2.D+0/CLX) )
!
!---    van Genuchten saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          CMX = RPNC(1,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKNX = (SNPX**2)*((1.D+0 - (SLPX)**(1.D+0/CMX))**CMX -
     &      (1.D+0 - (SLPX+SNPX)**(1.D+0/CMX))**CMX)
!
!---    Brooks and Corey saturation function w/
!       hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          CLX = RPNC(1,N)
          SLRX = SCHR(4,N)
          SLPX = MIN( MAX( (SLZ-SLRX)/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          SNPX = MIN( MAX( SNZ/(1.D+0-SHZ-SLRX),0.D+0 ),1.D+0 )
          RKNX = (SNPX**2)*( (SLPX+SNPX)**(1.0D+0 + 2.D+0/CLX) -
     &      SLPX**(1.0D+0 + 2.D+0/CLX) )
        ENDIF
!
!---  Free Corey relative permeability function,
!     modified from STOMP-CO2 for the Moridis
!     code comparison problem  ---
!
      ELSEIF( IRPN(N).EQ.7 ) THEN
        SLRX = RPNC(3,N)
        SNRX = RPNC(4,N)
        SNPX = MIN( MAX( (SNZ-SNRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        RKNX = RPNC(1,N)*(SNPX**(RPNC(2,N)))
!
!---  Unrecognized aqueous relative permeability  ---
!
      ELSE
        PRINT *,'Unrecognized NAPL Relative Permeability' //
     &      ' Function: IRPN(N) = ',IRPN(N),' ID = ',ID
      ENDIF
      RKNX = MAX( RKNX,0.D+0 )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKN_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RSDL_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute the maximum relative residuals
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 10 September 2021.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
      USE JACOB
      USE HYST
      USE GRID
      USE FILES
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(LUK*(1+LWELL+LSPILL)) :: RSDLX	
      REAL*8, DIMENSION(11) :: VARX	
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: NSDLX,NPHLX,NPHX
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: IDLX,IDX
      INTEGER, DIMENSION(NFCGC(ID+1)) :: IRSDX
      INTEGER, DIMENSION(19) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*128 PH_CND(43)
!
!----------------------Data Statements---------------------------------!
!
      DATA PH_CND /9*'','SH = 0, SG = 0, SN = 0',10*'',
     &  'SH = 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN )',
     &  'SH = 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN )',
     &  'SH = 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO )',7*'',
     &  'SH > 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN ), YMHGA >= MAX(YMH
     &GO,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN ), YMHGA >= MAX(YMH
     &GO,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO ), YMHGA >= MAX(YMH
     &GO,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN ), YMHGO >= MAX(YMH
     &GA,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN ), YMHGO >= MAX(YMH
     &GA,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO ), YMHGO >= MAX(YMH
     &GA,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN ), YMHGN >= MAX(YMH
     &GA,YMHGO )',
     &  'SH > 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN ), YMHGN >= MAX(YMH
     &GA,YMHGO )',
     &  'SH > 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO ), YMHGN >= MAX(YMH
     &GA,YMHGO )','',
     &  'SH > 0, SG + SN = 0, YMHGA >= MAX(YMHGO,YMHGN )',
     &  'SH > 0, SG + SN = 0, YMHGO >= MAX(YMHGA,YMHGN )',
     &  'SH > 0, SG + SN = 0, YMHGN >= MAX(YMHGA,YMHGO )'/
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RSDL_HYDT_KE'
!
!---  Zero local and global maximum residuals  ---
!
      DO M = 1,ISVC
        RSD(M) = 0.D+0
        RSDLX(M) = 0.D+0
        NSD(M) = 0
        NSDLX(M) = 0
        NPHLX(M) = 0
      ENDDO
!
!---  Loop over local nodes  ---
!
      NMD = 0
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        MPT = NMD + IEQT
        DPT = BLU(MPT)
        MPW = NMD + IEQW
        DPW = BLU(MPW)
        IF( ISLC(45).EQ.0 ) THEN
          MPA = NMD + IEQA
          DPA = BLU(MPA)
        ENDIF
        IF( ISLC(64).EQ.0 ) THEN
          MPO = NMD + IEQO
          DPO = BLU(MPO)
        ENDIF
        IF( ISLC(65).EQ.0 ) THEN
          MPN = NMD + IEQN
          DPN = BLU(MPN)
        ELSE
          DPN = 0.D+0
        ENDIF
        IF( ISLC(45).EQ.0 ) THEN
          MPHA = NMD + IEQHA
          DPHA = BLU(MPHA)
        ENDIF
        IF( ISLC(64).EQ.0 ) THEN
          MPHO = NMD + IEQHO
          DPHO = BLU(MPHO)
        ENDIF
        IF( ISLC(65).EQ.0 ) THEN
          MPHN = NMD + IEQHN
          DPHN = BLU(MPHN)
        ELSE
          DPHN = 0.D+0
        ENDIF
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ELSE
          DPS = 0.D+0
        ENDIF
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
!
!---    Skip selected nodes in the residual calculation 
!       (not implemented)  ---
!
!        IF( ISKP(N).EQ.1 ) CYCLE
!
!---    Salt mass equation, isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          ACP = TMS(2,N)*DTI*VOL(N)
          CALL SOL_LS( T(2,N),XLSMX )
          RSDX = MIN( (ABS(DPS)/XLSMX),
     &      ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
          RSDX = RSDX*1.D-1
          IF( RSDX.GT.RSDLX(IEQS) ) THEN
            RSDLX(IEQS) = RSDX
            NSDLX(IEQS) = N
            NPHLX(IEQS) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
        ENDIF
!
!---    Core phase condition  ---
!
        NPHZX = MOD(NPHAZ(2,N),100)
!
!---    Phase condition #10 (10 series)  ---
!
!       SH = 0, SG + SN = 0, SL + SI = 1
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        IF( NPHZX.EQ.10 ) THEN
          PX = PSO(2,N) + PATM
          PX = MAX( PX,PG(2,N)-PL(2,N) )
!
!---      Energy equation  ---
!
          RSDX = ABS(DPT)/TABS
          IF( RSDX.GT.RSDLX(IEQT) ) THEN
            RSDLX(IEQT) = RSDX
            NSDLX(IEQT) = N
            NPHLX(IEQT) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Water residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) + 
     &      RHOI(2,N)*SI(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N) + 
     &      RHON(2,N)*SN(2,N)*XNW(2,N) + 
     &      RHOH(2,N)*SH(2,N)*XHW(2,N) )*DTI*VOL(N)
          RSDX = MIN( ABS(DPW)/PX,
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( POSM(2,N).LT.1.D-6 ) RSDX = 0.D+0
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Mobile CO2 residual  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( PVA(2,N).GT.(1.D-6*PX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLA(2,N) + 
     &          RHON(2,N)*SN(2,N)*XNA(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(DPA)/PX,
     &          ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX(IEQA) ) THEN
                RSDLX(IEQA) = RSDX
                NSDLX(IEQA) = N
                NPHLX(IEQA) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Mobile CH4 residual  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( PVO(2,N).GT.(1.D-6*PX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGO(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLO(2,N) + 
     &          RHON(2,N)*SN(2,N)*XNO(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(DPO)/PX,
     &          ABS(RSDL(IEQO,N)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX(IEQO) ) THEN
                RSDLX(IEQO) = RSDX
                NSDLX(IEQO) = N
                NPHLX(IEQO) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Mobile N2 residual  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( PVN(2,N).GT.(1.D-6*PX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGN(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLN(2,N) + 
     &          RHON(2,N)*SN(2,N)*XNN(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(DPN)/PX,
     &          ABS(RSDL(IEQN,N)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX(IEQN) ) THEN
                RSDLX(IEQN) = RSDX
                NSDLX(IEQN) = N
                NPHLX(IEQN) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---    Phase conditions 21 through 23 (20 series)  ---
!
!       SH = 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation - POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.21 .AND. NPHZX.LE.23  ) THEN
          PX = PSO(2,N) + PATM
          PX = MAX( PX,PG(2,N)-PL(2,N) )
!
!---      Energy equation  ---
!
          RSDX = ABS(DPT)/TABS
          IF( RSDX.GT.RSDLX(IEQT) ) THEN
            RSDLX(IEQT) = RSDX
            NSDLX(IEQT) = N
            NPHLX(IEQT) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Water residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) + 
     &      RHOI(2,N)*SI(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N) + 
     &      RHON(2,N)*SN(2,N)*XNW(2,N) + 
     &      RHOH(2,N)*SH(2,N)*XHW(2,N) )*DTI*VOL(N)
          RSDX = MIN( ABS(DPW)/PX,
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( POSM(2,N).LT.1.D-6 ) RSDX = 0.D+0
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Mobile CO2 residual  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &        RHOL(2,N)*SL(2,N)*XLA(2,N) + 
     &        RHON(2,N)*SN(2,N)*XNA(2,N))*DTI*VOL(N)
            IF( NPHZX.EQ.21 ) THEN
              IF( PSO(2,N).GT.(1.D-6*PX) ) THEN
                RSDX = MIN( ABS(DPA)/PX,
     &            ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              ENDIF
            ELSE
              RSDX = MIN( ABS(DPA),
     &          ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              IF( ZMCA(2,N).LT.EPSL .AND. DPA.LT.0.D+0 ) RSDX = 0.D+0
            ENDIF
            IF( RSDX.GT.RSDLX(IEQA) ) THEN
              RSDLX(IEQA) = RSDX
              NSDLX(IEQA) = N
              NPHLX(IEQA) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Mobile CH4 residual  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGO(2,N) +
     &        RHOL(2,N)*SL(2,N)*XLO(2,N) + 
     &        RHON(2,N)*SN(2,N)*XNO(2,N))*DTI*VOL(N)
            IF( NPHZX.EQ.22 ) THEN
              IF( PSO(2,N).GT.(1.D-6*PX) ) THEN
                RSDX = MIN( ABS(DPO)/PX,
     &            ABS(RSDL(IEQO,N)/(ACP+SMALL)) )
              ENDIF
            ELSE
              RSDX = MIN( ABS(DPO),
     &          ABS(RSDL(IEQO,N)/(ACP+SMALL)) )
              IF( ZMCO(2,N).LT.EPSL .AND. DPO.LT.0.D+0 ) RSDX = 0.D+0
            ENDIF
            IF( RSDX.GT.RSDLX(IEQO) ) THEN
              RSDLX(IEQO) = RSDX
              NSDLX(IEQO) = N
              NPHLX(IEQO) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Mobile N2 residual  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGN(2,N) +
     &        RHOL(2,N)*SL(2,N)*XLN(2,N) + 
     &        RHON(2,N)*SN(2,N)*XNN(2,N))*DTI*VOL(N)
            IF( NPHZX.EQ.22 ) THEN
              IF( PSO(2,N).GT.(1.D-6*PX) ) THEN
                RSDX = MIN( ABS(DPN)/PX,
     &            ABS(RSDL(IEQN,N)/(ACP+SMALL)) )
              ENDIF
            ELSE
              RSDX = MIN( ABS(DPN),
     &          ABS(RSDL(IEQN,N)/(ACP+SMALL)) )
              IF( ZMCN(2,N).LT.EPSL .AND. DPN.LT.0.D+0 ) RSDX = 0.D+0
            ENDIF
            IF( RSDX.GT.RSDLX(IEQN) ) THEN
              RSDLX(IEQN) = RSDX
              NSDLX(IEQN) = N
              NPHLX(IEQN) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase conditions #31 through #39 (30 series)  ---
!
!       SH > 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #34
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #35
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #36
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #37
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #38
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #39
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation, POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.39 ) THEN
          PX = PSO(2,N) + PATM
          PX = MAX( PX,PG(2,N)-PL(2,N) )
!
!---      Energy equation  ---
!
          RSDX = ABS(DPT)/TABS
          IF( RSDX.GT.RSDLX(IEQT) ) THEN
            RSDLX(IEQT) = RSDX
            NSDLX(IEQT) = N
            NPHLX(IEQT) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Water residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) + 
     &      RHOI(2,N)*SI(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N) + 
     &      RHON(2,N)*SN(2,N)*XNW(2,N) + 
     &      RHOH(2,N)*SH(2,N)*XHW(2,N) )*DTI*VOL(N)
          RSDX = MIN( ABS(DPW)/PX,
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( POSM(2,N).LT.1.D-6 ) RSDX = 0.D+0
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Mobile CO2 residual  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &        RHOL(2,N)*SL(2,N)*XLA(2,N) + 
     &        RHON(2,N)*SN(2,N)*XNA(2,N))*DTI*VOL(N)
            IF( NPHZX.GE.31 .AND. NPHZX.LE.33 ) THEN
              IF( PSO(2,N).GT.(1.D-6*PX) ) THEN
                RSDX = MIN( ABS(DPA)/PX,
     &            ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              ENDIF
            ELSE
              RSDX = MIN( ABS(DPA),
     &          ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              IF( ZMCA(2,N).LT.EPSL .AND. DPA.LT.0.D+0 ) RSDX = 0.D+0
            ENDIF
            RSDX = 1.D-1*RSDX
            IF( RSDX.GT.RSDLX(IEQA) ) THEN
              RSDLX(IEQA) = RSDX
              NSDLX(IEQA) = N
              NPHLX(IEQA) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Mobile CH4 residual  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGO(2,N) +
     &        RHOL(2,N)*SL(2,N)*XLO(2,N) + 
     &        RHON(2,N)*SN(2,N)*XNO(2,N))*DTI*VOL(N)
            IF( NPHZX.GE.34 .AND. NPHZX.LE.36 ) THEN
              IF( PSO(2,N).GT.(1.D-6*PX) ) THEN
                RSDX = MIN( ABS(DPO)/PX,
     &            ABS(RSDL(IEQO,N)/(ACP+SMALL)) )
              ENDIF
            ELSE
              RSDX = MIN( ABS(DPO),
     &          ABS(RSDL(IEQO,N)/(ACP+SMALL)) )
              IF( ZMCO(2,N).LT.EPSL .AND. DPO.LT.0.D+0 ) RSDX = 0.D+0
            ENDIF
            RSDX = 1.D-1*RSDX
            IF( RSDX.GT.RSDLX(IEQO) ) THEN
              RSDLX(IEQO) = RSDX
              NSDLX(IEQO) = N
              NPHLX(IEQO) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Mobile N2 residual  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGN(2,N) +
     &        RHOL(2,N)*SL(2,N)*XLN(2,N) + 
     &        RHON(2,N)*SN(2,N)*XNN(2,N))*DTI*VOL(N)
            IF( NPHZX.GE.37 .AND. NPHZX.LE.39 ) THEN
              IF( PSO(2,N).GT.(1.D-6*PX) ) THEN
                RSDX = MIN( ABS(DPN)/PX,
     &            ABS(RSDL(IEQN,N)/(ACP+SMALL)) )
              ENDIF
            ELSE
              RSDX = MIN( ABS(DPN),
     &          ABS(RSDL(IEQN,N)/(ACP+SMALL)) )
              IF( ZMCN(2,N).LT.EPSL .AND. DPN.LT.0.D+0 ) RSDX = 0.D+0
            ENDIF
            RSDX = 1.D-1*RSDX
            IF( RSDX.GT.RSDLX(IEQN) ) THEN
              RSDLX(IEQN) = RSDX
              NSDLX(IEQN) = N
              NPHLX(IEQN) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Hydrate-CO2 residual  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOH(2,N)*SH(2,N)*XHA(2,N))*DTI*VOL(N)
            RSDX = 1.D-1*MIN( ABS(DPHA),
     &        ABS(RSDL(IEQHA,N)/(ACP+SMALL)) )
            IF( YMHGA(2,N).LT.1.D-9 ) RSDX = 0.D+0
            IF( RSDX.GT.RSDLX(IEQHA) ) THEN
              RSDLX(IEQHA) = RSDX
              NSDLX(IEQHA) = N
              NPHLX(IEQHA) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Hydrate-CH4 residual  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOH(2,N)*SH(2,N)*XHO(2,N))*DTI*VOL(N)
            RSDX = 1.D-1*MIN( ABS(DPHO),
     &        ABS(RSDL(IEQHO,N)/(ACP+SMALL)) )
            IF( YMHGO(2,N).LT.1.D-9 ) RSDX = 0.D+0
            IF( RSDX.GT.RSDLX(IEQHO) ) THEN
              RSDLX(IEQHO) = RSDX
              NSDLX(IEQHO) = N
              NPHLX(IEQHO) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Hydrate-N2 residual  ---
!
          IF( ISLC(65).EQ.0 ) THEN 
            ACP = PORD(2,N)*(RHOH(2,N)*SH(2,N)*XHN(2,N))*DTI*VOL(N)
            RSDX = 1.D-1*MIN( ABS(DPHN),
     &        ABS(RSDL(IEQHN,N)/(ACP+SMALL)) )
            IF( YMHGN(2,N).LT.1.D-9 ) RSDX = 0.D+0
            IF( RSDX.GT.RSDLX(IEQHN) ) THEN
              RSDLX(IEQHN) = RSDX
              NSDLX(IEQHN) = N
              NPHLX(IEQHN) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase conditions #41 through #43 (40 series)  ---
!
!       SH > 0, SG + SN = 0, SL + SI < 1
!       YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!       YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!       YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
          PX = PSO(2,N) + PATM
          PX = MAX( PX,PG(2,N)-PL(2,N) )
!
!---      Energy equation  ---
!
          RSDX = ABS(DPT)/TABS
          IF( RSDX.GT.RSDLX(IEQT) ) THEN
            RSDLX(IEQT) = RSDX
            NSDLX(IEQT) = N
            NPHLX(IEQT) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Water residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) + 
     &      RHOI(2,N)*SI(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N) + 
     &      RHON(2,N)*SN(2,N)*XNW(2,N) + 
     &      RHOH(2,N)*SH(2,N)*XHW(2,N) )*DTI*VOL(N)
          RSDX = MIN( ABS(DPW)/PX,
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( POSM(2,N).LT.1.D-6 ) RSDX = 0.D+0
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Mobile CO2 residual  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( PVA(2,N).GT.(1.D-6*PX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLA(2,N) + 
     &          RHON(2,N)*SN(2,N)*XNA(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(DPA)/PX,
     &          ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              RSDX = 1.D-1*RSDX
              IF( RSDX.GT.RSDLX(IEQA) ) THEN
                RSDLX(IEQA) = RSDX
                NSDLX(IEQA) = N
                NPHLX(IEQA) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Mobile CH4 residual  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( PVO(2,N).GT.(1.D-6*PX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGO(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLO(2,N) + 
     &          RHON(2,N)*SN(2,N)*XNO(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(DPO)/PX,
     &          ABS(RSDL(IEQO,N)/(ACP+SMALL)) )
              RSDX = 1.D-1*RSDX
              IF( RSDX.GT.RSDLX(IEQO) ) THEN
                RSDLX(IEQO) = RSDX
                NSDLX(IEQO) = N
                NPHLX(IEQO) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Mobile N2 residual  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( PVN(2,N).GT.(1.D-6*PX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGN(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLN(2,N) + 
     &          RHON(2,N)*SN(2,N)*XNN(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(DPN)/PX,
     &          ABS(RSDL(IEQN,N)/(ACP+SMALL)) )
              RSDX = 1.D-1*RSDX
              IF( RSDX.GT.RSDLX(IEQN) ) THEN
                RSDLX(IEQN) = RSDX
                NSDLX(IEQN) = N
                NPHLX(IEQN) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Hydrate-CO2 residual  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOH(2,N)*SH(2,N)*XHA(2,N))*DTI*VOL(N)
            RSDX = 1.D-1*MIN( ABS(DPHA),
     &        ABS(RSDL(IEQHA,N)/(ACP+SMALL)) )
            IF( YMHGA(2,N).LT.1.D-9 ) RSDX = 0.D+0
            IF( RSDX.GT.RSDLX(IEQHA) ) THEN
              RSDLX(IEQHA) = RSDX
              NSDLX(IEQHA) = N
              NPHLX(IEQHA) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Hydrate-CH4 residual  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOH(2,N)*SH(2,N)*XHO(2,N))*DTI*VOL(N)
            RSDX = 1.D-1*MIN( ABS(DPHO),
     &        ABS(RSDL(IEQHO,N)/(ACP+SMALL)) )
            IF( YMHGO(2,N).LT.1.D-9 ) RSDX = 0.D+0
            IF( RSDX.GT.RSDLX(IEQHO) ) THEN
              RSDLX(IEQHO) = RSDX
              NSDLX(IEQHO) = N
              NPHLX(IEQHO) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Hydrate-N2 residual  ---
!
          IF( ISLC(65).EQ.0 ) THEN 
            ACP = PORD(2,N)*(RHOH(2,N)*SH(2,N)*XHN(2,N))*DTI*VOL(N)
            RSDX = 1.D-1*MIN( ABS(DPHN),
     &        ABS(RSDL(IEQHN,N)/(ACP+SMALL)) )
            IF( YMHGN(2,N).LT.1.D-9 ) RSDX = 0.D+0
            IF( RSDX.GT.RSDLX(IEQHN) ) THEN
              RSDLX(IEQHN) = RSDX
              NSDLX(IEQHN) = N
              NPHLX(IEQHN) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
        ENDIF
      ENDDO
!
!---  Maximum global residuals  ---
!
      CALL MPI_ALLREDUCE( RSDLX,RSD,ISVC,MPI_REAL8,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
!
!---  Identify processor with maximum residual  ---
!
      DO M = 1,ISVC
        IDLX(M) = -1
        IF( ABS((RSDLX(M)-RSD(M))/EPSL).LT.EPSL ) IDLX(M) = ID
        IF( ID.EQ.IDLX(M) ) THEN
          NSD(M) = ND( NSDLX(M) )
          NPHX(M) = NPHLX(M)
        ENDIF
      ENDDO
      CALL MPI_ALLREDUCE( IDLX,IDX,ISVC,MPI_INTEGER,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
      DO M = 1,ISVC
        CALL MPI_BCAST( NSD(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
        CALL MPI_BCAST( NPHX(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
      ENDDO
!
!---  Assign a convergence index  ---
!
      RSDX = 1.D-20
      DO M = 1,ISVC
        IF( RSD(M).GT.RSDMX ) ICNV = 2
        RSDX = MAX( RSD(M),RSDX )
      ENDDO
      IF( ICNV.EQ.2 .AND. NITER.GE.NRIMX ) ICNV = 1
!
!---  Unconverged solution and Newton-Raphson iteration 
!     limit exceeded  ---
!
      IF( ICNV.EQ.1 ) THEN
        OFFSET = IOFFSET_REF
        IF( ID.EQ.0 ) THEN
          PRINT *,'           ---  Convergence Failure  ---'
          IVARX(1) = -1
        ENDIF
!
!---    Debug printing to the screen  ---
!
        IF( ID.EQ.0 ) THEN
!
!---    Energy equation  ---
!
          NX = NSD(IEQT)
          IF( NX.GT.0 ) THEN
            NPX = MOD( NPHX(IEQT),100 )
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'Energy Equation Maximum Residual = ',
     &        RSD(IEQT),': Node = ',NX,
     &        ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Water mass equation  ---
!
          NX = NSD(IEQW)
          IF( NX.GT.0 ) THEN
            NPX = MOD( NPHX(IEQW),100 )
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'Water Mass Equation Maximum Residual = ',
     &        RSD(IEQW),': Node = ',NX,
     &        ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Mobile-CO2 mass equation  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            NX = NSD(IEQA)
            IF( NX.GT.0 ) THEN
              NPX = MOD( NPHX(IEQA),100 )
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'Mobile-CO2 Mass Equation Maximum Residual = ',
     &          RSD(IEQA),': Node = ',NX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Mobile-CH4 mass equation  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            NX = NSD(IEQO)
            IF( NX.GT.0 ) THEN
              NPX = MOD( NPHX(IEQO),100 )
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'Mobile-CH4 Mass Equation Maximum Residual = ',
     &          RSD(IEQO),': Node = ',NX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Mobile-N2 mass equation  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            NX = NSD(IEQN)
            IF( NX.GT.0 ) THEN
              NPX = MOD( NPHX(IEQN),100 )
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'Mobile-N2 Mass Equation Maximum Residual = ',
     &          RSD(IEQN),': Node = ',NX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Hydrate-CO2 mass equation  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            NX = NSD(IEQHA)
            IF( NX.GT.0 ) THEN
              NPX = MOD( NPHX(IEQHA),100 )
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'Hydrate-CO2 Mass Equation Maximum Residual = ',
     &          RSD(IEQHA),': Node = ',NX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Hydrate-CH4 mass equation  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            NX = NSD(IEQHO)
            IF( NX.GT.0 ) THEN
              NPX = MOD( NPHX(IEQHO),100 )
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'Hydrate-CH4 Mass Equation Maximum Residual = ',
     &          RSD(IEQHO),': Node = ',NX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Hydrate-N2 mass equation  ---
!
          IF( ISLC(65).EQ.0 ) THEN 
            NX = NSD(IEQHN)
            IF( NX.GT.0 ) THEN
              NPX = MOD( NPHX(IEQHN),100 )
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'Hydrate-N2 Mass Equation Maximum Residual = ',
     &          RSD(IEQHN),': Node = ',NX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            NX = NSD(IEQS)
            IF( NX.GT.0 ) THEN
              NPX = MOD( NPHX(IEQS),100 )
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'Salt Equation Maximum Residual = ',
     &          RSD(IEQS),': Node = ',NX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            ZMCA(2,N) = ZMCA(1,N)
            ZMCO(2,N) = ZMCO(1,N)
            ZMCN(2,N) = ZMCN(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            POSM(2,N) = POSM(1,N)
            SH(2,N) = SH(1,N)
            SI(2,N) = SI(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            YMGA(2,N) = YMGA(1,N)
            YMGO(2,N) = YMGO(1,N)
            YMGN(2,N) = YMGN(1,N)
            YMHGA(2,N) = YMHGA(1,N)
            YMHGO(2,N) = YMHGO(1,N)
            YMHGN(2,N) = YMHGN(1,N)
            TMHA(2,N) = TMHA(1,N)
            TMHO(2,N) = TMHO(1,N)
            TMHN(2,N) = TMHN(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
          IVARX(1) = -11
          VARX(10) = DTX*CNVTM
          VARX(11) = DT*CNVTM
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' // 
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the 
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          RETURN
        ENDIF
!
!---    Write a convergence failure index in the NSTEP location
!       plus write the global node numbers and phase condition indices
!       for the location of maximum residuals for the water, CO2, 
!       and salt equations to output.bin  ---
!
        NVAR = 19
        IVARX(2) = NSD(IEQT)
        IVARX(3) = NPHX(IEQT)
        IVARX(4) = NSD(IEQW)
        IVARX(5) = NPHX(IEQW)
        IF( ISLC(45).EQ.0 ) THEN
          IVARX(6) = NSD(IEQA)
          IVARX(7) = NPHX(IEQA)
          IVARX(12) = NSD(IEQHA)
          IVARX(13) = NPHX(IEQHA)
        ELSE
          IVARX(6) = 0
          IVARX(7) = 0
          IVARX(12) = 0
          IVARX(13) = 0
        ENDIF
        IF( ISLC(64).EQ.0 ) THEN
          IVARX(8) = NSD(IEQO)
          IVARX(9) = NPHX(IEQO)
          IVARX(14) = NSD(IEQHO)
          IVARX(15) = NPHX(IEQHO)
        ELSE
          IVARX(8) = 0
          IVARX(9) = 0
          IVARX(14) = 0
          IVARX(15) = 0
        ENDIF
        IF( ISLC(65).EQ.0 ) THEN
          IVARX(10) = NSD(IEQN)
          IVARX(11) = NPHX(IEQN)
          IVARX(16) = NSD(IEQHN)
          IVARX(17) = NPHX(IEQHN)
        ELSE
          IVARX(10) = 0
          IVARX(11) = 0
          IVARX(16) = 0
          IVARX(17) = 0
        ENDIF
        IF( ISLC(32).EQ.0 ) THEN
          IVARX(18) = NSD(IEQS)
          IVARX(19) = NPHX(IEQS)
        ELSE
          IVARX(18) = 0
          IVARX(19) = 0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &    MPI_INTEGER,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTI
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---    Write maximum residuals for the water, CO2, and salt 
!       equations and time step reductions to output.bin  ---
!
        NVAR = 11
        VARX(1) = RSD(IEQT)
        VARX(2) = RSD(IEQW)
        IF( ISLC(45).EQ.0 ) THEN
          VARX(3) = RSD(IEQA)
          VARX(6) = RSD(IEQHA)
        ELSE
          VARX(3) = 0.D+0
          VARX(6) = 0.D+0
        ENDIF
        IF( ISLC(64).EQ.0 ) THEN
          VARX(4) = RSD(IEQO)
          VARX(7) = RSD(IEQHO)
        ELSE
          VARX(4) = 0.D+0
          VARX(7) = 0.D+0
        ENDIF
        IF( ISLC(65).EQ.0 ) THEN
          VARX(5) = RSD(IEQN)
          VARX(8) = RSD(IEQHN)
        ELSE
          VARX(5) = 0.D+0
          VARX(8) = 0.D+0
        ENDIF
        IF( ISLC(32).EQ.0 ) THEN
          VARX(9) = RSD(IEQS)
        ELSE
          VARX(9) = 0.D+0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &    MPI_REAL8,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTR
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RSDL_HYDT_KE group
!
      RETURN
      END
      
!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SORC_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Compute source terms.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 23 June 2021
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE PROP
      USE HYST
      USE GRID
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 SRX(8)
      REAL*8 HIDX(LHF_HT),HRESX(LHF_HT)
      REAL*8 YMGX(LHF_HT),YMNX(LHF_HT)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/SORC_HYDT_KE'
!
!---  Zero source terms  ---
!
      DO NS = 1,NSR(ID+1)
        N = ISRN(NS)
        DO M = 1,ISVF
          SRCA(M,N) = 0.D+0
          SRCO(M,N) = 0.D+0
          SRCN(M,N) = 0.D+0
          SRCW(M,N) = 0.D+0
          SRCS(M,N) = 0.D+0
          SRCT(M,N) = 0.D+0
        ENDDO
      ENDDO
!
!---  Loop over sources  ---
!
      DO NS = 1,NSR(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = ISRIN(NS)
        IF( TMZ.LE.SRC(1,1,MB) ) CYCLE
        IF( ISRM(NS).EQ.1 ) THEN
          DO N = 1,8
            SRX(N) = SRC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,ISRM(NS)
            IF( TMZ.LE.SRC(1,M,MB) ) THEN
             DTSR = MIN( SRC(1,M,MB)-TMZ,DT )
             TFSR = (TMZ-0.5D+0*DTSR-SRC(1,M-1,MB))/
     &         (SRC(1,M,MB)-SRC(1,M-1,MB))
             DO N = 1,8
               SRX(N) = SRC(N,M-1,MB) + TFSR*(SRC(N,M,MB)-SRC(N,M-1,MB))
             ENDDO
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
!
!---    Loop over increment indices  ---
!
        N = ISRN(NS)
        DO M = 2,ISVC+2
          PGX = PG(M,N) + PATM
          PNX = PN(M,N) + PATM
          PLX = PL(M,N) + PATM
          TX = T(M,N)
!
!---      Power  ---
!
          IF( ISRT(NS).EQ.1 ) THEN
            SRCT(M,N) = SRCT(M,N) + SRX(4)
!
!---      Power Density  ---
!
          ELSEIF( ISRT(NS).EQ.2 ) THEN
            SRCT(M,N) = SRCT(M,N) + SRX(4)*VOL(N)
!
!---      Fluid mass rate  ---
!
          ELSEIF( ISRT(NS).EQ.3 ) THEN
            XFAGX = XGA(M,N)*RHOG(M,N)*SG(M,N)
            XFALX = XLA(M,N)*RHOL(M,N)*SL(M,N)
            XFANX = XNA(M,N)*RHON(M,N)*SN(M,N)
            XFAX = XFAGX + XFALX + XFANX
            XFOGX = XGO(M,N)*RHOG(M,N)*SG(M,N)
            XFOLX = XLO(M,N)*RHOL(M,N)*SL(M,N)
            XFONX = XNO(M,N)*RHON(M,N)*SN(M,N)
            XFOX = XFOGX + XFOLX + XFONX
            XFNGX = XGN(M,N)*RHOG(M,N)*SG(M,N)
            XFNLX = XLN(M,N)*RHOL(M,N)*SL(M,N)
            XFNNX = XNN(M,N)*RHON(M,N)*SN(M,N)
            XFNX = XFNGX + XFNLX + XFNNX
            XFSLX = XLS(M,N)*RHOL(M,N)*SL(M,N)
            XFSX = XFSLX
            XFWGX = XGW(M,N)*RHOG(M,N)*SG(M,N)
            XFWLX = XLW(M,N)*RHOL(M,N)*SL(M,N)
            XFWNX = XNW(M,N)*RHON(M,N)*SN(M,N)
            XFWX = XFWGX + XFWLX + XFWNX
            XFTX = XFAX+XFOX+XFSX+XFWX+XFNX
            SRCA(M,N) = SRCA(M,N) + SRX(4)*XFAX/XFTX
            SRCO(M,N) = SRCO(M,N) + SRX(4)*XFOX/XFTX
            SRCN(M,N) = SRCN(M,N) + SRX(4)*XFNX/XFTX
            SRCW(M,N) = SRCW(M,N) + SRX(4)*XFWX/XFTX
            SRCS(M,N) = SRCS(M,N) + SRX(4)*XFSX/XFTX
            XFGX = (XFAGX+XFOGX+XFWGX+XFNGX)/XFTX
            XFLX = (XFALX+XFOLX+XFSLX+XFWLX+XFNLX)/XFTX
            XFNX = (XFANX+XFONX+XFNNX)/XFTX
            SRCT(M,N) = SRCT(M,N) + SRX(4)*
     &        (XFGX*HG(M,N) + XFLX*HL(M,N) + XFNX*HN(M,N))
!
!---      Nonaqueous fluid mass rate  ---
!
          ELSEIF( ISRT(NS).EQ.4 ) THEN
            PX = PSO(M,N) + PATM
            PSOX = PSO(M,N)
            TX = SRX(2)
            WGWX = SRX(3)
            CALL SP_W( TX,PSWX )
            PVWX = WGWX*PSWX          
!
!---        Total nonaqueous component mole fractions  ---
!
            ZMCAX = SRX(5)
            ZMCOX = SRX(6)
            ZMCNX = MIN( MAX( 1.D+0-ZMCAX-ZMCOX,0.D+0 ),1.D+0 )
!
!---        Nonaqueous fluid state and compositions  ---
!
            CALL FLH_SR1( PPELX,PPEUX,PSOX,PVAX,PVNX,PVOX,PVWX,
     &        RHOGX,RHONX,SGX,SNX,TX,TCRX,TCTX,XGAX,XGNX,
     &        XGOX,XGWX,XNAX,XNNX,XNOX,XNWX,YMGAX,YMGNX,YMGOX,
     &        YMNAX,YMNNX,YMNOX,ZMCAX,ZMCOX,ZMCNX )
!
!---        Pure water vapor enthalpy  ---
!
            CALL SP_W( TX,PSWX )
            PEX = MIN( PSWX,PSOX )
            ISRX = 2
            CALL ENTH_W( TX,PEX,HLWX,HGWX,ISRX )
!
!---        Gas enthalpy and internal energy  ---
!
            YMGX(1) = YMGAX
            YMGX(2) = YMGOX
            YMGX(3) = YMGNX
            CALL ENTH_ID( TX,HIDX )
            INDX = 1
            CALL ENTH_RES( PSOX,TX,HRESX,YMGX,INDX )
            HGAX = (HIDX(1) + HRESX(1))/WTMA
            HGOX = (HIDX(2) + HRESX(2))/WTMO
            HGNX = (HIDX(3) + HRESX(3))/WTMN
            HGX = XGAX*HGAX + XGOX*HGOX + XGNX*HGNX + XGWX*HGWX
!
!---        Nonaqueous-liquid enthalpy and internal energy  ---
!
            YMNX(1) = YMNAX
            YMNX(2) = YMNOX
            YMNX(3) = YMNNX
            CALL ENTH_ID( TX,HIDX )
            INDX = 2
            CALL ENTH_RES( PSOX,TX,HRESX,YMNX,INDX )
            HNAX = (HIDX(1) + HRESX(1))/WTMA
            HNOX = (HIDX(2) + HRESX(2))/WTMO
            HNNX = (HIDX(3) + HRESX(3))/WTMN
            HNX = XNAX*HNAX + XNOX*HNOX + XNNX*HNNX + XNWX*HGWX
!
!---        Total density  ---
!
            RHOX = SGX*RHOGX + SNX*RHONX
!
!---        CO2 mass fractions  ---
!
            XFGAX = XGAX*SGX*RHOGX/(RHOX+SMALL)
            XFNAX = XNAX*SNX*RHONX/(RHOX+SMALL)
            XFAX = XFGAX + XFNAX
!
!---        CH4 mass fractions  ---
!
            XFGOX = XGOX*SGX*RHOGX/(RHOX+SMALL)
            XFNOX = XNOX*SNX*RHONX/(RHOX+SMALL)
            XFOX = XFGOX + XFNOX
!
!---        N2 mass fractions  ---
!
            XFGNX = XGNX*SGX*RHOGX/(RHOX+SMALL)
            XFNNX = XNNX*SNX*RHONX/(RHOX+SMALL)
            XFNX = XFGNX + XFNNX
!
!---        Water mass fractions  ---
!
            XFGWX = XGWX*SGX*RHOGX/(RHOX+SMALL)
            XFNWX = XNWX*SNX*RHONX/(RHOX+SMALL)
            XFWX = XFGWX + XFNWX
!
!---        Energy fractions  ---
!
            XFGEX = HGX*SGX*RHOGX/(RHOX+SMALL)
            XFNEX = HNX*SNX*RHONX/(RHOX+SMALL)
            XFEX = XFGEX + XFNEX
!
!---        Mass and energy sources  ---
!
            SRCA(M,N) = SRCA(M,N) + SRX(4)*XFAX
            SRCO(M,N) = SRCO(M,N) + SRX(4)*XFOX
            SRCN(M,N) = SRCN(M,N) + SRX(4)*XFNX
            SRCW(M,N) = SRCW(M,N) + SRX(4)*XFWX
            SRCT(M,N) = SRCT(M,N) + SRX(4)*XFEX
!
!---      Initial-condition fluid mass rate  ---
!
          ELSEIF( ISRT(NS).EQ.5 ) THEN
            IF( (NSTEP-NRST).EQ.1 .AND. NITER.EQ.1
     &        .AND. M.EQ.2 ) THEN
              DO MX = 1,ISRM(NS)
                SRC(3,MX,NS) = HL(2,N)
                SRC(5,MX,NS) = XLA(2,N)
                SRC(6,MX,NS) = XLO(2,N)
                SRC(7,MX,NS) = XLS(2,N)
                SRC(8,MX,NS) = XLW(2,N)
                SRX(3) = HL(2,N)
                SRX(5) = XLA(2,N)
                SRX(6) = XLO(2,N)
                SRX(7) = XLS(2,N)
                SRX(8) = XLW(2,N)
              ENDDO
            ENDIF
            SRCT(M,N) = SRCT(M,N) + SRX(4)*SRX(3)
            SRCA(M,N) = SRCA(M,N) + SRX(4)*SRX(5)
            SRCO(M,N) = SRCO(M,N) + SRX(4)*SRX(6)
            SRCS(M,N) = SRCS(M,N) + SRX(4)*SRX(7)
            SRCW(M,N) = SRCW(M,N) + SRX(4)*SRX(8)
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of SORC_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SP_HYDT_KE( PIX,PLX,PNX,SHX,SIX,SLX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 January 2013
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE HYST
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Data Statements---------------------------------!
!
      DATA TOL /1.D-12/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/SP_HYDT_KE'
!
!---  Hydrate saturation independent ksp or sp  ---
!
      SHZ = SHX
      IF( ISLC(82).EQ.2 .OR. ISLC(82).EQ.3 ) SHZ = 0.D+0 
!
!---  Residual aqueous saturation for relative permeability  ---
!
      SLRX = SCHR(4,N)
!
!---  van Genuchten saturation function w/o or w/ the
!     hydrate capillary pressure barrier or w/ the
!     hydrate-porosity model  ---
!
      IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.11 .OR.
     &  ISCHR(N).EQ.13 ) THEN
        IF( SHZ.LT.TOL ) SHZ = 0.D+0
        HCPBFX = 1.D+0
!
!---    Entry pressure with hydrate barrier adjustment  ---
!
        IF( ISCHR(N).EQ.11 ) THEN
          HCPBFX = MAX( 1.D+0,SCHR(10,N) + SCHR(11,N)*
     &      SIN(SCHR(12,N)*SHZ + SCHR(13,N)) )
!
!---    Entry pressure with hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.13 ) THEN
          HCPBFX = (1.D+0-SHZ)**(-(SCHR(10,N)-1.D+0)/SCHR(10,N))
        ENDIF
        HNL = MAX( 0.D+0,BNL*(PNX-PLX)/RHORL/GRAV )/HCPBFX
        HIL = MAX( 0.D+0,BIL*(PIX-PLX)/RHORL/GRAV )/HCPBFX
        CNX = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( IRPL(N).EQ.2 ) THEN
            CMX = 1.D+0 - 2.D+0/CNX
          ELSE
            CMX = 1.D+0 - 1.D+0/CNX
         ENDIF
        ELSE
          CMX = SCHR(14,N)
        ENDIF
        SRX = SCHR(4,N)
!
!---    Webb extension  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HMPX = SCHR(17,N)
!
!---      Gas-aqueous capillary head above matching-point
!         head, use Webb extension  ---
!
          IF( HNL.GT.HMPX ) THEN
            SMPX = SCHR(16,N)
            HNL = MIN( HNL,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HMPX))
            ASLX = -(LOG10(HNL)-LOG10(HDOD))*DMPX
            ESLX = ASLX
!
!---      Gas-aqueous capillary head below 
!         matching-point head  ---
!
          ELSE
            ASLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HNL)**CNX))**CMX
            ESLX = (ASLX*(1.D+0-SRX) + SRX)
          ENDIF
!
!---      Ice-aqueous capillary head above matching-point
!         head, use Webb extension  ---
!
          IF( HIL.GT.HMPX ) THEN
            SMPX = SCHR(16,N)
            HIL = MIN( HIL,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HMPX))
            ASLIX = -(LOG10(HIL)-LOG10(HDOD))*DMPX
            ESLIX = ASLIX
            ESLIX = MIN( ESLX,ESLIX )
!
!---      Ice-aqueous capillary head below 
!         matching-point head  ---
!
          ELSE
            ASLIX = (1.D+0/(1.D+0 + (SCHR(1,N)*HIL)**CNX))**CMX
            ESLIX = (ASLIX*(1.D+0-SRX) + SRX)
            ESLIX = MIN( ESLX,ESLIX )
          ENDIF
!
!---    No extension  ---
!
        ELSE
          ASLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HNL)**CNX))**CMX
          ASLIX = (1.D+0/(1.D+0 + (SCHR(1,N)*HIL)**CNX))**CMX
          ESLX = (ASLX*(1.D+0-SRX) + SRX)
          ESLIX = (ASLIX*(1.D+0-SRX) + SRX)
          ESLIX = MIN( ESLX,ESLIX )
        ENDIF
!
!---    Ice saturation  ---
!
        ESIX = ESLX-ESLIX
        IF( ESIX.LT.TOL ) ESIX = 0.D+0
        ESLX = ESLX-ESIX
        IF( ESLX.LT.TOL ) ESLX = 0.D+0
        ESGNX = 1.D+0-ESLX-ESIX
        IF( ESGNX.LT.TOL ) ESGNX = 0.D+0
!
!---    Actual saturations  ---
!
!        SLX = ESLX*(1.D+0-SHZ)
        SIX = ESIX*(1.D+0-SHZ)
        SLX = MAX( SLX-SIX,0.D+0 )
!
!---    Effective saturations for relative permeability
!       calculations  ---
!
        ASLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
!
!---  Brooks and Corey saturation function w/o or w/ the
!     hydrate capillary pressure barrier or w/ the
!     hydrate-porosity model  ---
!
      ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.12 .OR.
     &  ISCHR(N).EQ.14 ) THEN
        IF( SHZ.LT.TOL ) SHZ = 0.D+0
        HCPBFX = 1.D+0
!
!---    Entry pressure with hydrate barrier adjustment  ---
!
        IF( ISCHR(N).EQ.12 ) THEN
          HCPBFX = MAX( 1.D+0,SCHR(10,N) + SCHR(11,N)*
     &      SIN(SCHR(12,N)*SHZ + SCHR(13,N)) )
!
!---    Entry pressure with hydrate-porosity model  ---
!
        ELSEIF( ISCHR(N).EQ.14 ) THEN
          HCPBFX = (1.D+0-SHZ)**(-(SCHR(10,N)-1.D+0)/SCHR(10,N))
        ENDIF
        HNL = MAX( 0.D+0,BNL*(PNX-PLX)/RHORL/GRAV )/HCPBFX
        HIL = MAX( ZERO,BIL*(PIX-PLX)/RHORL/GRAV )/HCPBFX
        CLX = MAX( SCHR(3,N),SMALL )
        SRX = SCHR(4,N)
!
!---    Webb extension  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HMPX = SCHR(17,N)
!
!---      Gas-aqueous capillary head above matching-point
!         head, use Webb extension  ---
!
          IF( HNL.GT.HMPX ) THEN
            SMPX = SCHR(16,N)
            HNL = MIN( HNL,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HMPX))
            ASLX = -(LOG10(HNL)-LOG10(HDOD))*DMPX
            ESLX = ASLX
!
!---      Gas-aqueous capillary head below 
!          matching-point head  ---
!
          ELSE
            IF( HNL-SCHR(2,N).LE.1.D-12 ) THEN
              ASLX = 1.D+0
            ELSE
              ASLX = (SCHR(2,N)/HNL)**CLX
            ENDIF
            ESLX = (ASLX*(1.D+0-SRX) + SRX)
          ENDIF
!
!---      Ice-aqueous capillary head above matching-point
!         head, use Webb extension  ---
!
          IF( HIL.GT.HMPX ) THEN
            SMPX = SCHR(16,N)
            HIL = MIN( HIL,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HMPX))
            ASLIX = -(LOG10(HIL)-LOG10(HDOD))*DMPX
            ESLIX = ASLIX
            ESLIX = MIN( ESLX,ESLIX )
!
!---      Ice-aqueous capillary head below 
!         matching-point head  ---
!
          ELSE
            IF( HIL-SCHR(2,N).LE.1.D-12 ) THEN
              ASLIX = 1.D+0
            ELSE
              ASLIX = (SCHR(2,N)/HNL)**CLX
            ENDIF
            ESLIX = (ASLIX*(1.D+0-SRX) + SRX)
            ESLIX = MIN( ESLX,ESLIX )
          ENDIF
!
!---    No extension  ---
!
        ELSE
          IF( HNL-SCHR(2,N).LE.1.D-12 ) THEN
            ASLX = 1.D+0
          ELSE
            ASLX = (SCHR(2,N)/HNL)**CLX
          ENDIF
          IF( HIL-SCHR(2,N).LE.1.D-12 ) THEN
            ASLIX = 1.D+0
          ELSE
            ASLIX = (SCHR(2,N)/HNL)**CLX
          ENDIF
          ESLX = (ASLX*(1.D+0-SRX) + SRX)
          ESLIX = (ASLIX*(1.D+0-SRX) + SRX)
          ESLIX = MIN( ESLX,ESLIX )
        ENDIF
!
!---    Ice saturation  ---
!
        ESIX = ESLX-ESLIX
        IF( ESIX.LT.TOL ) ESIX = 0.D+0
        ESLX = ESLX-ESIX
        IF( ESLX.LT.TOL ) ESLX = 0.D+0
        ESGNX = 1.D+0-ESLX-ESIX
        IF( ESGNX.LT.TOL ) ESGNX = 0.D+0
!
!---    Actual saturations  ---
!
!        SLX = ESLX*(1.D+0-SHZ)
        SIX = ESIX*(1.D+0-SHZ)
        SLX = MAX( SLX-SIX,0.D+0 )
!
!---    Effective saturations for relative permeability
!       calculations  ---
!
        ASLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of SP_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Update the primary variables on field cells w/o ghost cells.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 26 August 2021.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
      USE JACOB
      USE HYST
      USE GRID
      USE FILES
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(32) :: VARZ	
      REAL*8, DIMENSION(28) :: VARX	
      INTEGER, DIMENSION(6) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*128 PH_CND(43)
!
!----------------------Data Statements---------------------------------!
!
      DATA PH_CND /9*'','SH = 0, SG = 0, SN = 0',10*'',
     &  'SH = 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN )',
     &  'SH = 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN )',
     &  'SH = 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO )',7*'',
     &  'SH > 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN ), YMHGA >= MAX(YMH
     &GO,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN ), YMHGA >= MAX(YMH
     &GO,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO ), YMHGA >= MAX(YMH
     &GO,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN ), YMHGO >= MAX(YMH
     &GA,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN ), YMHGO >= MAX(YMH
     &GA,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO ), YMHGO >= MAX(YMH
     &GA,YMHGN )',
     &  'SH > 0, SG + SN > 0, ZMCA >= MAX( ZMCO,ZMCN ), YMHGN >= MAX(YMH
     &GA,YMHGO )',
     &  'SH > 0, SG + SN > 0, ZMCO >= MAX( ZMCA,ZMCN ), YMHGN >= MAX(YMH
     &GA,YMHGO )',
     &  'SH > 0, SG + SN > 0, ZMCN >= MAX( ZMCA,ZMCO ), YMHGN >= MAX(YMH
     &GA,YMHGO )','',
     &  'SH > 0, SG + SN = 0, YMHGA >= MAX(YMHGO,YMHGN )',
     &  'SH > 0, SG + SN = 0, YMHGO >= MAX(YMHGA,YMHGN )',
     &  'SH > 0, SG + SN = 0, YMHGN >= MAX(YMHGA,YMHGO )'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_HYDT_KE'
      OFFSET = IOFFSET_REF
      IF( ICNV.EQ.1 ) THEN
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ') - 1
          IF( ID.EQ.0 ) PRINT *,'Linear System Solver Failure: ' //
     &      'Time Step  Reduced from ',DTX*CNVTM,UNTM(1:NCH),' to ',
     &      DT*CNVTM,UNTM(1:NCH)
!
!---      Write a linear system solver failure index of -3 in the 
!         NSTEP location plus time step reductions to output.bin  ---
!
          NVAR = 1
          IVARX(1) = -3
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          NVAR = 2
          VARX(1) = DTX*CNVTM
          VARX(2) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            ZMCA(2,N) = ZMCA(1,N)
            ZMCO(2,N) = ZMCO(1,N)
            ZMCN(2,N) = ZMCN(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            POSM(2,N) = POSM(1,N)
            SH(2,N) = SH(1,N)
            SI(2,N) = SI(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            YMGA(2,N) = YMGA(1,N)
            YMGO(2,N) = YMGO(1,N)
            YMGN(2,N) = YMGN(1,N)
            YMHGA(2,N) = YMHGA(1,N)
            YMHGO(2,N) = YMHGO(1,N)
            YMHGN(2,N) = YMHGN(1,N)
            TMHA(2,N) = TMHA(1,N)
            TMHO(2,N) = TMHO(1,N)
            TMHN(2,N) = TMHN(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            ZMCA(2,N) = ZMCA(1,N)
            ZMCO(2,N) = ZMCO(1,N)
            ZMCN(2,N) = ZMCN(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            POSM(2,N) = POSM(1,N)
            SH(2,N) = SH(1,N)
            SI(2,N) = SI(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            YMGA(2,N) = YMGA(1,N)
            YMGO(2,N) = YMGO(1,N)
            YMGN(2,N) = YMGN(1,N)
            YMHGA(2,N) = YMHGA(1,N)
            YMHGO(2,N) = YMHGO(1,N)
            YMHGN(2,N) = YMHGN(1,N)
            TMHA(2,N) = TMHA(1,N)
            TMHO(2,N) = TMHO(1,N)
            TMHN(2,N) = TMHN(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
          IF( ID.EQ.0 )  PRINT *,'          ---  Time Step ' // 
     &      'Reduction Limit Exceeded  ---'
          ICNV = 4
          IVARX(1) = -2
!
!---      Write a time-step reduction limit exceeded index in the 
!         NSTEP location to output.bin.  ---
!
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
!
!---    Reset subroutine string sequence  ---
!
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Update primary variables on field cells  ---
!
      IERR = 0
      IERRL = NFLD + 1
      IERRG = NFLD + 1
      NMD = 0
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        IF( IERRL.NE.(NFLD+1) ) CYCLE
        MPT = NMD + IEQT
        DPT = BLU(MPT)
        MPW = NMD + IEQW
        DPW = BLU(MPW)
        IF( ISLC(45).EQ.0 ) THEN
          MPA = NMD + IEQA
          DPA = BLU(MPA)
        ENDIF
        IF( ISLC(64).EQ.0 ) THEN
          MPO = NMD + IEQO
          DPO = BLU(MPO)
        ENDIF
        IF( ISLC(65).EQ.0 ) THEN
          MPN = NMD + IEQN
          DPN = BLU(MPN)
        ELSE
          DPN = 0.D+0
        ENDIF
        IF( ISLC(45).EQ.0 ) THEN
          MPHA = NMD + IEQHA
          DPHA = BLU(MPHA)
        ENDIF
        IF( ISLC(64).EQ.0 ) THEN
          MPHO = NMD + IEQHO
          DPHO = BLU(MPHO)
        ENDIF
        IF( ISLC(65).EQ.0 ) THEN
          MPHN = NMD + IEQHN
          DPHN = BLU(MPHN)
        ELSE
          DPHN = 0.D+0
        ENDIF
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ELSE
          DPS = 0.D+0
        ENDIF
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
!
!---    Check for excessive change in temperature   ---
!
        IF( ABS(DPT).GT.1.D+2 ) IERR = 1
!
!---    Excess changes in primary variables, skip updates  ---
!
        IF( IERR.EQ.1 .AND. IERRL.EQ.(NFLD+1) ) THEN
          IERRL = ND(N)
          VARZ(1) = REAL( N )
          VARZ(2) = REAL( NPHAZ(2,N) )
          VARZ(3) = DPT
          VARZ(4) = DPW
          VARZ(5) = DPA
          VARZ(6) = DPO
          VARZ(7) = DPN
          VARZ(8) = DPHA
          VARZ(9) = DPHO
          VARZ(10) = DPHN
          VARZ(11) = DPS
          VARZ(12) = T(2,N)
          VARZ(13) = PSO(2,N)
          VARZ(14) = SL(2,N)
          VARZ(15) = SH(2,N)
          VARZ(16) = SI(2,N)
          VARZ(17) = PVA(2,N)
          VARZ(18) = PVO(2,N)
          VARZ(19) = PVN(2,N)
          VARZ(20) = TMHA(2,N)
          VARZ(21) = TMHO(2,N)
          VARZ(22) = TMHN(2,N)
          VARZ(23) = ZMCA(2,N)
          VARZ(24) = ZMCO(2,N)
          VARZ(25) = ZMCN(2,N)
          VARZ(26) = YMHGA(2,N)
          VARZ(27) = YMHGO(2,N)
          VARZ(28) = YMHGN(2,N)
          VARZ(29) = YLS(2,N)
          VARZ(30) = REAL(ISLC(45))
          VARZ(31) = REAL(ISLC(64))
          VARZ(32) = REAL(ISLC(65))
        ENDIF
        IF( IERRL.NE.(NFLD+1) ) CYCLE
!
!---    Limit salt mass fraction changes to 0.25 of the
!       maximum value if salt mass fraction is less than
!       the maximum, isobrine option   ---
!
        IF( ISLC(32).EQ.0 ) THEN
          CALL SOL_LS( T(2,N),XLSMX )
          IF( YLS(2,N).LT.XLSMX ) THEN
            DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
          ENDIF
!
!---      Zero negative corrections for zero dissolved salt  ---
!
          IF( YLS(2,N)/EPSL.LT.EPSL .AND. DPS/EPSL.LT.EPSL ) THEN
            BLU(MPS) = 0.D+0
            DPS = 0.D+0
          ENDIF
          YLS(2,N) = YLS(2,N)+DPS
          IF( YLS(2,N).LT.1.D-12 ) YLS(2,N) = 0.D+0
          XLS(2,N) = MIN( YLS(2,N),XLSMX )
        ENDIF
!
!---    Freezing point  ---
!
        CALL ICE( T(2,N),PL(2,N),XLS(2,N),TFPX,PIX )
!
!---    Limit changes in temperature to 0.25 C without hydrate, 
!       and to 0.1 C with hydrate   ---
!
        IF( SH(2,N).GT.EPSL ) THEN
          DPT = SIGN( MIN( 1.D-1,ABS(DPT) ),DPT )
        ELSE
          DPT = SIGN( MIN( 2.5D-1,ABS(DPT) ),DPT )
        ENDIF
!
!---    Relax temperature change in transition from no-ice to ice,
!       relax temperature change in transition from ice to no-ice  ---
!
        DTFPX = T(2,N)-TFPX
        IF( DTFPX.GE.0.D+0 .AND. (DTFPX+DPT).LT.0.D+0 ) THEN
          T(2,N) = TFPX + 6.D-1*DPT
        ELSEIF( DTFPX.LT.0.D+0 .AND. (DTFPX+DPT).GE.0.D+0 ) THEN
          T(2,N) = TFPX + 6.D-1*DPT
        ELSE
          T(2,N) = T(2,N) + DPT
        ENDIF
!
!---    Core phase condition  ---
!
        NPHZX = MOD(NPHAZ(2,N),100)
!
!---    Phase condition #10 (10 series)  ---
!
!       SH = 0, SG + SN = 0, SL + SI = 1
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        IF( NPHZX.EQ.10 ) THEN
!
!---      Limit changes in pressure  ---
!
          DPX = 2.D-1*(PSO(2,N)+PATM)
          DPW = SIGN( MIN( ABS(DPX),ABS(DPW) ),DPW )
          PSO(2,N) = PSO(2,N) + DPW
!
!---      Zero negative corrections for zero CO2 partial pressure  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( PVA(2,N)/EPSL.LT.EPSL .AND. DPA/EPSL.LT.EPSL ) THEN
              BLU(MPA) = 0.D+0
              DPA = 0.D+0
            ENDIF
            DPA = SIGN( MIN( ABS(DPX),ABS(DPA) ),DPA )
            PVA(2,N) = MAX( (PVA(2,N)+DPA),0.D+0 )
            IF( PVA(2,N).LT.1.D-6 ) PVA(2,N) = 0.D+0
          ENDIF
!
!---      Zero negative corrections for zero CH4 partial pressure  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( PVO(2,N)/EPSL.LT.EPSL .AND. DPO/EPSL.LT.EPSL ) THEN
              BLU(MPO) = 0.D+0
              DPO = 0.D+0
            ENDIF
            DPO = SIGN( MIN( ABS(DPX),ABS(DPO) ),DPO )
            PVO(2,N) = MAX( (PVO(2,N)+DPO),0.D+0 )
            IF( PVO(2,N).LT.1.D-6 ) PVO(2,N) = 0.D+0
          ENDIF
!
!---      Zero negative corrections for zero N2 partial pressure  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( PVN(2,N)/EPSL.LT.EPSL .AND. DPN/EPSL.LT.EPSL ) THEN
              BLU(MPN) = 0.D+0
              DPN = 0.D+0
            ENDIF
            DPN = SIGN( MIN( ABS(DPX),ABS(DPN) ),DPN )
            PVN(2,N) = MAX( (PVN(2,N)+DPN),0.D+0 )
            IF( PVN(2,N).LT.1.D-6 ) PVN(2,N) = 0.D+0
          ENDIF
!
!---      Limit changes in CO2 hydrate mass  ---
!
          TMHA(2,N) = 0.D+0
!
!---      Limit changes in CH4 hydrate mass  ---
!
          TMHO(2,N) = 0.D+0
!
!---      Limit changes in N2 hydrate mass  ---
!
          TMHN(2,N) = 0.D+0
!
!---    Phase conditions 21 through 23 (20 series)  ---
!
!       SH = 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation - POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!       hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!       hydrate N2 mass - hydrate N2 mass, kg - TMHN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.21 .AND. NPHZX.LE.23  ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          DPX = 2.5D-2
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          POSM(2,N) = POSM(2,N) + DPW
          IF( POSM(2,N).LT.EPSL ) POSM(2,N) = 0.D+0
!
!---      ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!
          IF( NPHZX.EQ.21 ) THEN
!
!---        Gas conditions  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
!
!---          Limit changes in pressure  ---
!
              DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-PL(2,N)) )
              DPA = SIGN( MIN(ABS(DPX),ABS(DPA)),DPA )
              PSO(2,N) = MAX( (PSO(2,N)+DPA),0.D+0 )
              IF( PSO(2,N).LT.1.D-6 ) PSO(2,N) = 0.D+0
            ELSE
!
!---          Limit changes in pressure  ---
!
              DPX = 2.D-1*(PSO(2,N)+PATM)
              DPA = SIGN( MIN( ABS(DPX),ABS(DPA) ),DPA )
              PSO(2,N) = PSO(2,N) + DPA
            ENDIF
          ELSE
!
!---        Zero negative corrections total nonaqueous 
!           CO2 mole fraction  ---
!
            IF( ISLC(45).EQ.0 ) THEN
              DPX = 2.5D-1
              DPA = SIGN( MIN( ABS(DPX),ABS(DPA) ),DPA )
              ZMCA(2,N) = MAX( (ZMCA(2,N)+DPA),0.D+0 )
              IF( ZMCA(2,N).LT.EPSL ) ZMCA(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!
          IF( NPHZX.EQ.22 ) THEN
!
!---        Gas conditions  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
!
!---          Limit changes in pressure  ---
!
              DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-PL(2,N)) )
              DPO = SIGN( MIN(ABS(DPX),ABS(DPO)),DPO )
              PSO(2,N) = MAX( (PSO(2,N)+DPO),0.D+0 )
              IF( PSO(2,N).LT.1.D-6 ) PSO(2,N) = 0.D+0
            ELSE
!
!---          Limit changes in pressure  ---
!
              DPX = 2.D-1*(PSO(2,N)+PATM)
              DPO = SIGN( MIN( ABS(DPX),ABS(DPO) ),DPO )
              PSO(2,N) = PSO(2,N) + DPO
            ENDIF
          ELSE
!
!---        Zero negative corrections total nonaqueous 
!           CH4 mole fraction  ---
!
            IF( ISLC(64).EQ.0 ) THEN
              DPX = 2.5D-1
              DPO = SIGN( MIN( ABS(DPX),ABS(DPO) ),DPO )
              ZMCO(2,N) = MAX( (ZMCO(2,N)+DPO),0.D+0 )
              IF( ZMCO(2,N).LT.EPSL ) ZMCO(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
          IF( NPHZX.EQ.23 ) THEN
!
!---        Gas conditions  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
!
!---          Limit changes in pressure  ---
!
              DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-PL(2,N)) )
              DPA = SIGN( MIN(ABS(DPX),ABS(DPN)),DPN )
              PSO(2,N) = MAX( (PSO(2,N)+DPN),0.D+0 )
              IF( PSO(2,N).LT.1.D-6 ) PSO(2,N) = 0.D+0
            ELSE
!
!---          Limit changes in pressure  ---
!
              DPX = 2.D-1*(PSO(2,N)+PATM)
              DPN = SIGN( MIN( ABS(DPX),ABS(DPN) ),DPN )
              PSO(2,N) = PSO(2,N) + DPN
            ENDIF
          ELSE
!
!---        Zero negative corrections total nonaqueous 
!           N2 mole fraction  ---
!
            IF( ISLC(65).EQ.0 ) THEN
              DPX = 2.5D-1
              DPN = SIGN( MIN( ABS(DPX),ABS(DPN) ),DPN )
              ZMCN(2,N) = MAX( (ZMCN(2,N)+DPN),0.D+0 )
              IF( ZMCN(2,N).LT.EPSL ) ZMCN(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      Limit changes in CO2 hydrate mass  ---
!
          TMHA(2,N) = 0.D+0
!
!---      Limit changes in CH4 hydrate mass  ---
!
          TMHO(2,N) = 0.D+0
!
!---      Limit changes in N2 hydrate mass  ---
!
          TMHN(2,N) = 0.D+0
!
!---    Phase conditions #31 through #39 (30 series)  ---
!
!       SH > 0, SG + SN > 0, SL + SI < 1
!       ZMCA = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33
!       ZMCO = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #34
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #35
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #36
!       ZMCN = MAX( ZMCA,ZMCO,ZMCN )
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #37
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #38
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #39
!
!       energy - temperature, C - T
!       water mass - aqueous + ice saturation, POSM
!       maximum mobile mass component - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!       mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!       mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.39 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          DPX = 2.5D-2
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          POSM(2,N) = POSM(2,N) + DPW
          IF( POSM(2,N).LT.EPSL ) POSM(2,N) = 0.D+0
!
!---      ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #31, #32, or #33
!
          IF( NPHZX.GE.31 .AND. NPHZX.LE.33 ) THEN
!
!---        Gas conditions  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
!
!---          Limit changes in pressure  ---
!
              DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-PL(2,N)) )
              DPA = SIGN( MIN(ABS(DPX),ABS(DPA)),DPA )
              PSO(2,N) = MAX( (PSO(2,N)+DPA),0.D+0 )
              IF( PSO(2,N).LT.1.D-6 ) PSO(2,N) = 0.D+0
            ELSE
!
!---          Limit changes in pressure  ---
!
              DPX = 2.D-1*(PSO(2,N)+PATM)
              DPA = SIGN( MIN( ABS(DPX),ABS(DPA) ),DPA )
              PSO(2,N) = PSO(2,N) + DPA
            ENDIF
          ELSE
!
!---        Zero negative corrections total nonaqueous 
!           CO2 mole fraction  ---
!
            IF( ISLC(45).EQ.0 ) THEN
              DPX = 2.5D-1
              DPA = SIGN( MIN( ABS(DPX),ABS(DPA) ),DPA )
              ZMCA(2,N) = MAX( (ZMCA(2,N)+DPA),0.D+0 )
              IF( ZMCA(2,N).LT.EPSL ) ZMCA(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #34, #35, or #36
!
          IF( NPHZX.GE.34 .AND. NPHZX.LE.36 ) THEN
!
!---        Gas conditions  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
!
!---          Limit changes in pressure  ---
!
              DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-PL(2,N)) )
              DPO = SIGN( MIN(ABS(DPX),ABS(DPO)),DPO )
              PSO(2,N) = MAX( (PSO(2,N)+DPO),0.D+0 )
              IF( PSO(2,N).LT.1.D-6 ) PSO(2,N) = 0.D+0
            ELSE
!
!---          Limit changes in pressure  ---
!
              DPX = 2.D-1*(PSO(2,N)+PATM)
              DPO = SIGN( MIN( ABS(DPX),ABS(DPO) ),DPO )
              PSO(2,N) = PSO(2,N) + DPO
            ENDIF
          ELSE
!
!---        Zero negative corrections total nonaqueous 
!           CH4 mole fraction  ---
!
            IF( ISLC(64).EQ.0 ) THEN
              DPX = 2.5D-1
              DPO = SIGN( MIN( ABS(DPX),ABS(DPO) ),DPO )
              ZMCO(2,N) = MAX( (ZMCO(2,N)+DPO),0.D+0 )
              IF( ZMCO(2,N).LT.EPSL ) ZMCO(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #37, #38, or #39
!
          IF( NPHZX.GE.37 .AND. NPHZX.LE.39 ) THEN
!
!---        Gas conditions  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
!
!---          Limit changes in pressure  ---
!
              DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-PL(2,N)) )
              DPA = SIGN( MIN(ABS(DPX),ABS(DPN)),DPN )
              PSO(2,N) = MAX( (PSO(2,N)+DPN),0.D+0 )
              IF( PSO(2,N).LT.1.D-6 ) PSO(2,N) = 0.D+0
            ELSE
!
!---          Limit changes in pressure  ---
!
              DPX = 2.D-1*(PSO(2,N)+PATM)
              DPN = SIGN( MIN( ABS(DPX),ABS(DPN) ),DPN )
              PSO(2,N) = PSO(2,N) + DPN
            ENDIF
          ELSE
!
!---        Zero negative corrections total nonaqueous 
!           N2 mole fraction  ---
!
            IF( ISLC(65).EQ.0 ) THEN
              DPX = 2.5D-1
              DPN = SIGN( MIN( ABS(DPX),ABS(DPN) ),DPN )
              ZMCN(2,N) = MAX( (ZMCN(2,N)+DPN),0.D+0 )
              IF( ZMCN(2,N).LT.EPSL ) ZMCN(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31, #34, or #37
!
          IF( NPHZX.EQ.31 .OR. NPHZX.EQ.34 .OR. NPHZX.EQ.37 ) THEN
!
!---        Limit changes in hydrate saturation  ---
!
            IF( ISLC(45).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHA = SIGN( MIN( ABS(DPHX),ABS(DPHA) ),DPHA )
              SH(2,N) = MIN( MAX( SH(2,N)+DPHA,0.D+0 ),1.D+0 )
            ENDIF
          ELSE
!
!---        Limit changes in hydrate-gas CO2 mole fraction of formers  ---
!
            IF( ISLC(45).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHA = SIGN( MIN( ABS(DPHX),ABS(DPHA) ),DPHA )
              YMHGA(2,N) = MIN( MAX( YMHGA(2,N)+DPHA,0.D+0 ),1.D+0 )
              IF( YMHGA(2,N).LT.EPSL ) YMHGA(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32, #35, or #38
!
          IF( NPHZX.EQ.32 .OR. NPHZX.EQ.35 .OR. NPHZX.EQ.38 ) THEN
!
!---        Limit changes in hydrate saturation  ---
!
            IF( ISLC(64).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHO = SIGN( MIN( ABS(DPHX),ABS(DPHO) ),DPHO )
              SH(2,N) = MIN( MAX( SH(2,N)+DPHO,0.D+0 ),1.D+0 )
            ENDIF
          ELSE
!
!---        Limit changes in hydrate-gas CH4 mole fraction of formers  ---
!
            IF( ISLC(64).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHO = SIGN( MIN( ABS(DPHX),ABS(DPHO) ),DPHO )
              YMHGO(2,N) = MIN( MAX( YMHGO(2,N)+DPHO,0.D+0 ),1.D+0 )
              IF( YMHGO(2,N).LT.EPSL ) YMHGO(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33, #36, or #39
!
          IF( NPHZX.EQ.33 .OR. NPHZX.EQ.36 .OR. NPHZX.EQ.39 ) THEN
!
!---        Limit changes in hydrate saturation  ---
!
            IF( ISLC(65).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHN = SIGN( MIN( ABS(DPHX),ABS(DPHN) ),DPHN )
              SH(2,N) = MIN( MAX( SH(2,N)+DPHN,0.D+0 ),1.D+0 )
            ENDIF
          ELSE
!
!---        Limit changes in hydrate-gas N2 mole fraction of formers  ---
!
            IF( ISLC(65).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHN = SIGN( MIN( ABS(DPHX),ABS(DPHN) ),DPHN )
              YMHGN(2,N) = MIN( MAX( YMHGN(2,N)+DPHN,0.D+0 ),1.D+0 )
              IF( YMHGN(2,N).LT.EPSL ) YMHGN(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---    Phase conditions #41 through #43 (40 series)  ---
!
!       SH > 0, SG + SN = 0, SL + SI < 1
!       YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!       YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!       YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
!       energy - temperature, C - T
!       water mass - pressure, Pa (gauge) - PSO
!       mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!       mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!       mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!       maximum hydrate mass component - hydrate saturation - SH
!       hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!       hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!       hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!       NaCl mass - total NaCl aqueous mass fraction - YLS
!
        ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
!
!---      Limit changes in pressure  ---
!
          DPX = 2.D-1*(PSO(2,N)+PATM)
          DPW = SIGN( MIN( ABS(DPX),ABS(DPW) ),DPW )
          PSO(2,N) = PSO(2,N) + DPW
!
!---      Zero negative corrections for zero CO2 partial pressure  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( PVA(2,N)/EPSL.LT.EPSL .AND. DPA/EPSL.LT.EPSL ) THEN
              BLU(MPA) = 0.D+0
              DPA = 0.D+0
            ENDIF
            DPA = SIGN( MIN( ABS(DPX),ABS(DPA) ),DPA )
            PVA(2,N) = MAX( (PVA(2,N)+DPA),0.D+0 )
            IF( PVA(2,N).LT.1.D-6 ) PVA(2,N) = 0.D+0
          ENDIF
!
!---      Zero negative corrections for zero CH4 partial pressure  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            IF( PVO(2,N)/EPSL.LT.EPSL .AND. DPO/EPSL.LT.EPSL ) THEN
              BLU(MPO) = 0.D+0
              DPO = 0.D+0
            ENDIF
            DPO = SIGN( MIN( ABS(DPX),ABS(DPO) ),DPO )
            PVO(2,N) = MAX( (PVO(2,N)+DPO),0.D+0 )
            IF( PVO(2,N).LT.1.D-6 ) PVO(2,N) = 0.D+0
          ENDIF
!
!---      Zero negative corrections for zero N2 partial pressure  ---
!
          IF( ISLC(65).EQ.0 ) THEN
            IF( PVN(2,N)/EPSL.LT.EPSL .AND. DPN/EPSL.LT.EPSL ) THEN
              BLU(MPN) = 0.D+0
              DPN = 0.D+0
            ENDIF
            DPN = SIGN( MIN( ABS(DPX),ABS(DPN) ),DPN )
            PVN(2,N) = MAX( (PVN(2,N)+DPN),0.D+0 )
            IF( PVN(2,N).LT.1.D-6 ) PVN(2,N) = 0.D+0
          ENDIF
!
!---      YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!
          IF( NPHZX.EQ.41 ) THEN
!
!---        Limit changes in hydrate saturation  ---
!
            IF( ISLC(45).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHA = SIGN( MIN( ABS(DPHX),ABS(DPHA) ),DPHA )
              SH(2,N) = MIN( MAX( SH(2,N)+DPHA,0.D+0 ),1.D+0 )
            ENDIF
          ELSE
!
!---        Limit changes in hydrate-gas CO2 mole fraction of formers  ---
!
            IF( ISLC(45).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHA = SIGN( MIN( ABS(DPHX),ABS(DPHA) ),DPHA )
              YMHGA(2,N) = MIN( MAX( YMHGA(2,N)+DPHA,0.D+0 ),1.D+0 )
              IF( YMHGA(2,N).LT.EPSL ) YMHGA(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!
          IF( NPHZX.EQ.42 ) THEN
!
!---        Limit changes in hydrate saturation  ---
!
            IF( ISLC(64).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHO = SIGN( MIN( ABS(DPHX),ABS(DPHO) ),DPHO )
              SH(2,N) = MIN( MAX( SH(2,N)+DPHO,0.D+0 ),1.D+0 )
            ENDIF
          ELSE
!
!---        Limit changes in hydrate-gas CH4 mole fraction of formers  ---
!
            IF( ISLC(64).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHO = SIGN( MIN( ABS(DPHX),ABS(DPHO) ),DPHO )
              YMHGO(2,N) = MIN( MAX( YMHGO(2,N)+DPHO,0.D+0 ),1.D+0 )
              IF( YMHGO(2,N).LT.EPSL ) YMHGO(2,N) = 0.D+0
            ENDIF
          ENDIF
!
!---      YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
          IF( NPHZX.EQ.43 ) THEN
!
!---        Limit changes in hydrate saturation  ---
!
            IF( ISLC(65).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHN = SIGN( MIN( ABS(DPHX),ABS(DPHN) ),DPHN )
              SH(2,N) = MIN( MAX( SH(2,N)+DPHN,0.D+0 ),1.D+0 )
            ENDIF
          ELSE
!
!---        Limit changes in hydrate-gas N2 mole fraction of formers  ---
!
            IF( ISLC(65).EQ.0 ) THEN
              DPHX = 1.D-1
              DPHN = SIGN( MIN( ABS(DPHX),ABS(DPHN) ),DPHN )
              YMHGN(2,N) = MIN( MAX( YMHGN(2,N)+DPHN,0.D+0 ),1.D+0 )
              IF( YMHGN(2,N).LT.EPSL ) YMHGN(2,N) = 0.D+0
            ENDIF
          ENDIF
        ENDIF
      ENDDO
!
!---  Identify minimum global node with errors  ---
!
      CALL MPI_ALLREDUCE( IERRL,IERRG,1,MPI_INTEGER,MPI_MIN,
     &  MPI_COMM_WORLD,IERR )
!
!---  Node identified with an excessive primary variable change  ---
!
      IF( IERRG.NE.(NFLD+1) ) THEN
        ICNV = 1
        ID2X = 0
!
!---    Identify processor with error  ---
!
        DO MP = 1,NP
          IF( IERRL.EQ.IERRG ) ID2X = ID
        ENDDO
        CALL MPI_ALLREDUCE( ID2X,IDX,1,MPI_INTEGER,MPI_MAX,
     &    MPI_COMM_WORLD,IERR )
!
!---    Send node state to P0  ---
!
        IF( ID.EQ.IDX ) THEN
          CALL MPI_SEND( VARZ,29,MPI_REAL8,0,18,MPI_COMM_WORLD,IERR )
        ENDIF
        IF( ID.EQ.0 ) THEN
          CALL MPI_RECV( VARZ,29,MPI_REAL8,IDX,18,MPI_COMM_WORLD,
     &      STATUS,IERR )
          N = INT(VARZ(1))
          NPHZX = MOD(INT(VARZ(2)),100)
          PRINT *,'---  Excessive Primary Variable Change  ---'
          PRINT *,'  Node = ',ND(N)  
          PRINT *,'  Phase Condition = ',PH_CND(NPHZX)
          PRINT *,'  DPT = ',VARZ(3)
          PRINT *,'  DPW = ',VARZ(4)
          IF( ISLC(45).EQ.0 ) THEN
            PRINT *,'  DPA = ',VARZ(5)
          ENDIF
          IF( ISLC(64).EQ.0 ) THEN
            PRINT *,'  DPO = ',VARZ(6)
          ENDIF
          IF( ISLC(65).EQ.0 ) THEN
            PRINT *,'  DPN = ',VARZ(7)
          ENDIF
          IF( ISLC(45).EQ.0 ) THEN
            PRINT *,'  DPHA = ',VARZ(8)
          ENDIF
          IF( ISLC(64).EQ.0 ) THEN
            PRINT *,'  DPHO = ',VARZ(9)
          ENDIF
          IF( ISLC(65).EQ.0 ) THEN
            PRINT *,'  DPHN = ',VARZ(10)
          ENDIF
          IF( ISLC(32).EQ.0 ) THEN
            PRINT *,'  DPS = ',VARZ(11)
          ENDIF
          PRINT *,'  Temperature, C = ',VARZ(12)
          PRINT *,'  Pressure, Pa = ',VARZ(13)+PATM
          PRINT *,'  Aqueous Saturation = ',VARZ(14)
          PRINT *,'  Ice Saturation = ',VARZ(16)
!
!---      Phase condition #10 (10 series)  ---
!
!         SH = 0, SG + SN = 0, SL + SI = 1
!
!         energy - temperature, C - T
!         water mass - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!         mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!         mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!         hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!         hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!         hydrate N2 mass - hydrate N2 mass, kg - TMHN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          IF( NPHZX.EQ.10 ) THEN
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  CO2 vapor pressure, Pa absolute = ',VARZ(17)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  CH4 vapor pressure, Pa absolute = ',VARZ(18)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  N2 vapor pressure, Pa absolute = ',VARZ(19)
            ENDIF
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  CO2 Hydrate Mass = ',VARZ(20)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  CH4 Hydrate Mass = ',VARZ(21)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  N2 Hydrate Mass = ',VARZ(22)
            ENDIF
!
!---      Phase conditions 21 through 23 (20 series)  ---
!
!         SH = 0, SG + SN > 0, SL + SI < 1
!         ZMCA = MAX( ZMCA,ZMCO,ZMCN ) #21
!         ZMCO = MAX( ZMCA,ZMCO,ZMCN ) #22
!         ZMCN = MAX( ZMCA,ZMCO,ZMCN ) #23
!
!         energy - temperature, C - T
!         water mass - aqueous + ice saturation - POSM
!         maximum mobile mass component - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!         mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!         mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!         hydrate CO2 mass - hydrate CO2 mass, kg - TMHA
!         hydrate CH4 mass - hydrate CH4 mass, kg - TMHO
!         hydrate N2 mass - hydrate N2 mass, kg - TMHN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.21 .AND. NPHZX.LE.23  ) THEN
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  Total Nonaqueous CO2 Mole Fraction = ',VARZ(23)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  Total Nonaqueous CH4 Mole Fraction = ',VARZ(24)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  Total Nonaqueous N2 Mole Fraction = ',VARZ(25)
            ENDIF
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  CO2 Hydrate Mass = ',VARZ(20)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  CH4 Hydrate Mass = ',VARZ(21)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  N2 Hydrate Mass = ',VARZ(22)
            ENDIF
!
!---      Phase conditions #31 through #39 (30 series)  ---
!
!         SH > 0, SG + SN > 0, SL + SI < 1
!         ZMCA = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #31
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #32
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #33
!         ZMCO = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #34
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #35
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #36
!         ZMCN = MAX( ZMCA,ZMCO,ZMCN )
!           YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #37
!           YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #38
!           YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #39
!
!         energy - temperature, C - T
!         water mass - aqueous + ice saturation, POSM
!         maximum mobile mass component - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - total nonaqueous CH4 mole fraction - ZMCA
!         mobile CH4 mass - total nonaqueous CH4 mole fraction - ZMCO
!         mobile N2 mass - total nonaqueous N2 mole fraction - ZMCN
!         maximum hydrate mass component - hydrate saturation - SH
!         hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!         hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!         hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.31 .AND. NPHZX.LE.39 ) THEN
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  Total Nonaqueous CO2 Mole Fraction = ',VARZ(23)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  Total Nonaqueous CH4 Mole Fraction = ',VARZ(24)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  Total Nonaqueous N2 Mole Fraction = ',VARZ(25)
            ENDIF
            PRINT *,'  Hydrate Saturation = ',VARZ(15)
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  Hydrate Gas CO2 Mole Fraction of Formers = ',
     &          VARZ(26)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  Hydrate Gas CH4 Mole Fraction of Formers = ',
     &          VARZ(27)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  Hydrate Gas N2 Mole Fraction of Formers = ',
     &          VARZ(28)
            ENDIF
!
!---      Phase conditions #41 through #43 (40 series)  ---
!
!         SH > 0, SG + SN = 0, SL + SI < 1
!         YMHGA = MAX( YMHGA,YMHGO,YMHGN ) #41
!         YMHGO = MAX( YMHGA,YMHGO,YMHGN ) #42
!         YMHGN = MAX( YMHGA,YMHGO,YMHGN ) #43
!
!         energy - temperature, C - T
!         water mass - pressure, Pa (gauge) - PSO
!         mobile CO2 mass - CO2 vapor pressure, Pa absolute - PVA
!         mobile CH4 mass - CH4 vapor pressure, Pa absolute - PVO
!         mobile N2 mass - N2 vapor pressure, Pa absolute - PVN
!         maximum hydrate mass component - hydrate saturation - SH
!         hydrate CO2 mass - hyd-gas CH4 mole frac. of formers - YMHGA
!         hydrate CH4 mass - hyd-gas CH4 mole frac. of formers - YMHGO
!         hydrate N2 mass - hyd-gas N2 mole frac. of formers - YMHGN
!         NaCl mass - total NaCl aqueous mass fraction - YLS
!
          ELSEIF( NPHZX.GE.41 .AND. NPHZX.LE.43 ) THEN
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  CO2 vapor pressure, Pa absolute = ',VARZ(17)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  CH4 vapor pressure, Pa absolute = ',VARZ(18)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  N2 vapor pressure, Pa absolute = ',VARZ(19)
            ENDIF
            PRINT *,'  Hydrate Saturation = ',VARZ(15)
            IF( ISLC(45).EQ.0 ) THEN
              PRINT *,'  Hydrate Gas CO2 Mole Fraction of Formers = ',
     &          VARZ(26)
            ENDIF
            IF( ISLC(64).EQ.0 ) THEN
              PRINT *,'  Hydrate Gas CH4 Mole Fraction of Formers = ',
     &          VARZ(27)
            ENDIF
            IF( ISLC(65).EQ.0 ) THEN
              PRINT *,'  Hydrate Gas N2 Mole Fraction of Formers = ',
     &          VARZ(28)
            ENDIF
          ENDIF
          PRINT *,'  Total-Salt Aqu. Mass Fraction = ',VARZ(29)
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            ZMCA(2,N) = ZMCA(1,N)
            ZMCO(2,N) = ZMCO(1,N)
            ZMCN(2,N) = ZMCN(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            POSM(2,N) = POSM(1,N)
            SH(2,N) = SH(1,N)
            SI(2,N) = SI(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            YMGA(2,N) = YMGA(1,N)
            YMGO(2,N) = YMGO(1,N)
            YMGN(2,N) = YMGN(1,N)
            YMHGA(2,N) = YMHGA(1,N)
            YMHGO(2,N) = YMHGO(1,N)
            YMHGN(2,N) = YMHGN(1,N)
            TMHA(2,N) = TMHA(1,N)
            TMHO(2,N) = TMHO(1,N)
            TMHN(2,N) = TMHN(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Write a excessive primary variable index in the NSTEP location
!         plus write the global node numbers and phase condition indices
!         for the location of maximum residuals for the energy, water,
!         mobile CO2, mobile CH4, mobile N2, hydrate CO2, hydrate CH4,
!         hydrate N2, and salt equations to output.bin  ---
!
          NVAR = 6
          IVARX(1) = -14
          IVARX(2) = ND(N)
          IVARX(3) = NPHZX
          IVARX(4) = INT(VARZ(30))
          IVARX(5) = INT(VARZ(31))
          IVARX(6) = INT(VARZ(32))
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---      Write maximum residuals for the energy, water, mobile CO2, 
!         mobile CH4, mobile N2, hydrate CO2, hydrate CH4, hydrate N2, 
!         and salt equations and time step reductions to output.bin  ---
!
          NVAR = 28
          DO M = 1,8
            VARX(M) = VARZ(M+2)
          ENDDO
          DO M = 9,26
            VARX(M) = VARZ(M+3)
          ENDDO
          VARX(27) = DTX*CNVTM
          VARX(28) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            ZMCA(2,N) = ZMCA(1,N)
            ZMCO(2,N) = ZMCO(1,N)
            ZMCN(2,N) = ZMCN(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            POSM(2,N) = POSM(1,N)
            SH(2,N) = SH(1,N)
            SI(2,N) = SI(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            YMGA(2,N) = YMGA(1,N)
            YMGO(2,N) = YMGO(1,N)
            YMGN(2,N) = YMGN(1,N)
            YMHGA(2,N) = YMHGA(1,N)
            YMHGO(2,N) = YMHGO(1,N)
            YMHGN(2,N) = YMHGN(1,N)
            TMHA(2,N) = TMHA(1,N)
            TMHO(2,N) = TMHO(1,N)
            TMHN(2,N) = TMHN(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
          IF( ID.EQ.0 ) PRINT '(10X,A)','---  Time Step Reduction ' // 
     &      'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the 
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_HYDT_KE group
!
      RETURN
      END
      
!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_GC_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-HYDT-KE (Ternary Gas Hydrate w/ Kinetic Exchange)
!
!     Update the primary variables on ghost cells
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 9 September 2021.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
      USE JACOB
      USE HYST
      USE GRID
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_GC_HYDT_KE'
      NPVX = 17
!
!---  Load sending buffer for bottom ghost cells for processors
!     with bottom ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
        MCS = 0
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(1,ID+1)
          SBFB(NCS+1) = POSM(2,NLSGC(M+MCS))
          SBFB(NCS+2) = PSO(2,NLSGC(M+MCS))
          SBFB(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFB(NCS+4) = PVN(2,NLSGC(M+MCS))
          SBFB(NCS+5) = PVO(2,NLSGC(M+MCS))
          SBFB(NCS+6) = SH(2,NLSGC(M+MCS))
          SBFB(NCS+7) = T(2,NLSGC(M+MCS))
          SBFB(NCS+8) = TMHA(2,NLSGC(M+MCS))
          SBFB(NCS+9) = TMHN(2,NLSGC(M+MCS))
          SBFB(NCS+10) = TMHO(2,NLSGC(M+MCS))
          SBFB(NCS+11) = YLS(2,NLSGC(M+MCS))
          SBFB(NCS+12) = YMHGA(2,NLSGC(M+MCS))
          SBFB(NCS+13) = YMHGN(2,NLSGC(M+MCS))
          SBFB(NCS+14) = YMHGO(2,NLSGC(M+MCS))
          SBFB(NCS+15) = ZMCA(2,NLSGC(M+MCS))
          SBFB(NCS+16) = ZMCN(2,NLSGC(M+MCS))
          SBFB(NCS+17) = ZMCO(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(1,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(1,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFB,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Bottom Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending bottom ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(6,ID+1)*NPVX
        IDSNDX = NPGC(6,ID+1) - 1
        NRCVX = NCGC(1,IDSNDX+1)*NPVX
        IDRCVX = NPGC(1,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFB,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Bottom Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,5
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(6,ID+1)
          POSM(2,NLRGC(M+MCR)) = RBFB(NCR+1)
          PSO(2,NLRGC(M+MCR)) = RBFB(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFB(NCR+3)
          PVN(2,NLRGC(M+MCR)) = RBFB(NCR+4)
          PVO(2,NLRGC(M+MCR)) = RBFB(NCR+5)
          SH(2,NLRGC(M+MCR)) = RBFB(NCR+6)
          T(2,NLRGC(M+MCR)) = RBFB(NCR+7)
          TMHA(2,NLRGC(M+MCR)) = RBFB(NCR+8)
          TMHN(2,NLRGC(M+MCR)) = RBFB(NCR+9)
          TMHO(2,NLRGC(M+MCR)) = RBFB(NCR+10)
          YLS(2,NLRGC(M+MCR)) = RBFB(NCR+11)
          YMHGA(2,NLRGC(M+MCR)) = RBFB(NCR+12)
          YMHGN(2,NLRGC(M+MCR)) = RBFB(NCR+13)
          YMHGO(2,NLRGC(M+MCR)) = RBFB(NCR+14)
          ZMCA(2,NLRGC(M+MCR)) = RBFB(NCR+15)
          ZMCN(2,NLRGC(M+MCR)) = RBFB(NCR+16)
          ZMCO(2,NLRGC(M+MCR)) = RBFB(NCR+17)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for south ghost cells for processors
!     with south ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
        MCS = NCGC(1,ID+1)
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(2,ID+1)
          SBFS(NCS+1) = POSM(2,NLSGC(M+MCS))
          SBFS(NCS+2) = PSO(2,NLSGC(M+MCS))
          SBFS(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFS(NCS+4) = PVN(2,NLSGC(M+MCS))
          SBFS(NCS+5) = PVO(2,NLSGC(M+MCS))
          SBFS(NCS+6) = SH(2,NLSGC(M+MCS))
          SBFS(NCS+7) = T(2,NLSGC(M+MCS))
          SBFS(NCS+8) = TMHA(2,NLSGC(M+MCS))
          SBFS(NCS+9) = TMHN(2,NLSGC(M+MCS))
          SBFS(NCS+10) = TMHO(2,NLSGC(M+MCS))
          SBFS(NCS+11) = YLS(2,NLSGC(M+MCS))
          SBFS(NCS+12) = YMHGA(2,NLSGC(M+MCS))
          SBFS(NCS+13) = YMHGN(2,NLSGC(M+MCS))
          SBFS(NCS+14) = YMHGO(2,NLSGC(M+MCS))
          SBFS(NCS+15) = ZMCA(2,NLSGC(M+MCS))
          SBFS(NCS+16) = ZMCN(2,NLSGC(M+MCS))
          SBFS(NCS+17) = ZMCO(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(2,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(2,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFS,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post South Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending south ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(5,ID+1)*NPVX
        IDSNDX = NPGC(5,ID+1) - 1
        NRCVX = NCGC(2,IDSNDX+1)*NPVX
        IDRCVX = NPGC(2,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFS,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post South Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,4
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(5,ID+1)
          POSM(2,NLRGC(M+MCR)) = RBFS(NCR+1)
          PSO(2,NLRGC(M+MCR)) = RBFS(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFS(NCR+3)
          PVN(2,NLRGC(M+MCR)) = RBFS(NCR+4)
          PVO(2,NLRGC(M+MCR)) = RBFS(NCR+5)
          SH(2,NLRGC(M+MCR)) = RBFS(NCR+6)
          T(2,NLRGC(M+MCR)) = RBFS(NCR+7)
          TMHA(2,NLRGC(M+MCR)) = RBFS(NCR+8)
          TMHN(2,NLRGC(M+MCR)) = RBFS(NCR+9)
          TMHO(2,NLRGC(M+MCR)) = RBFS(NCR+10)
          YLS(2,NLRGC(M+MCR)) = RBFS(NCR+11)
          YMHGA(2,NLRGC(M+MCR)) = RBFS(NCR+12)
          YMHGN(2,NLRGC(M+MCR)) = RBFS(NCR+13)
          YMHGO(2,NLRGC(M+MCR)) = RBFS(NCR+14)
          ZMCA(2,NLRGC(M+MCR)) = RBFS(NCR+15)
          ZMCN(2,NLRGC(M+MCR)) = RBFS(NCR+16)
          ZMCO(2,NLRGC(M+MCR)) = RBFS(NCR+17)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for west ghost cells for processors
!     with west ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,2
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(3,ID+1)
          SBFW(NCS+1) = POSM(2,NLSGC(M+MCS))
          SBFW(NCS+2) = PSO(2,NLSGC(M+MCS))
          SBFW(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFW(NCS+4) = PVN(2,NLSGC(M+MCS))
          SBFW(NCS+5) = PVO(2,NLSGC(M+MCS))
          SBFW(NCS+6) = SH(2,NLSGC(M+MCS))
          SBFW(NCS+7) = T(2,NLSGC(M+MCS))
          SBFW(NCS+8) = TMHA(2,NLSGC(M+MCS))
          SBFW(NCS+9) = TMHN(2,NLSGC(M+MCS))
          SBFW(NCS+10) = TMHO(2,NLSGC(M+MCS))
          SBFW(NCS+11) = YLS(2,NLSGC(M+MCS))
          SBFW(NCS+12) = YMHGA(2,NLSGC(M+MCS))
          SBFW(NCS+13) = YMHGN(2,NLSGC(M+MCS))
          SBFW(NCS+14) = YMHGO(2,NLSGC(M+MCS))
          SBFW(NCS+15) = ZMCA(2,NLSGC(M+MCS))
          SBFW(NCS+16) = ZMCN(2,NLSGC(M+MCS))
          SBFW(NCS+17) = ZMCO(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(3,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(3,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFW,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post West Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending west ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(4,ID+1)*NPVX
        IDSNDX = NPGC(4,ID+1) - 1
        NRCVX = NCGC(3,IDSNDX+1)*NPVX
        IDRCVX = NPGC(3,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFW,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post West Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,3
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(4,ID+1)
          POSM(2,NLRGC(M+MCR)) = RBFW(NCR+1)
          PSO(2,NLRGC(M+MCR)) = RBFW(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFW(NCR+3)
          PVN(2,NLRGC(M+MCR)) = RBFW(NCR+4)
          PVO(2,NLRGC(M+MCR)) = RBFW(NCR+5)
          SH(2,NLRGC(M+MCR)) = RBFW(NCR+6)
          T(2,NLRGC(M+MCR)) = RBFW(NCR+7)
          TMHA(2,NLRGC(M+MCR)) = RBFW(NCR+8)
          TMHN(2,NLRGC(M+MCR)) = RBFW(NCR+9)
          TMHO(2,NLRGC(M+MCR)) = RBFW(NCR+10)
          YLS(2,NLRGC(M+MCR)) = RBFW(NCR+11)
          YMHGA(2,NLRGC(M+MCR)) = RBFW(NCR+12)
          YMHGN(2,NLRGC(M+MCR)) = RBFW(NCR+13)
          YMHGO(2,NLRGC(M+MCR)) = RBFW(NCR+14)
          ZMCA(2,NLRGC(M+MCR)) = RBFW(NCR+15)
          ZMCN(2,NLRGC(M+MCR)) = RBFW(NCR+16)
          ZMCO(2,NLRGC(M+MCR)) = RBFW(NCR+17)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for east ghost cells for processors
!     with east ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,3
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(4,ID+1)
          SBFE(NCS+1) = POSM(2,NLSGC(M+MCS))
          SBFE(NCS+2) = PSO(2,NLSGC(M+MCS))
          SBFE(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFE(NCS+4) = PVN(2,NLSGC(M+MCS))
          SBFE(NCS+5) = PVO(2,NLSGC(M+MCS))
          SBFE(NCS+6) = SH(2,NLSGC(M+MCS))
          SBFE(NCS+7) = T(2,NLSGC(M+MCS))
          SBFE(NCS+8) = TMHA(2,NLSGC(M+MCS))
          SBFE(NCS+9) = TMHN(2,NLSGC(M+MCS))
          SBFE(NCS+10) = TMHO(2,NLSGC(M+MCS))
          SBFE(NCS+11) = YLS(2,NLSGC(M+MCS))
          SBFE(NCS+12) = YMHGA(2,NLSGC(M+MCS))
          SBFE(NCS+13) = YMHGN(2,NLSGC(M+MCS))
          SBFE(NCS+14) = YMHGO(2,NLSGC(M+MCS))
          SBFE(NCS+15) = ZMCA(2,NLSGC(M+MCS))
          SBFE(NCS+16) = ZMCN(2,NLSGC(M+MCS))
          SBFE(NCS+17) = ZMCO(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(4,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(4,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFE,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post East Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending east ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(3,ID+1)*NPVX
        IDSNDX = NPGC(3,ID+1) - 1
        NRCVX = NCGC(4,IDSNDX+1)*NPVX
        IDRCVX = NPGC(4,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFE,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post East Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,2
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(3,ID+1)
          POSM(2,NLRGC(M+MCR)) = RBFE(NCR+1)
          PSO(2,NLRGC(M+MCR)) = RBFE(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFE(NCR+3)
          PVN(2,NLRGC(M+MCR)) = RBFE(NCR+4)
          PVO(2,NLRGC(M+MCR)) = RBFE(NCR+5)
          SH(2,NLRGC(M+MCR)) = RBFE(NCR+6)
          T(2,NLRGC(M+MCR)) = RBFE(NCR+7)
          TMHA(2,NLRGC(M+MCR)) = RBFE(NCR+8)
          TMHN(2,NLRGC(M+MCR)) = RBFE(NCR+9)
          TMHO(2,NLRGC(M+MCR)) = RBFE(NCR+10)
          YLS(2,NLRGC(M+MCR)) = RBFE(NCR+11)
          YMHGA(2,NLRGC(M+MCR)) = RBFE(NCR+12)
          YMHGN(2,NLRGC(M+MCR)) = RBFE(NCR+13)
          YMHGO(2,NLRGC(M+MCR)) = RBFE(NCR+14)
          ZMCA(2,NLRGC(M+MCR)) = RBFE(NCR+15)
          ZMCN(2,NLRGC(M+MCR)) = RBFE(NCR+16)
          ZMCO(2,NLRGC(M+MCR)) = RBFE(NCR+17)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for north ghost cells for processors
!     with north ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,4
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(5,ID+1)
          SBFN(NCS+1) = POSM(2,NLSGC(M+MCS))
          SBFN(NCS+2) = PSO(2,NLSGC(M+MCS))
          SBFN(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFN(NCS+4) = PVN(2,NLSGC(M+MCS))
          SBFN(NCS+5) = PVO(2,NLSGC(M+MCS))
          SBFN(NCS+6) = SH(2,NLSGC(M+MCS))
          SBFN(NCS+7) = T(2,NLSGC(M+MCS))
          SBFN(NCS+8) = TMHA(2,NLSGC(M+MCS))
          SBFN(NCS+9) = TMHN(2,NLSGC(M+MCS))
          SBFN(NCS+10) = TMHO(2,NLSGC(M+MCS))
          SBFN(NCS+11) = YLS(2,NLSGC(M+MCS))
          SBFN(NCS+12) = YMHGA(2,NLSGC(M+MCS))
          SBFN(NCS+13) = YMHGN(2,NLSGC(M+MCS))
          SBFN(NCS+14) = YMHGO(2,NLSGC(M+MCS))
          SBFN(NCS+15) = ZMCA(2,NLSGC(M+MCS))
          SBFN(NCS+16) = ZMCN(2,NLSGC(M+MCS))
          SBFN(NCS+17) = ZMCO(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(5,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(5,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFN,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post North Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending north ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(2,ID+1)*NPVX
        IDSNDX = NPGC(2,ID+1) - 1
        NRCVX = NCGC(5,IDSNDX+1)*NPVX
        IDRCVX = NPGC(5,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFN,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post North Receive: IERR = ',IERR,' ID = ',ID
        MCR = NCGC(1,ID+1)
!        PRINT *,' MCR = ',MCR,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(2,ID+1)
          POSM(2,NLRGC(M+MCR)) = RBFN(NCR+1)
          PSO(2,NLRGC(M+MCR)) = RBFN(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFN(NCR+3)
          PVN(2,NLRGC(M+MCR)) = RBFN(NCR+4)
          PVO(2,NLRGC(M+MCR)) = RBFN(NCR+5)
          SH(2,NLRGC(M+MCR)) = RBFN(NCR+6)
          T(2,NLRGC(M+MCR)) = RBFN(NCR+7)
          TMHA(2,NLRGC(M+MCR)) = RBFN(NCR+8)
          TMHN(2,NLRGC(M+MCR)) = RBFN(NCR+9)
          TMHO(2,NLRGC(M+MCR)) = RBFN(NCR+10)
          YLS(2,NLRGC(M+MCR)) = RBFN(NCR+11)
          YMHGA(2,NLRGC(M+MCR)) = RBFN(NCR+12)
          YMHGN(2,NLRGC(M+MCR)) = RBFN(NCR+13)
          YMHGO(2,NLRGC(M+MCR)) = RBFN(NCR+14)
          ZMCA(2,NLRGC(M+MCR)) = RBFN(NCR+15)
          ZMCN(2,NLRGC(M+MCR)) = RBFN(NCR+16)
          ZMCO(2,NLRGC(M+MCR)) = RBFN(NCR+17)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for top ghost cells for processors
!     with top ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,5
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(6,ID+1)
          SBFT(NCS+1) = POSM(2,NLSGC(M+MCS))
          SBFT(NCS+2) = PSO(2,NLSGC(M+MCS))
          SBFT(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFT(NCS+4) = PVN(2,NLSGC(M+MCS))
          SBFT(NCS+5) = PVO(2,NLSGC(M+MCS))
          SBFT(NCS+6) = SH(2,NLSGC(M+MCS))
          SBFT(NCS+7) = T(2,NLSGC(M+MCS))
          SBFT(NCS+8) = TMHA(2,NLSGC(M+MCS))
          SBFT(NCS+9) = TMHN(2,NLSGC(M+MCS))
          SBFT(NCS+10) = TMHO(2,NLSGC(M+MCS))
          SBFT(NCS+11) = YLS(2,NLSGC(M+MCS))
          SBFT(NCS+12) = YMHGA(2,NLSGC(M+MCS))
          SBFT(NCS+13) = YMHGN(2,NLSGC(M+MCS))
          SBFT(NCS+14) = YMHGO(2,NLSGC(M+MCS))
          SBFT(NCS+15) = ZMCA(2,NLSGC(M+MCS))
          SBFT(NCS+16) = ZMCN(2,NLSGC(M+MCS))
          SBFT(NCS+17) = ZMCO(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(6,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(6,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFT,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Top Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending top ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(1,ID+1)*NPVX
        IDSNDX = NPGC(1,ID+1) - 1
        NRCVX = NCGC(6,IDSNDX+1)*NPVX
        IDRCVX = NPGC(6,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFT,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Top Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
!        PRINT *,' MCR = ',MCR,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(1,ID+1)
          POSM(2,NLRGC(M+MCR)) = RBFT(NCR+1)
          PSO(2,NLRGC(M+MCR)) = RBFT(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFT(NCR+3)
          PVN(2,NLRGC(M+MCR)) = RBFT(NCR+4)
          PVO(2,NLRGC(M+MCR)) = RBFT(NCR+5)
          SH(2,NLRGC(M+MCR)) = RBFT(NCR+6)
          T(2,NLRGC(M+MCR)) = RBFT(NCR+7)
          TMHA(2,NLRGC(M+MCR)) = RBFT(NCR+8)
          TMHN(2,NLRGC(M+MCR)) = RBFT(NCR+9)
          TMHO(2,NLRGC(M+MCR)) = RBFT(NCR+10)
          YLS(2,NLRGC(M+MCR)) = RBFT(NCR+11)
          YMHGA(2,NLRGC(M+MCR)) = RBFT(NCR+12)
          YMHGN(2,NLRGC(M+MCR)) = RBFT(NCR+13)
          YMHGO(2,NLRGC(M+MCR)) = RBFT(NCR+14)
          ZMCA(2,NLRGC(M+MCR)) = RBFT(NCR+15)
          ZMCN(2,NLRGC(M+MCR)) = RBFT(NCR+16)
          ZMCO(2,NLRGC(M+MCR)) = RBFT(NCR+17)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_GC_HYDT_KE group
!
      RETURN
      END
      
