!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Call the Jacobian matrix loaders for STOMP-GT
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE JACOB
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_GT'
      ICNV = 3
!
!---  Zero residual array  ---
!
      DO N = 1,NFCGC(ID+1)
        DO M = 1,ISVC
          RSDL(M,N) = 0.D+0
        ENDDO
      ENDDO
!
!---  Load Jacobian matrix for the energy equation
!     (zero flux boundary), isothermal option  ---
!
      IF( ISLC(30).EQ.0 ) CALL JCBT_GT
!      PRINT *,'Post JCBT_GT: ID = ',ID
!
!---  Load Jacobian matrix for the water equation
!     (zero flux boundary)  ---
!
      CALL JCBW_GT
!      PRINT *,'Post JCBW_GT: ID = ',ID
!
!---  Load Jacobian matrix for the air equation
!     (zero flux boundary)  ---
!
      CALL JCBA_GT
!      PRINT *,'Post JCBA_GT: ID = ',ID
!
!---  Load Jacobian matrix for the salt equation
!     (zero flux boundary), isobrine option  ---
!
      IF( ISLC(32).EQ.0 ) CALL JCBS_GT
!      PRINT *,'Post JCBS_GT: ID = ',ID
!
!---  Fracture and borehole flow and transport solution  ---
!
      IF( ISLC(74).NE.0 ) THEN
!
!---    Load Jacobian matrix for the fracture energy equation, 
!       isothermal option  ---
!
        IF( ISLC(30).EQ.0 .AND. (ISLC(74).EQ.1 .OR. ISLC(74).EQ.3) )
     &    CALL JCBT_FRC_GT
!        PRINT *,'Post JCBT_FRC_GT: ID = ',ID
!!
!!---    Load Jacobian matrix for the borehole energy equation, 
!!       isothermal option  ---
!!
!        IF( ISLC(30).EQ.0 .AND. (ISLC(74).EQ.2 .OR. ISLC(74).EQ.3) )
!     &    CALL JCBT_BH_GT
!!
!!---    Modify Jacobian matrix for the borehole and fracture energy 
!!       equations for borehole to fracture connections, 
!!       isothermal option  ---
!!
!        IF( ISLC(30).EQ.0 ) CALL JCBT_BF_GT
!
!---    Modify Jacobian matrix for matrix grid cells, 
!       fracture triangles, and borehole nodes for transfer of energy
!       between matrix grid cells and fracture triangles and borehole
!       nodes  ---
!
        IF( ISLC(30).EQ.0 ) CALL JCBT_MFB_GT
!        PRINT *,'Post JCBT_MFB_GT: ID = ',ID
!
!---    Load Jacobian matrix for the fracture water equation  ---
!
        IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL JCBW_FRC_GT
!        PRINT *,'Post JCBW_FRC_GT: ID = ',ID
!!
!!---    Load Jacobian matrix for the borehole water equation  ---
!!
!        IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL JCBW_BH_GT
!!
!!---    Modify Jacobian matrix for the borehole and fracture water 
!!       equations for borehole to fracture connections  ---
!!
!        CALL JCBW_BF_GT
!!
!!---    Modify Jacobian matrix for matrix grid cells, 
!!       fracture triangles, and borehole nodes for transfer of water
!!       mass between matrix grid cells and fracture triangles and 
!!       borehole nodes  ---
!!
        IF( ISLC(38).EQ.0 ) CALL JCBW_MFB_GT
!        PRINT *,'Post JCBW_MFB_GT: ID = ',ID
!
!---    Load Jacobian matrix for the fracture air equation  ---
!
        IF( ISLC(37).EQ.0 ) THEN
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL JCBA_FRC_GT
!          PRINT *,'Post JCBA_FRC_GT: ID = ',ID
!!
!!---      Load Jacobian matrix for the borehole air equation  ---
!!
!          IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL JCBA_BH_GT
!!
!!---      Modify Jacobian matrix for the borehole and fracture air 
!!         equations for borehole to fracture connections  ---
!!
!          CALL JCBA_BF_GT
!!
!!---      Modify Jacobian matrix for matrix grid cells, 
!!         fracture triangles, and borehole nodes for transfer of air
!!         mass between matrix grid cells and fracture triangles and 
!!         borehole nodes  ---
!!
          IF( ISLC(38).EQ.0 ) CALL JCBA_MFB_GT
!          PRINT *,'Post JCBA_MFB_GT: ID = ',ID
        ENDIF
!
!---    Load Jacobian matrix for the fracture salt equation  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL JCBS_FRC_GT
!          PRINT *,'Post JCBS_FRC_GT: ID = ',ID
!!
!!---      Load Jacobian matrix for the borehole salt equation  ---
!!
!          IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL JCBS_BH_GT
!!
!!---      Modify Jacobian matrix for the borehole and fracture salt 
!!         equations for borehole to fracture connections, 
!!         isothermal option  ---
!!
!          CALL JCBS_BF_GT
!!
!!---      Modify Jacobian matrix for matrix grid cells, 
!!         fracture triangles, and borehole nodes for transfer of salt
!!         mass between matrix grid cells and fracture triangles and 
!!         borehole nodes  ---
!!
          IF( ISLC(38).EQ.0 ) CALL JCBS_MFB_GT
!          PRINT *,'Post JCBS_MFB_GT: ID = ',ID
        ENDIF
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBP_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Configure the arrays for compressed sparse row matrix storage.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBP_GT'
!
!---  Coupled fracture or boreholes  ---
!
      IF( L_FRC.EQ.1 .OR. L_BH.EQ.1  ) THEN
        CALL JCBP_MFB_GT
!        PRINT *,'Post JCBP_MFB_GT: ID = ',ID
!
!---  No coupled fracture or boreholes  ---
!
      ELSE
        CALL JCBP_NMFB_GT
!        PRINT *,'Post JCBP_NMFB_GT: ID = ',ID
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBP_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_SV
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Set values of the Jacobian matrix
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_SV'
#ifdef lis
!
!---  Lis solver  ---
!
      CALL LIS_MATRIX_SET_CSR( NNZ,NLU,MLU,DLU,F_MAT,IERR )
      IF( IERR.NE.0 ) THEN
        I_ERR(1) = 0
        I_ERR(2) = 0
        I_ERR(3) = 0
        I_ERR(4) = ID
        M_ERR(1) = 'Coupled Flow and Transport Lis Matrix Set CSR'
        RETURN
      ENDIF
#endif
#ifdef petsc
!
!---  PETSC solver  ---
!
      NC = 0
      DO NEQ = 1,NUKFL(ID+1)
        MC = 0
        DO NCOL = NLU(NEQ),(NLU(NEQ+1)-1)
          NC = NC + 1
          MC = MC + 1
          BUFFER(MC) = DLU(NC)
          ICOL(MC) = MLU(NC)
        ENDDO
        IROW = NEQ + NUKFO(ID+1) - 1
        CALL MatSetValues( F_MAT,1,IROW,MC,ICOL,BUFFER,
     &    INSERT_VALUES,IERR )
      ENDDO
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_SV group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBP_MFB_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Configure the arrays for compressed sparse row matrix storage
!     for problems with coupled fractures or boreholes.
!
!     Fracture triangle equations are stored after the grid-cell
!     equations on each processor
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 25 July 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBP_MFB_GT'
!
!---  Determine the number of non-zero elements on each processor,
!     number of equations on each processor,
!     
      NNZ = 0
      NROW = 0
      NROW_FRC = 0
      NCMX = 0
      NCMX_FRC = 0
      NMDMN = (NFLD+NFT_G)*ISVC
      NMDMN_FRC = (NFLD+NFT_G)*ISVC
!
!---  Loop over local nodes, skipping inactive and ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        NC = 0
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
!
!---      Node  ---
!
          NNZ = NNZ + ISVC
          NROW = NROW + 1
          NC = NC + 1
          NMDMN = MIN( NMDMN,NMD+L)
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC + 1
          ENDIF
!
!---      Check for connection with fracture triangle(s), with
!         multiple connections possible  ---
!
          IF( INTP_FRC(1,N).NE.0 ) THEN
            DO NT = INTP_FRC(1,N),INTP_FRC(2,N)
              NNZ = NNZ + ISVC
!              NC = NC + 1
            ENDDO
          ENDIF          
        ENDDO
        NCMX = MAX( NCMX,NC )
      ENDDO
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NC_FRC = 0
        NMD_FRC = (IXP_FRC(NT1X)-1)*ISVC
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
!
!---      Fracture triangle  ---
!
          NNZ = NNZ + ISVC
          NROW_FRC = NROW_FRC + 1
          NC_FRC = NC_FRC + 1
          NMDMN_FRC = MIN( NMDMN_FRC,NMD_FRC+L)
!
!---      Loop over active fracture triangle connections  ---
!
          DO NTC = 1,3
            NT2X = ITTCM_FRC(NTC,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            NNZ = NNZ + ISVC
            NC_FRC = NC_FRC + 1
          ENDDO
!
!---      Matrix node connections  ---
!
          N = ITNCM_FRC(NT1X)
          IF( N.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC_FRC = NC_FRC + 1
          ENDIF
        ENDDO
        NCMX_FRC = MAX( NCMX_FRC,NC_FRC )
      ENDDO
!
!---  Matrix node and fracture triangle equation local offsets ---
!
      IEQ_OFFSET = NMDMN - 1
      IF( NFT(ID+1).EQ.0 ) THEN
        IEQ_OFFSET_FRC = 0
      ELSE
        IEQ_OFFSET_FRC = NMDMN_FRC - 1
      ENDIF
!      PRINT *,'IEQ_OFFSET = ',IEQ_OFFSET,'IEQ_OFFSET_FRC = ',
!     &  IEQ_OFFSET_FRC,'ID = ',ID
!
!---  Allocate memory for NSD_FRC ---
!
      ALLOCATE( NSD_FRC(1:LUK),STAT=ISTAT )
      CHMSG = 'NSD_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for RSD_FRC ---
!
      ALLOCATE( RSD_FRC(1:LUK),STAT=ISTAT )
      CHMSG = 'RSD_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), and equation to index pointer (KLU) ---
!
      ALLOCATE( NLU(1:NROW+NROW_FRC+1),STAT=ISTAT )
      CHMSG = 'NLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( MLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'MLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( DLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'DLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( BLU(1:NUKFL(ID+1)),STAT=ISTAT )
      CHMSG = 'BLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!      PRINT *,'NNZ = ',NNZ,'ID = ',ID
!      PRINT *,'1: LJG = ',LJG,'LJH = ',LJH,'LJG_FRC = ',LJG_FRC,
!     &  'LJH_FRC = ',LJH_FRC,'LJG_FCM = ',LJG_FCM,
!     &  'LJH_FCM = ',LJH_FCM,'LJG_MCF = ',LJG_MCF,
!     &  'LJH_MCF = ',LJH_MCF,'IEQ_OFFSET = ',IEQ_OFFSET,
!     &  'IEQ_OFFSET_FRC = ',IEQ_OFFSET_FRC,'ID = ',ID
      LJG = MAX(NROW,1)
      LJH = MAX(NCMX,1)
!      PRINT *,'LJG = ',LJG,'LJH = ',LJH,'ID = ',ID
!
!---  Allocate memory for KLU ---
!
      ALLOCATE( KLU(1:LJG,1:LJH),STAT=ISTAT )
      CHMSG = 'KLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      LJG_FRC = MAX(NROW_FRC,1)
      LJH_FRC = MAX(NCMX_FRC,1)
!
!---  Allocate memory for KLU_FRC ---
!
      ALLOCATE( KLU_FRC(1:LJG_FRC,1:LJH_FRC),STAT=ISTAT )
      CHMSG = 'KLU_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      LJG_FCM = MAX(NROW_FRC,1)
      LJH_FCM = MAX(ISVC,1)
!
!---  Allocate memory for KLU_FCM ---
!
      ALLOCATE( KLU_FCM(1:LJG_FCM,1:LJH_FCM),STAT=ISTAT )
      CHMSG = 'KLU_FCM'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      LJG_MCF = MAX(NROW_FRC,1)
      LJH_MCF = MAX(ISVC,1)
!
!---  Allocate memory for KLU_MCF ---
!
      ALLOCATE( KLU_MCF(1:LJG_MCF,1:LJH_MCF),STAT=ISTAT )
      CHMSG = 'KLU_MCF'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!      PRINT *,'2: LJG = ',LJG,'LJH = ',LJH,'LJG_FRC = ',LJG_FRC,
!     &  'LJH_FRC = ',LJH_FRC,'LJG_FCM = ',LJG_FCM,
!     &  'LJH_FCM = ',LJH_FCM,'LJG_MCF = ',LJG_MCF,
!     &  'LJH_MCF = ',LJH_MCF,'IEQ_OFFSET = ',IEQ_OFFSET,
!     &  'IEQ_OFFSET_FRC = ',IEQ_OFFSET_FRC,'ID = ',ID
!
!---  Initialize memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), and equation to index pointer (KLU) ---
!
      DO L = 1,NROW+NROW_FRC+1
        NLU(L) = 0
      ENDDO
      DO L = 1,NNZ
        MLU(L) = 0
        DLU(L) = 0.D+0
      ENDDO
      DO M = 1,LJH
        DO L = 1,LJG
          KLU(L,M) = 0
        ENDDO
      ENDDO
      DO M = 1,LJH_FRC
        DO L = 1,LJG_FRC
          KLU_FRC(L,M) = 0
        ENDDO
      ENDDO
      DO M = 1,LJH_FCM
        DO L = 1,LJG_FCM
          KLU_FCM(L,M) = 0
        ENDDO
      ENDDO
      DO M = 1,LJH_MCF
        DO L = 1,LJG_MCF
          KLU_MCF(L,M) = 0
        ENDDO
      ENDDO
!
!---  Assign CSR pointer (NLU), index (MLU), and equation to 
!     index pointer (KLU) ---
!
      NC = 0
      NLU(1) = 0
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
          MA = 0
!
!---      Node  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            MLU(NC) = NMD+M-1
            KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
          ENDDO
          MA = MA + ISVC
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NMDB = (IXP(NB)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDB+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NMDS = (IXP(NS)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDS+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NMDW = (IXP(NW)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDW+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NMDE = (IXP(NE)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDE+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NMDN = (IXP(NN)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDN+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NMDT = (IXP(NT)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDT+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      Check for connection with fracture triangle(s), with
!         multiple connections possible  ---
!
          IF( INTP_FRC(1,N).NE.0 ) THEN
            DO NT = INTP_FRC(1,N),INTP_FRC(2,N)
              NTX = INTCM_FRC(NT)
              NMDF = (IXP_FRC(NTX)-1)*ISVC
              DO M = 1,ISVC
                NC = NC + 1
                MLU(NC) = NMDF+M-1
                KLU_MCF(NMDF+L-IEQ_OFFSET_FRC,M) = NC
              ENDDO
            ENDDO
          ENDIF          
          NLU(NMD+L-IEQ_OFFSET+1) = NC
        ENDDO
      ENDDO
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NMD = (IXP_FRC(NT1X)-1)*ISVC
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
          MA = 0
!
!---      Fracture triangle  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            MLU(NC) = NMD+M-1
            KLU_FRC(NMD+L-IEQ_OFFSET_FRC,M+MA) = NC
          ENDDO
          MA = MA + ISVC
!
!---      Loop over active fracture triangle connections  ---
!
          DO NTC = 1,3
            NT2X = ITTCM_FRC(NTC,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            NMDT = (IXP_FRC(NT2X)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDT+M-1
              KLU_FRC(NMD+L-IEQ_OFFSET_FRC,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDDO
!
!---      Matrix node connections  ---
!
          N = ITNCM_FRC(NT1X)
          NMDN = (IXP(N)-1)*ISVC
          DO M = 1,ISVC
            NC = NC + 1
            MLU(NC) = NMDN+M-1
            KLU_FCM(NMD+L-IEQ_OFFSET_FRC,M) = NC
          ENDDO
          NLU(NMD+L-IEQ_OFFSET+1) = NC
        ENDDO
      ENDDO
!
!---  Solute or reactive species transport solution  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!
!---    Determine the number of non-zero elements on each processor,
!       number of equations on each processor,
!       
        NNZC = 0
        NROWC = 0
        NROWC_FRC = 0
        NCMXC = 0
        NCMXC_FRC = 0
        NMDMNC = (NFLD+NFT_G)
        NMDMNC_FRC = (NFLD+NFT_G)
!
!       Loop over local nodes, skipping inactive and ghost cells  ---
!
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          NMD = IXP(N)
          NC = 0
!
!---      Node  ---
!
          NNZC = NNZC + 1
          NROWC = NROWC + 1
          NMDMNC = MIN( NMDMNC,NMD)
          NC = NC + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      Connections with fracture triangles, multiple connections
!         are possible  ---
!
          IF( INTP_FRC(1,N).NE.0 ) THEN
            DO M = INTP_FRC(1,N),INTP_FRC(2,N)
              NNZC = NNZC + 1
              NC = NC + 1
            ENDDO
          ENDIF 
          NCMXC = MAX( NCMXC,NC )
        ENDDO
!
!---    Loop over local fracture triangles, skipping ghost triangles  ---
!
        DO NT1X = 1,NFT(ID+1)
          NC_FRC = 0
          NMD_FRC = IXP_FRC(NT1X)
!
!---      Fracture triangle  ---
!
          NNZC = NNZC + 1
          NROWC_FRC = NROWC_FRC + 1
          NC_FRC = NC_FRC + 1
          NMDMNC_FRC = MIN( NMDMNC_FRC,NMD_FRC)
!
!---      Loop over active fracture triangle connections  ---
!
          DO NTC = 1,3
            NT2X = ITTCM_FRC(NTC,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            NNZC = NNZC + 1
            NC_FRC = NC_FRC + 1
          ENDDO
!
!---      Connections with matrix nodes, only one connection
!         is possible  ---
!
          N = ITNCM_FRC(NT1X)
          IF( N.NE.0 ) THEN
            NNZC = NNZC + 1
            NC_FRC = NC_FRC + 1
          ENDIF
          NCMXC_FRC = MAX( NCMXC_FRC,NC_FRC )
        ENDDO
!
!---    Transport equation local offsets ---
!
        IEQC_OFFSET = NMDMNC - 1
        IEQC_OFFSET_FRC = NMDMNC_FRC - 1
!
!---    Allocate memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        ALLOCATE( NLUC(1:NROWC+NROWC_FRC+1),STAT=ISTAT )
        CHMSG = 'NLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        ALLOCATE( MLUC(1:NNZC),STAT=ISTAT )
        CHMSG = 'MLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        LJK = MAX(NROWC,1)
        LJL = MAX(NCMXC,1)
        ALLOCATE( KLUC(1:LJK,1:LJL),STAT=ISTAT )
        CHMSG = 'KLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        LJK_FRC = MAX(NROWC_FRC,1)
        LJL_FRC = MAX(NCMXC_FRC,1)
        ALLOCATE( KLUC_FRC(1:LJK_FRC,1:LJL_FRC),STAT=ISTAT )
        CHMSG = 'KLUC_FRC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        LJK_FCM = MAX(NROWC_FRC,1)
        LJL_FCM = 1
        ALLOCATE( KLUC_FCM(1:LJK_FCM,1:LJL_FCM),STAT=ISTAT )
        CHMSG = 'KLUC_FCM'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        LJK_MCF = MAX(NROWC_FRC,1)
        LJL_MCF = 1
        ALLOCATE( KLUC_MCF(1:LJK_MCF,1:LJL_MCF),STAT=ISTAT )
        CHMSG = 'KLUC_MCF'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---    Initialize memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        DO L = 1,NROWC+NROWC_FRC+1
          NLUC(L) = 0
        ENDDO
        DO L = 1,NNZC
          MLUC(L) = 0
        ENDDO
        DO M = 1,LJL
          DO L = 1,LJK
            KLUC(L,M) = 0
          ENDDO
        ENDDO
        DO M = 1,LJL_FRC
          DO L = 1,LJK_FRC
            KLUC_FRC(L,M) = 0
          ENDDO
        ENDDO
        DO M = 1,LJL_FCM
          DO L = 1,LJK_FCM
            KLUC_FCM(L,M) = 0
          ENDDO
        ENDDO
        DO M = 1,LJL_MCF
          DO L = 1,LJK_MCF
            KLUC_MCF(L,M) = 0
          ENDDO
        ENDDO
!
!---    Assign CSR pointer (NLUC), index (MLUC), and equation to 
!       index pointer (KLUC) ---
!
        NC = 0
        NLUC(1) = 0
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          NMD = IXP(N)
          MA = 1
!
!---      Node  ---
!
          NC = NC + 1
          MLUC(NC) = NMD-1
          KLUC(NMD-IEQC_OFFSET,MA) = NC
          MA = MA + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NB)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NS)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NW)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NE)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NN)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NT)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      Check for connection with fracture triangle(s), with
!         multiple connections possible  ---
!
          IF( INTP_FRC(1,N).NE.0 ) THEN
            DO NT = INTP_FRC(1,N),INTP_FRC(2,N)
              NTX = INTCM_FRC(NT)
              NMDF = IXP_FRC(NTX)
              NC = NC + 1
              MLUC(NC) = NMDF-1
              KLUC_MCF(NMDF-IEQC_OFFSET_FRC,1) = NC
            ENDDO
          ENDIF          
          NLUC(NMD-IEQC_OFFSET+1) = NC
        ENDDO
!
!---    Loop over local fracture triangles, skipping ghost triangles  ---
!
        DO NT1X = 1,NFT(ID+1)
          NMD = IXP_FRC(NT1X)
          MA = 1
!
!---      Fracture triangle  ---
!
          NC = NC + 1
          MLUC(NC) = NMD-1
          KLUC_FRC(NMD-IEQC_OFFSET_FRC,MA) = NC
          MA = MA + 1
!
!---      Loop over active fracture triangle connections  ---
!
          DO NTC = 1,3
            NT2X = ITTCM_FRC(NTC,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            NC = NC + 1
            MLUC(NC) = IXP_FRC(NT2X)-1
            KLUC_FRC(NMD-IEQC_OFFSET_FRC,MA) = NC
            MA = MA + 1
          ENDDO
!
!---      Connections with matrix nodes, only one connection
!         is possible  ---
!
          N = ITNCM_FRC(NT1X)
          IF( N.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(N)-1
            KLUC_FCM(NMD-IEQC_OFFSET_FRC,1) = NC
          ENDIF
          NLUC(NMD-IEQC_OFFSET+1) = NC
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBP_MFB_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBP_NMFB_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Configure the arrays for compressed sparse row matrix storage
!     for problems without coupled fractures or boreholes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE JACOB
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBP_NMFB_GT'
!
!---  Determine the number of non-zero elements on each processor,
!     number of equations on each processor,
!     
      NNZ = 0
      NROW = 0
      NMDMN = NFLD*ISVC
      NCMX = 0
!
!     Loop over local nodes, skipping inactive and ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        NC = 0
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
!
!---      Node  ---
!
          NNZ = NNZ + ISVC
          NROW = NROW + 1
          NC = NC + 1
          NMDMN = MIN( NMDMN,NMD+L)
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
          NCMX = MAX( NCMX,NC )
        ENDDO
      ENDDO
!
!---  Flow and transport equation local offsets ---
!
      IEQ_OFFSET = NMDMN - 1
!
!---  Allocate memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), equation to index pointer (KLU),
!     and problem/solution vector (BLU) ---
!
      ALLOCATE( NLU(1:NROW+1),STAT=ISTAT )
      CHMSG = 'NLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( MLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'MLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( DLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'DLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
#ifdef lis
      ALLOCATE( BLU(1:NUKFL(ID+1)),STAT=ISTAT )
      CHMSG = 'BLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
#endif
#ifdef petsc
      NUKX = NFCGC(ID+1)*ISVC
      ALLOCATE( BLU(1:NUKX),STAT=ISTAT )
      CHMSG = 'BLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
#endif
      LJG = MAX(NROW,1)
      LJH = MAX(NCMX,1)
      ALLOCATE( KLU(1:LJG,1:LJH),STAT=ISTAT )
      CHMSG = 'KLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Initialize memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), and equation to index pointer (KLU) ---
!
      DO L = 1,NROW+1
        NLU(L) = 0
      ENDDO
      DO L = 1,NNZ
        MLU(L) = 0
        DLU(L) = 0.D+0
      ENDDO
      DO M = 1,LJH
        DO L = 1,LJG
          KLU(L,M) = 0
        ENDDO
      ENDDO
!
!---  Assign CSR pointer (NLU), index (MLU), and equation to 
!     index pointer (KLU) ---
!
      MC = 0
      NC = 0
      NLU(1) = 0
      NNZFR = 0
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        MC = MC + 1
        NMD = (IXP(N)-1)*ISVC
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
          MA = 0
!
!---      Node  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            MLU(NC) = NMD+M-1
            KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
          ENDDO
          MA = MA + ISVC
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NMDB = (IXP(NB)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDB+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NMDS = (IXP(NS)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDS+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NMDW = (IXP(NW)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDW+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NMDE = (IXP(NE)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDE+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NMDN = (IXP(NN)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDN+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NMDT = (IXP(NT)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDT+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
          NLU(NMD+L-IEQ_OFFSET+1) = NC
          NNZFR = MAX( NNZFR,(NC-NLU(NMD+L-IEQ_OFFSET)) )
        ENDDO
      ENDDO
!
!---  Solute or reactive species transport solution  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!
!---    Determine the number of non-zero elements on each processor,
!       number of equations on each processor,
!       
        NNZC = 0
        NROWC = 0
        NMDMNC = NFLD
        NCMXC = 0
!
!       Loop over local nodes, skipping inactive and ghost cells  ---
!
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          NMD = IXP(N)
          NC = 0
!
!---      Node  ---
!
          NNZC = NNZC + 1
          NROWC = NROWC + 1
          NMDMNC = MIN( NMDMNC,NMD)
          NC = NC + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
          NCMXC = MAX( NCMXC,NC )
        ENDDO
!
!---    Transport equation local offsets ---
!
        IEQC_OFFSET = NMDMNC - 1
!
!---    Allocate memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        ALLOCATE( NLUC(1:NROWC+1),STAT=ISTAT )
        CHMSG = 'NLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        ALLOCATE( MLUC(1:NNZC),STAT=ISTAT )
        CHMSG = 'MLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        LJK = MAX(NROWC,1)
        LJL = MAX(NCMXC,1)
        ALLOCATE( KLUC(1:LJK,1:LJL),STAT=ISTAT )
        CHMSG = 'KLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---    Initialize memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        DO L = 1,NROWC+1
          NLUC(L) = 0
        ENDDO
        DO L = 1,NNZC
          MLUC(L) = 0
        ENDDO
        DO M = 1,LJL
          DO L = 1,LJK
            KLUC(L,M) = 0
          ENDDO
        ENDDO
!
!---    Assign CSR pointer (NLUC), index (MLUC), and equation to 
!       index pointer (KLUC) ---
!
        MC = 0
        NC = 0
        NLUC(1) = 0
        NNZTR = 0
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          MC = MC + 1
          NMD = IXP(N)
          MA = 1
!
!---      Node  ---
!
          NC = NC + 1
          MLUC(NC) = NMD-1
          KLUC(NMD-IEQC_OFFSET,MA) = NC
          MA = MA + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NB)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NS)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NW)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NE)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NN)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NT)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
          NLUC(NMD-IEQC_OFFSET+1) = NC
          NNZTR = MAX( NNZTR,(NC-NLUC(NMD-IEQC_OFFSET)) )
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBP_NMFB_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBL_GT( RSS,RSP,RSA,N,MEQ )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 RSP(LUK),RSA(LUK,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBL_GT'
#ifdef lis
!
!---  Lis solver  ---
!
!
!---  Node  ---
!
      NMD = (IXP(N)-1)*ISVC
      IROW = NMD + MEQ
      MA = 0
      DO M = 1,ISVC
        MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
        DLU(MCOL) = DLU(MCOL) + (RSP(M)-RSS)/DNR(M,N)
      ENDDO
      BUFFER = -RSS
      CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &    F_RHS_VEC,IERR )
      RSDL(MEQ,N) = RSDL(MEQ,N) - RSS
      MA = MA + ISVC
!
!---  Bottom ---
!
      NB = ICM(1,N)
      IF( NB.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,1)-RSS)/DNR(M,NB)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  South ---
!
      NS = ICM(2,N)
      IF( NS.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,2)-RSS)/DNR(M,NS)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  West ---
!
      NW = ICM(3,N)
      IF( NW.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,3)-RSS)/DNR(M,NW)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  East ---
!
      NE = ICM(4,N)
      IF( NE.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,4)-RSS)/DNR(M,NE)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  North ---
!
      NN = ICM(5,N)
      IF( NN.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,5)-RSS)/DNR(M,NN)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  Top ---
!
      NT = ICM(6,N)
      IF( NT.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,6)-RSS)/DNR(M,NT)
        ENDDO
        MA = MA + ISVC
      ENDIF
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBL_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBA_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the air equation with
!     aqueous and gas contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STAX(LUK+1),RAP(LUK),RAA(LUK,6),FA(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBA_GT'
      IEQAX = IEQA
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        STA1 = PORD(1,N)*(XLA(1,N)*RHOL(1,N)*SL(1,N) +
     &      XGA(1,N)*RHOG(1,N)*SG(1,N))
        DO M = 1,ISVC+1
          MP = M + 1
          STA0 = PORD(MP,N)*(XLA(MP,N)*RHOL(MP,N)*SL(MP,N) +
     &      XGA(MP,N)*RHOG(MP,N)*SG(MP,N))
          STAX(M) = (STA0-STA1)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FA(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---  Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FA(M,1) = -AFZ(1,N)*(WLA(M,1,N)+WGA(M,1,N))
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FA(M,2) = -AFY(1,N)*(VLA(M,1,N)+VGA(M,1,N))
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FA(M,3) = -AFX(1,N)*(ULA(M,1,N)+UGA(M,1,N))
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FA(M,4) = AFX(2,N)*(ULA(MF,2,N)+UGA(MF,2,N))
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FA(M,5) = AFY(2,N)*(VLA(MF,2,N)+VGA(MF,2,N))
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FA(M,6) = AFZ(2,N)*(WLA(MF,2,N)+WGA(MF,2,N))
          ENDDO
        ENDIF
!
!---    Compute GT equation residuals  ---
!
        RAS = STAX(1) - SRCA(2,N)
        DO MD = 1,6
          RAS = RAS + FA(1,MD)
        ENDDO
        DO M = 1,ISVC
          RAP(M) = STAX(M+1) - SRCA(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RAP(M) = RAP(M) + FA(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RAA(M,MD) = RAS - FA(1,MD) + FA(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_GT( RAS,RAP,RAA,N,IEQAX )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBA_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBS_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the salt equation with
!     aqueous contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STSX(LUK+1),RSP(LUK),RSA(LUK,6),FS(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBS_GT'
      IEQSX = IEQS
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        DO M = 1,ISVC+1
          MP = M + 1
          STSX(M) = (TMS(MP,N)-TMS(1,N))*VOL(N)*DTI
        ENDDO
!
!---    Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FS(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---    Bottom surface flux component  ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FS(M,1) = -AFZ(1,N)*WS(M,1,N)
          ENDDO
        ENDIF
!
!---    South surface flux component ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FS(M,2) = -AFY(1,N)*VS(M,1,N)
          ENDDO
        ENDIF
!
!---    West surface flux component ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FS(M,3) = -AFX(1,N)*US(M,1,N)
          ENDDO
        ENDIF
!
!---    East surface flux component  ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FS(M,4) = AFX(2,N)*US(MF,2,N)
          ENDDO
        ENDIF
!
!---    North surface flux component  ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FS(M,5) = AFY(2,N)*VS(MF,2,N)
          ENDDO
        ENDIF
!
!---    Top surface flux component  ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FS(M,6) = AFZ(2,N)*WS(MF,2,N)
          ENDDO
        ENDIF
!
!---    Salt equation residuals  ---
!
        RSS = STSX(1) - SRCS(2,N)
        DO MD = 1,6
          RSS = RSS + FS(1,MD)
        ENDDO
        DO M = 1,ISVC
          RSP(M) = STSX(M+1) - SRCS(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RSP(M) = RSP(M) + FS(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RSA(M,MD) = RSS - FS(1,MD) + FS(MM,MD)
          ENDDO
        ENDDO
!
!---    Jacobian matrix loader  --
!
        CALL JCBL_GT( RSS,RSP,RSA,N,IEQSX )
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBS_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBT_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the energy equation with
!     aqueous-phase and gas-phase contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 6 July 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STTX(LUK+1),RTP(LUK),RTA(LUK,6),FT(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBT_GT'
      IEQTX = IEQT
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        STT1 = (1.D+0-POR(2,N))*RHOS(N)*CPS(N)*T(1,N) +
     &    PORD(1,N)*SS(1,N)*RHOSP(1,N)*HSP(1,N) +
     &    (PORT(1,N)-PORD(1,N))*RHOL(1,N)*HL(1,N) +
     &    PORD(1,N)*(SL(1,N)*RHOL(1,N)*HL(1,N) +
     &    SG(1,N)*RHOG(1,N)*UEG(1,N))
        DO M = 1,ISVC+1
          MP = M + 1
          STT0 = (1.D+0-POR(2,N))*RHOS(N)*CPS(N)*T(MP,N) +
     &      PORD(MP,N)*SS(MP,N)*RHOSP(MP,N)*HSP(MP,N) +
     &      (PORT(MP,N)-PORD(MP,N))*RHOL(MP,N)*HL(MP,N) +
     &      PORD(MP,N)*(SL(MP,N)*RHOL(MP,N)*HL(MP,N) +
     &      SG(MP,N)*RHOG(MP,N)*UEG(MP,N))
          STTX(M) = (STT0-STT1)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FT(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---    Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FT(M,1) = -AFZ(1,N)*WQ(M,1,N)
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FT(M,2) = -AFY(1,N)*VQ(M,1,N)
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FT(M,3) = -AFX(1,N)*UQ(M,1,N)
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FT(M,4) = AFX(2,N)*UQ(MF,2,N)
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FT(M,5) = AFY(2,N)*VQ(MF,2,N)
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FT(M,6) = AFZ(2,N)*WQ(MF,2,N)
          ENDDO
        ENDIF
!
!---    Compute water equation residuals  ---
!
        RTS = STTX(1) - SRCT(2,N)
        DO MD = 1,6
          RTS = RTS + FT(1,MD)
        ENDDO
        DO M = 1,ISVC
          RTP(M) = STTX(M+1) - SRCT(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RTP(M) = RTP(M) + FT(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RTA(M,MD) = RTS - FT(1,MD) + FT(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_GT( RTS,RTP,RTA,N,IEQTX )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBT_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBW_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the water equation with
!     aqueous and gas contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STWX(LUK+1),RWP(LUK),RWA(LUK,6),FW(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBW_GT'
      IEQWX = IEQW
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        STW1 = PORD(1,N)*(XLW(1,N)*RHOL(1,N)*SL(1,N) +
     &      XGW(1,N)*RHOG(1,N)*SG(1,N))
        DO M = 1,ISVC+1
          MP = M + 1
          STW0 = PORD(MP,N)*(XLW(MP,N)*RHOL(MP,N)*SL(MP,N) +
     &      XGW(MP,N)*RHOG(MP,N)*SG(MP,N))
          STWX(M) = (STW0-STW1)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FW(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---    Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FW(M,1) = -AFZ(1,N)*(WLW(M,1,N)+WGW(M,1,N))
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FW(M,2) = -AFY(1,N)*(VLW(M,1,N)+VGW(M,1,N))
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FW(M,3) = -AFX(1,N)*(ULW(M,1,N)+UGW(M,1,N))
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FW(M,4) = AFX(2,N)*(ULW(MF,2,N)+UGW(MF,2,N))
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FW(M,5) = AFY(2,N)*(VLW(MF,2,N)+VGW(MF,2,N))
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FW(M,6) = AFZ(2,N)*(WLW(MF,2,N)+WGW(MF,2,N))
          ENDDO
        ENDIF
!
!---    Compute water equation residuals  ---
!
        RWS = STWX(1) - SRCW(2,N)
        DO MD = 1,6
          RWS = RWS + FW(1,MD)
        ENDDO
        DO M = 1,ISVC
          RWP(M) = STWX(M+1) - SRCW(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RWP(M) = RWP(M) + FW(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RWA(M,MD) = RWS - FW(1,MD) + FW(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_GT( RWS,RWP,RWA,N,IEQWX )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBW_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBZ_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Zero the Jacobian matrix.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBZ_GT'
!
!---  Zero problem vector array for flow and transport  ---
!
#ifdef lis
      DO N = 1,NUKFL(ID+1)
        BLU(N) = 0.D+0
      ENDDO
#endif
#ifdef petsc
      NUKX = NFCGC(ID+1)*ISVC
      IF( ID+1.EQ.NP ) NUKX = NUKX + N_CW
      DO N = 1,NUKX
        BLU(N) = 0.D+0
      ENDDO
#endif
!
!---  Zero Jacobian matrix array for flow and transport  ---
!
      DO N = 1,NNZ
        DLU(N) = 0.D+0
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBZ_GT group
!
      RETURN
      END


