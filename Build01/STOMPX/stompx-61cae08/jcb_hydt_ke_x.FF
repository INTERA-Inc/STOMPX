!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the mobile-CO2 equation with
!     aqueous, gas, and nonaqueous-liquid contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_HYDT_KE'
      ICNV = 3
!
!---  Zero residual array  ---
!
      DO N = 1,NFCGC(ID+1)
        DO M = 1,ISVC
          RSDL(M,N) = 0.D+0
        ENDDO
      ENDDO
!
!---  Load Jacobian matrix for the energy equation
!     (zero flux boundary)  ---
!
      CALL JCBT_HYDT_KE
!
!---  Load Jacobian matrix for the water equation
!     (zero flux boundary)  ---
!
      CALL JCBW_HYDT_KE
!
!---  Load Jacobian matrix for the mobile-CO2 equation
!     (zero flux boundary)  ---
!
      IF( ISLC(45).EQ.0 ) CALL JCBA_HYDT_KE
!
!---  Load Jacobian matrix for the mobile-CH4 equation
!     (zero flux boundary)  ---
!
      IF( ISLC(64).EQ.0 ) CALL JCBO_HYDT_KE
!
!---  Load Jacobian matrix for the mobile-N2 equation
!     (zero flux boundary)  ---
!
      IF( ISLC(65).EQ.0 ) CALL JCBN_HYDT_KE
!
!---  Load Jacobian matrix for the hydrate-CO2 equation
!     (zero flux boundary)  ---
!
      IF( ISLC(45).EQ.0 ) CALL JCBHA_HYDT_KE
!
!---  Load Jacobian matrix for the hydrate-CH4 equation
!     (zero flux boundary)  ---
!
      IF( ISLC(64).EQ.0 ) CALL JCBHO_HYDT_KE
!
!---  Load Jacobian matrix for the hydrate-N2 equation
!     (zero flux boundary)  ---
!
      IF( ISLC(65).EQ.0 ) CALL JCBHN_HYDT_KE
!
!---  Load Jacobian matrix for the salt equation
!     (zero flux boundary), isobrine option  ---
!
      IF( ISLC(32).EQ.0 ) CALL JCBS_HYDT_KE
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBP_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Configure the arrays for compressed sparse row matrix storage.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 April 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBP_HYDT_KE'
!
!---  Coupled-well model  ---
!
      IF( N_CW.GT.0  ) THEN
        CALL JCBP_CW_HYDT_KE
!
!---  No coupled well model  ---
!
      ELSE
        CALL JCBP_NCW_HYDT_KE
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBP_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBP_CW_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Configure the arrays for compressed sparse row matrix storage
!     for problems with coupled wells.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 April 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE JACOB
      USE GRID
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBP_CW_HYDT_KE'
!
!---  Determine the number of non-zero elements on each processor,
!     number of equations on each processor
!     
      NNZ = 0
      NROW = 0
      NROW_CW = 0
      NMDMN = NFLD*ISVC
      NCMX = 0
      NCMX_CW = 0
!
!     Loop over local nodes, skipping inactive and ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        NC = 0
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
!
!---      Node  ---
!
          NNZ = NNZ + ISVC
          NROW = NROW + 1
          NC = NC + 1
          NMDMN = MIN( NMDMN,NMD+L)
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
          NCMX = MAX( NCMX,NC )
        ENDDO
      ENDDO
!
!---  Flow and transport equation local offsets ---
!
      IEQ_OFFSET = NMDMN - 1
!
!---  Loop over coupled wells ---
!
      DO NCW = 1,N_CW
        JM_CW(NCW) = (NFLD-NXP)*ISVC + NCW
      ENDDO
!
!---  Loop over coupled wells, adding one non-zero element
!     for the coupled-well unknown, and adding one equation ---
!
      DO NCW = 1,N_CW
        NC = 0
!
!---    Loop over coupled-well well nodes ---
!
        DO NWN = ID_CW(3,NCW),ID_CW(4,NCW)
          N = IWN_CW(NWN)
          IF( N.EQ.0 ) CYCLE
!
!---      Change in water mass flux into field node with respect
!         to change in coupled-well pressure  ---
!
          NNZ = NNZ + 1
!
!---      Change in mobile-CH4 mass flow with respect
!         to change in coupled-well pressure  ---
!
          IF( ISLC(64).EQ.0 ) NNZ = NNZ + 1
!
!---      Change in mobile-CO2 mass flow with respect
!         to change in coupled-well pressure  ---
!
          IF( ISLC(45).EQ.0 ) NNZ = NNZ + 1
!
!---      Change in mobile N2 mass flow with respect
!         to change in coupled-well pressure  ---
!
          IF( ISLC(65).EQ.0 ) NNZ = NNZ + 1
!
!---      Change in salt mass flux into field node with respect
!         to change in coupled-well pressure  ---
!
          IF( ISLC(32).EQ.0 ) NNZ = NNZ + 1
        ENDDO
!
!---    Coupled well equations located after field node equations
!       on last processor  ---
!
        IF( ID.EQ.(NP-1) ) THEN
          NROW_CW = NROW_CW + 1
!
!---      Change in coupled-well mass balance with respect to
!         change in coupled-well pressure  ---
!
          NC = NC + 1
          NNZ = NNZ + 1
!
!---      Loop over field nodes with coupled-well nodes ---
!
          DO NWF = ID_CW(5,NCW),ID_CW(6,NCW)
!
!---        Change in coupled-well mass balance with respect to
!           change in field node primary variables  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              NNZ = NNZ + 1
            ENDDO
          ENDDO
        ENDIF
        NCMX_CW = MAX( NCMX_CW,NC )
      ENDDO
!
!---  Allocate memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), and equation to index pointer (KLU) ---
!
      ALLOCATE( NLU(1:NROW+NROW_CW+1),STAT=ISTAT )
      CHMSG = 'NLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( MLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'MLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( DLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'DLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      LJG = MAX(NROW,1)
      LJH = MAX(NCMX,1)
      ALLOCATE( KLU(1:LJG,1:LJH),STAT=ISTAT )
      CHMSG = 'KLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( KLU1_CW(1:LUK,1:LWN_CW,1:LN_CW),STAT=ISTAT )
      CHMSG = 'KLU1_CW'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( KLU2_CW(1:NCMX_CW,1:LN_CW),STAT=ISTAT )
      CHMSG = 'KLU2_CW'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( BLU(1:NUKFL(ID+1)),STAT=ISTAT )
      CHMSG = 'BLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!      PRINT *,'NROW = ',NROW,'NNZ = ',NNZ,'NCMX = ',NCMX,'LJG = ',LJG,
!     &  'LJH = ',LJH,'LUK = ',LUK,'LWN_CW = ',LWN_CW,'LN_CW',LN_CW,
!     &  'NCMX_CW = ',NCMX_CW,'NROW_CW = ',NROW_CW,'ID = ',ID
!
!---  Initialize memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), and equation to index pointer (KLU) ---
!
      DO L = 1,NROW+NROW_CW+1
        NLU(L) = 0
      ENDDO
      DO L = 1,NNZ
        MLU(L) = 0
        DLU(L) = 0.D+0
      ENDDO
      DO M = 1,LJH
        DO L = 1,LJG
          KLU(L,M) = 0
        ENDDO
      ENDDO
      DO M = 1,LN_CW
        DO L = 1,LWN_CW
          DO K = 1,LUK
            KLU1_CW(K,L,M) = 0
          ENDDO
        ENDDO
        DO L = 1,NCMX_CW
          KLU2_CW(L,M) = 0
        ENDDO
      ENDDO
!
!---  Assign CSR pointer (NLU), index (MLU), and equation to 
!     index pointer (KLU) ---
!
      MC = 0
      NC = 0
      NLU(1) = 0
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        MC = MC + 1
        NMD = (IXP(N)-1)*ISVC
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
          MA = 0
!
!---      Node  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            MLU(NC) = NMD + M - 1
            KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
          ENDDO
          MA = MA + ISVC
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NMDB = (IXP(NB)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDB + M - 1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NMDS = (IXP(NS)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDS + M - 1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NMDW = (IXP(NW)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDW + M - 1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NMDE = (IXP(NE)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDE + M - 1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NMDN = (IXP(NN)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDN + M - 1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NMDT = (IXP(NT)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDT + M - 1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      Node contains a coupled well node,
!         include coupled well equations in nodal equations  ---
!
          DO NCW = 1,N_CW
            DO NWF = ID_CW(5,NCW),ID_CW(6,NCW)
              IF( IWF_CW(NWF).EQ.N ) THEN
                NC = NC+1
                MLU(NC) = JM_CW(NCW)-1
                DO NWN = ID_CW(3,NCW),ID_CW(4,NCW)
                  IF( IWN_CW(NWN).EQ.N ) THEN
                    KLU1_CW(L,NWN,NCW) = NC
                  ENDIF
                ENDDO
              ENDIF
            ENDDO
          ENDDO
          NLU(NMD+L-IEQ_OFFSET+1) = NC
        ENDDO
      ENDDO
!
!---  Coupled well equations located after field node equations
!     on last processor  ---
!
      IF( ID.EQ.(NP-1) ) THEN
!
!---    Loop over coupled wells ---
!
        DO NCW = 1,N_CW
          NCCW = 0
!
!---      Change in coupled-well mass balance with respect to
!         change in coupled-well pressure  ---
!
          NC = NC + 1
          NCCW = NCCW + 1
          NMD = JM_CW(NCW)
          MLU(NC) = NMD-1
          KLU2_CW(NCCW,NCW) = NC
!
!---      Loop over field nodes with coupled-well nodes ---
!
          DO NWF = ID_CW(5,NCW),ID_CW(6,NCW)
!
!---        Change in coupled-well mass balance with respect to
!           change in field node primary variables  ---
!
            DO M = 1,ISVC
              NC = NC + 1
              NCCW = NCCW + 1
              MLU(NC) = (IXPG_CW(NWF)-1)*ISVC + M - 1
              KLU2_CW(NCCW,NCW) = NC
            ENDDO
          ENDDO
          NLU(NMD-IEQ_OFFSET+1) = NC
        ENDDO
      ENDIF
!
!---  Solute or reactive species transport solution  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!
!---    Determine the number of non-zero elements on each processor,
!       number of equations on each processor,
!       
        NNZC = 0
        NROWC = 0
        NMDMNC = NFLD
        NCMXC = 0
!
!       Loop over local nodes, skipping inactive and ghost cells  ---
!
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          NMD = IXP(N)
          NC = 0
!
!---      Node  ---
!
          NNZC = NNZC + 1
          NROWC = NROWC + 1
          NMDMNC = MIN( NMDMNC,NMD)
          NC = NC + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
          NCMXC = MAX( NCMXC,NC )
        ENDDO
!
!---    Transport equation local offsets ---
!
        IEQC_OFFSET = NMDMNC - 1
!
!---    Allocate memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        ALLOCATE( NLUC(1:NROWC+1),STAT=ISTAT )
        CHMSG = 'NLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        ALLOCATE( MLUC(1:NNZC),STAT=ISTAT )
        CHMSG = 'MLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        LJK = MAX(NROWC,1)
        LJL = MAX(NCMXC,1)
        ALLOCATE( KLUC(1:LJK,1:LJL),STAT=ISTAT )
        CHMSG = 'KLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---    Initialize memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        DO L = 1,NROWC+1
          NLUC(L) = 0
        ENDDO
        DO L = 1,NNZC
          MLUC(L) = 0
        ENDDO
        DO M = 1,LJL
          DO L = 1,LJK
            KLUC(L,M) = 0
          ENDDO
        ENDDO
!
!---    Assign CSR pointer (NLUC), index (MLUC), and equation to 
!       index pointer (KLUC) ---
!
        MC = 0
        NC = 0
        NLUC(1) = 0
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          MC = MC + 1
          NMD = IXP(N)
          MA = 1
!
!---      Node  ---
!
          NC = NC + 1
          MLUC(NC) = NMD-1
          KLUC(NMD-IEQC_OFFSET,MA) = NC
          MA = MA + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NB)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NS)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NW)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NE)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NN)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NT)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
          NLUC(NMD-IEQC_OFFSET+1) = NC
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBP_CW_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBP_NCW_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Configure the arrays for compressed sparse row matrix storage
!     for problems without coupled wells.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 April 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE JACOB
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBP_NCW_HYDT_KE'
!
!---  Determine the number of non-zero elements on each processor,
!     number of equations on each processor,
!     
      NNZ = 0
      NROW = 0
      NMDMN = NFLD*ISVC
      NCMX = 0
!
!     Loop over local nodes, skipping inactive and ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        NC = 0
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
!
!---      Node  ---
!
          NNZ = NNZ + ISVC
          NROW = NROW + 1
          NC = NC + 1
          NMDMN = MIN( NMDMN,NMD+L)
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZ = NNZ + ISVC
            NC = NC +1
          ENDIF
          NCMX = MAX( NCMX,NC )
        ENDDO
      ENDDO
!
!---  Flow and transport equation local offsets ---
!
      IEQ_OFFSET = NMDMN - 1
!
!---  Allocate memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), and equation to index pointer (KLU) ---
!
      ALLOCATE( NLU(1:NROW+1),STAT=ISTAT )
      CHMSG = 'NLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( MLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'MLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( DLU(1:NNZ),STAT=ISTAT )
      CHMSG = 'DLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( BLU(1:NUKFL(ID+1)),STAT=ISTAT )
      CHMSG = 'BLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      LJG = MAX(NROW,1)
      LJH = MAX(NCMX,1)
      ALLOCATE( KLU(1:LJG,1:LJH),STAT=ISTAT )
      CHMSG = 'KLU'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Initialize memory for the CSR pointer (NLU), index (MLU),
!     value (DLU), and equation to index pointer (KLU) ---
!
      DO L = 1,NROW+1
        NLU(L) = 0
      ENDDO
      DO L = 1,NNZ
        MLU(L) = 0
        DLU(L) = 0.D+0
      ENDDO
      DO M = 1,LJH
        DO L = 1,LJG
          KLU(L,M) = 0
        ENDDO
      ENDDO
!
!---  Assign CSR pointer (NLU), index (MLU), and equation to 
!     index pointer (KLU) ---
!
      MC = 0
      NC = 0
      NLU(1) = 0
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        MC = MC + 1
        NMD = (IXP(N)-1)*ISVC
!
!---    Loop over number of equations  ---
!
        DO L = 1,ISVC
          MA = 0
!
!---      Node  ---
!
          DO M = 1,ISVC
            NC = NC + 1
            MLU(NC) = NMD+M-1
            KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
          ENDDO
          MA = MA + ISVC
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NMDB = (IXP(NB)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDB+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NMDS = (IXP(NS)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDS+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NMDW = (IXP(NW)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDW+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NMDE = (IXP(NE)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDE+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NMDN = (IXP(NN)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDN+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NMDT = (IXP(NT)-1)*ISVC
            DO M = 1,ISVC
              NC = NC + 1
              MLU(NC) = NMDT+M-1
              KLU(NMD+L-IEQ_OFFSET,M+MA) = NC
            ENDDO
            MA = MA + ISVC
          ENDIF
          NLU(NMD+L-IEQ_OFFSET+1) = NC
        ENDDO
      ENDDO
!
!---  Solute or reactive species transport solution  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!
!---    Determine the number of non-zero elements on each processor,
!       number of equations on each processor,
!       
        NNZC = 0
        NROWC = 0
        NMDMNC = NFLD
        NCMXC = 0
!
!       Loop over local nodes, skipping inactive and ghost cells  ---
!
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          NMD = IXP(N)
          NC = 0
!
!---      Node  ---
!
          NNZC = NNZC + 1
          NROWC = NROWC + 1
          NMDMNC = MIN( NMDMNC,NMD)
          NC = NC + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NNZC = NNZC + 1
            NC = NC + 1
          ENDIF
          NCMXC = MAX( NCMXC,NC )
        ENDDO
!
!---    Transport equation local offsets ---
!
        IEQC_OFFSET = NMDMNC - 1
!
!---    Allocate memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        ALLOCATE( NLUC(1:NROWC+1),STAT=ISTAT )
        CHMSG = 'NLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        ALLOCATE( MLUC(1:NNZC),STAT=ISTAT )
        CHMSG = 'MLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        LJK = MAX(NROWC,1)
        LJL = MAX(NCMXC,1)
        ALLOCATE( KLUC(1:LJK,1:LJL),STAT=ISTAT )
        CHMSG = 'KLUC'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---    Initialize memory for the CSR pointer (NLUC), index (MLUC),
!       and equation to index pointer (KLUC) ---
!
        DO L = 1,NROWC+1
          NLUC(L) = 0
        ENDDO
        DO L = 1,NNZC
          MLUC(L) = 0
        ENDDO
        DO M = 1,LJL
          DO L = 1,LJK
            KLUC(L,M) = 0
          ENDDO
        ENDDO
!
!---    Assign CSR pointer (NLUC), index (MLUC), and equation to 
!       index pointer (KLUC) ---
!
        MC = 0
        NC = 0
        NLUC(1) = 0
        DO N = 1,NFCGC(ID+1)
!
!---      Skip for inactive nodes or ghost cells  ---
!
          IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
          MC = MC + 1
          NMD = IXP(N)
          MA = 1
!
!---      Node  ---
!
          NC = NC + 1
          MLUC(NC) = NMD-1
          KLUC(NMD-IEQC_OFFSET,MA) = NC
          MA = MA + 1
!
!---      Bottom ---
!
          NB = ICM(1,N)
          IF( NB.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NB)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      South ---
!
          NS = ICM(2,N)
          IF( NS.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NS)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      West ---
!
          NW = ICM(3,N)
          IF( NW.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NW)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      East ---
!
          NE = ICM(4,N)
          IF( NE.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NE)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      North ---
!
          NN = ICM(5,N)
          IF( NN.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NN)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
!
!---      Top ---
!
          NT = ICM(6,N)
          IF( NT.NE.0 ) THEN
            NC = NC + 1
            MLUC(NC) = IXP(NT)-1
            KLUC(NMD-IEQC_OFFSET,MA) = NC
            MA = MA + 1
          ENDIF
          NLUC(NMD-IEQC_OFFSET+1) = NC
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBP_NCW_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCB_SV
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Set values of the Jacobian matrix
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 8 March 2022
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCB_SV'
#ifdef lis
!
!---  Lis solver  ---
!
      CALL LIS_MATRIX_SET_CSR( NNZ,NLU,MLU,DLU,F_MAT,IERR )
      IF( IERR.NE.0 ) THEN
        I_ERR(1) = 0
        I_ERR(2) = 0
        I_ERR(3) = 0
        I_ERR(4) = ID
        M_ERR(1) = 'Coupled Flow and Transport Lis Matrix Set CSR'
        RETURN
      ENDIF
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCB_SV group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBL_HYDT_KE( RSS,RSP,RSA,N,MEQ )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 April 2022.
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 RSP(LUK),RSA(LUK,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBL_HYDT_KE'
#ifdef lis
!
!---  Lis solver  ---
!
!
!---  Node  ---
!
      NMD = (IXP(N)-1)*ISVC
      IROW =  NMD + MEQ
      MA = 0
      DO M = 1,ISVC
        MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
        DLU(MCOL) = DLU(MCOL) + (RSP(M)-RSS)/DNR(M,N)
      ENDDO
      BUFFER = -RSS
      CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &    F_RHS_VEC,IERR )
      RSDL(MEQ,N) = RSDL(MEQ,N) - RSS
      MA = MA + ISVC
!
!---  Bottom ---
!
      NB = ICM(1,N)
      IF( NB.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,1)-RSS)/DNR(M,NB)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  South ---
!
      NS = ICM(2,N)
      IF( NS.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,2)-RSS)/DNR(M,NS)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  West ---
!
      NW = ICM(3,N)
      IF( NW.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,3)-RSS)/DNR(M,NW)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  East ---
!
      NE = ICM(4,N)
      IF( NE.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,4)-RSS)/DNR(M,NE)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  North ---
!
      NN = ICM(5,N)
      IF( NN.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,5)-RSS)/DNR(M,NN)
        ENDDO
        MA = MA + ISVC
      ENDIF
!
!---  Top ---
!
      NT = ICM(6,N)
      IF( NT.NE.0 ) THEN
        DO M = 1,ISVC
          MCOL = KLU(IROW-IEQ_OFFSET,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,6)-RSS)/DNR(M,NT)
        ENDDO
        MA = MA + ISVC
      ENDIF
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBL_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBA_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the mobile-CO2 equation with
!     aqueous, gas, and nonaqueous-liquid contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STA(LUK+1),RAP(LUK),RAA(LUK,6),FA(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBA_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        USLOX = PORD(1,N)*XLA(1,N)*RHOL(1,N)*SL(1,N)
        USGOX = PORD(1,N)*XGA(1,N)*RHOG(1,N)*SG(1,N)
        USNOX = PORD(1,N)*XNA(1,N)*RHON(1,N)*SN(1,N)
        DO M = 1,ISVC+1
          MP = M + 1
          USLX = PORD(MP,N)*XLA(MP,N)*RHOL(MP,N)*SL(MP,N)
          USGX = PORD(MP,N)*XGA(MP,N)*RHOG(MP,N)*SG(MP,N)
          USNX = PORD(MP,N)*XNA(MP,N)*RHON(MP,N)*SN(MP,N)
          DUSLX = USLX-USLOX
          DUSGX = USGX-USGOX
          DUSNX = USNX-USNOX
          STA(M) = DUSLX + DUSGX + DUSNX
          STA(M) = STA(M)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FA(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---  Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FA(M,1) = -AFZ(1,N)*(WLA(M,1,N)+WGA(M,1,N)+WNA(M,1,N))
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FA(M,2) = -AFY(1,N)*(VLA(M,1,N)+VGA(M,1,N)+VNA(M,1,N))
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FA(M,3) = -AFX(1,N)*(ULA(M,1,N)+UGA(M,1,N)+UNA(M,1,N))
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FA(M,4) = AFX(2,N)*(ULA(MF,2,N)+UGA(MF,2,N)+UNA(MF,2,N))
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FA(M,5) = AFY(2,N)*(VLA(MF,2,N)+VGA(MF,2,N)+VNA(MF,2,N))
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FA(M,6) = AFZ(2,N)*(WLA(MF,2,N)+WGA(MF,2,N)+WNA(MF,2,N))
          ENDDO
        ENDIF
!
!---  Compute CO2 equation residuals  ---
!
        RAS = STA(1) - SRCA(2,N) + TMBP_A(2,N)
        DO MD = 1,6
          RAS = RAS + FA(1,MD)
        ENDDO
        DO M = 1,ISVC
          RAP(M) = STA(M+1) - SRCA(M+2,N) + TMBP_A(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RAP(M) = RAP(M) + FA(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RAA(M,MD) = RAS - FA(1,MD) + FA(MM,MD)
          ENDDO
        ENDDO
!
!---  Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( RAS,RAP,RAA,N,IEQA )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBA_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBHA_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the hydrate-CO2 equation with
!     hydrate contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE FDVP
      USE FDVH
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STA(LUK+1),RAP(LUK),RAA(LUK,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBHA_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        DO M = 1,ISVC+1
          MP = M + 1
          STA(M) = PORD(MP,N)*TMHA(MP,N)-PORD(1,N)*TMHA(1,N)
          STA(M) = STA(M)*DTI*VOL(N)
        ENDDO
!
!---  Compute CO2 equation residuals  ---
!
        RAS = STA(1) - TMBP_A(2,N)
        DO M = 1,ISVC
          RAP(M) = STA(M+1) - TMBP_A(M+2,N)
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RAA(M,MD) = RAS
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( RAS,RAP,RAA,N,IEQHA )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBHA_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBN_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the N2 equation with
!     aqueous, gas, and nonaqueous-liquid contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STN(LUK+1),RNP(LUK),RNA(LUK,6),FN(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBN_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        USLOX = PORD(1,N)*XLN(1,N)*RHOL(1,N)*SL(1,N)
        USGOX = PORD(1,N)*XGN(1,N)*RHOG(1,N)*SG(1,N)
        USNOX = PORD(1,N)*XNN(1,N)*RHON(1,N)*SN(1,N)
        DO M = 1,ISVC+1
          MP = M + 1
          USLX = PORD(MP,N)*XLN(MP,N)*RHOL(MP,N)*SL(MP,N)
          USGX = PORD(MP,N)*XGN(MP,N)*RHOG(MP,N)*SG(MP,N)
          USNX = PORD(MP,N)*XNN(MP,N)*RHON(MP,N)*SN(MP,N)
          DUSLX = (USLX-USLOX)
          DUSGX = (USGX-USGOX)
          DUSNX = (USNX-USNOX)
          STN(M) = DUSLX + DUSGX + DUSNX
          STN(M) = STN(M)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FN(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---  Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FN(M,1) = -AFZ(1,N)*(WLN(M,1,N)+WGN(M,1,N)+WNN(M,1,N))
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FN(M,2) = -AFY(1,N)*(VLN(M,1,N)+VGN(M,1,N)+VNN(M,1,N))
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FN(M,3) = -AFX(1,N)*(ULN(M,1,N)+UGN(M,1,N)+UNN(M,1,N))
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FN(M,4) = AFX(2,N)*(ULN(MF,2,N)+UGN(MF,2,N)+UNN(MF,2,N))
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FN(M,5) = AFY(2,N)*(VLN(MF,2,N)+VGN(MF,2,N)+VNN(MF,2,N))
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FN(M,6) = AFZ(2,N)*(WLN(MF,2,N)+WGN(MF,2,N)+WNN(MF,2,N))
          ENDDO
        ENDIF
!
!---  Compute N2 equation residuals  ---
!
        RNS = STN(1) - SRCN(2,N) + TMBP_N(2,N)
        DO MD = 1,6
          RNS = RNS + FN(1,MD)
        ENDDO
        DO M = 1,ISVC
          RNP(M) = STN(M+1) - SRCN(M+2,N) + TMBP_N(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RNP(M) = RNP(M) + FN(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RNA(M,MD) = RNS - FN(1,MD) + FN(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( RNS,RNP,RNA,N,IEQN )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBN_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBHN_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the hydrate-N2 equation with
!     hydrate contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE FDVP
      USE FDVH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STN(LUK+1),RNP(LUK),RNA(LUK,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBHN_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        DO M = 1,ISVC+1
          MP = M + 1
          STN(M) = PORD(MP,N)*TMHN(MP,N)-PORD(1,N)*TMHN(1,N)
          STN(M) = STN(M)*DTI*VOL(N)
        ENDDO
!
!---  Compute N2 equation residuals  ---
!
        RNS = STN(1) - TMBP_N(2,N)
        DO M = 1,ISVC
          RNP(M) = STN(M+1) - TMBP_N(M+2,N)
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RNA(M,MD) = RNS
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( RNS,RNP,RNA,N,IEQHN )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBHN_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBO_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the CH4 equation with
!     aqueous, gas, and nonaqueous-liquid contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STO(LUK+1),ROP(LUK),ROA(LUK,6),FO(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBO_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        USLOX = PORD(1,N)*XLO(1,N)*RHOL(1,N)*SL(1,N)
        USGOX = PORD(1,N)*XGO(1,N)*RHOG(1,N)*SG(1,N)
        USNOX = PORD(1,N)*XNO(1,N)*RHON(1,N)*SN(1,N)
        DO M = 1,ISVC+1
          MP = M + 1
          USLX = PORD(MP,N)*XLO(MP,N)*RHOL(MP,N)*SL(MP,N)
          USGX = PORD(MP,N)*XGO(MP,N)*RHOG(MP,N)*SG(MP,N)
          USNX = PORD(MP,N)*XNO(MP,N)*RHON(MP,N)*SN(MP,N)
          DUSLX = (USLX-USLOX)
          DUSGX = (USGX-USGOX)
          DUSNX = (USNX-USNOX)
          STO(M) = DUSLX + DUSGX + DUSNX
          STO(M) = STO(M)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FO(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---  Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FO(M,1) = -AFZ(1,N)*(WLO(M,1,N)+WGO(M,1,N)+WNO(M,1,N))
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FO(M,2) = -AFY(1,N)*(VLO(M,1,N)+VGO(M,1,N)+VNO(M,1,N))
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FO(M,3) = -AFX(1,N)*(ULO(M,1,N)+UGO(M,1,N)+UNO(M,1,N))
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FO(M,4) = AFX(2,N)*(ULO(MF,2,N)+UGO(MF,2,N)+UNO(MF,2,N))
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FO(M,5) = AFY(2,N)*(VLO(MF,2,N)+VGO(MF,2,N)+VNO(MF,2,N))
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FO(M,6) = AFZ(2,N)*(WLO(MF,2,N)+WGO(MF,2,N)+WNO(MF,2,N))
          ENDDO
        ENDIF
!
!---    Compute CH4 equation residuals  ---
!
        ROS = STO(1) - SRCO(2,N) + TMBP_O(2,N)
        DO MD = 1,6
          ROS = ROS + FO(1,MD)
        ENDDO
        DO M = 1,ISVC
          ROP(M) = STO(M+1) - SRCO(M+2,N) + TMBP_O(M+2,N)
          MM = 2*M
          DO MD = 1,6
            ROP(M) = ROP(M) + FO(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            ROA(M,MD) = ROS - FO(1,MD) + FO(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( ROS,ROP,ROA,N,IEQO )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBO_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBHO_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the hydrate-CH4 equation with
!     hydrate contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE GRID
      USE FDVP
      USE FDVH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STO(LUK+1),ROP(LUK),ROA(LUK,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBHO_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        DO M = 1,ISVC+1
          MP = M + 1
          STO(M) = PORD(MP,N)*TMHO(MP,N)-PORD(1,N)*TMHO(1,N)
          STO(M) = STO(M)*DTI*VOL(N)
        ENDDO
!
!---    Compute CO2 equation residuals  ---
!
        ROS = STO(1) - TMBP_O(2,N)
        DO M = 1,ISVC
          ROP(M) = STO(M+1) - TMBP_O(M+2,N)
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            ROA(M,MD) = ROS
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( ROS,ROP,ROA,N,IEQHO )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBHO_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBS_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the salt equation with
!     aqueous contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STS(LUK+1),RSP(LUK),RSA(LUK,6),FS(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBS_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        DO M = 1,ISVC+1
          MP = M + 1
          STS(M) = (TMS(MP,N)-TMS(1,N))*VOL(N)*DTI
        ENDDO
!
!---    Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FS(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---    Bottom surface flux component  ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FS(M,1) = -AFZ(1,N)*WS(M,1,N)
          ENDDO
        ENDIF
!
!---    South surface flux component ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FS(M,2) = -AFY(1,N)*VS(M,1,N)
          ENDDO
        ENDIF
!
!---    West surface flux component ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FS(M,3) = -AFX(1,N)*US(M,1,N)
          ENDDO
        ENDIF
!
!---    East surface flux component  ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FS(M,4) = AFX(2,N)*US(MF,2,N)
          ENDDO
        ENDIF
!
!---    North surface flux component  ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FS(M,5) = AFY(2,N)*VS(MF,2,N)
          ENDDO
        ENDIF
!
!---    Top surface flux component  ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FS(M,6) = AFZ(2,N)*WS(MF,2,N)
          ENDDO
        ENDIF
!
!---    Salt equation residuals  ---
!
        RSS = STS(1) - SRCS(2,N)
        DO MD = 1,6
          RSS = RSS + FS(1,MD)
        ENDDO
        DO M = 1,ISVC
          RSP(M) = STS(M+1) - SRCS(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RSP(M) = RSP(M) + FS(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RSA(M,MD) = RSS - FS(1,MD) + FS(MM,MD)
          ENDDO
        ENDDO
!
!---    Jacobian matrix loader  --
!
        CALL JCBL_HYDT_KE( RSS,RSP,RSA,N,IEQS )
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBS_HYDT_KE group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBT_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the energy equation with
!     aqueous, gas, liquid CO2, and hydrate contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STT(LUK+1),RTP(LUK),RTA(LUK,6),FT(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBT_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        USTOX = RHOS(N)*CPS(N)*(1.D+0-PORD(1,N))*T(1,N)
        USLOX = PORD(1,N)*SL(1,N)*RHOL(1,N)*UEL(1,N)
        USGOX = PORD(1,N)*SG(1,N)*RHOG(1,N)*UEG(1,N)
        USNOX = PORD(1,N)*SN(1,N)*RHON(1,N)*UEN(1,N)
        USHOX = PORD(1,N)*SH(1,N)*RHOH(1,N)*HH(1,N)
        USIOX = PORD(1,N)*SI(1,N)*RHOI(1,N)*HI(1,N)
        USSOX = PORD(1,N)*SS(1,N)*RHOSP(1,N)*HSP(1,N)
        DO M = 1,ISVC+1
          MP = M + 1
          USTX = RHOS(N)*CPS(N)*(1.D+0-PORD(MP,N))*T(MP,N)
          USLX = PORD(MP,N)*SL(MP,N)*RHOL(MP,N)*UEL(MP,N)
          USGX = PORD(MP,N)*SG(MP,N)*RHOG(MP,N)*UEG(MP,N)
          USNX = PORD(MP,N)*SN(MP,N)*RHON(MP,N)*UEN(MP,N)
          USHX = PORD(MP,N)*SH(MP,N)*RHOH(MP,N)*HH(MP,N)
          USIX = PORD(MP,N)*SI(MP,N)*RHOI(MP,N)*HI(MP,N)
          USSX = PORD(MP,N)*SS(MP,N)*RHOSP(MP,N)*HSP(MP,N)
          DUSTX = (USTX-USTOX)
          DUSLX = (USLX-USLOX)
          DUSGX = (USGX-USGOX)
          DUSNX = (USNX-USNOX)
          DUSHX = (USHX-USHOX)
          DUSIX = (USIX-USIOX)
          DUSSX = (USSX-USSOX)
          STT(M) = DUSTX + DUSLX + DUSGX + DUSNX + DUSHX + DUSIX + DUSSX
          STT(M) = STT(M)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FT(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---    Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FT(M,1) = -AFZ(1,N)*WQ(M,1,N)
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FT(M,2) = -AFY(1,N)*VQ(M,1,N)
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FT(M,3) = -AFX(1,N)*UQ(M,1,N)
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FT(M,4) = AFX(2,N)*UQ(MF,2,N)
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FT(M,5) = AFY(2,N)*VQ(MF,2,N)
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FT(M,6) = AFZ(2,N)*WQ(MF,2,N)
          ENDDO
        ENDIF
!
!---    Compute air equation residuals  ---
!
        RTS = STT(1) - SRCT(2,N)
        DO MD = 1,6
          RTS = RTS + FT(1,MD)
        ENDDO
        DO M = 1,ISVC
          RTP(M) = STT(M+1) - SRCT(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RTP(M) = RTP(M) + FT(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RTA(M,MD) = RTS - FT(1,MD) + FT(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( RTS,RTP,RTA,N,IEQT )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBT_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBW_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Load the Jacobian matrix for the water equation with
!     aqueous, gas, nonaqueous-liquid, ice, and hydrate contributions
!     (zero flux boundary conditions).
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 September 2010
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE GRID
      USE FLUX
      USE FDVP
      USE FDVH
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STWX(LUK+1),RWP(LUK),RWA(LUK,6),FW(LSFV,6)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBW_HYDT_KE'
!
!---  Loop over local nodes  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    First-order, forward-difference, time differential  ---
!
        USLOX = PORD(1,N)*XLW(1,N)*RHOL(1,N)*SL(1,N)
        USGOX = PORD(1,N)*XGW(1,N)*RHOG(1,N)*SG(1,N)
        USNOX = PORD(1,N)*XNW(1,N)*RHON(1,N)*SN(1,N)
        USHOX = PORD(1,N)*XHW(1,N)*RHOH(1,N)*SH(1,N)
        USIOX = PORD(1,N)*RHOI(1,N)*SI(1,N)
        DO M = 1,ISVC+1
          MP = M + 1
          USLX = PORD(MP,N)*XLW(MP,N)*RHOL(MP,N)*SL(MP,N)
          USGX = PORD(MP,N)*XGW(MP,N)*RHOG(MP,N)*SG(MP,N)
          USNX = PORD(MP,N)*XNW(MP,N)*RHON(MP,N)*SN(MP,N)
          USHX = PORD(MP,N)*XHW(MP,N)*RHOH(MP,N)*SH(MP,N)
          USIX = PORD(MP,N)*RHOI(MP,N)*SI(MP,N)
          DUSLX = (USLX-USLOX)
          DUSGX = (USGX-USGOX)
          DUSNX = (USNX-USNOX)
          DUSHX = (USHX-USHOX)
          DUSIX = (USIX-USIOX)
          STWX(M) = DUSLX + DUSGX + DUSNX + DUSHX + DUSIX
          STWX(M) = STWX(M)*DTI*VOL(N)
        ENDDO
!
!---  Initialize surface fluxes  ---
!
        DO MD = 1,6
          DO M = 1,ISVF
            FW(M,MD) = 0.D+0
          ENDDO
        ENDDO
!
!---    Compute surface fluxes  ---
!
!---    Bottom ---
!
        NB = ICM(1,N)
        IF( NB.NE.0 ) THEN
          DO M = 1,ISVF
            FW(M,1) = -AFZ(1,N)*(WLW(M,1,N)+WGW(M,1,N)+WNW(M,1,N))
          ENDDO
        ENDIF
!
!---    South ---
!
        NS = ICM(2,N)
        IF( NS.NE.0 ) THEN
          DO M = 1,ISVF
            FW(M,2) = -AFY(1,N)*(VLW(M,1,N)+VGW(M,1,N)+VNW(M,1,N))
          ENDDO
        ENDIF
!
!---    West ---
!
        NW = ICM(3,N)
        IF( NW.NE.0 ) THEN
          DO M = 1,ISVF
            FW(M,3) = -AFX(1,N)*(ULW(M,1,N)+UGW(M,1,N)+UNW(M,1,N))
          ENDDO
        ENDIF
!
!---    East ---
!
        NE = ICM(4,N)
        IF( NE.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FW(M,4) = AFX(2,N)*(ULW(MF,2,N)+UGW(MF,2,N)+UNW(MF,2,N))
          ENDDO
        ENDIF
!
!---    North ---
!
        NN = ICM(5,N)
        IF( NN.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FW(M,5) = AFY(2,N)*(VLW(MF,2,N)+VGW(MF,2,N)+VNW(MF,2,N))
          ENDDO
        ENDIF
!
!---    Top ---
!
        NT = ICM(6,N)
        IF( NT.NE.0 ) THEN
          DO M = 1,ISVF
            MF = MFLX(M)
            FW(M,6) = AFZ(2,N)*(WLW(MF,2,N)+WGW(MF,2,N)+WNW(MF,2,N))
          ENDDO
        ENDIF
!
!---    Compute water equation residuals  ---
!
        RWS = STWX(1) - SRCW(2,N)
        DO MD = 1,6
          RWS = RWS + FW(1,MD)
        ENDDO
        DO M = 1,ISVC
          RWP(M) = STWX(M+1) - SRCW(M+2,N)
          MM = 2*M
          DO MD = 1,6
            RWP(M) = RWP(M) + FW(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,6
            RWA(M,MD) = RWS - FW(1,MD) + FW(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_HYDT_KE( RWS,RWP,RWA,N,IEQW )
!
!---  Continue to Next Node  ---
!
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBW_HYDT_KE group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBZ_HYDT_KE
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Zero the Jacobian matrix.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 April 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE JACOB
      USE GRID
      USE COUP_WELL
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBZ_HYDT_KE'
!
!---  Zero problem vector array for flow and transport  ---
!
      DO N = 1,NUKFL(ID+1)
        BLU(N) = 0.D+0
      ENDDO
!
!---  Zero Jacobian matrix array for flow and transport  ---
!
      DO N = 1,NNZ
        DLU(N) = 0.D+0
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBZ_HYDT_KE group
!
      RETURN
      END

