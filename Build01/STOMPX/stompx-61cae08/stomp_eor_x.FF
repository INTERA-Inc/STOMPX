!----------------------Program-----------------------------------------!
!
      PROGRAM STOMP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------------------------------------------------------!
!
!     STOMPX: Subsurface Transport Over Multiple Phases Extensible
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     This engineering program numerically simulates the transport
!     of H2O, CO2, CH4, and petroleum components through multifluid
!     geologic media under non-isothermal conditions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE PROP
      USE OUTPU
      USE JACOB
      USE FLUX
      USE FILES
      USE FDVP
      USE GRID
      USE GLB_PAR
      USE GEO_MECH
      USE COUP_WELL
      USE BCV
#ifdef lis
!
!----------------------Lis Modules-----------------------------------!
!
      USE LIS_STOMP
#endif
#ifdef petsc
!
!----------------------PETSc Modules-----------------------------------!
!
      USE PETSCKSP
      USE PETSC_STOMP
#endif
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
#ifdef petsc
#include "petsc/finclude/petscmat.h"
#include "petsc/finclude/petscvec.h"
#include "petsc/finclude/petscksp.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
      LOGICAL HALT,PLOT,RESTART
#ifdef lis
      LIS_INTEGER :: IERR
#endif
#ifdef petsc
      PetscErrorCode :: IERR
#endif
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*132 CHMSGX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = 1
      SUB_LOG(1) = 'STOMPX-CO2'
!
!---  Initialize MPI  ---
!
      CALL MPI_INIT( IERR )
!
!---  Get the individual process ID  ---
!
      CALL MPI_COMM_RANK( MPI_COMM_WORLD,ID,IERR )
!
!---  Get the number of processes  ---
!
      CALL MPI_COMM_SIZE ( MPI_COMM_WORLD,NP,IERR )
#ifdef lis
!
!---  Initialize Lis ---
!
      CALL LIS_INITIALIZE( IERR )
!      PRINT *,'LIS_INITIALIZE: IERR = ',IERR,'ID = ',ID
#endif
#ifdef petsc
!
!---  Initialize PETSc ---
!
      CALL PetscInitialize(PETSC_NULL_CHARACTER,IERR )
#endif
!
!---  Print banner to screen ---
!
      IF( ID.EQ.0 ) THEN
      PRINT *,' Welcome to ...'
      PRINT *,' '
      PRINT *,'                     STOMPX-EOR'
      PRINT *,'        Subsurface Transport Over Multiple Phases'
      PRINT *,'         Enhanced Oil Recovery Operational Mode'
      PRINT *,'               OpenMPI Extensible Version'
      PRINT *,' '
      PRINT *,' This screen echo was produced by STOMPX, a numerical '
      PRINT *,' simulator developed by the Pacific Northwest National '
      PRINT *,' Laboratory. The simulator additionally produces'
      PRINT *,' binary formatted output files: output.bin, plot_xxx.bin'
      PRINT *,' and surface.bin, which can be converted to text format'
      PRINT *,' with postprocessing utilities.'
      PRINT *,' '
      PRINT *,'                     Disclaimer'
      PRINT *,' This material was prepared as an account of work '
      PRINT *,' sponsored by an agency of the United States Government.'
      PRINT *,' Neither the United States Government nor the United '
      PRINT *,' States Department of Energy, nor Battelle, nor any of '
      PRINT *,' their employees, makes any warranty, express or '
      PRINT *,' implied, or assumes any legal liability or '
      PRINT *,' responsibility for the accuracy, completeness, or '
      PRINT *,' usefulness of any information, apparatus, product, '
      PRINT *,' software or process disclosed, or represents that its '
      PRINT *,' use would not infringe privately owned rights.'
      PRINT *,' '
      PRINT *,'                     Acknowledgement'
      PRINT *,' This software and its documentation were produced with '
      PRINT *,' Government support under Contract Number '
      PRINT *,' DE-AC06-76RLO-1830 awarded by the United Department of '
      PRINT *,' of Energy. The Government retains a paid-up '
      PRINT *,' non-exclusive, irrevocable worldwide license to'
      PRINT *,' implied, or assumes any legal liability or '
      PRINT *,' reproduce, prepare derivative works, perform publicly '
      PRINT *,' and display publicly by or for the Government, '
      PRINT *,' including the right to distribute to other Government '
      PRINT *,' contractors.'
      PRINT *,' '
      PRINT *,' For support:  Tel: 509.372.6070'
      PRINT *,'               E-mail:  mark.white@pnnl.gov'
      PRINT *,' '
      PRINT *,'                     Notice'
      PRINT *,' This screen echo only reports basic time stepping '
      PRINT *,' information to track the simulation progress. Expanded'
      PRINT *,' simulation results are reported in binary formatted '
      PRINT *,' output files: output.bin, plot_xxx.bin and '
      PRINT *,' surface.bin.'
      PRINT *,' '
      ENDIF
!
!---  Read binary files from preprocessor and allocate
!     memory for global arrays  ---
!
      CALL READ_BIN_EOR
      ISKIP = 1
      IF( ISKIP.EQ.0 ) THEN
!
!---  Initialize global arrays  ---
!
      CALL INTLZ_EOR
!      PRINT *,'Post INTLZ_EOR: ID = ',ID
!
!---  For geomechanics set k iterate value of pore pressure  ---
!
      IF( ISLC(50).NE.0 ) THEN
        INDX = 2
        CALL PRESS_GM( INDX )
!        PRINT *,'Post PRESS_GM: ID = ',ID
      ENDIF
!
!---  Configure the arrays for compressed sparse row matrix storage  ---
!
      CALL JCBP_EOR
!      PRINT *,'Post JCBP_EOR: ID = ',ID
!
!---  For geomechanics simulations compute Jacobian matrix pointers  --
!
      IF( ISLC(50).NE.0 ) CALL JCBP_GM
!      PRINT *,'Post JCBP_GM: ID = ',ID
!
!---  Compute primary variable increments  ---
!
      CALL INCRM_EOR
!
!---  Hydrologic and thermodynamic properties  ---
!
      CALL PROP_EOR
      CALL BCP_EOR
!
!---  Compute initial solute concentrations  ---
!
      CALL CISC_EOR
!
!---  Reactive transport  ---
!
      IF( ISLC(40).EQ.1 ) THEN
!
!---    Convert initial reactive species concentrations to
!       node volume basis, mol/m^3  ---
!
        CALL FLHSP
!
!---    Temporarily store time stepping  ---
!
        DT_RST = DT
        DTI_RST = DTI
        TM_RST = TM
!
!---    Loop over number of conservation component species  ---
!
        DO NEQ = 1,NEQC
          NSL = NEQ + NSOLU
!
!---      Mobile conservation component fractions   ---
!
          CALL MOBCF( NEQ )
!
!---      Add immobile conservation component fractions   ---
!
          CALL IMOBCF( NEQ )
        ENDDO
!
!---    Loop over number of kinetic component species  ---
!
        DO NEQ = 1,NEQK
          NSL = NEQ + NEQC + NSOLU
!
!---      Mobile kinetic component fractions   ---
!
          CALL MOBKF( NEQ )
!
!---      Add immobile kinetic component fractions   ---
!
          CALL IMOBKF( NEQ )
        ENDDO
!
!---    Equilibrium-conservation-kinetic reaction chemistry   ---
!
        CALL ECKECHEM
!
!---    Reconstitute mineral species concentrations for initial
!       output  ---
!
        CALL RMNSP
!
!---    Reset time stepping  ---
!
        DT = DT_RST
        DTI = DTI_RST
        TM = TM_RST
      ENDIF
!
!---  Communicate the state of field nodes with coupled well nodes
!     to all processors, increment coupled-well primary variables  ---
!
      IF( L_CW.EQ.1 ) THEN
!        CALL COMST_COUP_WELL
        CALL INCRM_COUP_WELL
      ENDIF
!
!---  Compute initial fluxes on non-boundary and boundary surfaces  ---
!
      ISVF = 1
      CALL FLUX_EOR
      CALL BCF_EOR
      ISVF = 2*ISVC + 1
!
!---  Surface flux integrator for zero time step  ---
!
      DTX = DT
      DT = 0.D+0
      CALL SFIN_EOR
      DT = DTX
#ifdef lis
!
!---  Create Lis matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
!      PRINT *,'NUKFL(ID+1) = ',NUKFL(ID+1),' ID = ',ID
!      PRINT *,'NUKFO(ID+1) = ',NUKFO(ID+1),' ID = ',ID
!      PRINT *,'NUKFG = ',NUKFG,' ID = ',ID
      INDX = 0
      CALL STOMP_LIS_CREATE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &  NUKFL(ID+1),INDX )
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!        PRINT *,'NUKTL(ID+1) = ',NUKTL(ID+1),' ID = ',ID
!        PRINT *,'NUKTO(ID+1) = ',NUKTO(ID+1),' ID = ',ID
!        PRINT *,'NUKTG = ',NUKTG,' ID = ',ID
        INDX = 1
        CALL STOMP_LIS_CREATE( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC,
     &    NUKTL(ID+1),INDX )
      ENDIF
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
!        PRINT *,'NUKGL(ID+1) = ',NUKGL(ID+1),' ID = ',ID
!        PRINT *,'NUKGO(ID+1) = ',NUKGO(ID+1),' ID = ',ID
!        PRINT *,'NUKGG = ',NUKGG,' ID = ',ID
        INDX = 2
        CALL STOMP_LIS_CREATE( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC,
     &    NUKGL(ID+1),INDX )
      ENDIF
#endif
#ifdef petsc
!
!---  Create PETSc matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
!      PRINT *,'NUKFL(ID+1) = ',NUKFL(ID+1),' ID = ',ID
!      PRINT *,'NUKFO(ID+1) = ',NUKFO(ID+1),' ID = ',ID
!      PRINT *,'NUKFG = ',NUKFG,' ID = ',ID
      INDX = 0
      CALL STOMP_PETSC_CREATE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &  F_SOL_VEC_S,NUKFL(ID+1),NUKFG,F_SCATTER,INDX )
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!        PRINT *,'NUKTL(ID+1) = ',NUKTL(ID+1),' ID = ',ID
!        PRINT *,'NUKTO(ID+1) = ',NUKTO(ID+1),' ID = ',ID
!        PRINT *,'NUKTG = ',NUKTG,' ID = ',ID
        INDX = 1
        CALL STOMP_PETSC_CREATE( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC,
     &    T_SOL_VEC_S,NUKTL(ID+1),NUKTG,T_SCATTER,INDX )
      ENDIF
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
!        PRINT *,'NUKGL(ID+1) = ',NUKGL(ID+1),' ID = ',ID
!        PRINT *,'NUKGO(ID+1) = ',NUKGO(ID+1),' ID = ',ID
!        PRINT *,'NUKGG = ',NUKGG,' ID = ',ID
        INDX = 2
        CALL STOMP_PETSC_CREATE( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC,
     &    G_SOL_VEC_S,NUKGL(ID+1),NUKGG,G_SCATTER,INDX )
      ENDIF
#endif
!
!---  Initialize geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
!
!---    Reference state porothermoelastic geomechanics; first call
!       to STATIC_GM eliminates reference boundary conditions  ---
!
        IREF_GM = 1
        CALL STATIC_GM
!
!---    Load reference displacements at finite elment nodes  ---
!
        CALL LDDISP_GM
!
!---    Reference volumetric stresses at finite element centroids  ---
!
        IF( ISLC(50).LT.0 ) THEN
          INDX = 0
          CALL VOLSS_GM( INDX )
!
!---      Remove restart check for geomechanics options  ---
!
          ISLC(50) = ABS(ISLC(50))
        ENDIF
!
!---    Static porothermoelastic geomechanics  ---
!
        IREF_GM = 0
        CALL STATIC_GM
!
!---    Set k iterate value of pore pressure and volumetric stress
!
        INDX = 2
        CALL PRESS_GM( INDX )
        CALL VOLSS_GM( INDX )
      ENDIF
!      ISKIP = 1
!      IF( ISKIP.EQ.0 ) THEN
!
!---  Check for fatal execution errors and stop simulation
!     if detected  ---
!
      CALL CHK_ERROR
!
!---  New Time Step ---
!
      IF( ID.EQ.0 ) ICNO = 10
      TSLOOP: DO
!
!---    Reference node(s) output  ---
!
        IF( MOD( (NSTEP-NRST),IFQO ).EQ.0 ) THEN
          CALL REFNOD_EOR
          IF( ID.EQ.0 ) THEN
            IF( ICNO.EQ.10 ) THEN
              ICNO = 0
              NCH = INDEX(UNTM(1:),'  ') - 1
              IF( ISLC(50).NE.0 ) THEN
                PRINT *,'       Step         Itr  MLp           Time' // 
     &            ' [',UNTM(1:NCH),']             Timestep [',
     &            UNTM(1:NCH),']'
              ELSE
                PRINT *,'       Step         Itr           Time' // 
     &            ' [',UNTM(1:NCH),']             Timestep [',
     &            UNTM(1:NCH),']'
              ENDIF
            ENDIF
            ICNO = ICNO + 1
            IF( ISLC(50).NE.0 ) THEN
              PRINT *,NSTEP,K_GM(2),K_GM(1),TM*CNVTM,DT*CNVTM
            ELSE
              PRINT *,NSTEP,NITER,TM*CNVTM,DT*CNVTM
            ENDIF
          ENDIF
        ENDIF
!
!---    Normalize mineral species concentrations after initial
!       output for normal simulations  ---
!
        IF( ISLC(40).EQ.1 .AND. (NSTEP-NRST).EQ.0 ) CALL NMNSP
!
!---    Update porosity and permeability in response to geomechanical
!       stress  ---
!
        IF( ISLC(50).NE.0 .AND. NSTEP.EQ.0 ) THEN
          CALL PORSTY_GM
          CALL PERMRF_GM
        ENDIF
!
!---    Load old time step arrays  ---
!
        CALL LDO_EOR
!
!---    Load old time step arrays for the coupled-well model  ---
!
        IF( L_CW.EQ.1 ) THEN
          CALL LDO_COUP_WELL
        ENDIF
!
!---    Load old time step arrays for the volumetric stress
!       and pore pressure  ---
!
        IF( ISLC(50).NE.0 ) THEN
          INDX = 1
          CALL LD_GM( INDX )
        ENDIF
!
!---    Stop simulation if simulation time exceeds limit  ---
!
        IF( ABS(TMMX-TM).LE.1.D-6 ) THEN
          IF( ID.EQ.0 ) PRINT *,'Simulation Stopped:  ' //
     &      'Simulation Time Limit'
          EXIT TSLOOP
        ENDIF
!
!---    Restart and plot file outputs  ---
!
        IF( ABS(TMPR-TM).LE.1.D-6 ) THEN
          CALL WRPLOT_EOR
          IF( ISLC(18).LT.1 ) CALL WRRST_EOR
        ENDIF
!
!---    Compute the next time step and increment time step counter  ---
!
        DTSO = DT
        CALL TMSTEP
        IF( NSTEP.EQ.0 ) DTSO = DT
        NSTEP = NSTEP + 1
        IF( NSTEP-NRST.GT.MXSTEP ) THEN
          IF( ID.EQ.0 ) PRINT *,'Simulation Stopped:  Time Step Limit'
          NSTEP = NSTEP - 1
          EXIT TSLOOP
        ENDIF
!
!---    Reset the time step reduction counter  ---
!
        NTSR = 0
!
!---    Top of sequential flow and transport and geomechanics  ---
!
        K_GM(1) = 0
        K_GM(2) = 0
        GMLOOP: DO
          K_GM(1) = K_GM(1) + 1
!
!---      New Newton-Raphson iteration ---
!
          NITER = 0
          NRLOOP: DO
            IF( ICNV.EQ.1 ) NITER = 0
            NITER = NITER + 1
!
!---        Compute boundary saturation, relative permeability, and
!           thermodynamic properties  ---
!
            CALL BCP_EOR
!
!---        Compute coupled-well fluxes  ---
!
            IF( L_CW.EQ.1 ) THEN
              DO NCW = 1,N_CW
!
!---            Injection well  ---
!
                IF( IT_CW(NCW).GT.0 ) THEN
                  CALL INJ_COUP_WELL( NCW )
!
!---            Production well  ---
!
                ELSE
                  CALL PROD_COUP_WELL( NCW )
                ENDIF
              ENDDO
            ENDIF
!
!---        Compute source contributions  ---
!
            CALL SORC_EOR
!
!---        Compute fluxes on non-boundary and boundary surfaces  ---
!
            CALL FLUX_EOR
            CALL BCF_EOR
!
!---        Zero Jacobian matrix  ---
!
            CALL JCBZ_EOR
!            PRINT *,'Post JCBZ_EOR:ID = ',ID
!
!---        Load Jacobian matrix for the water, CO2
!           and salt mass equations (zero flux boundary)  ---
!
            CALL JCB_EOR
!            PRINT *,'Post JCB_EOR:ID = ',ID
!
!---        Modify the Jacobian matrix for boundary conditions  ---
!
            CALL BCJ_EOR
!            PRINT *,'Post BCJ_EOR:ID = ',ID
!
!---        Modify Jacobian matrix for coupled-well equations  ---
!
            IF( L_CW.EQ.1 ) THEN
              CALL JCB_COUP_WELL
            ENDIF
!
!---        Set values of the Jacobian matrix  ---
!
            CALL JCB_SV
!            PRINT *,'Post JCB_SV:ID = ',ID
!
!---        Check for fatal execution errors and stop simulation
!           if detected  ---
!
            CALL CHK_ERROR
!
!---        Solve the linear system A x = b for coupled flow  ---
!
#ifdef   lis
            INDX = 0
            CALL STOMP_LIS_SOLVE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &        NUKFO(ID+1),NUKFL(ID+1),INDX )
            IF( ICNV.EQ.4 ) EXIT TSLOOP
#endif  
#ifdef petsc
            INDX = 0
            CALL STOMP_PETSC_SOLVE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &        F_SOL_VEC_S,F_SCATTER,INDX )
            IF( ICNV.EQ.4 ) EXIT TSLOOP
#endif
!
!---        Check for fatal execution errors and stop simulation
!           if detected  ---
!
            CALL CHK_ERROR
!
!---        Update primary variables for coupled wells  ---
!
            IF( L_CW.EQ.1 ) THEN
              CALL UPDT_COUP_WELL
            ENDIF
!
!---        Update primary variables on field nodes w/o ghost cells  ---
!
            CALL UPDT_EOR
#ifdef lis
!
!---        Update primary variables on ghost cells  ---
!
            CALL UPDT_GC_EOR
#endif
!
!---        Convergence check for couped wells  ---
!
            IF( L_CW.EQ.1 ) THEN
              CALL RSDL_COUP_WELL
            ENDIF
!
!---        Compute convergence from maximum relative residuals  ---
!
            CALL RSDL_EOR
!
!---        Compute primary variable increments, saturation,
!           relative permeability, porosity, tortuosity,
!           thermodynamic properties for interior nodes,
!           except immediately after a new time step  ---
!
            CALL INCRM_EOR
            CALL PROP_EOR
!
!---        For geomechanics simulations alter permeability with
!           porosity  --
!
            IF( ISLC(50).NE.0 ) CALL PERMRF_GM
!
!---        Increment coupled-well primary variables  ---
!
            IF( L_CW.EQ.1 ) THEN
              CALL INCRM_COUP_WELL
            ENDIF
!
!---        Convergence check  ---
!
!           ICNV = 1 - cut time step and restart Newton-Raphson loop
!           ICNV = 2 - next Newton-Raphson loop
!           ICNV = 3 - converged solution next time step
!           ICNV = 4 - total convergence failure stop simulation
!
            IF( ID.EQ.0 ) THEN
!              PRINT *,'NSTEP = ',NSTEP,' NITER = ',NITER
!              DO M = 1,ISVC
!                PRINT *,'RSD(',M,') = ',RSD(M),
!     &            'NSD(',M,') = ',NSD(M),' ICNV = ',ICNV
!              ENDDO
!              PRINT *,'RSD_CW = ',RSD_CW,' ID_CW(8,1) = ',ID_CW(8,1),
!       &        'P_CW(2,1) = ',P_CW(2,1),'P_CW(3,1) = ',P_CW(3,1)
            ENDIF
!            PRINT *,'ND(1) = ',ND(1),'PORD(2,1) = ',PORD(2,1),'ID = ',ID
            IF( ICNV.EQ.3 ) EXIT NRLOOP
            IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---      Proceed to new Newton-Raphson iteration  ---
!
          ENDDO NRLOOP
!
!---      Solve geomechanics  ---
!
          IF( ISLC(50).NE.0 ) THEN
!
!---        Set k+1 iterate value of pore pressure  ---
!
            INDX = 3
            CALL PRESS_GM( INDX )
!
!---        Static porothermoelastic geomechanics  ---
!
            CALL STATIC_GM
!
!---        Convergence check for sequential coupled flow and transport
!           and geomechanics  ---
!
            CALL RSDL_GM
            IF( RSD_GM.GT.RSDM_GM(IEPD) ) THEN
!
!---          Load k level arrays for the volumetric stress
!             and pore pressure  ---
!
              INDX = 2
              CALL LD_GM( INDX )
!
!---          Update porosity and permeability for geomechical stress  ---
!
              CALL PORSTY_GM
              CALL PERMRF_GM
              CYCLE GMLOOP
            ENDIF
!
!---        Update porosity and permeability for geomechical stress  ---
!
            CALL PORSTY_GM
            CALL PERMRF_GM
            EXIT GMLOOP
          ELSE
            EXIT GMLOOP
          ENDIF
        ENDDO GMLOOP
!
!---    Integrate coupled-equation sources ---
!
        CALL SORIC_EOR
!
!---    Compute current fluxes for transport solutions or flux
!       integrations  ---
!
        ISVF = 1
        CALL FLUX_EOR
        CALL BCF_EOR
        ISVF = 2*ISVC + 1
!
!---    Compute Local Courant Numbers  ---
!
        IF( ICRNT.EQ.1 ) CALL CRNTNB
        ISVF = 2*ISVC+1
!
!---    Beginning of transport equation solution  ---
!
        IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!
!---      Loop over number of solutes  ---
!
          DO NSL = 1,NSOLU
!
!---        Courant number limiting  ---
!
            N_CRN(NSL) = 1
            IF( ISLC(17).NE.0 ) CALL CRN_LIM( NSL )
!            PRINT *,'N_CRN(',NSL,') = ',N_CRN(NSL),' ID = ',ID
!
!---        Sub-time step loop  ---
!
            DO NC = 1,N_CRN(NSL)
              IF( ISLC(17).NE.0 ) TM = MIN( TM+DT,TM_CRN )
!
!---          Compute solute mole fractions ---
!
              CALL SPRP_EOR( NSL )
!
!---          Solute transport ---
!
              CALL TPORT_EOR( NSL )
              IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---        Bottom of sub-time step loop  ---
!
            ENDDO
!
!---        Courant number limiting, reset time stepping  ---
!
            IF( ISLC(17).NE.0 ) THEN
              DT = DT_CRN
              DTI = DTI_CRN
              TM = TM_CRN
            ENDIF
          ENDDO
!
!---      Decay matrix, fracture, and borehole solutes via Bateman
!         chain decay solution  ---
!
          CALL CHAIN_DECAY
!
!---      Reactive transport  ---
!
          IF( ISLC(40).EQ.1 ) THEN
            N_CRN(NSOLU+1) = 1
            IF( ISLC(17).NE.0 ) CALL CRN_LIM( NSOLU+1 )
!
!---        Courant-limiting sub-time step loop  ---
!
            DO NCR = 1,N_CRN(NSOLU+1)
              IF( ISLC(17).NE.0 ) TM = MIN( TM+DT,TM_CRN )
!
!---          Temporarily store time stepping  ---
!
              DT_RST = DT
              DTI_RST = DTI
              TM_RST = TM
              TM = TM - DT
              N_RST = 1
!
!---          Top of ECKEChem time-step reduction loop  ---
!
              TRLOOP: DO
!
!---            Zero linked sources  ---
!
                CALL ZLKSRC
!
!---            Sub-time step reduction limit exceeded  ---
!
                IF( N_RST.GT.16 ) THEN
                  IF( ID.EQ.0 ) PRINT *, '          ---  ECKEChem ' //
     &              'Sub-Time Step Reduction Limit Exceeded  ---'
                  DT = DT_RST
                  DTI = DTI_RST
                  TM = TM_RST
                  NSTEP = NSTEP-1
                  TM = TM-DT
                  DT = DTO
                  CALL BCK_STP
                  EXIT TSLOOP
                ENDIF
!
!---            Sub-time step loop  ---
!
                DO NC = 1,N_RST
                  TM = TM + DT
!
!---              Loop over number of conservation component species ---
!
                  DO NEQ = 1,NEQC
                    NSL = NEQ + NSOLU
!
!---                Skip transport for linked aqueous CO2   ---
!
                    IF( ISPLK(6).EQ.NSL ) THEN
                      CALL IMOBCF( NEQ )
!
!---                Transport for conservation component species   ---
!
                    ELSE
!
!---                  Mobile conservation component fractions   ---
!
                      CALL MOBCF( NEQ )
!
!---                  Solute transport ---
!
                      CALL TPORT_EOR( NSL )
                      IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---                  Add immobile conservation component fractions  ---
!
                      CALL IMOBCF( NEQ )
                    ENDIF
!
!---              End of conservation component species transport  ---
!
                  ENDDO
!
!---              Loop over number of kinetic component species  ---
!
                  DO NEQ = 1,NEQK
                    NSL = NEQ + NEQC + NSOLU
!
!---                Skip transport for linked aqueous CO2   ---
!
                    IF( ISPLK(6).EQ.NSL ) THEN
                      CALL IMOBKF( NEQ )
!
!---                Transport for mobile kinetic component species   ---
!
                    ELSE
!
!---                  Mobile kinetic component fractions   ---
!
                      CALL MOBKF( NEQ )
!
!---                  Solute transport ---
!
                      CALL TPORT_EOR( NSL )
                      IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---                  Add immobile kinetic component fractions   ---
!
                      CALL IMOBKF( NEQ )
                    ENDIF
!
!---              End of kinetic component species transport  ---
!
                  ENDDO
!
!---              Equilibrium-conservation-kinetic reaction
!                 chemistry  ---
!
                  CALL ECKECHEM
                  IF( ECKE_ER ) CYCLE TRLOOP
!
!---              Load old sub-time-step reactive species concentrations
!                 and component species concentrations  ---
!
                  IF( ISLC(17).NE.0 ) CALL UPDTCHEM
!
!---            Bottom of sub-time step loop  ---
!
                ENDDO
!
!---             Exit time-step reduction loop  ---
!
                 EXIT TRLOOP
!
!---          Bottom of ECKEChem time-step reduction loop  ---
!
              ENDDO TRLOOP
!
!---          Reset time stepping  ---
!
              IF( N_RST.GT.1 ) THEN
                DT = DT_RST
                DTI = DTI_RST
                TM = TM_RST
              ENDIF
            ENDDO
!
!---        Courant number limiting, reset time stepping  ---
!
            IF( ISLC(17).NE.0 ) THEN
              DT = DT_CRN
              DTI = DTI_CRN
              TM = TM_CRN
            ENDIF
          ENDIF
        ENDIF
!
!---    Surface flux integrator  ---
!
        CALL SFIN_EOR
!
!---  Proceed to new time step  ---
!
      ENDDO TSLOOP
#ifdef lis
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
      CALL STOMP_LIS_DESTROY( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC )
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
        CALL STOMP_LIS_DESTROY( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC )
      ENDIF
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
        CALL STOMP_LIS_DESTROY( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC )
      ENDIF
!
!---  Finalize Lis execution  ---
!
      CALL LIS_FINALIZE(IERR)
#endif
#ifdef petsc
!
!---  Destroy solution vector, problem vector, matrix, solver, and
!     solution-vector scatter scheme for the PETSc solver for coupled
!     flow and heat transport  ---
!
      INDX = 0
      CALL STOMP_PETSC_DESTROY( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &  F_SOL_VEC_S,F_SCATTER,INDX )
!
!---  Destroy solution vector, problem vector, matrix, solver, and
!     solution-vector scatter scheme for the PETSc solver for 
!     solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
        INDX = 1
        CALL STOMP_PETSC_DESTROY( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC,
     &   T_SOL_VEC_S,T_SCATTER,INDX )
      ENDIF
!
!---  Destroy solution vector, problem vector, matrix, solver, and
!     solution-vector scatter scheme for the PETSc solver for 
!     geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
        INDX = 2
        CALL STOMP_PETSC_DESTROY( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC,
     &   G_SOL_VEC_S,G_SCATTER,INDX )
      ENDIF
!
!---  Finalize PETSc execution  ---
!
      CALL PetscFinalize( IERR )
#endif
!
!---  Write plot_xxx.bin file  ---
!
      CALL WRPLOT_EOR
!
!---  Write restart_xxx.bin file  ---
!
      CALL WRRST_EOR
!
!---  Close output.bin file, putting a closing -9 at the end
!     of the file  ---
!
      NVAR = 1
      IVARX = -9
      OFFSET = IOFFSET_REF
      IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &   MPI_INTEGER,STATUS,IERR)
      CALL MPI_FILE_CLOSE( IWR,IERR )
!
!---  Close surface.bin file(s), putting a closing -9.D+20 at the end
!     of the file  ---
!
      NSTART = 1
      IF( ISFGP(1).EQ.0 ) NSTART = 2
      DO NSG = NSTART,NSFGP
        NVAR = 1
        VARX = -9.D+20
        OFFSET = IOFFSET_SF(NSG)
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( ISF(NSG),OFFSET,VARX,
     &     NVAR,MPI_REAL8,STATUS,IERR)
        CALL MPI_FILE_CLOSE( ISF(NSG),IERR )
      ENDDO
      ENDIF
      CALL MPI_FINALIZE(IERR)
!
!---  End of STOMP program  ---
!
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCF_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute boundary surface fluxes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 BCX(LBCV)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCF_EOR'
      DO NB = 1,NBC(ID+1)
        N = IBCN(NB)
        IF( IBCD(NB).EQ.-3 ) THEN
          DO M = 1,ISVF
            WL(M,1,N) = 0.D+0
            WG(M,1,N) = 0.D+0
            WN(M,1,N) = 0.D+0
            WLA(M,1,N) = 0.D+0
            WLW(M,1,N) = 0.D+0
            WGW(M,1,N) = 0.D+0
            WDLA(M,1,N) = 0.D+0
            WDLW(M,1,N) = 0.D+0
            WDGW(M,1,N) = 0.D+0
            WQ(M,1,N) = 0.D+0
            WS(M,1,N) = 0.D+0
            WDS(M,1,N) = 0.D+0
            DO IGC = 1,NGC+2
              WGC(IGC,M,1,N) = 0.D+0
              WNC(IGC,M,1,N) = 0.D+0
              WDGC(IGC,M,1,N) = 0.D+0
              WDNC(IGC,M,1,N) = 0.D+0
            ENDDO
          ENDDO
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
          DO M = 1,ISVF
            VL(M,1,N) = 0.D+0
            VG(M,1,N) = 0.D+0
            VN(M,1,N) = 0.D+0
            VLA(M,1,N) = 0.D+0
            VLW(M,1,N) = 0.D+0
            VGW(M,1,N) = 0.D+0
            VDLA(M,1,N) = 0.D+0
            VDLW(M,1,N) = 0.D+0
            VDGW(M,1,N) = 0.D+0
            VQ(M,1,N) = 0.D+0
            VS(M,1,N) = 0.D+0
            VDS(M,1,N) = 0.D+0
            DO IGC = 1,NGC+2
              VGC(IGC,M,1,N) = 0.D+0
              VNC(IGC,M,1,N) = 0.D+0
              VDGC(IGC,M,1,N) = 0.D+0
              VDNC(IGC,M,1,N) = 0.D+0
            ENDDO
          ENDDO
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
          DO M = 1,ISVF
            UL(M,1,N) = 0.D+0
            UG(M,1,N) = 0.D+0
            UN(M,1,N) = 0.D+0
            ULA(M,1,N) = 0.D+0
            ULW(M,1,N) = 0.D+0
            UGW(M,1,N) = 0.D+0
            UDLA(M,1,N) = 0.D+0
            UDLW(M,1,N) = 0.D+0
            UDGW(M,1,N) = 0.D+0
            UQ(M,1,N) = 0.D+0
            US(M,1,N) = 0.D+0
            UDS(M,1,N) = 0.D+0
            DO IGC = 1,NGC+2
              UGC(IGC,M,1,N) = 0.D+0
              UNC(IGC,M,1,N) = 0.D+0
              UDGC(IGC,M,1,N) = 0.D+0
              UDNC(IGC,M,1,N) = 0.D+0
            ENDDO
          ENDDO
        ELSEIF( IBCD(NB).EQ.1 ) THEN
          DO M = 1,ISVF
            UL(M,2,N) = 0.D+0
            UG(M,2,N) = 0.D+0
            UN(M,2,N) = 0.D+0
            ULA(M,2,N) = 0.D+0
            ULW(M,2,N) = 0.D+0
            UGW(M,2,N) = 0.D+0
            UDLA(M,2,N) = 0.D+0
            UDLW(M,2,N) = 0.D+0
            UDGW(M,2,N) = 0.D+0
            UQ(M,2,N) = 0.D+0
            US(M,2,N) = 0.D+0
            UDS(M,2,N) = 0.D+0
            DO IGC = 1,NGC+2
              UGC(IGC,M,2,N) = 0.D+0
              UNC(IGC,M,2,N) = 0.D+0
              UDGC(IGC,M,2,N) = 0.D+0
              UDNC(IGC,M,2,N) = 0.D+0
            ENDDO
          ENDDO
        ELSEIF( IBCD(NB).EQ.2 ) THEN
          DO M = 1,ISVF
            VL(M,2,N) = 0.D+0
            VG(M,2,N) = 0.D+0
            VN(M,2,N) = 0.D+0
            VLA(M,2,N) = 0.D+0
            VLW(M,2,N) = 0.D+0
            VGW(M,2,N) = 0.D+0
            VDLA(M,2,N) = 0.D+0
            VDLW(M,2,N) = 0.D+0
            VDGW(M,2,N) = 0.D+0
            VQ(M,2,N) = 0.D+0
            VS(M,2,N) = 0.D+0
            VDS(M,2,N) = 0.D+0
            DO IGC = 1,NGC+2
              VGC(IGC,M,2,N) = 0.D+0
              VNC(IGC,M,2,N) = 0.D+0
              VDGC(IGC,M,2,N) = 0.D+0
              VDNC(IGC,M,2,N) = 0.D+0
            ENDDO
          ENDDO
        ELSEIF( IBCD(NB).EQ.3 ) THEN
          DO M = 1,ISVF
            WL(M,2,N) = 0.D+0
            WG(M,2,N) = 0.D+0
            WN(M,2,N) = 0.D+0
            WLA(M,2,N) = 0.D+0
            WLW(M,2,N) = 0.D+0
            WGW(M,2,N) = 0.D+0
            WDLA(M,2,N) = 0.D+0
            WDLW(M,2,N) = 0.D+0
            WDGW(M,2,N) = 0.D+0
            WQ(M,2,N) = 0.D+0
            WS(M,2,N) = 0.D+0
            WDS(M,2,N) = 0.D+0
            DO IGC = 1,NGC+2
              WGC(IGC,M,2,N) = 0.D+0
              WNC(IGC,M,2,N) = 0.D+0
              WDGC(IGC,M,2,N) = 0.D+0
              WDNC(IGC,M,2,N) = 0.D+0
            ENDDO
          ENDDO
        ENDIF
      ENDDO
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
!
!---  Assign local boundary condition variables  ---
!
        IF( IBCM(NB).EQ.1 ) THEN
          DO N = 1,LBCV
            BCX(N) = BC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,IBCM(NB)
            IF( TMZ.LE.BC(1,M,MB) ) THEN
             TDBC = (BC(1,M,MB)-BC(1,M-1,MB))
             DTBC = MIN( BC(1,M,MB)-TMZ,DT )
             TFBC = (TMZ-BC(1,M-1,MB))/TDBC
             DO N = 1,LBCV
               BCX(N) = BC(N,M-1,MB) + TFBC*(BC(N,M,MB)-BC(N,M-1,MB))
             ENDDO
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
        N = IBCN(NB)
        N_DB = -NB
        ITFX = MOD(IBCT(2,NB),10)
        ITGX = MOD(IBCT(2,NB),100)/10
        ITLX = MOD(IBCT(2,NB),1000)/100
        ITNX = MOD(IBCT(2,NB),10000)/1000
!
!---    Bottom boundary  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
!
!---      Fluid flow Neumann boundary  ---
!
          IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
            IF( BCX(3).GT.0.D+0 ) THEN
              DO M = 1,ISVF
                MP = MPOS(M)
                IF( ITGX.EQ.0 ) WG(M,1,N) = SGB(MP,NB)*BCX(3)
                IF( ITLX.EQ.0 ) WL(M,1,N) = SLB(MP,NB)*BCX(3)
                IF( ITNX.EQ.0 ) WN(M,1,N) = SNB(MP,NB)*BCX(3)
              ENDDO
            ELSE
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
              DO M = 1,ISVF
                IF( ITGX.EQ.0 ) WG(M,1,N) = BCX(3)*FMGX/SFMX
                IF( ITLX.EQ.0 ) WL(M,1,N) = BCX(3)*FMLX/SFMX
                IF( ITNX.EQ.0 ) WN(M,1,N) = BCX(3)*FMNX/SFMX
              ENDDO
            ENDIF
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAB( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSB( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWB( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCB( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCB( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCB( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCB( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCB( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCB( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWB( N,NB )
!
!---      Fluid flow non-zero flux boundary  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            IF( ITGX.EQ.0 ) CALL DRCVGB( N,NB )
            IF( ITLX.EQ.0 ) CALL DRCVLB( N,NB )
            IF( ITNX.EQ.0 ) CALL DRCVNB( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAB( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSB( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWB( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCB( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCB( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCB( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCB( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCB( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCB( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWB( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                WQ(M,1,N) = BCX(2)
              ENDDO
!
!---        Energy outflow, inflow, or advective  ---
!
            ELSEIF( IBCT(1,NB).EQ.5 .OR. IBCT(1,NB).EQ.6 .OR.
     &         IBCT(1,NB).EQ.7 ) THEN
              CALL THLB_EOR( N,NB )
              CALL THGB_EOR( N,NB )
              CALL THNB_EOR( N,NB )
!
!---        Energy non-zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDB_EOR( N,NB )
              CALL THLB_EOR( N,NB )
              CALL THGB_EOR( N,NB )
              CALL THNB_EOR( N,NB )
            ENDIF
          ENDIF
!
!---    South boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
!
!---      Fluid flow Neumann boundary  ---
!
          IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
            IF( BCX(3).GT.0.D+0 ) THEN
              DO M = 1,ISVF
                MP = MPOS(M)
                IF( ITGX.EQ.0 ) VG(M,1,N) = SGB(MP,NB)*BCX(3)
                IF( ITLX.EQ.0 ) VL(M,1,N) = SLB(MP,NB)*BCX(3)
                IF( ITNX.EQ.0 ) VN(M,1,N) = SNB(MP,NB)*BCX(3)
              ENDDO
            ELSE
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
              DO M = 1,ISVF
                IF( ITGX.EQ.0 ) VG(M,1,N) = BCX(3)*FMGX/SFMX
                IF( ITLX.EQ.0 ) VL(M,1,N) = BCX(3)*FMLX/SFMX
                IF( ITNX.EQ.0 ) VN(M,1,N) = BCX(3)*FMNX/SFMX
              ENDDO
            ENDIF
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAS( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSS( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWS( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCS( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCS( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCS( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCS( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCS( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCS( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWS( N,NB )
!
!---      Fluid flow non-zero flux boundary  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            IF( ITGX.EQ.0 ) CALL DRCVGS( N,NB )
            IF( ITLX.EQ.0 ) CALL DRCVLS( N,NB )
            IF( ITNX.EQ.0 ) CALL DRCVNS( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAS( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSS( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWS( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCS( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCS( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCS( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCS( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCS( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCS( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWS( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                VQ(M,1,N) = BCX(2)
              ENDDO
!
!---        Energy outflow, inflow, or advective  ---
!
            ELSEIF( IBCT(1,NB).EQ.5 .OR. IBCT(1,NB).EQ.6 .OR.
     &         IBCT(1,NB).EQ.7 ) THEN
              CALL THLS_EOR( N,NB )
              CALL THGS_EOR( N,NB )
              CALL THNS_EOR( N,NB )
!
!---        Energy non-zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDS_EOR( N,NB )
              CALL THLS_EOR( N,NB )
              CALL THGS_EOR( N,NB )
              CALL THNS_EOR( N,NB )
            ENDIF
          ENDIF
!
!---    West boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
!
!---      Fluid flow Neumann boundary  ---
!
          IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
            IF( BCX(3).GT.0.D+0 ) THEN
              DO M = 1,ISVF
                MP = MPOS(M)
                IF( ITGX.EQ.0 ) UG(M,1,N) = SGB(MP,NB)*BCX(3)
                IF( ITLX.EQ.0 ) UL(M,1,N) = SLB(MP,NB)*BCX(3)
                IF( ITNX.EQ.0 ) UN(M,1,N) = SNB(MP,NB)*BCX(3)
              ENDDO
            ELSE
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
              DO M = 1,ISVF
                IF( ITGX.EQ.0 ) UG(M,1,N) = BCX(3)*FMGX/SFMX
                IF( ITLX.EQ.0 ) UL(M,1,N) = BCX(3)*FMLX/SFMX
                IF( ITNX.EQ.0 ) UN(M,1,N) = BCX(3)*FMNX/SFMX
              ENDDO
            ENDIF
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAW( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSW( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWW( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCW( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCW( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCW( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCW( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCW( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCW( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWW( N,NB )
!
!---      Fluid flow non-zero flux boundary  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            IF( ITGX.EQ.0 ) CALL DRCVGW( N,NB )
            IF( ITLX.EQ.0 ) CALL DRCVLW( N,NB )
            IF( ITNX.EQ.0 ) CALL DRCVNW( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAW( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSW( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWW( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCW( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCW( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCW( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCW( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCW( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCW( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWW( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                UQ(M,1,N) = BCX(2)
              ENDDO
!
!---        Energy outflow, inflow, or advective  ---
!
            ELSEIF( IBCT(1,NB).EQ.5 .OR. IBCT(1,NB).EQ.6 .OR.
     &         IBCT(1,NB).EQ.7 ) THEN
              CALL THLW_EOR( N,NB )
              CALL THGW_EOR( N,NB )
              CALL THNW_EOR( N,NB )
!
!---        Energy non-zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDW_EOR( N,NB )
              CALL THLW_EOR( N,NB )
              CALL THGW_EOR( N,NB )
              CALL THNW_EOR( N,NB )
            ENDIF
          ENDIF
!
!---    East boundary  ---
!
        ELSEIF( IBCD(NB).EQ.1 ) THEN
!
!---      Fluid flow Neumann boundary  ---
!
          IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
            IF( BCX(3).LT.0.D+0 ) THEN
              DO M = 1,ISVF
                MN = MNEG(M)
                IF( ITGX.EQ.0 ) UG(M,2,N) = SGB(MN,NB)*BCX(3)
                IF( ITLX.EQ.0 ) UL(M,2,N) = SLB(MN,NB)*BCX(3)
                IF( ITNX.EQ.0 ) UN(M,2,N) = SNB(MN,NB)*BCX(3)
              ENDDO
            ELSE
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
              DO M = 1,ISVF
                IF( ITGX.EQ.0 ) UG(M,2,N) = BCX(3)*FMGX/SFMX
                IF( ITLX.EQ.0 ) UL(M,2,N) = BCX(3)*FMLX/SFMX
                IF( ITNX.EQ.0 ) UN(M,2,N) = BCX(3)*FMNX/SFMX
              ENDDO
            ENDIF
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAE( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSE( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWE( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCE( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCE( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCE( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCE( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCE( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCE( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWE( N,NB )
!
!---      Fluid flow non-zero flux boundary  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            IF( ITGX.EQ.0 ) CALL DRCVGE( N,NB )
            IF( ITLX.EQ.0 ) CALL DRCVLE( N,NB )
            IF( ITNX.EQ.0 ) CALL DRCVNE( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAE( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSE( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWE( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCE( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCE( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCE( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCE( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCE( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCE( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWE( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                UQ(M,2,N) = BCX(2)
              ENDDO
!
!---        Energy outflow, inflow, or advective  ---
!
            ELSEIF( IBCT(1,NB).EQ.5 .OR. IBCT(1,NB).EQ.6 .OR.
     &         IBCT(1,NB).EQ.7 ) THEN
              CALL THLE_EOR( N,NB )
              CALL THGE_EOR( N,NB )
              CALL THNE_EOR( N,NB )
!
!---        Energy non-zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDE_EOR( N,NB )
              CALL THLE_EOR( N,NB )
              CALL THGE_EOR( N,NB )
              CALL THNE_EOR( N,NB )
            ENDIF
          ENDIF
!
!---    North boundary
!
        ELSEIF( IBCD(NB).EQ.2 ) THEN
!
!---      Fluid flow Neumann boundary  ---
!
          IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
            IF( BCX(3).LT.0.D+0 ) THEN
              DO M = 1,ISVF
                MN = MNEG(M)
                IF( ITGX.EQ.0 ) VG(M,2,N) = SGB(MN,NB)*BCX(3)
                IF( ITLX.EQ.0 ) VL(M,2,N) = SLB(MN,NB)*BCX(3)
                IF( ITNX.EQ.0 ) VN(M,2,N) = SNB(MN,NB)*BCX(3)
              ENDDO
            ELSE
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
              DO M = 1,ISVF
                IF( ITGX.EQ.0 ) VG(M,2,N) = BCX(3)*FMGX/SFMX
                IF( ITLX.EQ.0 ) VL(M,2,N) = BCX(3)*FMLX/SFMX
                IF( ITNX.EQ.0 ) VN(M,2,N) = BCX(3)*FMNX/SFMX
              ENDDO
            ENDIF
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAN( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSN( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWN( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCN( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCN( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCN( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCN( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCN( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCN( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWN( N,NB )
!
!---      Fluid flow non-zero flux boundary  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            IF( ITGX.EQ.0 ) CALL DRCVGN( N,NB )
            IF( ITLX.EQ.0 ) CALL DRCVLN( N,NB )
            IF( ITNX.EQ.0 ) CALL DRCVNN( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAN( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLSN( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWN( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCN( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCN( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCN( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCN( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCN( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCN( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWN( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                VQ(M,2,N) = BCX(2)
              ENDDO
!
!---        Energy outflow, inflow, or advective  ---
!
            ELSEIF( IBCT(1,NB).EQ.5 .OR. IBCT(1,NB).EQ.6 .OR.
     &         IBCT(1,NB).EQ.7 ) THEN
              CALL THLN_EOR( N,NB )
              CALL THGN_EOR( N,NB )
              CALL THNN_EOR( N,NB )
!
!---        Energy non-zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDN_EOR( N,NB )
              CALL THLN_EOR( N,NB )
              CALL THGN_EOR( N,NB )
              CALL THNN_EOR( N,NB )
            ENDIF
          ENDIF
!
!---    Top boundary  ---
!
        ELSEIF( IBCD(NB).EQ.3 ) THEN
!
!---      Fluid flow Neumann boundary  ---
!
          IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
            IF( BCX(3).GT.0.D+0 ) THEN
              DO M = 1,ISVF
                MN = MNEG(M)
                IF( ITGX.EQ.0 ) WG(M,2,N) = SGB(MN,NB)*BCX(3)
                IF( ITLX.EQ.0 ) WL(M,2,N) = SLB(MN,NB)*BCX(3)
                IF( ITNX.EQ.0 ) WN(M,2,N) = SNB(MN,NB)*BCX(3)
              ENDDO
            ELSE
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
              DO M = 1,ISVF
                IF( ITGX.EQ.0 ) WG(M,2,N) = BCX(3)*FMGX/SFMX
                IF( ITLX.EQ.0 ) WL(M,2,N) = BCX(3)*FMLX/SFMX
                IF( ITNX.EQ.0 ) WN(M,2,N) = BCX(3)*FMNX/SFMX
              ENDDO
            ENDIF
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAT( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLST( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWT( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCT( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCT( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCT( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCT( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCT( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCT( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWT( N,NB )
!
!---      Fluid flow non-zero flux boundary  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            IF( ITGX.EQ.0 ) CALL DRCVGT( N,NB )
            IF( ITLX.EQ.0 ) CALL DRCVLT( N,NB )
            IF( ITNX.EQ.0 ) CALL DRCVNT( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(45).EQ.0 ) CALL DFFLAT( N,NB )
            IF( ITLX.EQ.0 .AND. ISLC(32).EQ.0 ) CALL DFFLST( N,NB )
            IF( ITLX.EQ.0 ) CALL DFFLWT( N,NB )
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCT( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCT( IGC,N,NB )
                ENDIF
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) THEN
                  IF( ITGX.EQ.0 ) CALL DFFGCT( IGC,N,NB )
                  IF( ITNX.EQ.0 ) CALL DFFNCT( IGC,N,NB )
                ENDIF
              ELSE
                IF( ITGX.EQ.0 ) CALL DFFGCT( IGC,N,NB )
                IF( ITNX.EQ.0 ) CALL DFFNCT( IGC,N,NB )
              ENDIF
            ENDDO
            IF( ITGX.EQ.0 ) CALL DFFGWT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                WQ(M,2,N) = BCX(2)
              ENDDO
!
!---        Energy outflow, inflow, or advective  ---
!
            ELSEIF( IBCT(1,NB).EQ.5 .OR. IBCT(1,NB).EQ.6 .OR.
     &         IBCT(1,NB).EQ.7 ) THEN
              CALL THLT_EOR( N,NB )
              CALL THGT_EOR( N,NB )
              CALL THNT_EOR( N,NB )
!
!---        Energy non-zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDT_EOR( N,NB )
              CALL THLT_EOR( N,NB )
              CALL THGT_EOR( N,NB )
              CALL THNT_EOR( N,NB )
            ENDIF
          ENDIF
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCF_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCJ_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Modify the Jacobian matrix for boundary conditions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCJ_EOR'
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
        IF( IBCM(NB).GT.1 .AND. TMZ.GT.BC(1,IBCM(NB),MB) ) CYCLE
        N = IBCN(NB)
        N_DB = -NB
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        ITFX = MOD(IBCT(2,NB),10)
        ITGX = MOD(IBCT(2,NB),100)/10
        ITLX = MOD(IBCT(2,NB),1000)/100
        ITNX = MOD(IBCT(2,NB),10000)/1000
!
!---    Bottom boundary  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            IF( ISLC(30).EQ.0 ) CALL JCBTB_EOR( N,NB,NPZ )
          ENDIF
!
!---      Fluid flow  ---
!
          IF( ITFX.NE.3 ) THEN
!
!---        Water mass  ---
!
            CALL JCBWB_EOR( N,NB,NPZ )
!
!---        Petroleum component mass  ---
!
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) CALL JCBCB_EOR( IGC,N,NB,NPZ )
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) CALL JCBCB_EOR( IGC,N,NB,NPZ )
              ELSE
                CALL JCBCB_EOR( IGC,N,NB,NPZ )
              ENDIF
            ENDDO
!
!---        Salt mass  ---
!
            IF( ISLC(32).EQ.0 ) CALL JCBSB_EOR( N,NB,NPZ )
          ENDIF
!
!---    South boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            IF( ISLC(30).EQ.0 ) CALL JCBTS_EOR( N,NB,NPY )
          ENDIF
!
!---      Fluid flow  ---
!
          IF( ITFX.NE.3 ) THEN
!
!---        Water mass  ---
!
            CALL JCBWS_EOR( N,NB,NPY )
!
!---        Petroleum component mass  ---
!
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) CALL JCBCS_EOR( IGC,N,NB,NPY )
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) CALL JCBCS_EOR( IGC,N,NB,NPY )
              ELSE
                CALL JCBCS_EOR( IGC,N,NB,NPY )
              ENDIF
            ENDDO
!
!---        Salt mass  ---
!
            IF( ISLC(32).EQ.0 ) CALL JCBSS_EOR( N,NB,NPY )
          ENDIF
!
!---    West boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            IF( ISLC(30).EQ.0 ) CALL JCBTW_EOR( N,NB,NPX )
          ENDIF
!
!---      Fluid flow  ---
!
          IF( ITFX.NE.3 ) THEN
!
!---        Water mass  ---
!
            CALL JCBWW_EOR( N,NB,NPX )
!
!---        Petroleum component mass  ---
!
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) CALL JCBCW_EOR( IGC,N,NB,NPX )
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) CALL JCBCW_EOR( IGC,N,NB,NPX )
              ELSE
                CALL JCBCW_EOR( IGC,N,NB,NPX )
              ENDIF
            ENDDO
!
!---        Salt mass  ---
!
            IF( ISLC(32).EQ.0 ) CALL JCBSW_EOR( N,NB,NPX )
          ENDIF
!
!---    East boundary  ---
!
        ELSEIF( IBCD(NB).EQ.1 ) THEN
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            IF( ISLC(30).EQ.0 ) CALL JCBTE_EOR( N,NB,NQX )
          ENDIF
!
!---      Fluid flow  ---
!
          IF( ITFX.NE.3 ) THEN
!
!---        Water mass  ---
!
            CALL JCBWE_EOR( N,NB,NQX )
!
!---        Petroleum component mass  ---
!
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) CALL JCBCE_EOR( IGC,N,NB,NQX )
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) CALL JCBCE_EOR( IGC,N,NB,NQX )
              ELSE
                CALL JCBCE_EOR( IGC,N,NB,NQX )
              ENDIF
            ENDDO
!
!---        Salt mass  ---
!
            IF( ISLC(32).EQ.0 ) CALL JCBSE_EOR( N,NB,NQX )
          ENDIF
!
!---    North boundary  ---
!
        ELSEIF( IBCD(NB).EQ.2 ) THEN
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            IF( ISLC(30).EQ.0 ) CALL JCBTN_EOR( N,NB,NQY )
          ENDIF
!
!---      Fluid flow  ---
!
          IF( ITFX.NE.3 ) THEN
!
!---        Water mass  ---
!
            CALL JCBWN_EOR( N,NB,NQY )
!
!---        Petroleum component mass  ---
!
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) CALL JCBCN_EOR( IGC,N,NB,NQY )
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) CALL JCBCN_EOR( IGC,N,NB,NQY )
              ELSE
                CALL JCBCN_EOR( IGC,N,NB,NQY )
              ENDIF
            ENDDO
!
!---        Salt mass  ---
!
            IF( ISLC(32).EQ.0 ) CALL JCBSN_EOR( N,NB,NQY )
          ENDIF
!
!---    Top boundary  ---
!
        ELSEIF( IBCD(NB).EQ.3 ) THEN
!
!---      Energy  ---
!
          IF( IBCT(1,NB).NE.3 ) THEN
            IF( ISLC(30).EQ.0 ) CALL JCBTT_EOR( N,NB,NQZ )
          ENDIF
!
!---      Fluid flow  ---
!
          IF( ITFX.NE.3 ) THEN
!
!---        Water mass  ---
!
            CALL JCBWT_EOR( N,NB,NQZ )
!
!---        Petroleum component mass  ---
!
            DO IGC = 1,NGC+2
              IF( IGC.EQ.1 ) THEN
!
!---            Iso-CO2 option  ---
!
                IF( ISLC(45).EQ.0 ) CALL JCBCT_EOR( IGC,N,NB,NQZ )
              ELSEIF( IGC.EQ.2 ) THEN
!
!---            Iso-CH4 option  ---
!
                IF( ISLC(64).EQ.0 ) CALL JCBCT_EOR( IGC,N,NB,NQZ )
              ELSE
                CALL JCBCT_EOR( IGC,N,NB,NQZ )
              ENDIF
            ENDDO
!
!---        Salt mass  ---
!
            IF( ISLC(32).EQ.0 ) CALL JCBST_EOR( N,NB,NQZ )
          ENDIF
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCJ_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCP_BO
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute saturation, relative permeability and thermodynamic
!     properties for boundary surfaces for the black-oil option.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 30 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 BCX(LBCV)
      REAL*8 TMCX(LNGC)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCP_BO'
!
!---  Assign values for initial condition type boundary conditions  ---
!
      IF( NSTEP-NRST.LE.1 .AND. NITER.LE.1 ) THEN
        DO NB = 1,NBC(ID+1)
          N = IBCN(NB)
          ITFX = MOD(IBCT(2,NB),10)
          IF( IBCT(1,NB).EQ.4 .OR. ITFX.EQ.4 ) THEN
            IF( IBCD(NB).EQ.-3 ) THEN
              DB = DZGP(1,N)
              GB = GRVZ(1,N)*DB
            ELSEIF( IBCD(NB).EQ.-2 ) THEN
              DB = DYGP(1,N)*RP(N)
              GB = GRVY(1,N)*DB
            ELSEIF( IBCD(NB).EQ.-1 ) THEN
              DB = DXGP(1,N)
              GB = GRVX(1,N)*DB
            ELSEIF( IBCD(NB).EQ.1 ) THEN
              DB = -DXGP(2,N)
              GB = GRVX(2,N)*DB
            ELSEIF( IBCD(NB).EQ.2 ) THEN
              DB = -DYGP(2,N)*RP(N)
              GB = GRVY(2,N)*DB
            ELSEIF( IBCD(NB).EQ.3 ) THEN
              DB = -DZGP(2,N)
              GB = GRVZ(2,N)*DB
            ENDIF
          ENDIF
!
!---      Fluid flow initial conditions  ---
!
          IF( ITFX.EQ.4 ) THEN
            PLB(1,NB) = PL(2,N) + RHOL(2,N)*GB
            PGB(1,NB) = PG(2,N) + RHOG(2,N)*GB
            PNB(1,NB) = PN(2,N) + RHON(2,N)*GB
          ENDIF
        ENDDO
      ENDIF
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
        ITFX = MOD(IBCT(2,NB),10)
        ITGX = MOD(IBCT(2,NB),100)/10
        ITLX = MOD(IBCT(2,NB),1000)/100
        ITNX = MOD(IBCT(2,NB),10000)/1000
!
!---    Assign local boundary condition variables  ---
!
        IF( IBCM(NB).EQ.1 ) THEN
          DO N = 1,LBCV
            BCX(N) = BC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,IBCM(NB)
            IF( TMZ.LE.BC(1,M,MB) ) THEN
             TDBC = (BC(1,M,MB)-BC(1,M-1,MB))
             DTBC = MIN( BC(1,M,MB)-TMZ,DT )
             TFBC = (TMZ-BC(1,M-1,MB))/TDBC
             DO N = 1,LBCV
               BCX(N) = BC(N,M-1,MB) + TFBC*(BC(N,M,MB)-BC(N,M-1,MB))
             ENDDO
!
!---         Fluid flow boundary  ---
!
             IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
               BCX(3) = BCX(3)-5.D-1*DTBC*(BC(3,M,MB)-BC(3,M-1,MB))/TDBC
             ENDIF
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
!
!---    Initial condition boundary condition  ---
!
        IF( IBCT(1,NB).EQ.4 ) BCX(2) = TB(1,NB)
        IF( ITFX.EQ.4 ) BCX(3) = MAX( PGB(1,NB),PLB(1,NB),PNB(1,NB) )
        N = IBCN(NB)
        IBD = ABS(IBCD(NB))
        N_DB = -NB
!
!---    Boundary Direction  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
          DB = 0.5D+0*DZGF(N)
          GB = GRVZ(1,N)*DB
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
          DB = 0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(1,N)*DB
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
          DB = 0.5D+0*DXGF(N)
          GB = GRVX(1,N)*DB
        ELSEIF( IBCD(NB).EQ.1 ) THEN
          DB = -0.5D+0*DXGF(N)
          GB = GRVX(2,N)*DB
        ELSEIF( IBCD(NB).EQ.2 ) THEN
          DB = -0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(2,N)*DB
        ELSEIF( IBCD(NB).EQ.3 ) THEN
          DB = -0.5D+0*DZGF(N)
          GB = GRVZ(2,N)*DB
        ENDIF
!
!---    Loop over secondary variable indices  ---
!
        DO M = 2,ISVC+2
          TB(M,NB) = T(M,N)
          PLB(M,NB) = PL(M,N)
          PGB(M,NB) = PG(M,N)
          PNB(M,NB) = PN(M,N)
          PX = MAX( PLB(M,NB),PGB(M,NB),PNB(M,NB) ) + PATM
          TKX = TB(M,NB) + TABS
!
!---      Boundary condition state #1  ---
!
!         SL = 1.0
!         SG+SN = 0.0
!
!         Declared variables:
!
!         BCX(5) - aqueous salt relative saturation, or
!                  aqueous salt mass fraction
!
          IF( IBCT(3,NB).EQ.1 ) THEN
            SGB(M,NB) = 0.D+0
            SLB(M,NB) = 1.D+0
            SNB(M,NB) = 0.D+0
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.   
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PLB(M,NB) = BCX(3)
            ENDIF
            PVAB(M,NB) = BCX(4)
            TMSX = BCX(5)
            PX = PL(M,NB) + PATM
            CALL BO_IC1( PX,RHOLB(M,NB),TMSX,TB(M,NB),XLSB(M,NB),
     &        XLWB(M,NB),YLSB(M,NB),IBCT(5,NB) )
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORDB(M,NB),PORTB(M,NB) )
            PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
            PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
            CALL CAP_EOR( SGB(M,NB),SLB(M,NB),SNB(M,NB),CPGTX,CPNLX,N )
            PNB(M,NB) = PLB(M,NB) + CPNLX
            PGB(M,NB) = MAX( PLB(M,NB),PNB(M,NB) ) + CPGTX
!
!---        Flash calculations  ---
!
            IZMCX = 0
            CALL BO_PC1( PORDB(M,NB),POSMBX,PVWB(M,NB),PX,
     &        RHOGB(M,NB),RHOLB(M,NB),RHONB(M,NB),SGB(M,NB),SLB(M,NB),
     &        SNB(M,NB),TMSX,TB(M,NB),VOL(N),XGCB(1,M,NB),
     &        XGWB(M,NB),XLSB(M,NB),XLWB(M,NB),XNCB(1,M,NB),YLSB(M,NB) )
!
!---      Boundary condition state #2  ---
!
!         SG >= 0.0
!         SL > 0.0
!         SN > 0.0
!
!         Declared variables:
!
!         BCX(4) - aqueous saturation
!         BCX(5) - aqueous salt relative saturation, or
!                  aqueous salt mass fraction
!         BCX(8) - gas saturation
!         BCX(9) - gas-oil ratio (m^3/m^3)
!
          ELSEIF( IBCT(3,NB).EQ.2 ) THEN
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.   
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PX = BCX(3) + PATM
            ENDIF
            SLB(M,NB) = BCX(4)
            TMSX = BCX(5)
            SGB(M,NB) = BCX(8)
            POSMBX = BCX(9)
            SNB(M,NB) = MAX( 1.D+0-SLB(M,NB)-SGB(M,NB),0.D+0 )
            CALL BO_IC2( POSMBX,PX,RHOGB(M,NB),RHOLB(M,NB),RHONB(M,NB),
     &        SLB(M,NB),TMSX,TB(M,NB),XGCB(1,M,NB),XGWB(M,NB),
     &        XLSB(M,NB),XLWB(M,NB),XNCB(1,M,NB),YLSB(M,NB),
     &        IBCT(5,NB),N )
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORDB(M,NB),PORTB(M,NB) )
            PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
            PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
            CALL CAP_EOR( SGB(M,NB),SLB(M,NB),SNB(M,NB),CPGTX,CPNLX,N )
            IF( SGB(M,NB).LT.EPSL ) THEN
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PX - PATM
                PLB(M,NB) = PNB(M,NB) - CPNLX
                PGB(M,NB) = PNB(M,NB) + CPGTX
              ELSE
                PLB(M,NB) = PX - PATM
                PNB(M,NB) = PLB(M,NB) + CPNLX
                PGB(M,NB) = PLB(M,NB) + CPGTX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              CALL BO_PC2( PORDB(M,NB),POSMBX,PVWB(M,NB),PX,
     &          RHOGB(M,NB),RHOLB(M,NB),RHONB(M,NB),SGB(M,NB),SLB(M,NB),
     &          SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),XGCB(1,M,NB),
     &          XGWB(M,NB),XLSB(M,NB),XLWB(M,NB),XNCB(1,M,NB),
     &          YLSB(M,NB),N )
            ELSE
              PGB(M,NB) = PX - PATM
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PGB(M,NB) - CPGTX
                PLB(M,NB) = PNB(M,NB) - CPNLX
              ELSE
                PLB(M,NB) = PGB(M,NB) - CPGTX
                PNB(M,NB) = PLB(M,NB) + CPNLX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              CALL BO_PC3( PORDB(M,NB),POSMBX,PVWB(M,NB),PX,
     &          RHOGB(M,NB),RHOLB(M,NB),RHONB(M,NB),SGB(M,NB),SLB(M,NB),
     &          SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),XGCB(1,M,NB),
     &          XGWB(M,NB),XLSB(M,NB),XLWB(M,NB),XNCB(1,M,NB),
     &          YLSB(M,NB),N )
            ENDIF
!
!---      Boundary condition state #3  ---
!
!         SG >= 0.0
!         SL = 0.0
!         SN > 0.0
!
!         Declared variables:
!
!         BCX(4) - water vapor relative saturation
!         BCX(8) - gas saturation
!         BCX(9) - gas-oil ratio (m^3/m^3)
!        
          ELSEIF( IBCT(3,NB).EQ.3 ) THEN
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.   
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PX = BCX(3) + PATM
            ENDIF
            SLB(M,NB) = 0.D+0
            YLSX = 0.D+0
            PVWX = BCX(4)
            SGB(M,NB) = BCX(8)
            POSMBX = BCX(9)
            SNB(M,NB) = MAX( 1.D+0-SGB(M,NB)-SLB(M,NB),0.D+0 )
            CALL BO_IC3( POSMBX,PVWX,PX,RHOGB(M,NB),RHONB(M,NB),
     &        TB(M,NB),XGCB(1,M,NB),XGWB(M,NB),XNCB(1,M,NB),YLSB(M,NB),
     &        N )
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORDB(M,NB),PORTB(M,NB) )
            PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
            PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
            CALL CAP_EOR( SGB(M,NB),SLB(M,NB),SNB(M,NB),CPGTX,CPNLX,N )
            IF( SGB(M,NB).LT.EPSL ) THEN
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PX - PATM
                PLB(M,NB) = PNB(M,NB) - CPNLX
                PGB(M,NB) = PNB(M,NB) + CPGTX
              ELSE
                PLB(M,NB) = PX - PATM
                PNB(M,NB) = PLB(M,NB) + CPNLX
                PGB(M,NB) = PLB(M,NB) + CPGTX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              TMSX = 0.D+0
              CALL BO_PC4( PORDB(M,NB),POSMBX,PVWB(M,NB),PX,
     &          RHOGB(M,NB),RHOLB(M,NB),RHONB(M,NB),SGB(M,NB),SLB(M,NB),
     &          SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),XGCB(1,M,NB),
     &          XGWB(M,NB),XLSB(M,NB),XLWB(M,NB),XNCB(1,M,NB),
     &          YLSB(M,NB),N )
            ELSE
              PGB(M,NB) = PX - PATM
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PGB(M,NB) - CPGTX
                PLB(M,NB) = PNB(M,NB) - CPNLX
              ELSE
                PLB(M,NB) = PGB(M,NB) - CPGTX
                PNB(M,NB) = PLB(M,NB) + CPNLX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              TMSX = 0.D+0
              CALL BO_PC5( PORDB(M,NB),POSMBX,PVWB(M,NB),PX,
     &          RHOGB(M,NB),RHOLB(M,NB),RHONB(M,NB),SGB(M,NB),SLB(M,NB),
     &          SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),XGCB(1,M,NB),
     &          XGWB(M,NB),XLSB(M,NB),XLWB(M,NB),XNCB(1,M,NB),
     &          YLSB(M,NB),N )
            ENDIF
          ENDIF
!
!---      Relative permeability  ---
!
          CALL RKG_EOR( RKGB(M,NB),SLB(M,NB),SNB(M,NB),N )
          CALL RKL_EOR( RKLB(M,NB),SLB(M,NB),N )
          CALL RKN_EOR( RKGB(M,NB),RKLB(M,NB),RKNB(M,NB),SGB(M,NB),
     &      SLB(M,NB),SNB(M,NB),N )
!
!---      Gas viscosity, Pa s  ---
!
          CALL BO_VISG( RHOGB(M,NB),VISGB(M,NB) )
!
!---      Aqueous viscosity, Pa s
!         concentration of CO2 in mol/kg,
!         concentration of salt in mol/kg  ---
!
          CMLAX = 0.D+0
          CMLSX = 1.D+3*XLSB(M,NB)*RHOLB(M,NB)/WTMS
          CALL VISC_L( CMLAX,CMLSX,PX,TB(M,NB),VISLB(M,NB) )
!
!---      Nonaqueous-liquid viscosity, Pa s  ---
!
          CALL BO_VISN( PX,POSMBX,TB(M,NB),VISNB(M,NB) )
!
!---      Salt aqueous diffusion coefficient  ---
!
          CALL DIFC_LS( DFLSB(M,NB),TB(M,NB),VISLB(M,NB),XLSB(M,NB) )
!
!---      Precipitated NaCl density, saturation, and enthalpy  ---
!
          CALL DENS_S( TB(M,NB),PX,RHOSPBX )
          CALL SOL_LS( TB(M,NB),XBSMX )
          CALL DENS_B( TB(M,NB),PX,XBSMX,RHOBX )
          SSB(M,NB) = MAX(YLSB(M,NB)-XBSMX,0.D+0)*RHOBX*SLB(M,NB)/
     &      RHOSPBX
!
!---      Change in porosity as a function of precipitated salt  ---
!
          PORDB(M,NB) = PORDB(M,NB)*(1.D+0-SSB(M,NB))
!
!---      Aqueous, gas, and nonaqueous-liquid tortuosity  ---
!
          IF( ISLC(3).EQ.1 ) CALL TORTU( N,SLB(M,NB),SGB(M,NB),
     &      SNB(M,NB),PORDB(M,NB),TORLB(M,NB),TORGB(M,NB),TORNB(M,NB) )
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCP_BO group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCP_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute saturation, relative permeability and thermodynamic
!     properties for boundary surfaces.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 BCX(LBCV)
      REAL*8 TMCX(LNGC),FKX(LNGC)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCP_EOR'
!
!---  Black-oil option  ---
!
      IF( ISLC(68).EQ.0 ) THEN
        CALL BCP_BO
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Compositional option  ---
!
!
!---  K-factors computed from fugacity coefficients  ---
!
      IFK = 0
!
!---  Assign values for initial condition type boundary conditions  ---
!
      IF( NSTEP-NRST.LE.1 .AND. NITER.LE.1 ) THEN
        DO NB = 1,NBC(ID+1)
          N = IBCN(NB)
          ITFX = MOD(IBCT(2,NB),10)
          IF( IBCT(1,NB).EQ.4 .OR. ITFX.EQ.4 ) THEN
            IF( IBCD(NB).EQ.-3 ) THEN
              DB = DZGP(1,N)
              GB = GRVZ(1,N)*DB
            ELSEIF( IBCD(NB).EQ.-2 ) THEN
              DB = DYGP(1,N)*RP(N)
              GB = GRVY(1,N)*DB
            ELSEIF( IBCD(NB).EQ.-1 ) THEN
              DB = DXGP(1,N)
              GB = GRVX(1,N)*DB
            ELSEIF( IBCD(NB).EQ.1 ) THEN
              DB = -DXGP(2,N)
              GB = GRVX(2,N)*DB
            ELSEIF( IBCD(NB).EQ.2 ) THEN
              DB = -DYGP(2,N)*RP(N)
              GB = GRVY(2,N)*DB
            ELSEIF( IBCD(NB).EQ.3 ) THEN
              DB = -DZGP(2,N)
              GB = GRVZ(2,N)*DB
            ENDIF
          ENDIF
!
!---      Energy initial conditions  ---
!
          IF( IBCT(1,NB).EQ.4 ) TB(1,NB) = T(1,N)
!
!---      Fluid flow initial conditions  ---
!
          IF( ITFX.EQ.4 ) THEN
            PLB(1,NB) = PL(2,N) + RHOL(2,N)*GB
            PGB(1,NB) = PG(2,N) + RHOG(2,N)*GB
            PNB(1,NB) = PN(2,N) + RHON(2,N)*GB
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 )  THEN
            IF( IBCT(IEQS,NB).EQ.12 ) YLSB(1,NB) = YLS(2,N)
          ENDIF
        ENDDO
      ENDIF
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
        ITFX = MOD(IBCT(2,NB),10)
        ITGX = MOD(IBCT(2,NB),100)/10
        ITLX = MOD(IBCT(2,NB),1000)/100
        ITNX = MOD(IBCT(2,NB),10000)/1000
!
!---    Assign local boundary condition variables  ---
!
        IF( IBCM(NB).EQ.1 ) THEN
          DO N = 1,LBCV
            BCX(N) = BC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,IBCM(NB)
            IF( TMZ.LE.BC(1,M,MB) ) THEN
             TDBC = (BC(1,M,MB)-BC(1,M-1,MB))
             DTBC = MIN( BC(1,M,MB)-TMZ,DT )
             TFBC = (TMZ-BC(1,M-1,MB))/TDBC
             DO N = 1,LBCV
               BCX(N) = BC(N,M-1,MB) + TFBC*(BC(N,M,MB)-BC(N,M-1,MB))
             ENDDO
!
!---         Energy boundary  ---
!
             IF( IBCT(1,NB).EQ.2 ) THEN
               BCX(2) = BCX(2)-5.D-1*DTBC*(BC(2,M,MB)-BC(2,M-1,MB))/TDBC
             ENDIF
!
!---         Fluid flow boundary  ---
!
             IF( ITFX.EQ.2 .OR. ITFX.EQ.7 .OR. ITFX.EQ.9 ) THEN
               BCX(3) = BCX(3)-5.D-1*DTBC*(BC(3,M,MB)-BC(3,M-1,MB))/TDBC
             ENDIF
!
!---         Isobrine option  ---
!
             IF( ISLC(32).EQ.0 )  THEN
              IF( IBCT(IEQS,NB).EQ.2 ) THEN
               BCX(6) = BCX(6)-5.D-1*DTBC*(BC(6,M,MB)-BC(6,M-1,MB))/TDBC
              ELSEIF( IBCT(IEQS,NB).EQ.12 ) THEN
                BCX(6) = YLSB(1,NB)
              ENDIF
             ENDIF
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
!
!---    Initial condition boundary condition  ---
!
        IF( IBCT(1,NB).EQ.4 ) BCX(2) = TB(1,NB)
        IF( ITFX.EQ.4 ) BCX(3) = MAX( PGB(1,NB),PLB(1,NB),PNB(1,NB) )
        N = IBCN(NB)
        IBD = ABS(IBCD(NB))
        N_DB = -NB
!
!---    Boundary Direction  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
          DB = 0.5D+0*DZGF(N)
          GB = GRVZ(1,N)*DB
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
          DB = 0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(1,N)*DB
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
          DB = 0.5D+0*DXGF(N)
          GB = GRVX(1,N)*DB
        ELSEIF( IBCD(NB).EQ.1 ) THEN
          DB = -0.5D+0*DXGF(N)
          GB = GRVX(2,N)*DB
        ELSEIF( IBCD(NB).EQ.2 ) THEN
          DB = -0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(2,N)*DB
        ELSEIF( IBCD(NB).EQ.3 ) THEN
          DB = -0.5D+0*DZGF(N)
          GB = GRVZ(2,N)*DB
        ENDIF
!
!---    Loop over secondary variable indices  ---
!
        DO M = 2,ISVC+2
          TB(M,NB) = T(M,N)
          PLB(M,NB) = PL(M,N)
          PGB(M,NB) = PG(M,N)
          PNB(M,NB) = PN(M,N)
          PX = MAX( PLB(M,NB),PGB(M,NB),PNB(M,NB) ) + PATM
!
!---      Full flash calculation for unincremented index, otherwise use
!         previous beta and K-factors as initial guesses  ---
!
          BETAX = -1.D+0
!
!---      Energy: Dirichlet, initial condition, inflow, or
!         advective only  ---
!
          IF( IBCT(1,NB).EQ.1 .OR. IBCT(1,NB).EQ.4
     &      .OR. IBCT(1,NB).EQ.5 .OR. IBCT(1,NB).EQ.7 ) THEN
            TB(M,NB) = BCX(2)
!
!---      Energy: Neumann  ---
!
          ELSEIF( IBCT(1,NB).EQ.2 ) THEN
            INDX = ABS( IBCD(NB) )
            THKP = MAX(1.D+0-PORD(M,N),0.D+0)*THKS(INDX,N) +
     &        PORD(M,N)*(THKL(M,N)*SL(M,N) +
     &        THKN(M,N)*SN(M,N) + THKG(M,N)*SG(M,N))
            TB(M,NB) = TB(M,NB) + BCX(2)*DB/THKP
!
!---      Energy: Geothermal Gradient  ---
!
          ELSEIF( IBCT(1,NB).EQ.8 ) THEN
            TB(M,NB) = BCX(2) + (ZPBC(NB)-BCX(8))*BCX(9)
          ENDIF
          TKX = TB(M,NB) + TABS
!
!---      Boundary condition state #1  ---
!
!         SL = 1.0
!         SG+SN = 0.0
!
!         Declared variables:
!
!         BCX(4) - aqueous CO2 relative saturation, or
!                  aqueous CO2 mass fraction
!         BCX(5) - aqueous salt relative saturation, or
!                  aqueous salt mass fraction
!
          NPHAZX = 0
          IF( IBCT(3,NB).EQ.1 ) THEN
            SGB(M,NB) = 0.D+0
            SLB(M,NB) = 1.D+0
            SNB(M,NB) = 0.D+0
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.   
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PLB(M,NB) = BCX(3)
            ENDIF
            PVAB(M,NB) = BCX(4)
            TMSX = BCX(5)
            PX = PL(M,NB) + PATM
            CALL FLH_IC1( PX,PVAB(M,NB),RHOLB(M,NB),RHOMLB(M,NB),TMSX,
     &        TB(M,NB),XLAB(M,NB),XLSB(M,NB),XLWB(M,NB),
     &        XMLAB(M,NB),XMLSB(M,NB),XMLWB(M,NB),YLSB(M,NB),
     &        ZMCB(1,M,NB),IBCT(4,NB),IBCT(5,NB) )
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORDB(M,NB),PORTB(M,NB) )
            PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
            PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
            CALL CAP_EOR( SGB(M,NB),SLB(M,NB),SNB(M,NB),CPGTX,CPNLX,N )
            PNB(M,NB) = PLB(M,NB) + CPNLX
            PGB(M,NB) = MAX( PLB(M,NB),PNB(M,NB) ) + CPGTX
!
!---        Flash calculations  ---
!
            IZMCX = 0
            IBETAX = 0
            CALL FLH_PC1( BETAX,FKX,GNIFTX,PORDB(M,NB),PVAB(M,NB),
     &        PVWB(M,NB),PX,RHOGB(M,NB),RHOLB(M,NB),RHOMGB(M,NB),
     &        RHOMLB(M,NB),RHOMNB(M,NB),RHONB(M,NB),SGB(M,NB),SLB(M,NB),
     &        SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),XGCB(1,M,NB),
     &        XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),XLWB(M,NB),XNCB(1,M,NB),
     &        XMGCB(1,M,NB),XMGWB(M,NB),XMLAB(M,NB),XMLSB(M,NB),
     &        XMLWB(M,NB),XMNCB(1,M,NB),YLSB(M,NB),ZGB(M,NB),
     &        ZMCB(1,M,NB),ZNB(M,NB),IBETAX,N,NPHAZX )
!
!---      Boundary condition state #2  ---
!
!         SL < 1.0
!         SG+SN > 0.0
!
!         Declared variables:
!
!         BCX(4) - aqueous saturation
!         BCX(5) - aqueous salt relative saturation, or
!                  aqueous salt mass fraction
!         BCX(8) - total mole fraction of petroleum components
!         BCX(10+NGC) - total mole fraction of petroleum comp.
!
          ELSEIF( IBCT(3,NB).EQ.2 ) THEN
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.   
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PX = BCX(3) + PATM
            ENDIF
            SLB(M,NB) = BCX(4)
            TMSX = BCX(5)
            DO IGC = 1,NGC+2
              JGC = IGC + 7
              ZMCB(IGC,M,NB) = BCX(JGC)
            ENDDO
            CALL FLH_IC2( PX,RHOGB(M,NB),RHOMGB(M,NB),RHOLB(M,NB),
     &        RHOMLB(M,NB),RHONB(M,NB),RHOMNB(M,NB),SGB(M,NB),SLB(M,NB),
     &        SNB(M,NB),TMSX,TB(M,NB),XGCB(1,M,NB),
     &        XMGCB(1,M,NB),
     &        XGWB(M,NB),XMGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &        XLWB(M,NB),XMLAB(M,NB),XMLSB(M,NB),XMLWB(M,NB),
     &        XNCB(1,M,NB),XMNCB(1,M,NB),YLSB(M,NB),
     &        ZGB(M,NB),ZMCB(1,M,NB),ZNB(M,NB),IBCT(5,NB),N,NPHAZX )
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORDB(M,NB),PORTB(M,NB) )
            PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
            PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
            CALL CAP_EOR( SGB(M,NB),SLB(M,NB),SNB(M,NB),CPGTX,CPNLX,N )
            IF( SGB(M,NB).LT.EPSL ) THEN
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PX - PATM
                PLB(M,NB) = PNB(M,NB) - CPNLX
                PGB(M,NB) = PNB(M,NB) + CPGTX
              ELSE
                PLB(M,NB) = PX - PATM
                PNB(M,NB) = PLB(M,NB) + CPNLX
                PGB(M,NB) = PLB(M,NB) + CPGTX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              IBETAX = 0
              CALL FLH_PC2( BETAX,FKX,GNIFTX,PORDB(M,NB),PVAB(M,NB),
     &          PVWB(M,NB),PX,RHOGB(M,NB),RHOLB(M,NB),RHOMGB(M,NB),
     &          RHOMLB(M,NB),RHOMNB(M,NB),RHONB(M,NB),SGB(M,NB),
     &          SLB(M,NB),SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),
     &          XGCB(1,M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &          XLWB(M,NB),XNCB(1,M,NB),XMGCB(1,M,NB),XMGWB(M,NB),
     &          XMLAB(M,NB),XMLSB(M,NB),XMLWB(M,NB),XMNCB(1,M,NB),
     &          YLSB(M,NB),ZGB(M,NB),ZMCB(1,M,NB),ZNB(M,NB),IBETAX,
     &          IZMCX,N,NPHAZX )
            ELSE
              PGB(M,NB) = PX - PATM
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PGB(M,NB) - CPGTX
                PLB(M,NB) = PNB(M,NB) - CPNLX
              ELSE
                PLB(M,NB) = PGB(M,NB) - CPGTX
                PNB(M,NB) = PLB(M,NB) + CPNLX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              IBETAX = 0
              CALL FLH_PC3( BETAX,FKX,GNIFTX,PORDB(M,NB),PVAB(M,NB),
     &          PVWB(M,NB),PX,RHOGB(M,NB),RHOLB(M,NB),RHOMGB(M,NB),
     &          RHOMLB(M,NB),RHOMNB(M,NB),RHONB(M,NB),SGB(M,NB),
     &          SLB(M,NB),SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),
     &          XGCB(1,M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &          XLWB(M,NB),XNCB(1,M,NB),XMGCB(1,M,NB),XMGWB(M,NB),
     &          XMLAB(M,NB),XMLSB(M,NB),XMLWB(M,NB),XMNCB(1,M,NB),
     &          YLSB(M,NB),ZGB(M,NB),ZMCB(1,M,NB),ZNB(M,NB),IBETAX,
     &          IZMCX,N,NPHAZX )
            ENDIF
!
!---      Boundary condition state #3  ---
!
!         SL = 0.0
!         SG+SN = 1.0
!
!         Declared variables:
!
!         BCX(4) - water vapor relative saturation
!         BCX(8+) - total mole fraction of petroleum components
!        
          ELSEIF( IBCT(3,NB).EQ.3 ) THEN
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.   
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PX = BCX(3) + PATM
            ENDIF
            SLB(M,NB) = 0.D+0
            ZMCMX = 0.D+0
            YLSX = 0.D+0
            PVWX = BCX(4)
            DO IGC = 1,NGC+2
              JGC = IGC + 7
              ZMCB(IGC,M,NB) = BCX(JGC)
            ENDDO
            CALL FLH_IC3( PVWX,PX,RHOGB(M,NB),RHOMGB(M,NB),RHONB(M,NB),
     &        RHOMNB(M,NB),SGB(M,NB),SNB(M,NB),TB(M,NB),
     &        XGCB(1,M,NB),XGWB(M,NB),XMGCB(1,M,NB),XMGWB(M,NB),
     &        XNCB(1,M,NB),XMNCB(1,M,NB),YLSX,
     &        ZGB(M,NB),ZMCB(1,M,NB),ZNB(M,NB),N,NPHAZX )
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORDB(M,NB),PORTB(M,NB) )
            PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
            PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
            CALL CAP_EOR( SGB(M,NB),SLB(M,NB),SNB(M,NB),CPGTX,CPNLX,N )
            IF( SGB(M,NB).LT.EPSL ) THEN
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PX - PATM
                PLB(M,NB) = PNB(M,NB) - CPNLX
                PGB(M,NB) = PNB(M,NB) + CPGTX
              ELSE
                PLB(M,NB) = PX - PATM
                PNB(M,NB) = PLB(M,NB) + CPNLX
                PGB(M,NB) = PLB(M,NB) + CPGTX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              IBETAX = 0
              TMSX = 0.D+0
              CALL FLH_PC4( BETAX,FKX,GNIFTX,PORDB(M,NB),PVAB(M,NB),
     &          PVWB(M,NB),PX,RHOGB(M,NB),RHOLB(M,NB),RHOMGB(M,NB),
     &          RHOMLB(M,NB),RHOMNB(M,NB),RHONB(M,NB),SGB(M,NB),
     &          SLB(M,NB),SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),
     &          XGCB(1,M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &          XLWB(M,NB),XNCB(1,M,NB),XMGCB(1,M,NB),XMGWB(M,NB),
     &          XMLAB(M,NB),XMLSB(M,NB),XMLWB(M,NB),XMNCB(1,M,NB),
     &          YLSB(M,NB),ZGB(M,NB),ZMCB(1,M,NB),ZNB(M,NB),IBETAX,
     &          IZMCX,N,NPHAZX )
            ELSE
              PGB(M,NB) = PX - PATM
              IF( CPNLX.GE.0.D+0 ) THEN
                PNB(M,NB) = PGB(M,NB) - CPGTX
                PLB(M,NB) = PNB(M,NB) - CPNLX
              ELSE
                PLB(M,NB) = PGB(M,NB) - CPGTX
                PNB(M,NB) = PLB(M,NB) + CPNLX
              ENDIF
!
!---          Flash calculations  ---
!
              IZMCX = 0
              TMSX = 0.D+0
              CALL FLH_PC5( BETAX,FKX,GNIFTX,PORDB(M,NB),PVAB(M,NB),
     &          PVWB(M,NB),PX,RHOGB(M,NB),RHOLB(M,NB),RHOMGB(M,NB),
     &          RHOMLB(M,NB),RHOMNB(M,NB),RHONB(M,NB),SGB(M,NB),
     &          SLB(M,NB),SNB(M,NB),TMCX,TMSX,TB(M,NB),VOL(N),
     &          XGCB(1,M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &          XMGCB(1,M,NB),XMGWB(M,NB),XMLAB(M,NB),XMLSB(M,NB),
     &          XLWB(M,NB),XNCB(1,M,NB),XMLWB(M,NB),XMNCB(1,M,NB),
     &          YLSB(M,NB),ZGB(M,NB),ZMCB(1,M,NB),ZNB(M,NB),IBETAX,
     &          IZMCX,N,NPHAZX )
            ENDIF
          ENDIF
!
!---      Relative permeability  ---
!
          CALL RKG_EOR( RKGB(M,NB),SLB(M,NB),SNB(M,NB),N )
          CALL RKL_EOR( RKLB(M,NB),SLB(M,NB),N )
          CALL RKN_EOR( RKGB(M,NB),RKLB(M,NB),RKNB(M,NB),SGB(M,NB),
     &      SLB(M,NB),SNB(M,NB),N )
!
!---      Gas viscosity, Pa s  ---
!
          CALL VISC_G( RHOMGB(M,NB),TB(M,NB),VISGB(M,NB),XMGCB(1,M,NB),
     &      XMGWB(M,NB) )
!
!---      Aqueous viscosity, Pa s
!         concentration of CO2 in mol/kg,
!         concentration of salt in mol/kg  ---
!
          CMLAX = 1.D+3*XMLAB(M,NB)*RHOMLB(M,NB)/RHOLB(M,NB)
          CMLSX = 1.D+3*XMLSB(M,NB)*RHOMLB(M,NB)/RHOLB(M,NB)
          CALL VISC_L( CMLAX,CMLSX,PX,TB(M,NB),VISLB(M,NB) )
!
!---      Nonaqueous-liquid viscosity, Pa s  ---
!
          CALL VISC_N( RHOMNB(M,NB),TB(M,NB),VISNB(M,NB),XMNCB(1,M,NB) )
!
!---      Component gas diffusion coefficients  ---
!
          CALL DIFC_G( DFGCB(1,M,NB),DFGWB(M,NB),PX,TB(M,NB),
     &      XMGCB(1,M,NB),XMGWB(M,NB) )
!
!---      CO2 aqueous diffusion coefficient  ---
!
          CALL DIFC_LA( DFLAB(M,NB),TB(M,NB),VISLB(M,NB) )
!
!---      Salt aqueous diffusion coefficient  ---
!
          CALL DIFC_LS( DFLSB(M,NB),TB(M,NB),VISLB(M,NB),XLSB(M,NB) )
!
!---      Petroleum component nonaqueous-liquid diffusion 
!         coefficients  ---
!
          CALL DIFC_N( DFNCB(1,M,NB),TB(M,NB),VISNB(M,NB) )
!
!---      Gas thermal conductivity, W/m K  ---
!
          CALL THK_G( PX,TB(M,NB),THKGB(M,NB),XMGCB(1,M,NB),
     &      XMGWB(M,NB) )
!
!---      Aqueous thermal conductivity  ---
!
          CALL THK_W( PX,TB(M,NB),THKLWX )
          CALL THK_B( TB(M,NB),XLSB(M,NB),THKLWX,THKLB(M,NB) )
!
!---      Nonaqueous thermal conductivity, W/m K  ---
!
          CALL THK_N( PX,TB(M,NB),THKNB(M,NB),XMNCB(1,M,NB) )
!
!---      Gas enthalpy and internal energy, W/kg  ---
!
          CALL ENTH_G( HGB(M,NB),HGAB(M,NB),HGWB(M,NB),PX,TB(M,NB),
     &      RHOGB(M,NB),UEGB(M,NB),XGCB(1,M,NB),XGWB(M,NB),
     &      XMGCB(1,M,NB),ZGB(M,NB) )
!
!---      Nonaqueous-liquid enthalpy and internal energy  ---
!
          CALL ENTH_N( HNB(M,NB),HNAX,PX,TB(M,NB),RHONB(M,NB),
     &      UENBX,XNCB(1,M,NB),XMNCB(1,M,NB),ZNB(M,NB) )
!
!---      Pure water liquid enthalpy  ---
!
          CALL SP_W( TB(M,NB),PSWX )
          PEX = MAX( PSWX,PX )
          ISRX = 1
          CALL ENTH_W( TB(M,NB),PEX,HLWB(M,NB),HGWX,ISRX )
!
!---      Brine enthalpy  ---
!
          CALL ENTH_B( TB(M,NB),XLSB(M,NB),HLWB(M,NB),HBX )
!
!---      Dissolved CO2 contribution  ---
!
          SGX = (BETAX/RHOMGB(M,NB))/
     &      (BETAX/RHOMGB(M,NB) + (1.D+0-BETAX)/RHOMNB(M,NB))
          IF( SGX.LT.1.D-12 ) SGX = 0.D+0
          SNX = 1.D+0 - SGX
          FGAX = SGX*RHOGB(M,NB)*XGCB(1,M,NB)
          FNAX = SNX*RHONB(M,NB)*XNCB(1,M,NB)
          IF( (FGAX+FNAX)/EPSL.LT.EPSL ) THEN
            HAX = 0.D+0
          ELSE
            HAX = (HGAB(M,NB)*FGAX + HNAX*FNAX)/(FGAX + FNAX)
          ENDIF
!
!---      Aqueous enthalpy and internal energy  ---
!
          CALL ENTH_L( HAX,HBX,HLB(M,NB),TB(M,NB),XLAB(M,NB),
     &      XLSB(M,NB) )
!
!---      Precipitated NaCl density, saturation, and enthalpy  ---
!
          CALL DENS_S( TB(M,NB),PX,RHOSPBX )
          CALL SOL_LS( TB(M,NB),XBSMX )
          CALL DENS_B( TB(M,NB),PX,XBSMX,RHOBX )
          SSB(M,NB) = MAX(YLSB(M,NB)-XBSMX,0.D+0)*RHOBX*SLB(M,NB)/
     &      RHOSPBX
!
!---      Change in porosity as a function of precipitated salt  ---
!
          PORDB(M,NB) = PORDB(M,NB)*(1.D+0-SSB(M,NB))
!
!---      Aqueous, gas, and nonaqueous-liquid tortuosity  ---
!
          IF( ISLC(3).EQ.1 ) CALL TORTU( N,SLB(M,NB),SGB(M,NB),
     &      SNB(M,NB),PORDB(M,NB),TORLB(M,NB),TORGB(M,NB),TORNB(M,NB) )
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCP_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CAP_EOR( SGX,SLX,SNX,CPGTX,CPNLX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute the gas to total-liquid capillary pressure,
!     and aqueous to nonaqueous-liquid capillary pressure, given
!     the gas saturation, aqueous saturation, nonaqueous-liquid
!     saturation and contact angle.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 30 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 GX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CAP_EOR'
!
!---  van Genuchten saturation function
!
      IF( ISCHR(N).EQ.1 ) THEN
        CALL CAP_VG( SGX,SLX,SNX,CPGTX,CPNLX,N )
!
!---  Brooks and Corey saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.2 ) THEN
        CALL CAP_BC( SGX,SLX,SNX,CPGTX,CPNLX,N )
!
!---  Zero capillary pressure saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.3 ) THEN
        CPGTX = 0.D+0
        CPNLX = 0.D+0
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CAP_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE FLUX_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute fluxes on internal and boundary surfaces.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE GLB_PAR
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/FLUX_EOR'
!
!---  Aqueous volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVL
!
!---  Gas volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVG
!
!---  Nonaqueous liquid volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVN
!
!---  Petroleum component diffusive flux through gas 
!     (non-boundary surfaces)  ---
!
      DO IGC = 1,NGC+2
        IF( IGC.EQ.1 ) THEN
!
!---      Iso-CO2 option  ---
!
          IF( ISLC(45).EQ.0 ) CALL DFFGC(IGC)
        ELSEIF( IGC.EQ.2 ) THEN
!
!---      Iso-CH4 option  ---
!
          IF( ISLC(64).EQ.0 ) CALL DFFGC(IGC)
        ELSE
          CALL DFFGC(IGC)
        ENDIF
      ENDDO
!
!---  Water diffusive flux through gas (non-boundary surfaces)  ---
!
      CALL DFFGW
!
!---  Mobile CO2 diffusive flux through aqueous (non-boundary surfaces)
!     inactive for iso-CO2 option  ---
!
      IF( ISLC(45).EQ.0 .AND. ISLC(68).NE.0 ) CALL DFFLA
!
!---  Salt diffusive flux through aqueous (non-boundary surfaces)
!     inactive for iso-brine option  ---
!
      IF( ISLC(32).EQ.0 ) CALL DFFLS
!
!---  Water diffusive flux through aqueous (non-boundary surfaces)
!     (last in aqueous diffusion order as molar H2O diffusion
!     in aqueous phase equal to minus the sum of the
!     molar diffusion of salt, N2, CH4, and CO2)  ---
!
      CALL DFFLW
!
!---  Petroleum component diffusive flux through nonaqueous liquid 
!     (non-boundary surfaces)  ---
!
      DO IGC = 1,NGC+2
        IF( IGC.EQ.1 ) THEN
!
!---      Iso-CO2 option  ---
!
          IF( ISLC(45).EQ.0 ) CALL DFFNC(IGC)
        ELSEIF( IGC.EQ.2 ) THEN
!
!---      Iso-CH4 option  ---
!
          IF( ISLC(64).EQ.0 ) CALL DFFNC(IGC)
        ELSE
          CALL DFFNC(IGC)
        ENDIF
      ENDDO
!
!---  Isothermal option  ---
!
      IF( ISLC(30).EQ.0 ) THEN
!
!---    Thermal diffusive flux (non-boundary surfaces)  ---
!
        CALL THD_EOR
!
!---    Thermal advective flux for aqueous (non-boundary surfaces)  ---
!
        CALL THL_EOR
!
!---    Thermal advective flux for gas (non-boundary surfaces)  ---
!
        CALL THG_EOR
!
!---    Thermal advective flux for nonaqueous liquid
!       (non-boundary surfaces)  ---
!
        CALL THN_EOR
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of FLUX_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE INCRM_BO
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute primary variable increments.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE PROP
      USE GLB_PAR
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE CCP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/INCRM_BO'
!
!---  Black-oil option  ---
!
      TOLX = 2.5D-2
!
!---  Loop over local grid cells, including ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip inactive cells  ---
!
        IF( IXP(N).EQ.0 ) CYCLE
        N_DB = ND(N)
!
!---    Absolute temperature  ---
!
        TKX = T(2,N)+TABS
!
!---    Phase condition #1  ---
!
!       SL = 1.0
!       SG+SN = 0.0
!       Aqueuous saturated
!
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       gas mass - total gas mass - TMC(1,2,N)
!       oil mass - total oil mass - TMC(2,2,N)
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      System pressure  ---
!
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
          CALL SP_B( T(2,N),XBSX,PSBX )
!
!---      Maximum solubility of CO2 in aqueous phase  ---
!
          PVAX = 0.D+0
          CALL EQUIL( T(2,N),PX,PVAX,XBSX,XLAX,XLSX,XLWX )
!
!---      Solubility of CO2 in aqueous phase  ---
!
          CALL EQUIL( T(2,N),PX,PVA(2,N),XBSX,XLA(2,N),XLS(2,N),
     &      XLW(2,N) )
!
!---      Brine density  ---
!
          CALL DENS_B( T(2,N),PX,XBSX,RHOBX )
!
!---      Aqueous density  ---
!
          CALL DENS_L( T(2,N),RHOBX,XLA(2,N),RHOL(2,N) )
!
!---      Aqueous mass  ---
!
          TMLX = RHOL(2,N)*PORD(2,N)*VOL(N)
!
!---      Gas + oil mass  ---
!
          TMGOX = TMC(1,2,N) + TMC(2,2,N)
!
!---      Gas + oil mass execeeds 1.e-5 of the
!         aqueous phase mass, transition to phase condition #2 or #3 ---
!
          IF( TMGOX.GT.(1.D-5*TMLX) ) THEN
            CALL SP_B( T(2,N),XBSX,PSBX )
            CALL VPL( PSBX,PVBX,SLX,T(2,N),N )
!
!---        Bubble-point pressure, assuming all gas is dissolved  ---
!
            RHOGX = 1.225D+0*GCPP(37,1)
            VGX = TMC(1,2,N)/RHOGX
            RHOOX = 1.D+3*GCPP(37,2)
            VOX = TMC(2,2,N)/RHOOX
            POSMX = VGX/VOX
            CALL BO_BP( PBPX,POSMX,T(2,N) )
!
!---        Pressure above bubble-point pressure  ---
!
            IF( PX.GT.PBPX ) THEN
              SN(2,N) = 1.D-4
              SL(2,N) = 1.D+0 - SN(2,N)
              SG(2,N) = 0.D+0
              POSM(2,N) = POSMX
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
!
!---        Pressure below bubble-point pressure  ---
!
            ELSE
              CALL BO_GOR( PX,POSM(2,N),T(2,N) )
              CALL BO_EQ_GAS( PX,PVBX,RHOG(2,N),T(2,N),XGC(1,2,N),
     &          XGW(2,N) )
              CALL BO_EQ_OIL( RHON(2,N),PX,POSM(2,N),T(2,N),XNC(1,2,N) )
              SGNX = 1.D-4
              SG(2,N) = SGNX*RHON(2,N)*(TMC(1,2,N)*XNC(2,2,N) - 
     &          TMC(2,2,N) + TMC(2,2,N)*XNC(2,2,N))/
     &          (RHON(2,N)*TMC(1,2,N)*XNC(2,2,N) - RHON(2,N)*TMC(2,2,N)
     &          + RHON(2,N)*TMC(2,2,N)*XNC(2,2,N) + 
     &          RHOG(2,N)*TMC(2,2,N)*XGC(1,2,N))
              SN(2,N) = SGNX - SG(2,N)
              SL(2,N) = 1.D+0-SGNX
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
            ENDIF
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #2  ---
!
!       SG = 0.0
!       SL > 0.0
!       SN > 0.0
!       Aqueous and nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
!
!---      Bubble-point pressure as a function of gas to oil ratio
!         (m^3/m^3) and temperature (C)  ---
!
          CALL BO_BP( PBPX,POSM(2,N),T(2,N) )
!
!---      Pressure below bubble-point pressure  ---
!
          IF( PX.LT.(PBPX-TOLX*GCPP(38,2)) ) THEN
            SG(2,N) = 1.D-4
            SN(2,N) = SN(2,N)*(1.D+0-SG(2,N))/(SN(2,N)+SL(2,N))
            SL(2,N) = 1.D+0-SG(2,N)-SN(2,N)
!
!---      Pressure above bubble-point pressure  ---
!
          ELSE
            SG(2,N) = 0.D+0
            SN(2,N) = 1.D+0-SL(2,N)
          ENDIF
          CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
!
!---      Nonaqueous phases disappears, transition to 
!         phase condition #1, conserving aqueous pressure  ---
!
          IF( (SG(2,N)+SN(2,N)).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 1
!
!---      Aqueous phases disappear, transition to 
!         phase condition #4  ---
!
          ELSEIF( (SG(2,N)+SL(2,N)).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
!
!---      Aqueous phase disappears and gas phase appears, transition to 
!         phase condition #5  ---
!
          ELSEIF( SL(2,N).LT.EPSL .AND. SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
!
!---      Gas phase appears, transition to phase condition #3  ---
!
          ELSEIF( SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
!
!---      No transition from phase condition #2  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #3  ---
!
!       SG > 0.0
!       SL > 0.0
!       SN > 0.0
!       Three-phase
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
!
!---      Aqueous disappears  ---
!
          IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
!
!---      Gas disappears  ---
!
          IF( SG(2,N).LT.EPSL ) THEN
            CALL BO_GOR( PX,POSM(2,N),T(2,N) )
            SG(2,N) = 0.D+0
          ENDIF
!
!---      Nonaqueous-liquid  ---
!
          SN(2,N) = 1.D+0-SL(2,N)-SG(2,N)
!
!---      Capillary pressure from saturations  ---
!
          CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
!
!---      Nonaqueous phases disappears, transition to 
!         phase condition #1  ---
!
          IF( (SG(2,N)+SN(2,N)).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 1
!
!---      Gas and aqueous phases disappear, transition to 
!         phase condition #4  ---
!
          ELSEIF( (SG(2,N)+SL(2,N)).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
!
!---      Aqueous phase disappears, transition to 
!         phase condition #5  ---
!
          ELSEIF( SL(2,N).LT.EPSL .AND. SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
!
!---      Gas phase disappears, transition to phase condition #2  ---
!
          ELSEIF( SG(2,N).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
!
!---      No transition from phase condition #3  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #4  ---
!
!       SG = 0.0
!       SL = 0.0
!       SN = 1.0
!       Nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
!
!---      Bubble-point pressure as a function of gas to oil ratio
!         (m^3/m^3) and temperature (C)  ---
!
          CALL BO_BP( PBPX,POSM(2,N),T(2,N) )
!
!---      Pressure below bubble-point pressure  ---
!
          IF( PX.LT.(PBPX-TOLX*GCPP(38,2)) ) THEN
            SG(2,N) = 1.D-4
            SN(2,N) = SN(2,N)*(1.D+0-SG(2,N))/(SN(2,N)+SL(2,N))
            SL(2,N) = 1.D+0-SG(2,N)-SN(2,N)
!
!---      Pressure above bubble-point pressure  ---
!
          ELSE
            SG(2,N) = 0.D+0
            SN(2,N) = 1.D+0-SL(2,N)
          ENDIF
!
!---      Aqueous phase appears, transition to 
!         phase condition #2 or #3  ---
!
          IF( SL(2,N).GT.1.D-6 ) THEN
!
!---        Gas phase appears, transition to phase condition #3  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
!
!---        No gas phase, transition to phase condition #2  ---
!
            ELSE
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
            ENDIF
!
!---      Gas phase appears, transition to phase condition #5  ---
!
          ELSEIF( SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
!
!---      No transition from phase condition #4  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #5  ---
!
!       SG > 0.0
!       SL = 0.0
!       SN > 0.0
!       Nonaqueous liquid and gas saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
          PX = PG(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
!
!---      Aqueous disappears  ---
!
          IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
!
!---      Gas disappears  ---
!
          IF( SG(2,N).LT.EPSL ) THEN
            CALL BO_GOR( PX,POSM(2,N),T(2,N) )
            SG(2,N) = 0.D+0
          ENDIF
!
!---      Nonaqueous-liquid  ---
!
          SN(2,N) = 1.D+0-SL(2,N)-SG(2,N)
!
!---      Capillary pressure from saturations  ---
!
          CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
!
!---      Aqueous phase appears, transition to 
!         phase condition #2 or #3  ---
!
          IF( SL(2,N).GT.1.D-6 ) THEN
!
!---        Gas phase disappears, transition to phase condition #2,
!           conserving nonaqueous-liquid pressure  ---
!
            IF( SG(2,N).LT.EPSL ) THEN
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
!
!---        Gas phase remains, transition to phase condition #3,
!           conserving gas pressure  ---
!
            ELSE
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
            ENDIF
!
!---      Gas phase disappears, transition to phase condition #4, 
!         conserving nonaqueous-liquid pressure  ---
!
          ELSEIF( SG(2,N).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
!
!---      No transition from phase condition #5  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
        ENDIF
!
!---    Compute increments  ---
!
!
!---    Phase condition #1  ---
!
!       SL = 1.0
!       SG+SN = 0.0
!       Aqueuous saturated
!
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       gas mass - total gas mass - TMC(1,2,N)
!       oil mass - total oil mass - TMC(2,2,N)
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      Water mass (system pressure), increment  ---
!
          DNR(IEQW,N) = MAX( 1.D-1,1.D-7*(PL(2,N)+PATM) )
!
!---      Gas mass (total gas mass), increment  ---
!
          DNR(IEQGC(1),N) = MAX( 1.D-7,1.D-7*TMC(1,2,N) )
!
!---      Oil mass (total oil mass), increment  ---
!
          DNR(IEQGC(2),N) = MAX( 1.D-7,1.D-7*TMC(2,2,N) )
!
!---      Salt mass (total salt brine mass fraction), increment  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            DNR(IEQS,N) = 1.D-7*XLSMX
          ENDIF
!
!---    Phase condition #2  ---
!
!       SG = 0.0
!       SL > 0.0
!       SN > 0.0
!       Aqueous and nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
          DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!
!---      Gas mass (gas to oil ratio) increment  ---
!
          DNR(IEQGC(1),N) = 1.D-6
!
!---      Oil mass (nonaqueous (system) pressure) increment   ---
!
          DNR(IEQGC(2),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
!
!---      Salt mass (total salt brine mass fraction), increment  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            DNR(IEQS,N) = 1.D-7*XLSMX
          ENDIF
!
!---    Phase condition #3  ---
!
!       SG > 0.0
!       SL > 0.0
!       SN > 0.0
!       Three-phase
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
          DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!
!---      Gas mass (gas (system) pressure) increment  ---
!
          DNR(IEQGC(1),N) = SIGN( 1.D-6,5.D-1-SG(2,N) )
!
!---      Oil mass (nonaqueous-liquid saturation) increment  ---
!
          DNR(IEQGC(2),N) = -MAX( 1.D-1,1.D-7*(PG(2,N)+PATM) )
!
!---      Salt mass (total salt brine mass fraction)  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            DNR(IEQS,N) = 1.D-7*XLSMX
          ENDIF
!
!---    Phase condition #4  ---
!
!       SG = 0.0
!       SL = 0.0
!       SN = 1.0
!       Nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
          DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!
!---      Gas mass (gas to oil ratio) increment  ---
!
          DNR(IEQGC(1),N) = 1.D-6
!
!---      Oil mass (nonaqueous (system) pressure) increment  ---
!
          DNR(IEQGC(2),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
!
!---      Salt mass (total salt mass), increment  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            DNR(IEQS,N) = 1.D-7
          ENDIF
!
!---    Phase condition #5  ---
!
!       SG > 0.0
!       SL = 0.0
!       SN > 0.0
!       Nonaqueous liquid and gas saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
          DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!
!---      Gas mass (gas (system) pressure) increment  ---
!
          DNR(IEQGC(1),N) = SIGN( 1.D-6,5.D-1-SG(2,N) )
!
!---      Oil mass (nonaqueous-liquid saturation) increment  ---
!
          DNR(IEQGC(2),N) = -MAX( 1.D-1,1.D-7*(PG(2,N)+PATM) )
!
!---      Salt mass (total salt mass)  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            DNR(IEQS,N) = 1.D-7
          ENDIF
        ENDIF
!
!---    Increment the primary variables  ---
!
        DO M = 3,ISVC+2
          T(M,N) = T(2,N)
          PG(M,N) = PG(2,N)
          PL(M,N) = PL(2,N)
          PN(M,N) = PN(2,N)
          POSM(M,N) = POSM(2,N)
          PSO(M,N) = PSO(2,N)
          PVA(M,N) = PVA(2,N)
          PVW(M,N) = PVW(2,N)
          SG(M,N) = SG(2,N)
          SL(M,N) = SL(2,N)
          SN(M,N) = SN(2,N)
          TMS(M,N) = TMS(2,N)
          YLS(M,N) = YLS(2,N)
          DO IGC = 1,NGC+2
            TMC(IGC,M,N) = TMC(IGC,2,N)
          ENDDO
!
!---      Phase condition #1  ---
!
!         SL = 1.0
!         SG+SN = 0.0
!         Aqueuous saturated
!
!         water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!         gas mass - total gas mass - TMC(1,2,N)
!         oil mass - total oil mass - TMC(2,2,N)
!         salt mass - total salt brine mass fraction - YLS
!
          IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
            IF( M.EQ.IEQW+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQGC(1)+2 ) THEN
              TMC(1,M,N) = TMC(1,M,N) + DNR(IEQGC(1),N)
            ELSEIF( M.EQ.IEQGC(2)+2 ) THEN
              TMC(2,M,N) = TMC(2,M,N) + DNR(IEQGC(2),N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Phase condition #2  ---
!
!         SG = 0.0
!         SL > 0.0
!         SN > 0.0
!         Aqueous and nonaqueous liquid saturated
!
!         water mass - aqueous saturation, SL
!         gas mass - gas to oil ratio, POSM
!         oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
            IF( M.EQ.IEQW+2 ) THEN
              SL(M,N) = SL(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQGC(1)+2 ) THEN
              POSM(M,N) = POSM(M,N) + DNR(IEQGC(1),N)
            ELSEIF( M.EQ.IEQGC(2)+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Phase condition #3  ---
!
!         SG > 0.0
!         SL > 0.0
!         SN > 0.0
!         Three-phase
!
!         water mass - aqueous saturation, SL
!         gas mass - gas saturation, SG
!         oil mass - gas (system) pressure, Pa gauge - PG,PSO
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
            IF( M.EQ.IEQW+2 ) THEN
              SL(M,N) = SL(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQGC(1)+2 ) THEN
              SG(M,N) = SG(M,N) + DNR(IEQGC(1),N)
            ELSEIF( M.EQ.IEQGC(2)+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Phase condition #4  ---
!
!         SG = 0.0
!         SL = 0.0
!         SN = 1.0
!         Nonaqueous liquid saturated
!
!         water mass - aqueous saturation, SL
!         gas mass - gas to oil ratio, POSM
!         oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
            IF( M.EQ.IEQW+2 ) THEN
              SL(M,N) = SL(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQGC(1)+2 ) THEN
              POSM(M,N) = POSM(M,N) + DNR(IEQGC(1),N)
            ELSEIF( M.EQ.IEQGC(2)+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              TMS(M,N) = TMS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---    Phase condition #5  ---
!
!       SG > 0.0
!       SL = 0.0
!       SN > 0.0
!       Nonaqueous liquid and gas saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
            IF( M.EQ.IEQW+2 ) THEN
              SL(M,N) = SL(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQGC(1)+2 ) THEN
              SG(M,N) = SG(M,N) + DNR(IEQGC(1),N)
            ELSEIF( M.EQ.IEQGC(2)+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              TMS(M,N) = TMS(M,N) + DNR(IEQS,N)
            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of INCRM_BO group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE INCRM_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute primary variable increments.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE PROP
      USE GLB_PAR
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE CCP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 FKX(LNGC)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/INCRM_EOR'
!
!---  Black-oil option  ---
!
      IF( ISLC(68).EQ.0 ) THEN
        CALL INCRM_BO
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
      PETA = 1.D-1
      EPSLX = 1.D-4
!
!---  Loop over local grid cells, including ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip inactive cells  ---
!
        IF( IXP(N).EQ.0 ) CYCLE
        N_DB = ND(N)
!
!---    K-factors fixed at second iterate values  ---
!
        IF( NITER.GT.2 ) THEN
          IFK = 1
          DO IGC = 1,NGC+2
            FKX(IGC) = FK(IGC,N)
          ENDDO
!
!---    K-factors computed from fugacity coefficients  ---
!
        ELSE
          IFK = 0
        ENDIF
!
!---    Absolute temperature  ---
!
        TKX = T(2,N)+TABS
!
!---    Phase condition #1  ---
!
!       SL = 1.0, SG+SN = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       CO2 mass - CO2 vapor pressure - PVA
!       CH4 mass - total CH4 mass - TMC
!       petroleum component mass - total petroleum component mass - TMC
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      System pressure  ---
!
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
          CALL SP_B( T(2,N),XBSX,PSBX )
!
!---      Maximum solubility of CO2 in aqueous phase  ---
!
          PVAX = PX - PSBX
          CALL EQUIL( T(2,N),PX,PVAX,XBSX,XLAX,XLSX,XLWX )
!
!---      Solubility of CO2 in aqueous phase  ---
!
          CALL EQUIL( T(2,N),PX,PVA(2,N),XBSX,XLA(2,N),XLS(2,N),
     &      XLW(2,N) )
!
!---      Brine density  ---
!
          CALL DENS_B( T(2,N),PX,XBSX,RHOBX )
!
!---      Aqueous density  ---
!
          CALL DENS_L( T(2,N),RHOBX,XLA(2,N),RHOL(2,N) )
!
!---      Total mass of CO2  ---
!
          TMC(1,2,N) = XLA(2,N)*RHOL(2,N)*PORD(2,N)*VOL(N)
!
!---      Non-CO2 petroleum mass and total petroleum molar mass  ---
!
          STMCX = -TMC(1,2,N)
          STMMCX = 0.D+0
          DO IGC = 1,NGC+2
            STMCX = STMCX + TMC(IGC,2,N)
            STMMCX = STMMCX + TMC(IGC,2,N)/GCPP(1,IGC)
          ENDDO
          IF( STMMCX.GT.EPSL ) THEN
            ZMCMX = 0.D+0
            DO IGC = 1,NGC+2
              ZMC(IGC,2,N) = TMC(IGC,2,N)/GCPP(1,IGC)/STMMCX
              IF( ZMC(IGC,2,N).GT.ZMCMX ) THEN
                IZMC(N) = IGC
                ZMCMX = ZMC(IGC,2,N)
              ENDIF
            ENDDO
          ELSE
            ZMC(1,2,N) = 1.D+0
            IZMC(N) = 1
            DO IGC = 2,NGC+2
              ZMC(IGC,2,N) = 0.D+0
            ENDDO
          ENDIF
!
!---      Aqueous mass  ---
!
          TMLX = RHOL(2,N)*PORD(2,N)*VOL(N)
!
!---      Mixture critical properties ---
!
          CALL CRIT_PROP( PAFX,PCRX,TBPX,TCRX,VMCRX,ZMC(1,2,N),ZCRX )
!
!---      Mixture vapor pressure (Pa), Riedel equation ---
!
          TRX = TKX/TCRX
          TBRX = TKX/TBPX
          PSI_BX = -3.5D+1 + 3.6D+1/TBRX + 4.2D+1*LOG(TBRX) - TBRX**6
          ALPHA_CX = (3.15D-1*PSI_BX + LOG(PCRX/PATM))/
     &      (8.38D-2*PSI_BX - LOG(TBRX))
          QX = 8.38D-2*(3.758D+0 - ALPHA_CX)
          AX = -3.5D+1*QX
          BX = -3.6D+1*QX
          CX = 4.2D+1*QX + ALPHA_CX
          DX = -QX
          PVPX = PATM*EXP( AX - BX/TRX + CX*LOG(TRX) + DX*(TRX**6) )
!
!---      Air concentration from vapor pressure  ---
!
          CASX = PVPX/(RCU*TKX)
!
!---      Carbon number from air concentration from Eastcott et al.  ---
!
          CNX = -(LOG10(CASX) - 4.35D+0)/5.7D-1
!
!---      Aqueous solubility (mol/cm^3) as a function of carbon 
!         number for aromatics from Eastcott et al.  ---
!
          CLSX = 1.D+1**(1.88D+0 - 2.4D-1*CNX)
!
!---      Aqueous concentration of organics (mol/cm^3)  ---
!
          CLCX = 1.D-3*STMMCX/(PORD(2,N)*VOL(N))
!
!---      CO2 concentration in aqueous phase exceeds solubility limit
!         or total petroleum component mass execeeds solubility limit,
!         transition to phase condition #2 or #3 ---
!
          IF( XLA(2,N).GT.XLAX .OR. CLCX.GT.CLSX ) THEN
            CALL SP_B( T(2,N),XBSX,PSBX )
            CALL VPL( PSBX,PVBX,SLX,T(2,N),N )
            PVX = PX - PVBX
            IBETAX = 0
            BETAX = -1.D+0
            GNIFTX = 0.D+0
            CALL FLH_NA( BETAX,FKX,GNIFTX,PVX,PVBX,RHOMG(2,N),
     &        RHOMN(2,N),SGX,SNX,T(2,N),XMGC(1,2,N),XMGW(2,N),
     &        XMNC(1,2,N),ZGX,ZMC(1,2,N),ZNX,IBETAX,NPHAZ(2,N) )
            SGNX = 1.D-4
            SL(2,N) = 1.D+0-SGNX
            SG(2,N) = (1.D+0-SL(2,N))*SGX
            SN(2,N) = (1.D+0-SL(2,N))*SNX
!            AST(N) = SGX/(SGX+SNX+SMALL)
            CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
            IF( SG(2,N).LT.EPSL ) THEN
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
            ELSE
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
            ENDIF
          ELSE
            CPGTX = 0.D+0
            CPNLX = 0.D+0
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #2  ---
!
!       SL < 1.0, ST > 0.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
          PVX = PX - PVBX
          IBETAX = 0
          BETAX = -1.D+0
          GNIFTX = 0.D+0
          CALL FLH_NA( BETAX,FKX,GNIFTX,PVX,PVBX,RHOMG(2,N),
     &      RHOMN(2,N),SGX,SNX,T(2,N),XMGC(1,2,N),XMGW(2,N),
     &      XMNC(1,2,N),ZGX,ZMC(1,2,N),ZNX,IBETAX,NPHAZ(2,N) )
!          IF( NITER.GE.2 ) THEN
!            SGX = AST(N)
!            SNX = 1.D+0 - AST(N)
!          ELSE
!            AST(N) = SGX/(SNX+SGX+SMALL)
!          ENDIF
          SG(2,N) = (1.D+0-SL(2,N))*SGX
          SN(2,N) = (1.D+0-SL(2,N))*SNX
          CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
!
!---      Assign maximum concentration of petroleum component  ---
!
          ZMCMX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ZMC(IGC,2,N).GT.ZMCMX ) THEN
              IZMC(N) = IGC
              ZMCMX = ZMC(IGC,2,N)
            ENDIF
          ENDDO
!
!---      Nonaqueous phases disappears, transition to 
!         phase condition #1, conserving aqueous pressure  ---
!
          IF( (SG(2,N)+SN(2,N)).LT.1.D-3 ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 1
!
!---      Aqueous phases disappear, transition to 
!         phase condition #4  ---
!
          ELSEIF( (SG(2,N)+SL(2,N)).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
!
!---      Aqueous phase disappears and gas phase appears, transition to 
!         phase condition #5  ---
!
          ELSEIF( SL(2,N).LT.EPSL .AND. SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
!
!---      Gas phase appears, transition to phase condition #3  ---
!
          ELSEIF( SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
!
!---      No transition from phase condition #2  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #3  ---
!
!       SL < 1.0, ST >= 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
          PVX = PX - PVBX
          IBETAX = 0
          BETAX = -1.D+0
          GNIFTX = 0.D+0
          CALL FLH_NA( BETAX,FKX,GNIFTX,PVX,PVBX,RHOMG(2,N),RHOMN(2,N),
     &      SGX,SNX,T(2,N),XMGC(1,2,N),XMGW(2,N),XMNC(1,2,N),
     &      ZGX,ZMC(1,2,N),ZNX,IBETAX,NPHAZ(2,N) )
!          IF( NITER.GE.2 ) THEN
!            SGX = AST(N)
!            SNX = 1.D+0 - AST(N)
!          ELSE
!            AST(N) = SGX/(SNX+SGX+SMALL)
!          ENDIF
          SG(2,N) = (1.D+0-SL(2,N))*SGX
          SN(2,N) = (1.D+0-SL(2,N))*SNX
          CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
!
!---      Assign maximum concentration of petroleum component  ---
!
          ZMCMX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ZMC(IGC,2,N).GT.ZMCMX ) THEN
              IZMC(N) = IGC
              ZMCMX = ZMC(IGC,2,N)
            ENDIF
          ENDDO
!
!---      Nonaqueous phases disappears, transition to 
!         phase condition #1  ---
!
          IF( (SG(2,N)+SN(2,N)).LT.1.D-3 ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 1
!
!---      Gas and aqueous phases disappear, transition to 
!         phase condition #4  ---
!
          ELSEIF( (SG(2,N)+SL(2,N)).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
!
!---      Aqueous phase disappears, transition to 
!         phase condition #5  ---
!
          ELSEIF( SL(2,N).LT.EPSL .AND. SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
!
!---      Gas phase disappears, transition to phase condition #2  ---
!
          ELSEIF( SG(2,N).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
!
!---      No transition from phase condition #3  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #4  ---
!
!       SL = 0.0, ST = 1.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
          PX = PSO(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
          PVX = PX - PVBX
          IBETAX = 0
          BETAX = -1.D+0
          GNIFTX = 0.D+0
          CALL FLH_NA( BETAX,FKX,GNIFTX,PVX,PVBX,RHOMG(2,N),RHOMN(2,N),
     &      SGX,SNX,T(2,N),XMGC(1,2,N),XMGW(2,N),XMNC(1,2,N),
     &      ZGX,ZMC(1,2,N),ZNX,IBETAX,NPHAZ(2,N) )
          SG(2,N) = (1.D+0-SL(2,N))*SGX
!          IF( NITER.GE.2 ) THEN
!            SGX = AST(N)
!            SNX = 1.D+0 - AST(N)
!          ELSE
!            AST(N) = SGX/(SNX+SGX+SMALL)
!          ENDIF
          SN(2,N) = (1.D+0-SL(2,N))*SNX
          CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
!
!---      Assign maximum concentration of petroleum component  ---
!
          ZMCMX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ZMC(IGC,2,N).GT.ZMCMX ) THEN
              IZMC(N) = IGC
              ZMCMX = ZMC(IGC,2,N)
            ENDIF
          ENDDO
!
!---      Aqueous phase appears, transition to 
!         phase condition #2 or #3  ---
!
          IF( SL(2,N).GT.1.D-6 ) THEN
!
!---        Gas phase appears, transition to phase condition #3  ---
!
            IF( SG(2,N).GT.EPSL ) THEN
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
!
!---        No gas phase, transition to phase condition #2  ---
!
            ELSE
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
            ENDIF
!
!---      Gas phase appears, transition to phase condition #5  ---
!
          ELSEIF( SG(2,N).GT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
!
!---      No transition from phase condition #4  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
!
!---    Phase condition #5  ---
!
!       SL = 0.0, ST >= 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
          PX = PG(2,N) + PATM
!
!---      Maximum solubility of salt in pure water  ---
!
          CALL SOL_LS( T(2,N),XBSMX )
!
!---      Salt mass fraction in brine  ---
!
          XBSX = MIN( YLS(2,N),XBSMX )
!
!---      Nonaqueous flash calculation  ---
!
          CALL SP_B( T(2,N),XBSX,PSBX )
          CALL VPL( PSBX,PVBX,SL(2,N),T(2,N),N )
          PVX = PX - PVBX
          IBETAX = 0
          BETAX = -1.D+0
          GNIFTX = 0.D+0
          CALL FLH_NA( BETAX,FKX,GNIFTX,PVX,PVBX,RHOMG(2,N),RHOMN(2,N),
     &      SGX,SNX,T(2,N),XMGC(1,2,N),XMGW(2,N),XMNC(1,2,N),
     &      ZGX,ZMC(1,2,N),ZNX,IBETAX,NPHAZ(2,N) )
!          IF( NITER.GE.2 ) THEN
!            SGX = AST(N)
!            SNX = 1.D+0 - AST(N)
!          ELSE
!            AST(N) = SGX/(SNX+SGX+SMALL)
!          ENDIF
          SG(2,N) = (1.D+0-SL(2,N))*SGX
          SN(2,N) = (1.D+0-SL(2,N))*SNX
          CALL CAP_EOR( SG(2,N),SL(2,N),SN(2,N),CPGTX,CPNLX,N )
!
!---      Assign maximum concentration of petroleum component  ---
!
          ZMCMX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ZMC(IGC,2,N).GT.ZMCMX ) THEN
              IZMC(N) = IGC
              ZMCMX = ZMC(IGC,2,N)
            ENDIF
          ENDDO
!
!---      Aqueous phase appears, transition to 
!         phase condition #2 or #3  ---
!
          IF( SL(2,N).GT.1.D-6 ) THEN
!
!---        Gas phase disappears, transition to phase condition #2,
!           conserving nonaqueous-liquid pressure  ---
!
            IF( SG(2,N).LT.EPSL ) THEN
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 2
!
!---        Gas phase remains, transition to phase condition #3,
!           conserving gas pressure  ---
!
            ELSE
              NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 3
            ENDIF
!
!---      Gas phase disappears, transition to phase condition #4, 
!         conserving nonaqueous-liquid pressure  ---
!
          ELSEIF( SG(2,N).LT.EPSL ) THEN
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 4
!
!---      No transition from phase condition #5  ---
!
          ELSE
            NPHAZ(2,N) = 10*(NPHAZ(2,N)/10) + 5
          ENDIF
!
!---      Phase pressure from phase capillary pressures and system
!         pressure  ---
!
          PG(2,N) = PSO(2,N)
          PTX = PG(2,N) - CPGTX
          IF( CPNLX.GT.0.D+0 ) THEN
            PN(2,N) = PTX
            PL(2,N) = PN(2,N) - CPNLX
          ELSE
            PL(2,N) = PTX
            PN(2,N) = PL(2,N) + CPNLX
          ENDIF
        ENDIF
!
!---    Compute increments  ---
!
!
!---    Absolute temperature  ---
!
        TKX = T(2,N)+TABS
!
!---    Phase condition #1  ---
!
!       SL = 1.0, SG+SN = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       CO2 mass - CO2 vapor pressure - PVA
!       CH4 mass - total CH4 mass - TMC
!       petroleum component mass - total petroleum component mass - TMC
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      Energy (temperature), increment  ---
!
          IF( ISLC(30).EQ.0 ) DNR(IEQT,N) = -1.D-7
!
!---      Water mass (system pressure), increment  ---
!
          DNR(IEQW,N) = MAX( 1.D-1,1.D-7*(PL(2,N)+PATM) )
!
!---      CO2 mass (CO2 vapor pressure), increment  ---
!
          IF( ISLC(45).EQ.0 ) DNR(IEQGC(1),N) = 1.D-2
!!
!!---      Aqueous mass  ---
!!
!          TMLX = RHOL(2,N)*PORD(2,N)*VOL(N)
!!
!!---      CH4 mass (total CH4 mass), increment  ---
!!
!          IF( ISLC(64).EQ.0 ) 
!     &      DNR(IEQGC(2),N) = MAX( 1.D-7*TMLX,1.D-6 )
!!
!!---      Petroleum component mass (total petroleum component mass),
!!         increment  ---
!!
!          DO IGC = 3,NGC+2
!            DNR(IEQGC(IGC),N) = MAX( 1.D-7*TMLX,1.D-6 )
!          ENDDO
!
!---      CH4 mass (total CH4 mass), increment  ---
!
          IF( ISLC(64).EQ.0 ) 
     &      DNR(IEQGC(2),N) = MAX( 1.D-7,1.D-7*TMC(2,2,N) )
!
!---      Petroleum component mass (total petroleum component mass),
!         increment  ---
!
          DO IGC = 3,NGC+2
            DNR(IEQGC(IGC),N) = MAX( 1.D-7,1.D-7*TMC(IGC,2,N) )
          ENDDO
!
!---      Salt mass (total salt brine mass fraction), increment  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            DNR(IEQS,N) = 1.D-7*XLSMX
          ENDIF
!
!---    Phase condition #2  ---
!
!       SL < 1.0, ST > 0.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---      Energy (temperature), increment  ---
!
          IF( ISLC(30).EQ.0 ) DNR(IEQT,N) = -1.D-7
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
!          IF( SL(2,N).GT.5.D-1 ) THEN
            NPHAZ(2,N) = MOD( NPHAZ(2,N),100) + 100
            DNR(IEQW,N) = MAX( 1.D-1,1.D-7*PSO(2,N) )
!          ELSE
!            NPHAZ(2,N) = MOD( NPHAZ(2,N),100 )
!            DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!          ENDIF
!
!---      CO2 mass increment  ---
!
          IF( ISLC(45).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.1 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(1),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(1),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Decrease mole fraction of volatile components,
!             and increase mole fraction of non-volatile components  ---
!
              IF( ZMC(1,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(1),N) = -MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(1),N) = MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      CH4 mass increment  ---
!
          IF( ISLC(64).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(2),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(2),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
              ENDIF            
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Decrease mole fraction of volatile components,
!             and increase mole fraction of non-volatile components  ---
!
              IF( ZMC(2,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(2),N) = -MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(2),N) = MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      Petroleum component mass (total petroleum component mass),
!         increment  ---
!
          DO IGC = 3,NGC+2
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.IGC ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(IGC),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(IGC),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
              ENDIF            
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Decrease mole fraction of volatile components,
!             and increase mole fraction of non-volatile components  ---
!
              IF( ZMC(IGC,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(IGC),N) = -MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(IGC),N) = MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDDO
!
!---      Salt mass (total salt brine mass fraction), increment  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            DNR(IEQS,N) = 1.D-7*XLSMX
          ENDIF
!
!---    Phase condition #3  ---
!
!       SL < 1.0, ST > 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---      Energy (temperature), increment  ---
!
          IF( ISLC(30).EQ.0 ) DNR(IEQT,N) = 1.D-7
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
!          IF( SL(2,N).GT.5.D-1 ) THEN
            NPHAZ(2,N) = MOD( NPHAZ(2,N),100) + 100
            DNR(IEQW,N) = MAX( 1.D-1,1.D-7*PSO(2,N) )
!          ELSE
!            NPHAZ(2,N) = MOD( NPHAZ(2,N),100 )
!            DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!          ENDIF
!
!---      CO2 mass increment  ---
!
          IF( ISLC(45).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.1 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(1),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(1),N) = -MAX( 1.D-1,1.D-5*(PG(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Increase mole fraction of volatile components,
!             and decrease mole fraction of non-volatile components  ---
!
              IF( ZMC(1,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(1),N) = -MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(1),N) = MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      CH4 mass increment  ---
!
          IF( ISLC(64).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(2),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(2),N) = -MAX( 1.D-1,1.D-5*(PG(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Increase mole fraction of volatile components,
!             and decrease mole fraction of non-volatile components  ---
!
              IF( ZMC(2,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(2),N) = -MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(2),N) = MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      Petroleum component mass (total petroleum component mass),
!         increment  ---
!
          DO IGC = 3,NGC+2
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.IGC ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(IGC),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(IGC),N) = -MAX( 1.D-1,1.D-5*(PG(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Increase mole fraction of volatile components,
!             and decrease mole fraction of non-volatile components  ---
!
              IF( ZMC(IGC,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(IGC),N) = -MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(IGC),N) = MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDDO
!
!---      Salt mass (total salt brine mass fraction)  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            DNR(IEQS,N) = 1.D-7*XLSMX
          ENDIF
!
!---    Phase condition #4  ---
!
!       SL = 0.0, ST = 1.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---      Energy (temperature), increment  ---
!
          IF( ISLC(30).EQ.0 ) DNR(IEQT,N) = -1.D-7
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
!          IF( SL(2,N).GT.5.D-1 ) THEN
            NPHAZ(2,N) = MOD( NPHAZ(2,N),100) + 100
            DNR(IEQW,N) = MAX( 1.D-1,1.D-7*PSO(2,N) )
!          ELSE
!            NPHAZ(2,N) = MOD( NPHAZ(2,N),100 )
!            DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!          ENDIF
!
!---      CO2 mass increment  ---
!
          IF( ISLC(45).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.1 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(1),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(1),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Decrease mole fraction of volatile components,
!             and increase mole fraction of non-volatile components  ---
!
              IF( ZMC(1,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(1),N) = -MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(1),N) = MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      CH4 mass increment  ---
!
          IF( ISLC(64).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(2),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(2),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Decrease mole fraction of volatile components,
!             and increase mole fraction of non-volatile components  ---
!
              IF( ZMC(2,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(2),N) = -MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(2),N) = MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      Petroleum component mass (total petroleum component mass),
!         increment  ---
!
          DO IGC = 3,NGC+2
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.IGC ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(IGC),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(IGC),N) = MAX( 1.D-1,1.D-7*(PN(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Decrease mole fraction of volatile components,
!             and increase mole fraction of non-volatile components  ---
!
              IF( ZMC(IGC,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(IGC),N) = -MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(IGC),N) = MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDDO
!
!---      Salt mass (total salt mass), increment  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            DNR(IEQS,N) = 1.D-7
          ENDIF
!
!---    Phase condition #5  ---
!
!       SL = 0.0, ST >= 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---      Energy (temperature), increment  ---
!
          IF( ISLC(30).EQ.0 ) DNR(IEQT,N) = -1.D-7
!
!---      Water mass (aqueous saturation), increment or decrement  ---
!
!          IF( SL(2,N).GT.5.D-1 ) THEN
            NPHAZ(2,N) = MOD( NPHAZ(2,N),100) + 100
            DNR(IEQW,N) = MAX( 1.D-1,1.D-7*PSO(2,N) )
!          ELSE
!            NPHAZ(2,N) = MOD( NPHAZ(2,N),100 )
!            DNR(IEQW,N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
!          ENDIF
!
!---      CO2 mass increment  ---
!
          IF( ISLC(45).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.1 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(1),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(1),N) = -MAX( 1.D-1,1.D-7*(PG(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Increase mole fraction of volatile components,
!             and decrease mole fraction of non-volatile components  ---
!
              IF( ZMC(1,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(1),N) = -MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(1),N) = MAX( 1.D-6*ZMC(1,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      CH4 mass increment  ---
!
          IF( ISLC(64).EQ.0 ) THEN
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(2),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(2),N) = -MAX( 1.D-1,1.D-7*(PG(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
 !
!---          Increase mole fraction of volatile components,
!             and decrease mole fraction of non-volatile components  ---
!
              IF( ZMC(2,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(2),N) = -MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(2),N) = MAX( 1.D-6*ZMC(2,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDIF
!
!---      Petroleum component mass (total petroleum component mass),
!         increment  ---
!
          DO IGC = 3,NGC+2
!
!---        System pressure, increment  ---
!
            IF( IZMC(N).EQ.IGC ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DNR(IEQGC(IGC),N) = SIGN( 1.D-6,5.D-1-SL(2,N) )
              ELSE
                DNR(IEQGC(IGC),N) = -MAX( 1.D-1,1.D-7*(PG(2,N)+PATM) )
              ENDIF
!
!---        Nonaqueous mole fraction, increment  ---
!
            ELSE
!
!---          Increase mole fraction of volatile components,
!             and decrease mole fraction of non-volatile components  ---
!
              IF( ZMC(IGC,2,N).GT.9.D-1 ) THEN
                DNR(IEQGC(IGC),N) = -MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ELSE
                DNR(IEQGC(IGC),N) = MAX( 1.D-6*ZMC(IGC,2,N),1.D-9 )
              ENDIF
            ENDIF
          ENDDO
!
!---      Salt mass (total salt mass)  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            DNR(IEQS,N) = 1.D-7
          ENDIF
        ENDIF
!
!---    Increment the primary variables  ---
!
        DO M = 3,ISVC+2
          T(M,N) = T(2,N)
          PG(M,N) = PG(2,N)
          PL(M,N) = PL(2,N)
          PN(M,N) = PN(2,N)
          PSO(M,N) = PSO(2,N)
          PVA(M,N) = PVA(2,N)
          PVW(M,N) = PVW(2,N)
          SL(M,N) = SL(2,N)
          TMS(M,N) = TMS(2,N)
          YLS(M,N) = YLS(2,N)
          DO IGC = 1,NGC+2
            TMC(IGC,M,N) = TMC(IGC,2,N)
            ZMC(IGC,M,N) = ZMC(IGC,2,N)
          ENDDO
!
!---      Phase condition #1  ---
!
!         SL = 1.0, SG+SN = 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!         CO2 mass - CO2 vapor pressure - PVA
!         CH4 mass - total CH4 mass - TMC
!         petroleum component mass - total petroleum comp. mass - TMC
!         salt mass - total salt brine mass fraction - YLS
!
          IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
            IF( M.EQ.IEQT+2 .AND. ISLC(30).EQ.0 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQGC(1)+2 .AND. ISLC(45).EQ.0 ) THEN
              PVA(M,N) = PVA(M,N) + DNR(IEQGC(1),N)
            ELSEIF( M.EQ.IEQGC(2)+2 .AND. ISLC(64).EQ.0 ) THEN
              TMC(2,M,N) = TMC(2,M,N) + DNR(IEQGC(2),N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ELSE
              DO IGC = 3,NGC+2
                IF( M.EQ.IEQGC(IGC)+2 ) THEN
                  TMC(IGC,M,N) = TMC(IGC,M,N) + DNR(IEQGC(IGC),N)
                ENDIF
              ENDDO
            ENDIF
!
!---      Phase condition #2  ---
!
!         SL < 1.0, ST > 0.0, SG = 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
            IF( M.EQ.IEQT+2 .AND. ISLC(30).EQ.0 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
              ELSE
                SL(M,N) = SL(M,N) + DNR(IEQW,N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(1)+2 .AND. ISLC(45).EQ.0 ) THEN
              IF( IZMC(N).EQ.1 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(1),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(1),N)
                ENDIF
              ELSE
                ZMC(1,M,N) = ZMC(1,M,N) + DNR(IEQGC(1),N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(2)+2 .AND. ISLC(64).EQ.0 ) THEN
              IF( IZMC(N).EQ.2 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(2),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
                ENDIF
              ELSE
                ZMC(2,M,N) = ZMC(2,M,N) + DNR(IEQGC(2),N)
              ENDIF
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ELSE
              DO IGC = 3,NGC+2
                IF( M.EQ.IEQGC(IGC)+2 ) THEN
                  IF( IZMC(N).EQ.IGC ) THEN
                    IF( NPHAZ(2,N).GT.100 ) THEN
                      SL(M,N) = SL(M,N) + DNR(IEQGC(IGC),N)
                    ELSE
                      PSO(M,N) = PSO(M,N) + DNR(IEQGC(IGC),N)
                    ENDIF
                  ELSE
                    ZMC(IGC,M,N) = ZMC(IGC,M,N) + DNR(IEQGC(IGC),N)
                  ENDIF
                ENDIF
              ENDDO
            ENDIF
!
!---      Phase condition #3  ---
!
!         SL < 1.0, ST > 0.0, SG > 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
            IF( M.EQ.IEQT+2 .AND. ISLC(30).EQ.0 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
              ELSE
                SL(M,N) = SL(M,N) + DNR(IEQW,N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(1)+2 .AND. ISLC(45).EQ.0 ) THEN
              IF( IZMC(N).EQ.1 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(1),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(1),N)
                ENDIF
              ELSE
                ZMC(1,M,N) = ZMC(1,M,N) + DNR(IEQGC(1),N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(2)+2 .AND. ISLC(64).EQ.0 ) THEN
              IF( IZMC(N).EQ.2 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(2),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
                ENDIF
              ELSE
                ZMC(2,M,N) = ZMC(2,M,N) + DNR(IEQGC(2),N)
              ENDIF
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ELSE
              DO IGC = 3,NGC+2
                IF( M.EQ.IEQGC(IGC)+2 ) THEN
                  IF( IZMC(N).EQ.IGC ) THEN
                    IF( NPHAZ(2,N).GT.100 ) THEN
                      SL(M,N) = SL(M,N) + DNR(IEQGC(IGC),N)
                    ELSE
                      PSO(M,N) = PSO(M,N) + DNR(IEQGC(IGC),N)
                    ENDIF
                  ELSE
                    ZMC(IGC,M,N) = ZMC(IGC,M,N) + DNR(IEQGC(IGC),N)
                  ENDIF
                ENDIF
              ENDDO
            ENDIF
!
!---      Phase condition #4  ---
!
!         SL = 0.0, ST = 1.0, SG = 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
            IF( M.EQ.IEQT+2 .AND. ISLC(30).EQ.0 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
              ELSE
                SL(M,N) = SL(M,N) + DNR(IEQW,N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(1)+2 .AND. ISLC(45).EQ.0 ) THEN
              IF( IZMC(N).EQ.1 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(1),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(1),N)
                ENDIF
              ELSE
                ZMC(1,M,N) = ZMC(1,M,N) + DNR(IEQGC(1),N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(2)+2 .AND. ISLC(64).EQ.0 ) THEN
              IF( IZMC(N).EQ.2 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(2),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
                ENDIF
              ELSE
                ZMC(2,M,N) = ZMC(2,M,N) + DNR(IEQGC(2),N)
              ENDIF
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              TMS(M,N) = TMS(M,N) + DNR(IEQS,N)
            ELSE
              DO IGC = 3,NGC+2
                IF( M.EQ.IEQGC(IGC)+2 ) THEN
                  IF( IZMC(N).EQ.IGC ) THEN
                    IF( NPHAZ(2,N).GT.100 ) THEN
                      SL(M,N) = SL(M,N) + DNR(IEQGC(IGC),N)
                    ELSE
                      PSO(M,N) = PSO(M,N) + DNR(IEQGC(IGC),N)
                    ENDIF
                  ELSE
                    ZMC(IGC,M,N) = ZMC(IGC,M,N) + DNR(IEQGC(IGC),N)
                  ENDIF
                ENDIF
              ENDDO
            ENDIF
!
!---      Phase condition #5  ---
!
!         SL = 0.0, ST >= 0.0, SG > 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
            IF( M.EQ.IEQT+2 .AND. ISLC(30).EQ.0 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                PSO(M,N) = PSO(M,N) + DNR(IEQW,N)
              ELSE
                SL(M,N) = SL(M,N) + DNR(IEQW,N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(1)+2 .AND. ISLC(45).EQ.0 ) THEN
              IF( IZMC(N).EQ.1 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(1),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(1),N)
                ENDIF
              ELSE
                ZMC(1,M,N) = ZMC(1,M,N) + DNR(IEQGC(1),N)
              ENDIF
            ELSEIF( M.EQ.IEQGC(2)+2 .AND. ISLC(64).EQ.0 ) THEN
              IF( IZMC(N).EQ.2 ) THEN
                IF( NPHAZ(2,N).GT.100 ) THEN
                  SL(M,N) = SL(M,N) + DNR(IEQGC(2),N)
                ELSE
                  PSO(M,N) = PSO(M,N) + DNR(IEQGC(2),N)
                ENDIF
              ELSE
                ZMC(2,M,N) = ZMC(2,M,N) + DNR(IEQGC(2),N)
              ENDIF
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              TMS(M,N) = TMS(M,N) + DNR(IEQS,N)
            ELSE
              DO IGC = 3,NGC+2
                IF( M.EQ.IEQGC(IGC)+2 ) THEN
                  IF( IZMC(N).EQ.IGC ) THEN
                    IF( NPHAZ(2,N).GT.100 ) THEN
                      SL(M,N) = SL(M,N) + DNR(IEQGC(IGC),N)
                    ELSE
                      PSO(M,N) = PSO(M,N) + DNR(IEQGC(IGC),N)
                    ENDIF
                  ELSE
                    ZMC(IGC,M,N) = ZMC(IGC,M,N) + DNR(IEQGC(IGC),N)
                  ENDIF
                ENDIF
              ENDDO
            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of INCRM_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LDO_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Load the current time step values into the old time step
!     variables.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE HYST
      USE GRID
      USE FDVP
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LDO_EOR'
!
!---  Loop over local grid cells, including ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip inactive grid cells  ---
!
        IF( IXP(N).EQ.0 ) CYCLE
!
!---  Assign old time step values  ---
!
        DO 10 IGC = 1,NGC+2
          DFGC(IGC,1,N) = DFGC(IGC,2,N)
          DFNC(IGC,1,N) = DFNC(IGC,2,N)
          TMC(IGC,1,N) = TMC(IGC,2,N)
          XGC(IGC,1,N) = XGC(IGC,2,N)
          XMGC(IGC,1,N) = XMGC(IGC,2,N)
          XLC(IGC,1,N) = XLC(IGC,2,N)
          XMLC(IGC,1,N) = XMLC(IGC,2,N)
          XMNC(IGC,1,N) = XMNC(IGC,2,N)
          XNC(IGC,1,N) = XNC(IGC,2,N)
          ZMC(IGC,1,N) = ZMC(IGC,2,N)
   10   CONTINUE
        ASLMIN(1,N) = MIN( ASL(N),ASLMIN(2,N) )
        ASLMIN(2,N) = ASLMIN(1,N)
        DO M = 1,6
          BETA(M,N) = 0.D+0
        ENDDO
        IBETA(N) = 0
        DFGW(1,N) = DFGW(2,N)
        DFLA(1,N) = DFLA(2,N)
        DFLS(1,N) = DFLS(2,N)
        GNIFT(1,N) = GNIFT(2,N)
!
!---    Isothermal option  ---
!
        IF( ISLC(30).EQ.0 ) THEN
          HG(1,N) = HG(2,N)
          HGA(1,N) = HGA(2,N)
          HGW(1,N) = HGW(2,N)
          HL(1,N) = HL(2,N)
          HLW(1,N) = HLW(2,N)
          HN(1,N) = HN(2,N)
          HSP(1,N) = HSP(2,N)
          UEG(1,N) = UEG(2,N)
          UEL(1,N) = UEL(2,N)
          UEN(1,N) = UEN(2,N)
          THKG(1,N) = THKG(2,N)
          THKL(1,N) = THKL(2,N)
          THKN(1,N) = THKN(2,N)
        ENDIF
        NPHAZ(1,N) = NPHAZ(2,N)
        PERMRF(1,N) = PERMRF(2,N)
        PG(1,N) = PG(2,N)
        PL(1,N) = PL(2,N)
        PN(1,N) = PN(2,N)
        POSM(1,N) = POSM(2,N)
        PSO(1,N) = PSO(2,N)
        PORD(1,N) = PORD(2,N)
        PORT(1,N) = PORT(2,N)
        PVA(1,N) = PVA(2,N)
        PVW(1,N) = PVW(2,N)
        RHOG(1,N) = RHOG(2,N)
        RHOL(1,N) = RHOL(2,N)
        RHOMG(1,N) = RHOMG(2,N)
        RHOML(1,N) = RHOML(2,N)
        RHOMN(1,N) = RHOMN(2,N)
        RHON(1,N) = RHON(2,N)
        RHOSP(1,N) = RHOSP(2,N)
        RKG(1,N) = RKG(2,N)
        RKL(1,N) = RKL(2,N)
        RKN(1,N) = RKN(2,N)
        SG(1,N) = SG(2,N)
        SL(1,N) = SL(2,N)
        SN(1,N) = SN(2,N)
        SS(1,N) = SS(2,N)
        T(1,N) = T(2,N)
        TMS(1,N) = TMS(2,N)
        TORG(1,N) = TORG(2,N)
        TORL(1,N) = TORL(2,N)
        TORN(1,N) = TORN(2,N)
        VISG(1,N) = VISG(2,N)
        VISL(1,N) = VISL(2,N)
        VISN(1,N) = VISN(2,N)
        XGW(1,N) = XGW(2,N)
        XLA(1,N) = XLA(2,N)
        XLS(1,N) = XLS(2,N)
        XLW(1,N) = XLW(2,N)
        XMGW(1,N) = XMGW(2,N)
        XMLA(1,N) = XMLA(2,N)
        XMLS(1,N) = XMLS(2,N)
        XMLW(1,N) = XMLW(2,N)
        YLS(1,N) = YLS(2,N)
        ZG(1,N) = ZG(2,N)
        ZN(1,N) = ZN(2,N)
        IBETA(N) = 0
        DO NSL = 1,NSOLU
          CO(N,NSL) = C(N,NSL)
        ENDDO
        IF( ISLC(40).EQ.1 ) THEN
          DO NEQ = 1,NEQC+NEQK
            NSL = NEQ + NSOLU 
            CO(N,NSL) = C(N,NSL)
          ENDDO
          DO NSP = 1,NSPR
            SP_CO(N,NSP) = SP_C(N,NSP)
          ENDDO
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LDO_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE PROP_BO
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute hydrologic, thermodynamic and physical properties
!     for the black-oil option
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE LEAK_WELL
      USE JACOB
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/PROP_BO'
!
!---  Loop over all nodes, skipping inactive nodes  ---
!
      DO N = 1,NFCGC(ID+1)
        IF( IXP(N).EQ.0 ) CYCLE
        N_DB = ND(N)
!
!---    Loop over increment indices  ---
!
        DO M = 2,ISVC+2
          TKX = T(M,N) + TABS
!
!---      Phase condition #1  ---
!
!         SL = 1.0, SG+SN = 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!         CO2 mass - CO2 vapor pressure - PVA
!         CH4 mass - total CH4 mass - TMC
!         petroleum component mass - total petroleum comp. mass - TMC
!         salt mass - total salt brine mass fraction - YLS
!
          IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL BO_PC1( PORD(M,N),POSM(M,N),PVW(M,N),PX,RHOG(M,N),
     &        RHOL(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),
     &        TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),YLS(M,N) )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #2  ---
!
!         SG = 0.0
!         SL > 0.0
!         SN > 0.0
!         Aqueous and nonaqueous liquid saturated
!
!         water mass - aqueous saturation, SL
!         gas mass - gas to oil ratio, POSM
!         oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL BO_PC2( PORD(M,N),POSM(M,N),PVW(M,N),PX,RHOG(M,N),
     &        RHOL(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),
     &        TMC(1,M,N),TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),YLS(M,N),N )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #3  ---
!
!         SG > 0.0
!         SL > 0.0
!         SN > 0.0
!         Three-phase
!
!         water mass - aqueous saturation, SL
!         gas mass - gas saturation, SG
!         oil mass - gas (system) pressure, Pa gauge - PG,PSO
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL BO_PC3( PORD(M,N),POSM(M,N),PVW(M,N),PX,RHOG(M,N),
     &        RHOL(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),
     &        TMC(1,M,N),TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),YLS(M,N),N )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #4  ---
!
!         SG = 0.0
!         SL = 0.0
!         SN = 1.0
!         Nonaqueous liquid saturated
!
!         water mass - aqueous saturation, SL
!         gas mass - gas to oil ratio, POSM
!         oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL BO_PC4( PORD(M,N),POSM(M,N),PVW(M,N),PX,RHOG(M,N),
     &        RHOL(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),
     &        TMC(1,M,N),TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),YLS(M,N),N )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #5  ---
!
!         SG > 0.0
!         SL = 0.0
!         SN > 0.0
!         Nonaqueous liquid and gas saturated
!
!         water mass - aqueous saturation, SL
!         gas mass - gas saturation, SG
!         oil mass - gas (system) pressure, Pa gauge - PG,PSO
!         salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL BO_PC5( PORD(M,N),POSM(M,N),PVW(M,N),PX,RHOG(M,N),
     &        RHOL(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),
     &        TMC(1,M,N),TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),YLS(M,N),N )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
          ENDIF
          CALL RKG_EOR( RKG(M,N),SL(M,N),SN(M,N),N )
          CALL RKL_EOR( RKL(M,N),SL(M,N),N )
          CALL RKN_EOR( RKG(M,N),RKL(M,N),RKN(M,N),SG(M,N),
     &      SL(M,N),SN(M,N),N )
!
!---      Gas viscosity, Pa s  ---
!
          CALL BO_VISG( RHOG(M,N),VISG(M,N) )
!
!---      Aqueous viscosity, Pa s
!         concentration of CO2 in mol/kg,
!         concentration of salt in mol/kg  ---
!
          CMLAX = 0.D+0
          CMLSX = 1.D+3*XLS(M,N)*RHOL(M,N)/WTMS
          CALL VISC_L( CMLAX,CMLSX,PX,T(M,N),VISL(M,N) )
!
!---      Nonaqueous-liquid viscosity, Pa s  ---
!
          CALL BO_VISN( PX,POSM(M,N),T(M,N),VISN(M,N) )
!
!---      Salt aqueous diffusion coefficient  ---
!
          CALL DIFC_LS( DFLS(M,N),T(M,N),VISL(M,N),XLS(M,N) )
!
!---      Precipitated NaCl density, saturation, and enthalpy  ---
!
          CALL DENS_S( T(M,N),PX,RHOSP(M,N) )
          CALL SOL_LS( T(M,N),XBSMX )
          CALL DENS_B( T(M,N),PX,XBSMX,RHOBX )
          SS(M,N) = MAX(YLS(M,N)-XBSMX,0.D+0)*RHOBX*SL(M,N)/RHOSP(M,N)
!
!---      Kozney-Carmen permeability reduction  ---
!
          PORDX = PORD(M,N)*(1.D+0-SS(M,N))
          PERMRF(M,N) = ((PORDX**3)/(1.D+0+PORDX))/
     &      ((PORD(M,N)**3)/(1.D+0+PORD(M,N)))
!
!---      Change in porosity as a function of precipitated salt  ---
!
          PORD(M,N) = PORD(M,N)*(1.D+0-SS(M,N))
!
!---      Aqueous, gas, and nonaqueous-liquid tortuosity  ---
!
          IF( ISLC(3).EQ.1 ) CALL TORTU( N,SL(M,N),SG(M,N),SN(M,N),
     &      PORD(M,N),TORL(M,N),TORG(M,N),TORN(M,N) )
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of PROP_BO group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE PROP_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute hydrologic, thermodynamic and physical properties.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE LEAK_WELL
      USE JACOB
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 FKX(LNGC)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/PROP_EOR'
!
!---  Black-oil option  ---
!
      IF( ISLC(68).EQ.0 ) THEN
        CALL PROP_BO
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Loop over local grid cells, including ghost cells  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Skip inactive grid cells  ---
!
        IF( IXP(N).EQ.0 ) CYCLE
        N_DB = ND(N)
!
!---    K-factors fixed at second iterate values  ---
!
        IF( NITER.GT.2 ) THEN
          IFK = 1
!
!---    K-factors computed from fugacity coefficients  ---
!
        ELSE
          IFK = 0
        ENDIF
!
!---    Schema for fixing beta  ---
!
        IBETAX = 0
        IF( NITER.GT.7 ) THEN
          DBETA1X = BETA(2,N)-BETA(1,N)
          DBETA2X = BETA(3,N)-BETA(2,N)
          ABETAX = 0.D+0
          DO M = 1,3
            ABETAX = ABETAX + BETA(M,N)
          ENDDO
          ABETAX = ABETAX/3.D+0
          SBETAX = 0.D+0
          DO M = 1,3
            SBETAX = SBETAX + (BETA(M,N)-ABETAX)**2
          ENDDO
          SBETAX = SQRT( SBETAX/3.D+0 )
!
!---      Beta previously fixed  ---
!
          IF( IBETA(N).EQ.1 ) THEN
            IBETAX = 1
            BETAX = BETA(3,N)
!
!---      Small variance in beta  ---
!
          ELSEIF( SBETAX.LT.1.D-4 ) THEN
            BETAX = ABETAX
            IBETA(N) = 1
            IBETAX = 1
!
!---      Beta oscillating  ---
!
          ELSEIF( (DBETA1X*DBETA2X).LT.0.D+0 .AND. 
     &      (DBETA1X+DBETA2X).LT.1.D-4 ) THEN
            BETAX = 5.D-1*(BETA(3,N)+BETA(2,N))
            IBETA(N) = 1
            IBETAX = 1
!
!---      Gas-nonaqueous liquid interfacial tension oscillating  ---
!
          ELSEIF( (BETA(4,N)*BETA(5,N)*BETA(6,N)).LT.EPSL .AND.
     &      (BETA(4,N)+BETA(5,N)+BETA(6,N)).GT.EPSL ) THEN
            BETAX = 0.D+0
            IBETAX = 0
            DO M = 1,3
              IF( BETA(M+3,N).GT.0.D+0 ) THEN
                BETAX = BETAX + BETA(M,N)
                IBETAX = IBETAX + 1
              ENDIF
            ENDDO
            BETAX = BETAX/REAL(IBETAX)
            IBETA(N) = 1
            IBETAX = 1
          ENDIF
        ENDIF
!
!---    Loop over increment indices  ---
!
        DO M = 2,ISVC+2
          IF( ISLC(79).EQ.1 .AND. M.GE.2 ) EXIT
          TKX = T(M,N) + TABS
!
!---      K-factors fixed at third iterate values  ---
!
          IF( IFK.EQ.1 ) THEN
            DO IGC = 1,NGC+2
              FKX(IGC) = FK(IGC,N)
            ENDDO
          ENDIF
!
!---      Phase condition #1  ---
!
!         SL = 1.0, SG+SN = 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!         CO2 mass - CO2 vapor pressure - PVA
!         CH4 mass - total CH4 mass - TMC
!         petroleum component mass - total petroleum comp. mass - TMC
!         salt mass - total salt brine mass fraction - YLS
!
          IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL FLH_PC1( BETAX,FKX,GNIFT(M,N),PORD(M,N),PVA(M,N),
     &        PVW(M,N),PX,RHOG(M,N),RHOL(M,N),RHOMG(M,N),RHOML(M,N),
     &        RHOMN(M,N),RHON(M,N),SGX,SLX,SNX,TMC(1,M,N),
     &        TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),XLA(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),XMGC(1,M,N),XMGW(M,N),
     &        XMLA(M,N),XMLS(M,N),XMLW(M,N),XMNC(1,M,N),YLS(M,N),
     &        ZG(M,N),ZMC(1,M,N),ZN(M,N),IBETAX,N,NPHAZ(2,N) )
            SL(M,N) = 1.D+0
            SG(M,N) = 0.D+0
            SN(M,N) = 0.D+0
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #2  ---
!
!         SL < 1.0, ST > 0.0, SG = 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL FLH_PC2( BETAX,FKX,GNIFT(M,N),PORD(M,N),PVA(M,N),
     &        PVW(M,N),PX,RHOG(M,N),RHOL(M,N),RHOMG(M,N),RHOML(M,N),
     &        RHOMN(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),TMC(1,M,N),
     &        TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),XLA(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),XMGC(1,M,N),XMGW(M,N),
     &        XMLA(M,N),XMLS(M,N),XMLW(M,N),XMNC(1,M,N),YLS(M,N),
     &        ZG(M,N),ZMC(1,M,N),ZN(M,N),IBETAX,IZMC(N),N,NPHAZ(2,N) )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #3  ---
!
!         SL < 1.0, ST > 0.0, SG > 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt brine mass fraction - YLS
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL FLH_PC3( BETAX,FKX,GNIFT(M,N),PORD(M,N),PVA(M,N),
     &        PVW(M,N),PX,RHOG(M,N),RHOL(M,N),RHOMG(M,N),RHOML(M,N),
     &        RHOMN(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),TMC(1,M,N),
     &        TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),XLA(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),XMGC(1,M,N),XMGW(M,N),
     &        XMLA(M,N),XMLS(M,N),XMLW(M,N),XMNC(1,M,N),YLS(M,N),
     &        ZG(M,N),ZMC(1,M,N),ZN(M,N),IBETAX,IZMC(N),N,NPHAZ(2,N) )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #4  ---
!
!         SL = 0.0, ST = 1.0, SG = 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - nonaqueous (system) pressure, Pa gauge - PN,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL FLH_PC4( BETAX,FKX,GNIFT(M,N),PORD(M,N),PVA(M,N),
     &        PVW(M,N),PX,RHOG(M,N),RHOL(M,N),RHOMG(M,N),RHOML(M,N),
     &        RHOMN(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),TMC(1,M,N),
     &        TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),XLA(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),XMGC(1,M,N),XMGW(M,N),
     &        XMLA(M,N),XMLS(M,N),XMLW(M,N),XMNC(1,M,N),YLS(M,N),
     &        ZG(M,N),ZMC(1,M,N),ZN(M,N),IBETAX,IZMC(N),N,NPHAZ(2,N) )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
!
!---      Phase condition #5  ---
!
!         SL = 0.0, ST >= 0.0, SG > 0.0
!
!         energy - temperature, C - T
!         water mass - aqueous saturation, SL
!         CO2 mass
!           if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!           endif
!         CH4 mass
!           if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!           endif
!         petroleum component mass
!           if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!             - gas (system) pressure, Pa gauge - PG,PSO
!           else
!             - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!           endif
!         salt mass - total salt mass - TMS(2,N)
!
          ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---        System pressure, absolute  ---
!
            PX = PSO(M,N) + PATM
!
!---        Porous-media porosity  ---
!
            CALL PORSTY( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
            PORD(M,N) = MAX( PORD(M,N),EPSL )
            PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---        Flash calculations  ---
!
            CALL FLH_PC5( BETAX,FKX,GNIFT(M,N),PORD(M,N),PVA(M,N),
     &        PVW(M,N),PX,RHOG(M,N),RHOL(M,N),RHOMG(M,N),RHOML(M,N),
     &        RHOMN(M,N),RHON(M,N),SG(M,N),SL(M,N),SN(M,N),TMC(1,M,N),
     &        TMS(M,N),T(M,N),VOL(N),XGC(1,M,N),XGW(M,N),XLA(M,N),
     &        XLS(M,N),XLW(M,N),XNC(1,M,N),XMGC(1,M,N),XMGW(M,N),
     &        XMLA(M,N),XMLS(M,N),XMLW(M,N),XMNC(1,M,N),YLS(M,N),
     &        ZG(M,N),ZMC(1,M,N),ZN(M,N),IBETAX,IZMC(N),N,NPHAZ(2,N) )
            CALL CAP_EOR( SG(M,N),SL(M,N),SN(M,N),CPGTX,CPNLX,N )
!
!---        Phase pressure from phase capillary pressures and system
!           pressure  ---
!
            PG(M,N) = PSO(M,N)
            PTX = PG(M,N) - CPGTX
            IF( CPNLX.GT.0.D+0 ) THEN
              PN(M,N) = PTX
              PL(M,N) = PN(M,N) - CPNLX
            ELSE
              PL(M,N) = PTX
              PN(M,N) = PL(M,N) + CPNLX
            ENDIF
          ENDIF
!
!---      Save unincremented K-factors  ---
!
          IF( M.EQ.2 .AND. NITER.LE.3 ) THEN
            DO IGC = 1,NGC+2
              FK(IGC,N) = FKX(IGC)
            ENDDO
          ENDIF
!
!---      Load component aqueous mass fraction for CO2  ---
!
          XLC(1,M,N) = XLA(M,N)
          IF( M.EQ.2 ) THEN
!
!---        Store recent iterative values of beta  ---
!
            BETA(1,N) = BETA(2,N)
            BETA(2,N) = BETA(3,N)
            BETA(3,N) = BETAX
!
!---        Store recent iterative values of gas-nonaqueous liquid
!           interfacial tension ---
!
            BETA(4,N) = BETA(5,N)
            BETA(5,N) = BETA(6,N)
            BETA(6,N) = GNIFT(2,N)
          ENDIF
        ENDDO
      ENDDO
!
!---  Subroutine split, loop over all nodes, 
!     skipping inactive nodes  ---
!
      DO N = 1,NFCGC(ID+1)
        IF( IXP(N).EQ.0 ) CYCLE
        N_DB = ND(N)
!
!---    Loop over increment indices  ---
!
        DO M = 2,ISVC+2
          IF( ISLC(79).EQ.1 .AND. M.GE.2 ) EXIT
          TKX = T(M,N) + TABS
!
!---      System pressure, absolute  ---
!
          PX = PSO(M,N) + PATM
!
!---      Relative permeability  ---
!
          CALL RKG_EOR( RKG(M,N),SL(M,N),SN(M,N),N )
          CALL RKL_EOR( RKL(M,N),SL(M,N),N )
          CALL RKN_EOR( RKG(M,N),RKL(M,N),RKN(M,N),SG(M,N),
     &      SL(M,N),SN(M,N),N )
!
!---      Gas viscosity, Pa s  ---
!
          CALL VISC_G( RHOMG(M,N),T(M,N),VISG(M,N),XMGC(1,M,N),
     &      XMGW(M,N) )
!
!---      Aqueous viscosity, Pa s
!         concentration of CO2 in mol/kg,
!         concentration of salt in mol/kg  ---
!
          CMLAX = 1.D+3*XMLA(M,N)*RHOML(M,N)/RHOL(M,N)
          CMLSX = 1.D+3*XMLS(M,N)*RHOML(M,N)/RHOL(M,N)
          CALL VISC_L( CMLAX,CMLSX,PX,T(M,N),VISL(M,N) )
!
!---      Nonaqueous-liquid viscosity, Pa s  ---
!
          CALL VISC_N( RHOMN(M,N),T(M,N),VISN(M,N),XMNC(1,M,N) )
!
!---      Component gas diffusion coefficients  ---
!
          CALL DIFC_G( DFGC(1,M,N),DFGW(M,N),PX,T(M,N),XMGC(1,M,N),
     &      XMGW(M,N) )
!
!---      CO2 aqueous diffusion coefficient  ---
!
          CALL DIFC_LA( DFLA(M,N),T(M,N),VISL(M,N) )
!
!---      Salt aqueous diffusion coefficient  ---
!
          CALL DIFC_LS( DFLS(M,N),T(M,N),VISL(M,N),XLS(M,N) )
!
!---      Petroleum component nonaqueous-liquid diffusion 
!         coefficients  ---
!
          CALL DIFC_N( DFNC(1,M,N),T(M,N),VISN(M,N) )
!
!---      Gas thermal conductivity, W/m K  ---
!
          CALL THK_G( PX,T(M,N),THKG(M,N),XMGC(1,M,N),XMGW(M,N) )
!
!---      Aqueous thermal conductivity  ---
!
          CALL THK_W( PX,T(M,N),THKLWX )
          CALL THK_B( T(M,N),XLS(M,N),THKLWX,THKL(M,N) )
!
!---      Nonaqueous thermal conductivity, W/m K  ---
!
          CALL THK_N( PX,T(M,N),THKN(M,N),XMNC(1,M,N) )
!
!---      Gas enthalpy and internal energy, W/kg  ---
!
          CALL ENTH_G( HG(M,N),HGA(M,N),HGW(M,N),PX,T(M,N),RHOG(M,N),
     &      UEG(M,N),XGC(1,M,N),XGW(M,N),XMGC(1,M,N),ZG(M,N) )
!
!---      Nonaqueous-liquid enthalpy and internal energy  ---
!
          CALL ENTH_N( HN(M,N),HNAX,PX,T(M,N),RHON(M,N),
     &      UEN(M,N),XNC(1,M,N),XMNC(1,M,N),ZN(M,N) )
!
!---      Pure water liquid enthalpy  ---
!
          CALL SP_W( T(M,N),PSWX )
          PEX = MAX( PSWX,PX )
          ISRX = 1
          CALL ENTH_W( T(M,N),PEX,HLW(M,N),HGWX,ISRX )
!
!---      Brine enthalpy  ---
!
          CALL ENTH_B( T(M,N),XLS(M,N),HLW(M,N),HBX )
          IF( SG(M,N).GT.0.D+0 ) THEN
            FGAX = SG(M,N)*RHOG(M,N)*XGC(1,M,N)
          ELSE
            FGAX = 0.D+0
          ENDIF
          IF( SN(M,N).GT.0.D+0 ) THEN
            FNAX = SN(M,N)*RHON(M,N)*XNC(1,M,N)
          ELSE
            FNAX = 0.D+0
          ENDIF
          IF( (FGAX+FNAX)/EPSL.LT.EPSL ) THEN
            HAX = 0.D+0
          ELSE
            HAX = (HGA(M,N)*FGAX + HNAX*FNAX)/(FGAX + FNAX + SMALL)
          ENDIF
!
!---      Aqueous enthalpy and internal energy  ---
!
          CALL ENTH_L( HAX,HBX,HL(M,N),T(M,N),XLA(M,N),XLS(M,N) )
          UEL(M,N) = HL(M,N) - PX/RHOL(M,N)
!
!---      Precipitated NaCl density, saturation, and enthalpy  ---
!
          CALL DENS_S( T(M,N),PX,RHOSP(M,N) )
          CALL SOL_LS( T(M,N),XBSMX )
          CALL DENS_B( T(M,N),PX,XBSMX,RHOBX )
          SS(M,N) = MAX(YLS(M,N)-XBSMX,0.D+0)*RHOBX*SL(M,N)/RHOSP(M,N)
!
!---      Precipitated NaCl enthalpy  ---
!
          CALL ENTH_S( T(M,N),HSP(M,N) )
!
!---      Permeability reduction factor  ---
!
          IF( IPRF(N).EQ.1 ) CALL PERM_R( SS(M,N),PERMRF(M,N),
     &      PORD(M,N),N )
!
!---      Change in porosity as a function of precipitated salt  ---
!
          PORD(M,N) = PORD(M,N)*(1.D+0-SS(M,N))
!
!---      Aqueous, gas, and nonaqueous-liquid tortuosity  ---
!
          IF( ISLC(3).EQ.1 ) CALL TORTU( N,SL(M,N),SG(M,N),SN(M,N),
     &      PORD(M,N),TORL(M,N),TORG(M,N),TORN(M,N) )
        ENDDO
        IF( ISLC(79).EQ.1 ) THEN
          DO M = 3,ISVC+2
            BETA(M,N) =  BETA(2,N)
            DFGW(M,N) = DFGW(2,N)
            DFLA(M,N) = DFLA(2,N)
            GNIFT(M,N) = GNIFT(2,N)
            HG(M,N) = HG(2,N)
            HGA(M,N) = HGA(2,N)
            HGW(M,N) = HGW(2,N)
            HL(M,N) = HL(2,N)
            HLW(M,N) = HLW(2,N)
            HN(M,N) = HN(2,N)
            HSP(M,N) = HSP(2,N)
            PERMRF(M,N) = PERMRF(2,N)
            PG(M,N) = PG(2,N)
            PL(M,N) = PL(2,N)
            PN(M,N) = PN(2,N)
            PORD(M,N) = PORD(2,N)
            PORT(M,N) = PORT(2,N)
            PSO(M,N) = PSO(2,N)
            PVA(M,N) = PVA(2,N)
            PVW(M,N) = PVW(2,N)
            RHOG(M,N) = RHOG(2,N)
            RHOL(M,N) = RHOL(2,N)
            RHOMG(M,N) = RHOMG(2,N)
            RHOML(M,N) = RHOML(2,N)
            RHOMN(M,N) = RHOMN(2,N)
            RHON(M,N) = RHON(2,N)
            RHOSP(M,N) = RHOSP(2,N)
            RKG(M,N) = RKG(2,N)
            RKL(M,N) = RKL(2,N)
            RKN(M,N) = RKN(2,N)
            SG(M,N) = SG(2,N)
            SL(M,N) = SL(2,N)
            SN(M,N) = SN(2,N)
            SS(M,N) = SS(2,N)
            T(M,N) = T(2,N)
            THKG(M,N) = THKG(2,N)
            THKL(M,N) = THKL(2,N)
            THKN(M,N) = THKN(2,N)
            TMS(M,N) = TMS(2,N)
            TORG(M,N) = TORG(2,N)
            TORL(M,N) = TORL(2,N)
            TORN(M,N) = TORN(2,N)
            UEG(M,N) = UEG(2,N)
            UEL(M,N) = UEL(2,N)
            UEN(M,N) = UEN(2,N)
            VISG(M,N) = VISG(2,N)
            VISL(M,N) = VISL(2,N)
            VISN(M,N) = VISN(2,N)
            XGW(M,N) = XGW(2,N)
            XLA(M,N) = XLA(2,N)
            XLS(M,N) = XLS(2,N)
            XLW(M,N) = XLW(2,N)
            XMGW(M,N) = XMGW(2,N)
            XMLA(M,N) = XMLA(2,N)
            XMLS(M,N) = XMLS(2,N)
            XMLW(M,N) = XMLW(2,N)
            YLS(M,N) = YLS(2,N)
            ZG(M,N) = ZG(2,N)
            ZN(M,N) = ZN(2,N)
            DO IGC = 1,NGC+2
              DFGC(IGC,M,N) =  DFGC(IGC,2,N)
              DFNC(IGC,M,N) =  DFNC(IGC,2,N)
              TMC(IGC,M,N) =  TMC(IGC,2,N)
              XGC(IGC,M,N) =  XGC(IGC,2,N)
              XLC(IGC,M,N) =  XLC(IGC,2,N)
              XMGC(IGC,M,N) =  XMGC(IGC,2,N)
              XMNC(IGC,M,N) =  XMNC(IGC,2,N)
              XNC(IGC,M,N) =  XNC(IGC,2,N)
            ENDDO
          ENDDO
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of PROP_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_BIN_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary files from processor.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE REACT
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_BIN_EOR'
!
!---  Read solu.bin for solution control and output data  ---
!
      CALL READ_SOLU_EOR
      PRINT *,'Post READ_SOLU_EOR: ID = ',ID
!
!---  Read a series of binary grid files for grid data  ---
!
      CALL READ_GRID_EOR
      PRINT *,'Post READ_GRID_EOR: ID = ',ID
!
!---  Read mech.bin, hydr.bin satu.bin, perm.bin,
!     comp.bin, and tabl.bin for property data  ---
!
      CALL READ_PROP_EOR
      PRINT *,'Post READ_PROP_EOR: ID = ',ID
!
!---  Read state.bin for state condition data  ---
!
      CALL READ_STATE_EOR
      PRINT *,'Post READ_STATE_EOR: ID = ',ID
      RETURN
!
!---  Read boco.bin for boundary condition data  ---
!
      CALL READ_BOCO_EOR
!      PRINT *,'Post READ_BOCO_EOR: ID = ',ID
!
!---  Read sorc.bin for source data  ---
!
      CALL READ_SORC_EOR
!      PRINT *,'Post READ_SORC_EOR: ID = ',ID
!
!---  Read well.bin for coupled-well data ---
!
      CALL READ_COUP_WELL_EOR
!      PRINT *,'Post READ_COUP_WELL_EOR: ID = ',ID
!
!---  Read tpor.bin for transport data  ---
!
      IF( IEQC.NE.0 ) CALL READ_TPOR_EOR
!      PRINT *,'Post READ_TPOR_EOR: ID = ',ID
!
!---  Read geomechanial binary files  ---
!
      IF( ISLC(50).NE.0 ) CALL READ_BIN_GM
!      PRINT *,'Post READ_BIN_GM: ID = ',ID
!
!---  Read ecke.bin for ECKEChem (i.e., reactive transport data)  ---
!
      IF( ISLC(40).EQ.1 ) THEN
        CALL READ_REACT_EOR
      ELSE
        ALLOCATE( ISPLK(1:2*LNGC+LSPR+14),STAT=ISTAT )
        CHMSG = 'ISPLK'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        DO L = 1,2*LNGC+LSPR+14
          ISPLK(L) = 0
        ENDDO
      ENDIF
!      PRINT *,'Post READ_REACT_EOR: ID = ',ID
!
!---  Read ptcf.bin  ---
!
      IF( IACTV.EQ.2 ) CALL READ_PTZRCOEF
!      PRINT *,'Post READ_PTZR_EOR: IACTV = ',IACTV,'ID = ',ID
!
!---  Read co2_prop.bin  ---
!
      CALL READ_PE_EOR
!      PRINT *,'Post READ_PE_EOR: ID = ',ID
!
!---  Read restart.bin for restart simulations  ---
!
      IF( IEO.EQ.2 ) CALL RDRST_EOR
!      PRINT *,'Post RDRST_EOR: IEO = ',IEO,'ID = ',ID
!
!---  Check for fatal execution errors and stop simulation
!     if detected  ---
!
      CALL CHK_ERROR
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_BIN_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_BOCO_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary boco_sorc.bin file for boundary condition data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE PROP
      USE MPI
      USE GRID
      USE GLB_PAR
      USE FILES
      USE BCVP
      USE BCV
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_BOCO_EOR'
!
!---  Open boco.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'boco.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate memory for NBC  ---
!
      ALLOCATE( NBC(1:NP),STAT=ISTAT )
      CHMSG = 'NBC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of boundary condition surfaces on each
!     processor  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NBC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for boundary condition arrays  ---
!
      CALL ALLOC_BCV
      CALL ALLOC_BCVP
!
!---  Initialize boundary condition variables  ---
!
      CALL INTLZ_BCV
      CALL INTLZ_BCVP
!
!---  Read boundary condition variables
!     (duplicated across processors)  ---
!
      NVAR = LBCV*LBTM*LBCIN
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,BC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read array of boundary condition nodes  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NBC(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NBC(N)
      ENDDO
!
!---  Index array of boundary condition field nodes  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCN: ID = ',ID
!
!---  Index array of boundary condition directions  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCD,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCD: ID = ',ID
!
!---  Index array of boundary condition number of time points  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCM: ID = ',ID
!
!---  Index array of boundary condition input links  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCIN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCIN: ID = ',ID
!
!---  Index array of boundary condition cycling options  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCC: ID = ',ID
!
!---  Index array of boundary condition types  ---
!
      LX = LUK+LSOLU*LC
      NVAR = NBC(ID+1)*LX
      OFFSET = IOFFSET + NC*LX*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*LX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCT: ID = ',ID
!
!---  Index array of boundary condition reactive species  ---
!
      NVAR = NBC(ID+1)*(LSPBC+1)
      OFFSET = IOFFSET + NC*(LSPBC+1)*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*(LSPBC+1)*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCSP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'IBCSP = ',((IBCSP(K,L),K=1,(LSPBC+1)),L=1,NBC(ID+1)),
!     &  ' ID = ',ID
!
!---  Array of x-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post XPBC: ID = ',ID
!
!---  Array of y-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post YPBC: ID = ',ID
!
!---  Array of z-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post ZPBC: ID = ',ID
!      DO NB = 1,NBC(ID+1)
!        PRINT *,'XPBC(',NB,') = ',XPBC(NB),' ID = ',ID
!        PRINT *,'YPBC(',NB,') = ',YPBC(NB),' ID = ',ID
!        PRINT *,'ZPBC(',NB,') = ',ZPBC(NB),' ID = ',ID
!      ENDDO
!
!---  Allocate local temporary real initial condition boundary
!     condition array memory  ---
!
      ALLOCATE( VARX(1:NBC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Array of initial condition boundary condition aqueous 
!     pressure  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        PLB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!
!---  Array of initial condition boundary condition gas 
!     pressure  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        PGB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!
!---  Array of initial condition boundary condition NAPL 
!     pressure  ---
!mlr added
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        PNB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!
!---  Array of initial condition boundary condition aqueous salt 
!     mass fraction  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        YLSB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!
!---  Deallocate local temporary real initial condition boundary
!     condition array memory  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Close the boco.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_BOCO_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_COUP_WELL_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary well.bin file for coupled-well data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE PROP
      USE OUTPU
      USE MPI
      USE GRID
      USE GLB_PAR
      USE SOURC
      USE FILES
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_COUP_WELL_EOR'
!
!---  Open wltp.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'well.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate memory for coupled-well variables  ---
!
      CALL ALLOC_COUP_WELL
!
!---  Initialize coupled-well variables  ---
!
      CALL INTLZ_COUP_WELL
!
!---  Read number of coupled wells (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,N_CW,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'N_CW = ',N_CW,' ID = ',ID
!
!---  Read coupled well parameters, indices, and variables
!     if coupled wells are modeled  ---
!
      IF( N_CW.GT.0 ) THEN
!
!---    Read well names (duplicated across processors)  ---
!
        NVAR = 64*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,WNM_CW,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'WNM_CW = ',(WNM_CW(M),M=1,LN_CW),' ID = ',ID
!
!---    Read type index of coupled wells
!       (duplicated across processors)  ---
!
        NVAR = LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IT_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IT_CW = ',(IT_CW(M),M=1,NVAR),' ID = ',ID
!
!---    Read injection well state index
!       (duplicated across processors)  ---
!
        NVAR = LWTP_CW*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ITS_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ITS_CW = ',((ITS_CW(M,N),M=1,LWTP_CW),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read x-, y-, and z-direction coupled well fraction factors
!       (duplicated across processors)  ---
!
        NVAR = 3*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,FF_CW,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'FF_CW = ',((FF_CW(M,N),M=1,3),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read coupled well indices (duplicated across processors)  ---
!
        NVAR = 10*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ID_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ID_CW = ',((ID_CW(M,N),M=1,10),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read coupled well total mass limit
!       (duplicated across processors)  ---
!
        NVAR = LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,TML_CW,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'TML_CW = ',(TML_CW(N),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read coupled well cyclic index (duplicated across processors)  ---
!
        NVAR = LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ICC_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ICC_CW = ',(ICC_CW(N),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read number of coupled well time points
!       (duplicated across processors)  ---
!
        NVAR = LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IM_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IM_CW = ',(IM_CW(N),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read number of coupled well time points per time period
!       (duplicated across processors)  ---
!
        NVAR = LWTP_CW*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IMP_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IMP_CW = ',((IMP_CW(M,N),M=1,LWTP_CW),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read number of coupled well reference nodes
!       (duplicated across processors)  ---
!
        NVAR = LVREF
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IREF_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IREF_CW = ',(IREF_CW(N),N=1,LVREF),
!       &  ' ID = ',ID
!
!---    Read coupled-well field to node pointers
!       (duplicated across processors)  ---
!
        NVAR = LWF_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IWFG_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IWFG_CW = ',(IWFG_CW(N),N=1,LWF_CW),
!       &  ' ID = ',ID
!
!---    Read coupled-well field to node-equation pointers
!       (duplicated across processors)  ---
!
        NVAR = LWF_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IXPG_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IXPG_CW = ',(IXPG_CW(N),N=1,LWF_CW),
!       &  ' ID = ',ID
!
!---    Read coupled-well field to node pointers
!       (duplicated across processors)  ---
!
        NVAR = LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IWNG_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IWNG_CW = ',(IWNG_CW(N),N=1,LWN_CW),
!       &  ' ID = ',ID
!
!---    Read coupled-well field to node pointers
!       (duplicated across processors)  ---
!
        NVAR = LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IWP_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IWP_CW = ',(IWP_CW(N),N=1,LWN_CW),
!       &  ' ID = ',ID
!
!---    Read type index for coupled well interval
!       (duplicated across processors)  ---
!
        NVAR = LWI_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IS_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR )
!        PRINT *,'IS_CW = ',(IS_CW(M),M=ID_CW(1,N),ID_CW(2,N)),
!     &    ' ID = ',ID
!
!---    Read x-transition points for coupled well interval
!       (duplicated across processors)  ---
!
        NVAR = 2*LWI_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,XTP_CW,NVAR,MPI_REAL8,
     &    STATUS,IERR )
!        PRINT *,'XTP_CW = ',((XTP_CW(L,M),L=1,2),M=ID_CW(1,N),
!     &    ID_CW(2,N)),' ID = ',ID
!
!---    Read y-transition points for coupled well interval
!       (duplicated across processors)  ---
!
        NVAR = 2*LWI_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,YTP_CW,NVAR,MPI_REAL8,
     &    STATUS,IERR )
!        PRINT *,'YTP_CW = ',((YTP_CW(L,M),L=1,2),M=ID_CW(1,N),
!     &    ID_CW(2,N)),' ID = ',ID
!
!---    Read z-transition points for coupled well interval
!       (duplicated across processors)  ---
!
        NVAR = 2*LWI_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ZTP_CW,NVAR,MPI_REAL8,
     &    STATUS,IERR )
!        PRINT *,'ZTP_CW = ',((ZTP_CW(L,M),L=1,2),M=ID_CW(1,N),
!     &    ID_CW(2,N)),' ID = ',ID
!
!---    Read parameters for coupled well interval
!       (duplicated across processors)  ---
!
        NVAR = 5*LWI_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PAR_CW,NVAR,MPI_REAL8,
     &    STATUS,IERR )
!        PRINT *,'PAR_CW = ',((PAR_CW(L,M),L=1,5),M=ID_CW(1,N),
!     &    ID_CW(2,N)),' ID = ',ID
!
!---    Read coupled-well interval
!       (duplicated across processors)  ---
!
        NVAR = LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,INV_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR )
!        PRINT *,'INV_CW = ',(INV_CW(M),M=ID_CW(3,N),ID_CW(4,N)),
!     &    ' ID = ',ID
!
!---    Read time dependent driving parameters for the coupled well
!       (duplicated across processors)  ---
!
        NVAR = 8*LWT_CW*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,VAR_CW,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'VAR_CW = ',(((VAR_CW(L,M,N),L=1,8),M=1,LWT_CW),
!       &  N=1,LN_CW),' ID = ',ID
!
!---    Read time dependent solute driving parameters for the coupled
!       well  (duplicated across processors)  ---
!
        NVAR = LSOLU_CW*LWT_CW*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,VARC_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'VARC_CW = ',(((VARC_CW(L,M,N),L=1,LSOLU_CW),M=1,LWT_CW),
!       &  N=1,LN_CW),' ID = ',ID
!
!---    Read time dependent species driving parameters for the coupled
!       well (duplicated across processors)  ---
!
        NVAR = LSPC_CW*LWT_CW*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,VARSP_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'VARSP_CW = ',(((VARSP_CW(L,M,N),L=1,LSPC_CW),M=1,LWT_CW),
!       &  N=1,LN_CW),' ID = ',ID
!
!---    Read x-direction well projections
!       (duplicated across processors)  ---
!
        NVAR = LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PLX_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'PLX_CW = ',(PLX_CW(N),N=1,LWN_CW),' ID = ',ID
!
!---    Read y-direction well projections
!       (duplicated across processors)  ---
!
        NVAR = LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PLY_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'PLY_CW = ',(PLY_CW(N),N=1,LWN_CW),' ID = ',ID
!
!---    Read z-direction well projections
!       (duplicated across processors)  ---
!
        NVAR = LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PLZ_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'PLZ_CW = ',(PLZ_CW(N),N=1,LWN_CW),' ID = ',ID
!
!---    Read x-direction well node points
!       (duplicated across processors)  ---
!
        NVAR = 2*LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,XP_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'XP_CW = ',((XP_CW(M,N),M=1,2),N=1,LWN_CW),' ID = ',ID
!
!---    Read y-direction well node points
!       (duplicated across processors)  ---
!
        NVAR = 2*LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,YP_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'YP_CW = ',((YP_CW(M,N),M=1,2),N=1,LWN_CW),' ID = ',ID
!
!---    Read z-direction well node points
!       (duplicated across processors)  ---
!
        NVAR = 2*LWN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ZP_CW,NVAR,MPI_REAL8,
     &      STATUS,IERR)
!        PRINT *,'ZP_CW = ',((ZP_CW(M,N),M=1,2),N=1,LWN_CW),' ID = ',ID
!
!---    Read active solutes in coupled well
!       (duplicated across processors)  ---
!
        NVAR = LSOLU_CW*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISOLU_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISOLU_CW = ',((ISOLU_CW(M,N),M=1,LSOLU_CW),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read active species in coupled well
!       (duplicated across processors)  ---
!
        NVAR = LSPC_CW*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISPC_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISPC_CW = ',((ISPC_CW(M,N),M=1,LSPC_CW),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read active component species in coupled well
!       (duplicated across processors)  ---
!
        NVAR = LEQC*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISOLC_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISOLC_CW = ',((ISOLC_CW(M,N),M=1,LEQC),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read active kinetic species in coupled well
!       (duplicated across processors)  ---
!
        NVAR = LEQK*LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISOLK_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISOLK_CW = ',((ISOLK_CW(M,N),M=1,LEQK),N=1,LN_CW),
!       &  ' ID = ',ID
!
!---    Read active kinetic species in coupled well
!       (duplicated across processors)  ---
!
        NVAR = LN_CW
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,NSP_CW,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'NSP_CW = ',(NSP_CW(M,N),N=1,LN_CW),
!       &  ' ID = ',ID
      ENDIF
!
!---  Return for no coupled wells  ---
!
      IF( N_CW.EQ.0 ) THEN
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Create a local copy of the arrays connecting well nodes
!     with field nodes and field nodes with well nodes
!     putting zeros for well nodes off the local
!     processor, start by looping over coupled wells
!
      DO NCW = 1,N_CW
!
!---    Loop over coupled-well nodes  ---
!
        DO NWN = ID_CW(3,NCW),ID_CW(4,NCW)
          IWN_CW(NWN) = 0
!
!---      Loop over local nodes, skipping ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
            IF( ND(N).EQ.IWNG_CW(NWN) ) THEN
              IWN_CW(NWN) = N
              EXIT
            ENDIF
          ENDDO
        ENDDO
!
!---    Loop over field nodes that contain coupled-well nodes  ---
!
        DO NWF = ID_CW(5,NCW),ID_CW(6,NCW)
          IWF_CW(NWF) = 0
!
!---      Loop over local nodes, skipping ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
            IF( ND(N).EQ.IWFG_CW(NWF) ) THEN
              IWF_CW(NWF) = N
              EXIT
            ENDIF
          ENDDO
        ENDDO
      ENDDO
!
!---  Close the well.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_COUP_WELL_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_GRID_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read a series of binary grid files for grid data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE JACOB
      USE GRID
      USE GLB_PAR
      USE FILES
      USE CONST
#ifdef lis
!
!----------------------Lis Modules-----------------------------------!
!
      USE LIS_STOMP
#endif
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER IVARX(10)
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_GRID_EOR'
!
!---  Allocate memory for NFCGC, number of field cells and ghost
!     cells on each processor  ---
!
      ALLOCATE( NFCGC(1:NP),STAT=ISTAT )
      CHMSG = 'NFCGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NFC, number of field cells on each
!     processor  ---
!
      ALLOCATE( NFC(1:NP),STAT=ISTAT )
      CHMSG = 'NFC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for IDP  ---
!
      ALLOCATE( IDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'IDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for JDP  ---
!
      ALLOCATE( JDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'JDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for KDP  ---
!
      ALLOCATE( KDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'KDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKFL ---
!
      ALLOCATE( NUKFL(1:NP),STAT=ISTAT )
      CHMSG = 'NUKFL'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKFO ---
!
      ALLOCATE( NUKFO(1:NP),STAT=ISTAT )
      CHMSG = 'NUKFO'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKTL ---
!
      ALLOCATE( NUKTL(1:NP),STAT=ISTAT )
      CHMSG = 'NUKTL'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKTO ---
!
      ALLOCATE( NUKTO(1:NP),STAT=ISTAT )
      CHMSG = 'NUKTO'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Open grid1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read NFCGC array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NFCGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NFCGC_G = 0
      DO N = 1,NP
        NFCGC_G = NFCGC_G + NFCGC(N)
      ENDDO
!
!---  Allocate memory for geometry arrays (including ghost cells)  ---
!
      CALL ALLOC_GRID
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Read IDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read JDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,JDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read KDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,KDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of XE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XE,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of YE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YE,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid3.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid3.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ZE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZE,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid3.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid4.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid4.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of XP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Read local copies of YP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Read local copies of ZP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Read local copies of RP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RP,NVAR,MPI_REAL8,STATUS,IERR)
!
!---  Close the grid4.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid5.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid5.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of DXGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DXGF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DYGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DYGF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DZGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DZGF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid5.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid6.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid6.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of DXGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DXGP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DYGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DYGP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of DZGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DZGP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid6.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid7.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid7.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of AFX array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of AFY array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFY,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of AFZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFZ,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid7.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid8.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid8.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of VOL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VOL,NVAR,MPI_REAL8,STATUS,
     &  IERR)
!
!---  Read local copies of GRVX array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of GRVY array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVY,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of GRVZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVZ,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the grid8.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid9.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid9.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of IXP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IXP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of INBS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,INBS,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of ND array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ND,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKFL (local flow equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKFO (local flow equation offsets)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFO,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKFG (global flow equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFG,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKTL (local transport equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKTO (local transport equation offsets)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTO,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NUKTG  (global transport equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTG,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read IFLD, JFLD, KFLD, NFLD (global field limits)
!     IPFLD, JPFLD, KPFLD, NPFLD (processor field limits)
!     (duplicated across processors)  ---
!
      NVAR = 10
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IFLD = IVARX(1)
      JFLD = IVARX(2)
      KFLD = IVARX(3)
      NFLD = IVARX(4)
      NXP = IVARX(5)
      ICS = IVARX(6)
      IPFLD = IVARX(7)
      JPFLD = IVARX(8)
      KPFLD = IVARX(9)
      NPFLD = IVARX(10)
      IF( NP.NE.NPFLD ) THEN
        IF( ID.EQ.0 ) PRINT *,'Processor Count Error: Number of ' //
     &    'Processors Requested  Input File Processor Count'
        CALL MPI_FINALIZE(IERR)
        STOP
      ENDIF
!
!---  Allocate memory for NGHC ---
!
      ALLOCATE( NGHC(1:NP),STAT=ISTAT )
      CHMSG = 'NGHC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NGHC array total number of ghost cells on a processor,
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NGHC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NCGC ---
!mlr this is named NCSGC in pre-processor
!
      ALLOCATE( NCGC(1:6,1:NP),STAT=ISTAT )
      CHMSG = 'NCGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NCGC array, number of ghost cells to be sent in the
!     stencil directions, (duplicated across processors)  ---
!
      NVAR = 6*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NCGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NPGC ---
!mlr this is named NPSGC in pre-processor
!
      ALLOCATE( NPGC(1:6,1:NP),STAT=ISTAT )
      CHMSG = 'NPGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NPGC array, receiving processors in the
!     stencil directions, (duplicated across processors)  ---
!
      NVAR = 6*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NPGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NLSGC ---
!
      ALLOCATE( NLSGC(1:NGHC(ID+1)),STAT=ISTAT )
      CHMSG = 'NLSGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      NCX = 0
      DO I = 1,ID
        NCX = NCX + NGHC(I)
      ENDDO
      NCSX = 0
      DO I = 1,NP
        NCSX = NCSX + NGHC(I)
      ENDDO
!
!---  Read local copies of NLSGC array  ---
!
      NVAR = NGHC(ID+1)
      OFFSET = IOFFSET + NBYTB + NCX*NBYTI
      IOFFSET = IOFFSET + NCSX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NLSGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NLRGC ---
!
      ALLOCATE( NLRGC(1:NGHC(ID+1)),STAT=ISTAT )
      CHMSG = 'NLRGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local copies of NLRGC array  ---
!
      NVAR = NGHC(ID+1)
      OFFSET = IOFFSET + NBYTB + NCX*NBYTI
      IOFFSET = IOFFSET + NCSX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NLRGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the grid9.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Load ITAG, sending/receiving tags
!     (duplicated across processors)  ---
!
      NC = 0
      DO NPRX = 1,NP
        DO NPSX = 1,NP
          NC = NC + 1
          ITAG(NPSX,NPRX) = NC
        ENDDO
      ENDDO
!
!---  Number of ghost-cell primary variables for STOMPX-EOR  ---
!
      NPVX = 12
!
!---  Allocate memory for ghost-cell send buffers in the six
!     stencil directions  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        PRINT *,'SBFB(',NPVX*NCGC(1,ID+1),' ID = ',ID
        ALLOCATE( SBFB(1:NPVX*NCGC(1,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFB on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(1,ID+1)
          SBFB(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        PRINT *,'SBFS(',NPVX*NCGC(2,ID+1),' ID = ',ID
        ALLOCATE( SBFS(1:NPVX*NCGC(2,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFS on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(2,ID+1)
          SBFS(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        PRINT *,'SBFW(',NPVX*NCGC(3,ID+1),' ID = ',ID
        ALLOCATE( SBFW(1:NPVX*NCGC(3,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFW on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(3,ID+1)
          SBFW(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        PRINT *,'SBFE(',NPVX*NCGC(4,ID+1),' ID = ',ID
        ALLOCATE( SBFE(1:NPVX*NCGC(4,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFE on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(4,ID+1)
          SBFE(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        PRINT *,'SBFN(',NPVX*NCGC(5,ID+1),' ID = ',ID
        ALLOCATE( SBFN(1:NPVX*NCGC(5,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFN on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(5,ID+1)
          SBFN(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        PRINT *,'SBFT(',NPVX*NCGC(6,ID+1),' ID = ',ID
        ALLOCATE( SBFT(1:NPVX*NCGC(6,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFT on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(6,ID+1)
          SBFT(M) = 0.D+0
        ENDDO
      ENDIF
!
!---  Allocate memory for ghost-cell receive buffers in the six
!     stencil directions  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        PRINT *,'RBFB(',NPVX*NCGC(6,ID+1),' ID = ',ID
        ALLOCATE( RBFB(1:NPVX*NCGC(6,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFB on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(6,ID+1)
          RBFB(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        PRINT *,'RBFS(',NPVX*NCGC(5,ID+1),' ID = ',ID
        ALLOCATE( RBFS(1:NPVX*NCGC(5,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFS on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(5,ID+1)
          RBFS(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        PRINT *,'RBFW(',NPVX*NCGC(4,ID+1),' ID = ',ID
        ALLOCATE( RBFW(1:NPVX*NCGC(4,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFW on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(4,ID+1)
          RBFW(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        PRINT *,'RBFE(',NPVX*NCGC(3,ID+1),' ID = ',ID
        ALLOCATE( RBFE(1:NPVX*NCGC(3,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFE on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(3,ID+1)
          RBFE(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        PRINT *,'RBFN(',NPVX*NCGC(2,ID+1),' ID = ',ID
        ALLOCATE( RBFN(1:NPVX*NCGC(2,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFN on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(2,ID+1)
          RBFN(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        PRINT *,'RBFT(',NPVX*NCGC(1,ID+1),' ID = ',ID
        ALLOCATE( RBFT(1:NPVX*NCGC(1,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFT on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(1,ID+1)
          RBFT(M) = 0.D+0
        ENDDO
      ENDIF
!
!---  Initialize ghost cell map  ---
!
      DO L = 1,NFCGC(ID+1)
        IGHC(L) = 0
      ENDDO
!
!---  Create a local node connection map and identify ghost cells  ---
!
      KFLD_L = KDP(2,ID+1)-KDP(1,ID+1)+1
      JFLD_L = JDP(2,ID+1)-JDP(1,ID+1)+1
      IFLD_L = IDP(2,ID+1)-IDP(1,ID+1)+1
      DO K = KDP(1,ID+1),KDP(2,ID+1)
        DO J = JDP(1,ID+1),JDP(2,ID+1)
          DO I = IDP(1,ID+1),IDP(2,ID+1)
            KX = K - KDP(1,ID+1) + 1
            JX = J - JDP(1,ID+1) + 1
            IX = I - IDP(1,ID+1) + 1
            N = (KX-1)*IFLD_L*JFLD_L + (JX-1)*IFLD_L + IX
!
!---        Bottom connection  ---
!
            ICM(1,N) = 0
            IF( KX.GT.1 ) THEN
              NB = N-IFLD_L*JFLD_L
              IF( IXP(NB).GT.0 .AND. INBS(1,N).EQ.0 ) ICM(1,N) = NB
            ENDIF
!
!---        Bottom ghost cells  ---
!
            IF( KX.EQ.1 .AND. K.GT.1 ) IGHC(N) = 1
!
!---        South connection  ---
!
            ICM(2,N) = 0
            IF( JX.GT.1 ) THEN
              NS = N-IFLD_L
              IF( IXP(NS).GT.0 .AND. INBS(2,N).EQ.0 ) ICM(2,N) = NS
            ENDIF
!
!---        South ghost cells  ---
!
            IF( JX.EQ.1 .AND. J.GT.1 ) IGHC(N) = 1
!
!---        West connection  ---
!
            ICM(3,N) = 0
            IF( IX.GT.1 ) THEN
              NW = N-1
              IF( IXP(NW).GT.0 .AND. INBS(3,N).EQ.0 ) ICM(3,N) = NW
            ENDIF
!
!---        West ghost cells  ---
!
            IF( IX.EQ.1 .AND. I.GT.1 ) IGHC(N) = 1
!
!---        East connection  ---
!
            ICM(4,N) = 0
            IF( IX.LT.IFLD_L ) THEN
              NE = N+1
              IF( IXP(NE).GT.0 .AND. INBS(4,N).EQ.0 ) ICM(4,N) = NE
            ENDIF
!
!---        East ghost cells  ---
!
            IF( IX.EQ.IFLD_L .AND. I.LT.IDP(2,NP) ) IGHC(N) = 1
!
!---        North connection  ---
!
            ICM(5,N) = 0
            IF( JX.LT.JFLD_L ) THEN
              NN = N+IFLD_L
              IF( IXP(NN).GT.0 .AND. INBS(5,N).EQ.0 ) ICM(5,N) = NN
            ENDIF
!
!---        North ghost cells  ---
!
            IF( JX.EQ.JFLD_L .AND. J.LT.JDP(2,NP) ) IGHC(N) = 1
!
!---        Top connection  ---
!
            ICM(6,N) = 0
            IF( KX.LT.KFLD_L ) THEN
              NT = N+IFLD_L*JFLD_L
              IF( IXP(NT).GT.0 .AND. INBS(6,N).EQ.0 ) ICM(6,N) = NT
            ENDIF
!
!---        Top ghost cells  ---
!
            IF( KX.EQ.KFLD_L .AND. K.LT.KDP(2,NP) ) IGHC(N) = 1
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_GRID_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_PE_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary co2_prop.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE NCG_PT
      USE GRID
      USE GLB_PAR
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(11) :: VARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_PE_EOR'
!
!---  Allocate memory for CO2 property variables  ---
!
      CALL ALLOC_NCG_PT
!
!---  Open co2_prop.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'co2_prop.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IFILE,IERR )
      INCG = 1
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
!
!---  Read number number of pressure points  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFILE,OFFSET,IP_TA(INCG),NVAR,
     &  MPI_INTEGER,STATUS,IERR )
!
!---  Read pressure points  ---
!
      NVAR = IP_TA(INCG)
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFILE,OFFSET,P_TA(1,INCG),NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read number of temperature points for each pressure point  ---
!
      NVAR = IP_TA(INCG)
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFILE,OFFSET,IT_TA(1,INCG),NVAR,
     &  MPI_INTEGER,STATUS,IERR )
!
!---  Loop over the number of pressure points, reading temperatures  ---
!
      DO IPX = 1,IP_TA(INCG)
        NVAR = IT_TA(IPX,INCG)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,T_TA(1,IPX,INCG),NVAR,
     &    MPI_REAL8,STATUS,IERR )
      ENDDO
!
!---  Loop over the number of pressure points, reading density  ---
!
      DO IPX = 1,IP_TA(INCG)
        NVAR = IT_TA(IPX,INCG)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,RHO_TA(1,IPX,INCG),NVAR,
     &    MPI_REAL8,STATUS,IERR )
      ENDDO
!
!---  Loop over the number of pressure points, reading enthalpy  ---
!
      DO IPX = 1,IP_TA(INCG)
        NVAR = IT_TA(IPX,INCG)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,H_TA(1,IPX,INCG),NVAR,
     &    MPI_REAL8,STATUS,IERR)
      ENDDO
!
!---  Loop over the number of pressure points, reading internal
!     energy  ---
!
      DO IPX = 1,IP_TA(INCG)
        NVAR = IT_TA(IPX,INCG)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,U_TA(1,IPX,INCG),NVAR,
     &    MPI_REAL8,STATUS,IERR)
      ENDDO
!
!---  Loop over the number of pressure points, reading fugacity  ---
!
      DO IPX = 1,IP_TA(INCG)
        NVAR = IT_TA(IPX,INCG)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,FUG_TA(1,IPX,INCG),NVAR,
     &    MPI_REAL8,STATUS,IERR )
      ENDDO
!
!---  Loop over the number of pressure points, reading entropy  ---
!
      DO IPX = 1,IP_TA(INCG)
        NVAR = IT_TA(IPX,INCG)
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,S_TA(1,IPX,INCG),NVAR,
     &    MPI_REAL8,STATUS,IERR )
      ENDDO
!
!---  Read index of vapor-liquid point  ---
!
      NVAR = IP_TA(INCG)
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFILE,OFFSET,IV_TA(1,INCG),NVAR,
     &  MPI_INTEGER,STATUS,IERR )
!
!---  Read number of vapor-liquid data points  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFILE,OFFSET,I_LV(INCG),NVAR,
     &  MPI_INTEGER,STATUS,IERR )
!
!---  Loop over the number of vapor-liquid data points, reading
!     temperature, pressure, liquid density, liquid enthalpy,
!     liquid internal energy, liquid entropy, vapor density,
!     vapor enthalpy, vapor internal energy, internal entropy,
!     vapor fugacity  ---
!
      DO IPX = 1,IP_TA(INCG)
        NVAR = 11
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFILE,OFFSET,VARX,NVAR,
     &    MPI_REAL8,STATUS,IERR )
        T_LV(IPX,INCG) = VARX(1)
        P_LV(IPX,INCG) = VARX(2)
        RHOL_LV(IPX,INCG) = VARX(3)
        HL_LV(IPX,INCG) = VARX(4)
        UL_LV(IPX,INCG) = VARX(5)
        SL_LV(IPX,INCG) = VARX(6)
        RHOV_LV(IPX,INCG) = VARX(7)
        HV_LV(IPX,INCG) = VARX(8)
        UV_LV(IPX,INCG) = VARX(9)
        SV_LV(IPX,INCG) = VARX(10)
        FUG_LV(IPX,INCG) = VARX(11)
      ENDDO
!
!---  Close the co2_prop.bin file  ---
!
      CALL MPI_FILE_CLOSE( IFILE,IERR )
!
!---  Load pressure triple-point and critical-point indices  ---
!
      DO I=1,IP_TA(INCG)
        IF( ABS(P_TA(I,INCG)-(1.D-6*PTPA)).LT.EPSL ) IPTP(INCG) = I
        IF( ABS(P_TA(I,INCG)-(1.D-6*PCRA)).LT.EPSL ) IPCR(INCG) = I
      ENDDO
!
!---  Vapor temperature splines  ---
!
      DO IPX = 1,IP_TA(INCG)
        N = IT_TA(IPX,INCG)-IV_TA(IPX,INCG)+1
        CALL SPLINE( T_TA(IV_TA(IPX,INCG),IPX,INCG),
     &    RHO_TA(IV_TA(IPX,INCG),IPX,INCG),N,
     &    RHO_ST(IV_TA(IPX,INCG),IPX,INCG) )
        CALL SPLINE( T_TA(IV_TA(IPX,INCG),IPX,INCG),
     &    H_TA(IV_TA(IPX,INCG),IPX,INCG),N,
     &    H_ST(IV_TA(IPX,INCG),IPX,INCG) )
        CALL SPLINE( T_TA(IV_TA(IPX,INCG),IPX,INCG),
     &    U_TA(IV_TA(IPX,INCG),IPX,INCG),N,
     &    U_ST(IV_TA(IPX,INCG),IPX,INCG) )
        CALL SPLINE( T_TA(IV_TA(IPX,INCG),IPX,INCG),
     &    FUG_TA(IV_TA(IPX,INCG),IPX,INCG),N,
     &    FUG_ST(IV_TA(IPX,INCG),IPX,INCG) )
        CALL SPLINE( T_TA(IV_TA(IPX,INCG),IPX,INCG),
     &    S_TA(IV_TA(IPX,INCG),IPX,INCG),N,
     &    S_ST(IV_TA(IPX,INCG),IPX,INCG) )
       ENDDO
!
!---  Liquid temperature splines  ---
!
      DO IPX = 1,IP_TA(INCG)
        N = IV_TA(IPX,INCG)-1
        IF( N.GT.0 ) THEN
          CALL SPLINE( T_TA(1,IPX,INCG),
     &      RHO_TA(1,IPX,INCG),N,
     &      RHO_ST(1,IPX,INCG) )
          CALL SPLINE( T_TA(1,IPX,INCG),
     &      H_TA(1,IPX,INCG),N,
     &      H_ST(1,IPX,INCG) )
          CALL SPLINE( T_TA(1,IPX,INCG),
     &      U_TA(1,IPX,INCG),N,
     &      U_ST(1,IPX,INCG) )
          CALL SPLINE( T_TA(1,IPX,INCG),
     &      FUG_TA(1,IPX,INCG),N,
     &      FUG_ST(1,IPX,INCG) )
          CALL SPLINE( T_TA(1,IPX,INCG),
     &      S_TA(1,IPX,INCG),N,
     &      S_ST(1,IPX,INCG) )
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_PE_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_PROP_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary mech.bin, hydr.bin, satu1.bin,  satu2.bin, perm.bin,
!     comp.bin, and tabl.bin files for property data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE PROP
      USE MPI
      USE GRID
      USE GLB_PAR
      USE GEO_MECH
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_PROP_EOR'
!
!---  Allocate local memory for property arrays ---
!
      CALL ALLOC_PROP
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Open mech.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'mech.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of IZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IZ,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RHOS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RHOS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of CPS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CPS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of CMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*4
      OFFSET = IOFFSET + NBYTB + NC*4*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*4*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of POR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,POR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TOR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TOR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of ITOR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ITOR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the mech.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open hydr.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'hydr.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of PERM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*9
      OFFSET = IOFFSET + NBYTB + NC*9*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*9*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PERM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'PERM(1,1) = ',PERM(1,1),'PERM(1,NFCGC(ID+1)) = ',
     &  PERM(1,NFCGC(ID+1)),'ID = ',ID
!
!---  Read local copies of IPRF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IPRF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      PRINT *,'IPRF(1) = ',IPRF(1),'IPRF(NFCGC(ID+1)) = ',
     &  IPRF(NFCGC(ID+1)),'ID = ',ID
!
!---  Close the hydr.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open satu1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'satu1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of SCHR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LSCHR
      OFFSET = IOFFSET + NBYTB + NC*LSCHR*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LSCHR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,SCHR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'SCHR(2,1) = ',SCHR(2,1),'SCHR(2,NFCGC(ID+1)) = ',
     &  SCHR(2,NFCGC(ID+1)),'ID = ',ID
!
!---  Close the satu1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open satu2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'satu2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ISCHR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISCHR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      PRINT *,'ISCHR(1) = ',ISCHR(1),'ISCHR(NFCGC(ID+1)) = ',
     &  ISCHR(NFCGC(ID+1)),'ID = ',ID
!
!---  Read local copies of ISM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      PRINT *,'ISM(1) = ',ISM(1),'ISM(NFCGC(ID+1)) = ',
     &  ISM(NFCGC(ID+1)),'ID = ',ID
!
!---  Close the satu2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open perm.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'perm.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ISKP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISKP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RPGC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPGC
      OFFSET = IOFFSET + NBYTB + NC*LRPGC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPGC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPGC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'RPGC(2,1) = ',RPGC(2,1),'RPGC(2,NFCGC(ID+1)) = ',
     &  RPGC(2,NFCGC(ID+1)),'ID = ',ID
!
!---  Read local copies of IRPG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPG,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RPLC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPLC
      OFFSET = IOFFSET + NBYTB + NC*LRPLC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPLC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPLC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'RPLC(2,1) = ',RPLC(2,1),'RPLC(2,NFCGC(ID+1)) = ',
     &  RPLC(2,NFCGC(ID+1)),'ID = ',ID
!
!---  Read local copies of IRPL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RPNC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPNC
      OFFSET = IOFFSET + NBYTB + NC*LRPNC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPNC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPNC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'RPNC(2,1) = ',RPNC(2,1),'RPNC(2,NFCGC(ID+1)) = ',
     &  RPNC(2,NFCGC(ID+1)),'ID = ',ID
!
!---  Read local copies of IRPN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the perm.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open comp.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'comp.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of PCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PCMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'PCMP(1) = ',PCMP(1),'PCMP(NFCGC(ID+1)) = ',
     &  PCMP(NFCGC(ID+1)),'ID = ',ID
!
!---  Read local copies of TCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TCMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'TCMP(1) = ',TCMP(1),'TCMP(NFCGC(ID+1)) = ',
     &  TCMP(NFCGC(ID+1)),'ID = ',ID
!
!---  Close the comp.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!mlr added - check alloc_prop to see that these variables are included
!---  Open ther.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'ther.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of THKS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*9
      OFFSET = IOFFSET + NBYTB + NC*9*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*9*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,THKS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'THKS(1,1) = ',THKS(1,1),'THKS(1,NFCGC(ID+1)) = ',
     &  THKS(1,NFCGC(ID+1)),'ID = ',ID
!
!---  Read local copies of ITHK array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ITHK,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      PRINT *,'ITHK(1) = ',ITHK(1),'ITHK(NFCGC(ID+1)) = ',
     &  PCMP(ITHK(ID+1)),'ID = ',ID
!
!---  Read local copies of DFEF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*5
      OFFSET = IOFFSET + NBYTB + NC*5*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*5*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DFEF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      PRINT *,'DFEF(1,1) = ',DFEF(1,1),'DFEF(1,NFCGC(ID+1)) = ',
     &  DFEF(1,NFCGC(ID+1)),'ID = ',ID
!
!---  Close the ther.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_PROP_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_REACT_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary ecke.bin file for ECKEChem (reactive transport) 
!     data
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE PROP
      USE HYST
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX,VARZ
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX,IVARZ
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_REACT_EOR'
!
!---  Open ecke.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'ecke.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate and initialize memory, global and local, for
!     reactive species arrays  ---
!
      CALL ALLOC_REACT
      CALL INTLZ_REACT
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Allocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of reactive species integers
!     (duplicated across processors)  ---
!
      NVAR = 19
      ALLOCATE( IVARZ(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARZ'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARZ,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IACTEX = IVARZ(1)
      IACTV = IVARZ(2)
      ISP_IEDL = IVARZ(3)
      NEQE = IVARZ(4)
      NEQC = IVARZ(5)
      NEQK = IVARZ(6)
      NESITE = IVARZ(7)
      NRCE = IVARZ(8)
      NRCK = IVARZ(9)
      NRTSI = IVARZ(10)
      NSPC = IVARZ(11)
      NSPE = IVARZ(12)
      NSPG = IVARZ(13)
      NSPK = IVARZ(14)
      NSPL = IVARZ(15)
      NSPLK = IVARZ(16)
      NSPN = IVARZ(17)
      NSPR = IVARZ(18)
      NSPS = IVARZ(19)
!      PRINT *,'IVARZ = ',(IVARZ(M),M=1,NVAR),' ID = ',ID
      DEALLOCATE( IVARZ,STAT=ISTAT )
      CHMSG = 'IVARZ'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read reactive transport parameters, indices, and variables
!     if reactive species are modeled  ---
!
      IF( NEQE+NEQC+NEQK.GT.0 ) THEN
!
!---    Read index for equilibrium equations
!       (duplicated across processors)  ---
!
        NVAR = (LSEE+2)*LEQE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_E,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_E = ',((IEQ_E(L,M),L=1,LSEE+2),M=1,LEQE),
!     &    ' ID = ',ID
!
!---    Read index for conservation equations
!       (duplicated across processors)  ---
!
        NVAR = (LSEC+1)*LEQC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_C,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_C = ',((IEQ_C(L,M),L=1,LSEC+1),M=1,LEQC),
!     &    ' ID = ',ID
!
!---    Read index for kinetic equations
!       (duplicated across processors)  ---
!
        NVAR = (LSEK+LREK+2)*LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_K,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_K = ',((IEQ_K(L,M),L=1,LSEK+LREK+2),M=1,LEQK),
!     &    ' ID = ',ID
!
!---    Read index for reactive equation sequencing
!       (duplicated across processors)  ---
!
        NVAR = LSPR
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_S,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_S = ',(IEQ_S(L),L=1,LSPR),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISP_E,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISP_E = ',(ISP_E(L),L=1,LSPE),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEL_LK,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEL_LK = ',(IEL_LK(L),L=1,LSPE),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPR
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISP_MN,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISP_MN = ',(ISP_MN(L),L=1,LSPR),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LEQE+LEQC+LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISP_S,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISP_S = ',(ISP_S(L),L=1,LEQE+LEQC+LEQK),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSOLU+LSPT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IMMB,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IMMB = ',(IMMB(L),L=1,LSOLU+LSPT),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = (LSPK+3)*LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IRC_K,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IRC_K = ',((IRC_K(L,M),L=1,LSPK+3),M=1,LRCK),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPK+11
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IRCKN,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IRCKN = ',(IRCKN(L),L=1,LSPK+11),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IRCKT,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IRCKT = ',(IRCKT(L),L=1,LRCK),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 2*LNGC+LSPR+14
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISPLK,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISPLK = ',(ISPLK(L),L=1,2*LNGC+LSPR+14),
!     &    ' ID = ',ID
!
!---    Read index for reactive species  ---
!
        DO J = 1,LSPS
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTI + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            ISP_OW(J,N) = IVARX(N)
          ENDDO
!          PRINT *,'ISP_OW(',J,',1) = ',ISP_OW(J,1),
!     &      'ISP_OW(',J,',',ND(NVAR),') = ',ISP_OW(J,NVAR),' ID = ',ID
        ENDDO
!
!---    Read index for reactive species  ---
!
        DO M = 1,LSPR
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTI + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            IC_SP(N,M) = IVARX(N)
          ENDDO
!          PRINT *,'IC_SP(1,',M,') = ',IC_SP(1,M),
!     &      'IC_SP(',ND(NVAR),',',M,') = ',IC_SP(NVAR,M),' ID = ',ID
        ENDDO
!
!---    Read parameters for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 4
        ALLOCATE( VARZ(1:NVAR),STAT=ISTAT )
        CHMSG = 'VARZ'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,VARZ,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        ACTVC = VARZ(1)
        CMIN = VARZ(2)
        SP_MDG = VARZ(3)
        SP_MDL = VARZ(4)
        DEALLOCATE( VARZ,STAT=ISTAT )
        CHMSG = 'VARZ'
        CALL DEALLOC_ERROR( CHMSG,ISTAT )
!        PRINT *,'ACTVC = ',ACTVC,' CMIN = ',CMIN,
!     &    ' SP_MDG = ',SP_MDG,' SP_MDL = ',SP_MDL,' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 3
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SP_SDCL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SP_SDCL = ',(SP_SDCL(L),L=1,3),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LMC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CFMX,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'LMC = ',LMC,' CFMX = ',(CFMX(L),L=1,LMC),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPR
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CHARG,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'LSPR = ',LSPR,' CHARG = ',(CHARG(L),L=1,LSPR),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSEC*LEQC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,EQ_C,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'EQ_C = ',((EQ_C(L,M),L=1,LSEC),M=1,LEQC),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSEE*LEQE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,EQ_E,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'EQ_E = ',((EQ_E(L,M),L=1,LSEE),M=1,LEQE),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = (LSEK+LREK)*LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,EQ_K,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'EQ_K = ',((EQ_K(L,M),L=1,LSEK+LREK),M=1,LEQK),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 5*LRCE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RC_E,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'RC_E = ',((RC_E(L,M),L=1,5),M=1,LRCE),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = (LSPK+11)*LCKN*LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RC_K,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'RC_K = ',(RC_K(K,1,1),K=1,LSPK+11),' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 3*LSPL
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SP_L,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SP_L = ',((SP_L(L,M),L=1,3),M=1,LSPL),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 2*LSPS
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SP_S,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SP_S = ',((SP_S(L,M),L=1,2),M=1,LSPS),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO I = 1,3
          DO J = 1,LSPS
            NVAR = NFCGC(ID+1)
            OFFSET = IOFFSET + NC*NBYTR + NBYTB
            IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
            CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &        STATUS,IERR)
            DO N = 1,NFCGC(ID+1)
              RS_S(I,J,N) = VARX(N)
            ENDDO
          ENDDO
        ENDDO
!        PRINT *,'RS_S = ',((RS_S(I,J,1),I=1,3),J=1,LSPS),' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO M = 1,LEQC+LEQK
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            YSPG(N,M) = VARX(N)
          ENDDO
        ENDDO
!        PRINT *,'YSPG = ',(YSPG(1,M),M=1,LEQC+LEQK),' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO M = 1,LEQC+LEQK
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            YSPL(N,M) = VARX(N)
          ENDDO
        ENDDO
!        PRINT *,'YSPL = ',(YSPL(1,M),M=1,LEQC+LEQK),' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO M = 1,LSPR
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            SP_C(N,M) = VARX(N)
          ENDDO
        ENDDO
!        PRINT *,'SP_C = ',(SP_C(1,M),M=1,LSPR),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LRCE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RCNME,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'RCNME = ',(RCNME(L),L=1,LRCE),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RCNMK,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'RCNMK = ',(RCNMK(L),L=1,LRCK),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LEQC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMC,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMC = ',(SPNMC(L),L=1,LEQC),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMK,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMK = ',(SPNMK(L),L=1,LEQK),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPG
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMG,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMG = ',(SPNMG(L),L=1,LSPG),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPL
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNML,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNML = ',(SPNML(L),L=1,LSPL),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPS
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMS,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMS = ',(SPNMS(L),L=1,LSPS),' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNME,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNME = ',(SPNME(L),L=1,LSPE),' ID = ',ID
      ENDIF
!
!---  Deallocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Close the ecke.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_REACT_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_SOLU_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary grid.bin file for solution control and output 
!     data
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE OUTPU
      USE GRID
      USE GLB_PAR
      USE FDVP
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
      CHARACTER(64), DIMENSION(2) :: FNSFX
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_SOLU_EOR'
!
!---  Open solu.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'solu.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Initialize error messaging variables  ---
!
      DO M = 1,4
        I_ERR(M) = 0
        M_ERR(M) = ''
      ENDDO
      I_ERR(4) = NP + 1
      R_ERR = 0.D+0
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
!
!---  Read parameter variables (duplicated across processors)  ---
!
      NVAR = 341
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      L_BH = IVARX(1)
      L_CW = IVARX(2)
      L_DP = IVARX(3)
      L_EC = IVARX(4)
      L_FRC = IVARX(5)
      L_LV = IVARX(6)
      L_LW = IVARX(7)
      L_SFC = IVARX(8)
      LAD = IVARX(9)
      LALC = IVARX(10)
      LAN = IVARX(11)
      LANI = IVARX(12)
      LANW = IVARX(13)
      LATM = IVARX(14)
      LBAL = IVARX(15)
      LBC = IVARX(16)
      LBC_BH = IVARX(17)
      LBC_EC = IVARX(18)
      LBC_FRC = IVARX(19)
      LBC_GM = IVARX(20)
      LBCA = IVARX(21)
      LBCC = IVARX(22)
      LBCG = IVARX(23)
      LBCGC = IVARX(24)
      LBCH = IVARX(25)
      LBCI = IVARX(26)
      LBCIN = IVARX(27)
      LBCIN_GM = IVARX(28)
      LBCL = IVARX(29)
      LBCN = IVARX(30)
      LBCN2 = IVARX(31)
      LBCS = IVARX(32)
      LBCT = IVARX(33)
      LBCU = IVARX(34)
      LBCV = IVARX(35)
      LBCV_GM = IVARX(36)
      LBD = IVARX(37)
      LBN_BH = IVARX(38)
      LBN_BHC = IVARX(39)
      LBR = IVARX(40)
      LBTM = IVARX(41)
      LBTM_GM = IVARX(42)
      LC = IVARX(43)
      LCAT = IVARX(44)
      LCDC = IVARX(45)
      LCDP = IVARX(46)
      LCDS = IVARX(47)
      LCH_HT = IVARX(48)
      LCHEM = IVARX(49)
      LCKN = IVARX(50)
      LCMP = IVARX(51)
      LCN = IVARX(52)
      LCN_HT = IVARX(53)
      LCOAX_BH = IVARX(54)
      LCP_HT = IVARX(55)
      LD = IVARX(56)
      LDCO2 = IVARX(57)
      LEPD = IVARX(58)
      LEQC = IVARX(59)
      LEQE = IVARX(60)
      LEQK = IVARX(61)
      LESITE = IVARX(62)
      LF_FRC = IVARX(63)
      LF_FRCC = IVARX(64)
      LFC_BH = IVARX(65)
      LFC_FRC = IVARX(66)
      LFD = IVARX(67)
      LFD_DP = IVARX(68)
      LFD_EC = IVARX(69)
      LFDA = IVARX(70)
      LFDC = IVARX(71)
      LFDCR = IVARX(72)
      LFDD = IVARX(73)
      LFDG = IVARX(74)
      LFDGC = IVARX(75)
      LFDH = IVARX(76)
      LFDI = IVARX(77)
      LFDL = IVARX(78)
      LFDM = IVARX(79)
      LFDN = IVARX(80)
      LFDN2 = IVARX(81)
      LFDNH = IVARX(82)
      LFDR = IVARX(83)
      LFDRG = IVARX(84)
      LFDRL = IVARX(85)
      LFDRN = IVARX(86)
      LFDS = IVARX(87)
      LFDT = IVARX(88)
      LFEN = IVARX(89)
      LFILES = IVARX(90)
      LFW = IVARX(91)
      LFX = IVARX(92)
      LFX_MPI = IVARX(93)
      LFXY = IVARX(94)
      LFY = IVARX(95)
      LFY_MPI = IVARX(96)
      LFYZ = IVARX(97)
      LFZ = IVARX(98)
      LFZ_MPI = IVARX(99)
      LFZX = IVARX(100)
      LG = IVARX(101)
      LGC = IVARX(102)
      LHBW = IVARX(103)
      LHE_HT = IVARX(104)
      LHF_HT = IVARX(105)
      LHYD = IVARX(106)
      LI_BH = IVARX(107)
      LINC = IVARX(108)
      LINH = IVARX(109)
      LIS = IVARX(110)
      LJA = IVARX(111)
      LJB = IVARX(112)
      LJC = IVARX(113)
      LJC_BH = IVARX(114)
      LJC_GM = IVARX(115)
      LJD = IVARX(116)
      LJE = IVARX(117)
      LJF = IVARX(118)
      LJG = IVARX(119)
      LJG_BCF = IVARX(120)
      LJG_BCM = IVARX(121)
      LJG_BH = IVARX(122)
      LJG_FCB = IVARX(123)
      LJG_FCM = IVARX(124)
      LJG_FRC = IVARX(125)
      LJG_GM = IVARX(126)
      LJG_MCB = IVARX(127)
      LJG_MCF = IVARX(128)
      LJH = IVARX(129)
      LJH_BCF = IVARX(130)
      LJH_BCM = IVARX(131)
      LJH_BH = IVARX(132)
      LJH_FCB = IVARX(133)
      LJH_FCM = IVARX(134)
      LJH_FRC = IVARX(135)
      LJH_GM = IVARX(136)
      LJH_MCB = IVARX(137)
      LJH_MCF = IVARX(138)
      LJI = IVARX(139)
      LJJ = IVARX(140)
      LJK = IVARX(141)
      LJK_BCF = IVARX(142)
      LJK_BCM = IVARX(143)
      LJK_BH = IVARX(144)
      LJK_FCB = IVARX(145)
      LJK_FCM = IVARX(146)
      LJK_FRC = IVARX(147)
      LJK_MCB = IVARX(148)
      LJK_MCF = IVARX(149)
      LJL = IVARX(150)
      LJL_BCF = IVARX(151)
      LJL_BCM = IVARX(152)
      LJL_BH = IVARX(153)
      LJL_FCB = IVARX(154)
      LJL_FCM = IVARX(155)
      LJL_FRC = IVARX(156)
      LJL_MCB = IVARX(157)
      LJL_MCF = IVARX(158)
      LJM = IVARX(159)
      LJN = IVARX(160)
      LJN_BH = IVARX(161)
      LJO = IVARX(162)
      LJO_GM = IVARX(163)
      LL = IVARX(164)
      LM = IVARX(165)
      LMC = IVARX(166)
      LMCG = IVARX(167)
      LMNP = IVARX(168)
      LMPH = IVARX(169)
      LN = IVARX(170)
      LN_BH = IVARX(171)
      LN_BHC = IVARX(172)
      LN_CW = IVARX(173)
      LN_LW = IVARX(174)
      LN2 = IVARX(175)
      LNAF = IVARX(176)
      LNC_FRC = IVARX(177)
      LNCF = IVARX(178)
      LNEU = IVARX(179)
      LNGC = IVARX(180)
      LNHC = IVARX(181)
      LNNF = IVARX(182)
      LNNGC = IVARX(183)
      LNOTES = IVARX(184)
      LNW = IVARX(185)
      LNWN = IVARX(186)
      LNWS = IVARX(187)
      LNWT = IVARX(188)
      LNWV = IVARX(189)
      LO_PH = IVARX(190)
      LO_TH = IVARX(191)
      LOBDS = IVARX(192)
      LOBDT = IVARX(193)
      LOUPV = IVARX(194)
      LP_MPI = IVARX(195)
      LP_TA = IVARX(196)
      LPC = IVARX(197)
      LPCF = IVARX(198)
      LPE_HT = IVARX(199)
      LPF_EOR = IVARX(200)
      LPH = IVARX(201)
      LPLANT = IVARX(202)
      LPOLYC = IVARX(203)
      LPOLYN = IVARX(204)
      LPP_HT = IVARX(205)
      LPT = IVARX(206)
      LPTA = IVARX(207)
      LPTM = IVARX(208)
      LPX_MPI = IVARX(209)
      LPY_MPI = IVARX(210)
      LPZ_MPI = IVARX(211)
      LR = IVARX(212)
      LRC = IVARX(213)
      LRCE = IVARX(214)
      LRCG = IVARX(215)
      LRCK = IVARX(216)
      LRCL = IVARX(217)
      LRCN = IVARX(218)
      LRCS = IVARX(219)
      LRCT = IVARX(220)
      LREF = IVARX(221)
      LREK = IVARX(222)
      LREL = IVARX(223)
      LREM = IVARX(224)
      LRFN = IVARX(225)
      LRK = IVARX(226)
      LRPGC = IVARX(227)
      LRPL = IVARX(228)
      LRPLC = IVARX(229)
      LRPNC = IVARX(230)
      LS = IVARX(231)
      LSALC = IVARX(232)
      LSCHR = IVARX(233)
      LSEC = IVARX(234)
      LSEE = IVARX(235)
      LSEK = IVARX(236)
      LSF = IVARX(237)
      LSFCA = IVARX(238)
      LSFCC = IVARX(239)
      LSFCN = IVARX(240)
      LSFCP = IVARX(241)
      LSFCT = IVARX(242)
      LSFDOM = IVARX(243)
      LSFV = IVARX(244)
      LSFVGC = IVARX(245)
      LSOLSR = IVARX(246)
      LSOLU = IVARX(247)
      LSOLU_BH = IVARX(248)
      LSOLU_CW = IVARX(249)
      LSP = IVARX(250)
      LSPBC = IVARX(251)
      LSPC_CW = IVARX(252)
      LSPE = IVARX(253)
      LSPG = IVARX(254)
      LSPILL = IVARX(255)
      LSPK = IVARX(256)
      LSPL = IVARX(257)
      LSPLK = IVARX(258)
      LSPN = IVARX(259)
      LSPR = IVARX(260)
      LSPS = IVARX(261)
      LSPT = IVARX(262)
      LSR = IVARX(263)
      LSR_BH = IVARX(264)
      LSR_FRC = IVARX(265)
      LSRX = IVARX(266)
      LSRY = IVARX(267)
      LSRZ = IVARX(268)
      LSTC = IVARX(269)
      LSTM = IVARX(270)
      LSTM_BH = IVARX(271)
      LSTM_FRC = IVARX(272)
      LSU = IVARX(273)
      LSV = IVARX(274)
      LSW = IVARX(275)
      LSX = IVARX(276)
      LSXC = IVARX(277)
      LSXG = IVARX(278)
      LSXGC = IVARX(279)
      LSXL = IVARX(280)
      LSXLC = IVARX(281)
      LSXN = IVARX(282)
      LSXN2 = IVARX(283)
      LSXNC = IVARX(284)
      LSXS = IVARX(285)
      LSXT = IVARX(286)
      LSY = IVARX(287)
      LSYC = IVARX(288)
      LSYG = IVARX(289)
      LSYGC = IVARX(290)
      LSYL = IVARX(291)
      LSYLC = IVARX(292)
      LSYN = IVARX(293)
      LSYN2 = IVARX(294)
      LSYNC = IVARX(295)
      LSYS = IVARX(296)
      LSYT = IVARX(297)
      LSZ = IVARX(298)
      LSZC = IVARX(299)
      LSZG = IVARX(300)
      LSZGC = IVARX(301)
      LSZL = IVARX(302)
      LSZLC = IVARX(303)
      LSZN = IVARX(304)
      LSZN2 = IVARX(305)
      LSZNC = IVARX(306)
      LSZS = IVARX(307)
      LSZT = IVARX(308)
      LSZW = IVARX(309)
      LT = IVARX(310)
      LT_BH = IVARX(311)
      LT_FRC = IVARX(312)
      LT_FRCC = IVARX(313)
      LT_PH = IVARX(314)
      LT_TA = IVARX(315)
      LT_TH = IVARX(316)
      LTBL = IVARX(317)
      LTC_FRC = IVARX(318)
      LTP_HT = IVARX(319)
      LUGR = IVARX(320)
      LUK = IVARX(321)
      LUK_BH = IVARX(322)
      LUK_CW = IVARX(323)
      LUK_SFC = IVARX(324)
      LUKW = IVARX(325)
      LVIC_FRC = IVARX(326)
      LVPLOT = IVARX(327)
      LVREF = IVARX(328)
      LWELL = IVARX(329)
      LWF_CW = IVARX(330)
      LWF_LW = IVARX(331)
      LWI_CW = IVARX(332)
      LWI_LW = IVARX(333)
      LWN_CW = IVARX(334)
      LWN_LW = IVARX(335)
      LWSI = IVARX(336)
      LWT_CW = IVARX(337)
      LWTI = IVARX(338)
      LWTP_CW = IVARX(339)
      LXP_FRC = IVARX(340)
      LXYZG = IVARX(341)
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read time variables (duplicated across processors)  ---
!
      NVAR = 18
      ALLOCATE( VARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      TM = VARX(1)
      TMMX = VARX(2)
      TMPR = VARX(3)
      DT = VARX(4)
      DTI = VARX(5)
      DTMX = VARX(6)
      DTMN = VARX(7)
      DTAF = VARX(8)
      DTCF = VARX(9)
      DTO = VARX(10)
      DTSO = VARX(11)
      RSDMX = VARX(12)
      RLXF = VARX(13)
      CRNTMXC = VARX(14)
      RTOL_PETSC = VARX(15)
      ATOL_PETSC = VARX(16)
      DTOL_PETSC = VARX(17)
      MAXITS_PETSC = INT(VARX(18))
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for solution control variables  ---
!
      CALL ALLOC_SOLTN
!
!---  Initialize solution control variables  ---
!
      CALL INTLZ_SOLTN
!
!---  Read time stepping variables (duplicated across processors)  ---
!
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPE,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPD,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPA,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RSDM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LUK*(1+LWELL+LSPILL)
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RSD,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = 20
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,WFMN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read solution control integers (duplicated across processors)  ---
!
      NVAR = 39
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IVRSN = IVARX(1)
      ISIC = IVARX(2)
      ICNV = IVARX(3)
      IEO = IVARX(4)
      ILES = IVARX(5)
      IOM = IVARX(6)
      ICODE = IVARX(7)
      IEQT = IVARX(8)
      IEQW = IVARX(9)
      IEQA = IVARX(10)
      IEQN = IVARX(11)
      IEQO = IVARX(12)
      IEQC = IVARX(13)
      IEQS = IVARX(14)
      IEQD = IVARX(15)
      IEQDO = IVARX(16)
      IEQHA = IVARX(17)
      IEQHN = IVARX(18)
      IEQHO = IVARX(19)
      IEQDA = IVARX(20)
      IAQU = IVARX(21)
      IGAS = IVARX(22)
      INAPL = IVARX(23)
      NEPD = IVARX(24)
      MEPD = IVARX(25)
      IEPD = IVARX(26)
      NRIMX = IVARX(27)
      NSTEP = IVARX(28)
      NRST = IVARX(29)
      NITER = IVARX(30)
      NTSR = IVARX(31)
      NGC = IVARX(32)
      MXSTEP = IVARX(33)
      IUNM = IVARX(34)
      IUNKG = IVARX(35)
      IUNS = IVARX(36)
      IUNK = IVARX(37)
      IUNMOL = IVARX(38)
      ISVC = IVARX(39)
      ISVF = 2*ISVC + 1
      DO M = 1,4
        M_ERR(M) = ''
      ENDDO
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read solution control integers (duplicated across processors)  ---
!
      NVAR = 100
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISLC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IEDLS = 1
      IF( ISLC(4).EQ.1 ) IEDLS = 3
!
!---  Read interfacial averaging indices
!     (duplicated across processors)  ---
!
      NVAR = 20
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IDMN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for output control variables  ---
!
      CALL ALLOC_OUTPU
!
!---  Initialize differential integrated water and component mass  ---
!
      DMW = 0.D+0
      DO L = 1,LNGC
        DMC(L) = 0.D+0
      ENDDO
!
!---  Read output unit conversions
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVTM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVLN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVPLOT,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVREF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      NVAR = 2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVSF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read output units
!     (duplicated across processors)  ---
!
      NVAR = 64
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNTM,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNLN,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64*LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNPLOT,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64*LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNREF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
      NVAR = 64*2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNSF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!
!---  Read output control variables
!     (duplicated across processors)  ---
!
      NVAR = LPTM
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PRTM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read output control integer arrays
!     (duplicated across processors)  ---
!
      NVAR = LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IPLOT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IREF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NDREF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFD,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFGP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read output control integers (duplicated across processors)  ---
!
      NVAR = 14
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      NPRTM = IVARX(1)
      NVPLOT = IVARX(2)
      NREF = IVARX(3)
      NVREF = IVARX(4)
      ICNO = IVARX(5)
      ICNS = IVARX(6)
      NSF = IVARX(7)
      NSFGP = IVARX(8)
      IHSF = IVARX(9)
      IHSF = 0
      IFQS = IVARX(10)
      IFQO = IVARX(11)
      ISGNS = IVARX(12)
      ISGNO = IVARX(13)
      ISGNP = IVARX(14)
!      PRINT *,'NSF = ',NSF,' ID = ',ID
!
!---  Read output character strings, duplicated over all processors  ---
!
      NVAR = 64*LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CHREF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!
!---  Read surface flux file names, duplicated over all processors  ---
!
      NVAR = 64*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,FNSF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!      PRINT *,'FNSF = ',(FNSF(M),M=1,NSF),' ID = ',ID
!
!---  Read surface flux header character strings,
!     duplicated over all processors  ---
!
      NVAR = 64*2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CHSF,NVAR,MPI_CHAR,
     &  STATUS,IERR)
!      PRINT *,'CHSF = ',((CHSF(L,M),L=1,2),M=1,NSF),' ID = ',ID
!
!---  Allocate memory for NSFN  ---
!
      ALLOCATE( NSFN(1:NP),STAT=ISTAT )
      CHMSG = 'NSFN'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local number of surface flux nodes on each processor,
!     duplicated over all processors  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSFN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      DO M = 1,NP
!        PRINT *,'NSFN(',M,') = ',NSFN(M),' ID = ',ID
!      ENDDO
!
!---  Determine offsets for reading ISFN and ISFS  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NSFN(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NSFN(N)
      ENDDO
!      PRINT *,'NC = ',NC,' NCP = ',NCP,' ID = ',ID
!
!---  Allocate memory for ISFN  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFN(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFN'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for ISFS  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFS(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFS'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for ISFB  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFB(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFB'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local surface-flux node number  ---
!
      NVAR = NSFN(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'ISFN = ',(ISFN(M),M=1,NSFN(ID+1)),' ID = ',ID
!
!---  Read local surface-flux number  ---
!
      NVAR = NSFN(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFS,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'ISFS = ',(ISFS(M),M=1,NSFN(ID+1)),' ID = ',ID
!
!---  Close the solu.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_SOLU_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_SORC_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary boco_sorc.bin file for source data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOURC
      USE SOLTN
      USE PROP
      USE OUTPU
      USE MPI
      USE GRID
      USE GLB_PAR
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_SORC_EOR'
!
!---  Open sorc.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'sorc.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate memory for NSR  ---
!
      ALLOCATE( NSR(1:NP),STAT=ISTAT )
      CHMSG = 'NSR'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of source nodes on each processor  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate local source arrays  ---
!
      CALL ALLOC_SOURC
!
!---  Initialize source variables  ---
!
      CALL INTLZ_SOURC
!
!---  Read source variables (duplicated across processors)  ---
!
      LX = 8+LSOLU+LSPT+LNGC
      NVAR = LX*LSTM*LSR
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,SRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read array of source nodes  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NSR(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NSR(N)
      ENDDO
!
!---  Index array of source field nodes  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source number of time points  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source inputs  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRIN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source types  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      DO N = 1,NSR(ID+1)
!        PRINT *,'ISRT(',N,') = ',ISRT(N),' ID = ',ID
!      ENDDO
!
!---  Close the sorc.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_SORC_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_STATE_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary state.bin file for state condition data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE PROP
      USE MPI
      USE HYST
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_STATE_EOR'
!
!---  Open state1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate local memory state condition arrays
!     (including ghost cells)  ---
!
      CALL ALLOC_FDVP
!
!---  Initialize global array memory for general field variables  ---
!
      CALL INTLZ_FDVP
!
!---  Allocate array memory for hysteretic k-s-P function
!     variables  ---
!
      CALL ALLOC_HYST
!
!---  Initialize global array memory for Hysteretic k-s-P function
!     variables  ---
!
      CALL INTLZ_HYST
!
!---  Allocate local temporary state condition arrays
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Read local copies of T array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        T(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PL(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PG(2,N) = VARX(N)
      ENDDO
!
!mlr added
!---  Read local copies of PN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PN(2,N) = VARX(N)
      ENDDO
!
!mlr added - not sure if the following are needed, but they
! are written to restart files so including them here too..
!---  Read local copies of POSM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        POSM(2,N) = VARX(N)
      ENDDO
!
!mlr added
!---  Read local copies of PSO array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PSO(2,N) = VARX(N)
      ENDDO
!
!mlr added
!---  Read local copies of PVA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PVA(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SG(2,N) = VARX(N)
      ENDDO
!
!mlr added
!---  Read local copies of SGT array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SGT(2,N) = VARX(N)
      ENDDO
!
!---  Close the state1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )

!mlr order of variables was different than in mpipp_eor.F
! so some were changed to make them consistent..
! Note: In mpipp_eor the split of variables written to state1.bin,
! state2.bin, etc was sort of arbitrary, but tried to have
! roughly equal numbers of variables written to each file.
!
!---  Open state2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of SL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SL(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SN(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of YLS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YLS(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of TMS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        TMS(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of PCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PCMP(N) = VARX(N)
      ENDDO
!
!---  Read local copies of TCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        TCMP(N) = VARX(N)
      ENDDO
!
!---  Read local copies of NPHAZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        NPHAZ(2,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SI(1,*) array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SI(1,N) = VARX(N)
      ENDDO
!
!---  Read local copies of SI(2,*) array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SI(2,N) = VARX(N)
      ENDDO
!
!---  Close the state2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open state3.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state3.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!mlr - check this..
!---  Read local copies of TMC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        DO IGC = 1,LNGC
          TMC(IGC,2,N) = VARX(N)
        ENDDO
      ENDDO
!
!---  Close the state3.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open state4.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state4.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ZMC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        DO IGC = 1,LNGC
          ZMC(IGC,2,N) = VARX(N)
        ENDDO
      ENDDO
!
!---  Close the state4.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Deallocate local temporary state condition arrays
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_STATE_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_TPOR_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Read binary well_tport.bin file for solute transport data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE PROP
      USE HYST
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_TPOR_EOR'
!
!---  Open tpor.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'tpor.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate and initialize memory, global and local, for
!     solute transport arrays  ---
!
      CALL ALLOC_TRNSPT
      CALL INTLZ_TRNSPT
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Allocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of solutes (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSOLU,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'NSOLU = ',NSOLU,' ID = ',ID
!
!---  Read solute parameters, indices, and variables
!     if solutes are modeled  ---
!
      IF( NSOLU.GT.0 ) THEN
!
!---    Read solute names (duplicated across processors)  ---
!
        NVAR = 64*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SOLUT,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SOLUT = ',(SOLUT(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Loop over the number of solutes  ---
!
        DO NSL = 1,NSOLU
!
!---      Read local copies of C array (including ghost cells)  ---
!
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            C(N,NSL) = VARX(N)
          ENDDO
!          PRINT *,'C(2,',NSL,') = ',C(2,NSL),'C(3,',NSL,') = ',C(3,NSL),
!     &      'C(4,',NSL,') = ',C(4,NSL),' ID = ',ID
        ENDDO
!
!---    Read solute aqueous diffusion coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SMDL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SMDL = ',(SMDL(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute gas diffusion coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SMDG,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SMDG = ',(SMDG(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read index for solute gas-aqueous partition coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IPCGL,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IPCGL = ',(IPCGL(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute gas-aqueous partition coefficient parameters
!       (duplicated across processors)  ---
!
        NVAR = 5*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PCGL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!
!---    Read solute aqueous-NAPL partition coefficient parameters
!       (duplicated across processors)  ---
!mlr added
        NVAR = 5*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PCLN,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!
!---    Read solute half-life, s
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,HLF,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'HLF = ',(HLF(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute chain-decay fraction
!       (duplicated across processors)  ---
!
        NVAR = NSOLU*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CHDF,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'CHDF = ',((CHDF(MSL,NSL),MSL=1,NSOLU),NSL=1,NSOLU),
!     &    ' ID = ',ID
!
!---    Read number of Bateman chain decay series
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,NBCDS,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'NBCDS = ',NBCDS,' ID = ',ID
!
!---    Read Bateman chain decay series index
!       (duplicated across processors)  ---
!
        NVAR = LCDC+LSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCDS,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IBCDS = ',(IBCDS(M),M=1,LCDC+LSOLU),' ID = ',ID
!
!---    Read Bateman number of solutes in chain decay path
!       (duplicated across processors)  ---
!
        NVAR = LCDC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,NBCDP,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'NBCDP = ',(NBCDP(M),M=1,LCDC),' ID = ',ID
!
!---    Read Bateman chain decay path indices
!       (duplicated across processors)  ---
!
        NVAR = LCDS*LCDP*LCDC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCDP,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IBCDP = ',
!     &    (((IBCDP(K,L,M),K=1,LCDS),L=1,LCDP),M=1,LCDC),' ID = ',ID
!
!---    Read Courant number calculation index
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ICRNT,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ICRNT = ',ICRNT,' ID = ',ID
!        PRINT *,'IBCDS = ',(IBCDS(M),M=1,NSOLU+NBCDS),' ID = ',ID
!
!---    Read maximum Courant number
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CRNTMXT,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'CRNTMXT = ',CRNTMXT,' ID = ',ID
!
!---    Loop over the number of solutes  ---
!
        DO NSL = 1,NSOLU
!
!---      Loop over the number of solid-aqueous partition
!         coefficient indices  ---
!
          DO M = 1,5
!
!---        Read local copies of solute solid-aqueous partition
!           coefficient (including ghost cells)  ---
!
            NVAR = NFCGC(ID+1)
            OFFSET = IOFFSET + NC*NBYTR + NBYTB
            IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
            CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &        STATUS,IERR)
            DO N = 1,NFCGC(ID+1)
              PCSL(M,N,NSL) = VARX(N)
            ENDDO
!            PRINT *,'PCSL(',M,',',ND(11),',',NSL,') = ',
!     &        PCSL(M,11,NSL),' ID = ',ID
          ENDDO
        ENDDO
!
!---    Read local copies of longitudinal dispersivity
!       (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTR + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,DISPL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'DISPL(1) = ',DISPL(1),' ID = ',ID
!
!---    Read local copies of transverse dispersivity
!       (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTR + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,DISPT,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'DISPT(1) = ',DISPT(1),' ID = ',ID
      ENDIF
!
!---  Loop over the number of solutes and reactive species  ---
!
      DO M = 1,LSOLU+LSPT
!
!---    Read local copies of solute or reactive species initial
!       condition indices (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTI + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
        DO N = 1,NFCGC(ID+1)
          ICT(N,M) = IVARX(N)
        ENDDO
!        PRINT *,'ICT(',ND(11),',',M,') = ',ICT(11,M),' ID = ',ID
      ENDDO
!
!---  Deallocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Close the tpor.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_TPOR_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKG_EOR( RKGX,SLX,SNX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Gas relative permeability
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 30 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '//RKG_EOR'
!
!---  Stone-I 3-phase relative permeability model  ---
!
      IF( IRPN(N).EQ.1 ) THEN
!
!---    Corey submodel  ---
!
        IF( MOD(IRPG(N),10).EQ.1 ) THEN
          STX = SLX + SNX
          STRX = RPGC(3,N)
          SGRX = RPGC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          RKGX = RPGC(1,N)*((1.D+0-ESTX)**RPGC(2,N))
!
!---    LET submodel  ---
!
        ELSEIF( MOD(IRPG(N),10).EQ.2 ) THEN
          STX = SLX + SNX
          STRX = RPGC(3,N)
          SGRX = RPGC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          VARX = (1.D+0-ESTX)**RPGC(2,N)
          RKGX = RPGC(1,N)*VARX/
     &      (VARX + RPGC(5,N)*(ESTX**RPGC(6,N)))
        ENDIF
!
!---  Stone-II 3-phase relative permeability model  ---
!
      ELSEIF( IRPN(N).EQ.2 ) THEN
!
!---    Corey submodel  ---
!
        IF( MOD(IRPG(N),10).EQ.1 ) THEN
          STX = SLX + SNX
          STRX = RPGC(3,N)
          SGRX = RPGC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          RKGX = RPGC(1,N)*((1.D+0-ESTX)**RPGC(2,N))
!
!---    LET submodel  ---
!
        ELSEIF( MOD(IRPG(N),10).EQ.2 ) THEN
          STX = SLX + SNX
          STRX = RPGC(3,N)
          SGRX = RPGC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          VARX = (1.D+0-ESTX)**RPGC(2,N)
          RKGX = RPGC(1,N)*VARX/
     &      (VARX + RPGC(5,N)*(ESTX**RPGC(6,N)))
        ENDIF
!
!---  Baker 3-phase relative permeability model  ---
!
      ELSEIF( IRPN(N).EQ.3 ) THEN
!
!---    Corey submodel  ---
!
        IF( MOD(IRPG(N),10).EQ.1 ) THEN
          STX = SLX + SNX
          STRX = RPGC(3,N)
          SGRX = RPGC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          RKGX = RPGC(1,N)*((1.D+0-ESTX)**RPGC(2,N))
!
!---    LET submodel  ---
!
        ELSEIF( MOD(IRPG(N),10).EQ.2 ) THEN
          STX = SLX + SNX
          STRX = RPGC(3,N)
          SGRX = RPGC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          VARX = (1.D+0-ESTX)**RPGC(2,N)
          RKGX = RPGC(1,N)*VARX/
     &      (VARX + RPGC(5,N)*(ESTX**RPGC(6,N)))
        ENDIF
      ENDIF
      RKGX = MAX( RKGX,0.D+0 )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKG_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKL_EOR( RKLX,SLX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Aqueous relative permeability
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 30 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '//RKL_EOR'
!
!---  Stone-I 3-phase relative permeability model  ---
!
      IF( IRPN(N).EQ.1 ) THEN
!
!---    Corey aqueous relative permeability vs
!       aqueous saturaton submodel  ---
!
        IF( MOD(IRPL(N),10).EQ.1 ) THEN
          SLRX = RPLC(3,N)
          SNRX = RPLC(4,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          RKLX = RPLC(1,N)*(ESLX**RPLC(2,N))
!
!---    LET aqueous relative permeability vs
!       aqueous saturaton submodel  ---
!
        ELSEIF( MOD(IRPL(N),10).EQ.2 ) THEN
          SLRX = RPLC(3,N)
          SNRX = RPLC(4,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          VARX = ESLX**RPLC(2,N)
          RKLX = RPLC(1,N)*VARX/
     &      (VARX + RPLC(5,N)*((1.D+0-ESLX)**RPLC(6,N)))
        ENDIF
!
!---  Stone-II 3-phase relative permeability model  ---
!
      ELSEIF( IRPN(N).EQ.2 ) THEN
!
!---    Corey aqueous relative permeability vs
!       aqueous saturaton submodel  ---
!
        IF( MOD(IRPL(N),10).EQ.1 ) THEN
          SLRX = RPLC(3,N)
          SNRX = RPLC(4,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          RKLX = RPLC(1,N)*(ESLX**RPLC(2,N))
!
!---    LET aqueous relative permeability vs
!       aqueous saturaton submodel  ---
!
        ELSEIF( MOD(IRPL(N),10).EQ.2 ) THEN
          SLRX = RPLC(3,N)
          SNRX = RPLC(4,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          VARX = ESLX**RPLC(2,N)
          RKLX = RPLC(1,N)*VARX/
     &      (VARX + RPLC(5,N)*((1.D+0-ESLX)**RPLC(6,N)))
        ENDIF
!
!---  Baker 3-phase relative permeability model  ---
!
      ELSEIF( IRPN(N).EQ.3 ) THEN
!
!---    Corey aqueous relative permeability vs
!       aqueous saturaton submodel  ---
!
        IF( MOD(IRPL(N),10).EQ.1 ) THEN
          SLRX = RPLC(3,N)
          SNRX = RPLC(4,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          RKLX = RPLC(1,N)*(ESLX**RPLC(2,N))
!
!---    LET aqueous relative permeability vs
!       aqueous saturaton submodel  ---
!
        ELSEIF( MOD(IRPL(N),10).EQ.2 ) THEN
          SLRX = RPLC(3,N)
          SNRX = RPLC(4,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          VARX = ESLX**RPLC(2,N)
          RKLX = RPLC(1,N)*VARX/
     &      (VARX + RPLC(5,N)*((1.D+0-ESLX)**RPLC(6,N)))
        ENDIF
      ENDIF
!
!---  End of RKL_EOR group  ---
!
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKL_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKN_EOR( RKGX,RKLX,RKNX,SGX,SLX,SNX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Nonaqueous-liquid relative permeability
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 30 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '//RKN_EOR'
!
!---  Stone-I 3-phase relative permeability model  ---
!
      IF( IRPN(N).EQ.1 ) THEN
!
!---    Nonaqueous liquid-gas Corey submodel  ---
!
        IF( IRPG(N)/10.EQ.1 ) THEN
          STX = SLX + SNX
          STRX = RPNC(3,N)
          SGRX = RPNC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          RKNGX = RPNC(1,N)*(ESTX**RPNC(2,N))
!
!---    Nonaqueous liquid-gas LET submodel  ---
!
        ELSEIF( IRPG(N)/10.EQ.2 ) THEN
          STX = SLX + SNX
          STRX = RPNC(3,N)
          SGRX = RPNC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          VARX = ESTX**RPNC(2,N)
          RKNGX = RPNC(1,N)*VARX/
     &      (VARX + RPNC(5,N)*((1.D+0-ESTX)**RPNC(6,N)))
        ENDIF
!
!---    Nonaqueous liquid-aqueous Corey submodel  ---
!
        IF( IRPL(N)/10.EQ.1 ) THEN
          SLRX = RPLC(9,N)
          SNRX = RPLC(10,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          RKNLX = RPLC(7,N)*((1.D+0-ESLX)**RPLC(8,N))
!
!---    Nonaqueous liquid-aqueous LET submodel  ---
!
        ELSEIF( IRPL(N)/10.EQ.2 ) THEN
          SLRX = RPLC(9,N)
          SNRX = RPLC(10,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          VARX = (1.D+0-ESLX)**RPLC(8,N)
          RKNLX = RPLC(7,N)*VARX/
     &      (VARX + RPLC(11,N)*(ESTX**RPLC(12,N)))
        ENDIF
        SNMX = MIN( SLRX/3.D+0,SLRX,STRX )
        SNSX = MAX( MIN( (SNX-SNMX)/(1.D+0-SLRX-SNMX),1.D+0 ),0.D+0 )
        SLSX = MAX( MIN( (SLX-SLRX)/(1.D+0-SLRX-SNMX),1.D+0 ),0.D+0 )
        SGSX = MAX( MIN( SGX/(1.D+0-SLRX-SNMX),1.D+0 ),0.D+0 )
        VARX = ((1.D+0-SLSX)*(1.D+0-SGSX)*RPLC(7,N))
        IF( SNSX.LT.EPSL .OR. VARX.LT.EPSL ) THEN
          RKNX = 0.D+0
        ELSE
          RKNX = SNSX*RKNLX*RKNGX/((1.D+0-SLSX)*(1.D+0-SGSX)*
     &      RPLC(7,N))
        ENDIF
!
!---  Stone-II 3-phase relative permeability model  ---
!
      ELSEIF( IRPN(N).EQ.2 ) THEN
!
!---    Nonaqueous liquid-gas Corey submodel  ---
!
        IF( IRPG(N)/10.EQ.1 ) THEN
          STX = SLX + SNX
          STRX = RPNC(3,N)
          SGRX = RPNC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          RKNGX = RPNC(1,N)*(ESTX**RPNC(2,N))
!
!---    Nonaqueous liquid-gas LET submodel  ---
!
        ELSEIF( IRPG(N)/10.EQ.2 ) THEN
          STX = SLX + SNX
          STRX = RPNC(3,N)
          SGRX = RPNC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          VARX = ESTX**RPNC(2,N)
          RKNGX = RPNC(1,N)*VARX/
     &      (VARX + RPNC(5,N)*((1.D+0-ESTX)**RPNC(6,N)))
        ENDIF
!
!---    Nonaqueous liquid-aqueous Corey submodel  ---
!
        IF( IRPL(N)/10.EQ.1 ) THEN
          SLRX = RPLC(9,N)
          SNRX = RPLC(10,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          RKNLX = RPLC(7,N)*((1.D+0-ESLX)**RPLC(8,N))
!
!---    Nonaqueous liquid-aqueous LET submodel  ---
!
        ELSEIF( IRPL(N)/10.EQ.2 ) THEN
          SLRX = RPLC(9,N)
          SNRX = RPLC(10,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          VARX = (1.D+0-ESLX)**RPLC(8,N)
          RKNLX = RPLC(7,N)*VARX/
     &      (VARX + RPLC(11,N)*(ESTX**RPLC(12,N)))
        ENDIF
        IF( RPLC(7,N).LT.EPSL ) THEN
          RKNX = 0.D+0
        ELSE
          RKNX = RPLC(7,N)*(((RKNLX/RPLC(7,N))+RKLX)*
     &      ((RKNGX/RPLC(7,N))+RKGX) - (RKLX+RKGX))
        ENDIF
!
!---  Baker 3-phase relative permeability model  ---
!
      ELSEIF( IRPN(N).EQ.3 ) THEN
!
!---    Nonaqueous liquid-gas Corey submodel  ---
!
        IF( IRPG(N)/10.EQ.1 ) THEN
          STX = SLX + SNX
          STRX = RPNC(3,N)
          SGRX = RPNC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          RKNGX = RPNC(1,N)*(ESTX**RPNC(2,N))
!
!---    Nonaqueous liquid-gas LET submodel  ---
!
        ELSEIF( IRPG(N)/10.EQ.2 ) THEN
          STX = SLX + SNX
          STRX = RPNC(3,N)
          SGRX = RPNC(4,N)
          ESTX = MIN( MAX( (STX-STRX)/(1.D+0-STRX-SGRX),0.D+0 ),1.D+0 )
          VARX = ESTX**RPNC(2,N)
          RKNGX = RPNC(1,N)*VARX/
     &      (VARX + RPNC(5,N)*((1.D+0-ESTX)**RPNC(6,N)))
        ENDIF
!
!---    Nonaqueous liquid-aqueous Corey submodel  ---
!
        IF( IRPL(N)/10.EQ.1 ) THEN
          SLRX = RPLC(9,N)
          SNRX = RPLC(10,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          RKNLX = RPLC(7,N)*((1.D+0-ESLX)**RPLC(8,N))
!
!---    Nonaqueous liquid-aqueous LET submodel  ---
!
        ELSEIF( IRPL(N)/10.EQ.2 ) THEN
          SLRX = RPLC(9,N)
          SNRX = RPLC(10,N)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SNRX),0.D+0 ),1.D+0 )
          VARX = (1.D+0-ESLX)**RPLC(8,N)
          RKNLX = RPLC(7,N)*VARX/
     &      (VARX + RPLC(11,N)*(ESTX**RPLC(12,N)))
        ENDIF
        DSLX = MAX((SLX-SLRX),0.D+0)
        DSGX = MAX((SGX-SGRX),0.D+0)
        IF( (DSLX+DSGX).GT.EPSL ) THEN
          RKNX = (DSLX*RKNLX + DSGX*RKNGX)/(DSLX+DSGX)
        ELSE
          RKNX = 5.D-1*(RKNLX+RKNGX)
        ENDIF
      ENDIF
      RKNX = MAX( RKNX,0.D+0 )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKN_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RSDL_BO
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute the maximum relative residuals for the black-oil option
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 12 December 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE OUTPU
      USE JACOB
      USE GRID
      USE FILES
      USE FDVP
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(LUK*(1+LWELL+LSPILL)) :: RSDLX,RSDAVGLX	
      REAL*8, DIMENSION(5) :: VARX	
      REAL*8 DPC(LNGC)
      INTEGER MPC(LNGC)
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: NSDLX,NPHLX,NPHX
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: IDLX,IDX
      INTEGER, DIMENSION(NFCGC(ID+1)) :: IRSDX
      INTEGER, DIMENSION(9) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*128 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      DATA PH_CND /'Phase Condition #1, SL = 1.0, SG+SN = 0.0',
     &  'Phase Condition #2, SL < 1.0, ST > 0.0, SG = 0.0',
     &  'Phase Condition #3, SL < 1.0, ST > 0.0, SG > 0.0',
     &  'Phase Condition #4, SL = 0.0, ST = 1.0, SG = 0.0',
     &  'Phase Condition #5, SL = 0.0, ST = 1.0, SG > 0.0'/
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RSDL_BO'
!
!---  Black-oil option  ---
!
!
!---  Zero local and global maximum residuals  ---
!
      DO M = 1,ISVC
        RSD(M) = 0.D+0
        RSDLX(M) = 0.D+0
        RSDAVG(M) = 0.D+0
        RSDAVGLX(M) = 0.D+0
        NSD(M) = 0
        NSDLX(M) = 0
        NPHLX(M) = 0
      ENDDO
!
!---  Loop over local grid cells  ---
!
      NMD = 0
      DO N = 1,NFCGC(ID+1)
#ifdef lis
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Water mass equation  ---
!
        MPW = NMD + IEQW
        DPW = BLU(MPW)
!
!---    Gas mass equation  ---
!
        IF( ISLC(45).EQ.0 ) THEN
          MPC(1) = NMD + IEQGC(1)
          DPC(1) = BLU(MPC(1))
        ELSE
          DPC(1) = 0.D+0
        ENDIF
!
!---    Oil mass equation  ---
!
        IF( ISLC(64).EQ.0 ) THEN
          MPC(2) = NMD + IEQGC(2)
          DPC(2) = BLU(MPC(2))
        ELSE
          DPC(2) = 0.D+0
        ENDIF
!
!---    Salt mass equation  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ELSE
          DPS = 0.D+0
        ENDIF
!
!---    Skip selected nodes in the residual calculation  ---
!
        IF( ISKP(N).EQ.1 ) CYCLE
!
!---    Absolute system pressure  ---
!
        PX = PSO(2,N) + PATM
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
#ifdef petsc
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Phase condition #1  ---
!
!       SL = 1.0
!       SG+SN = 0.0
!       Aqueuous saturated
!
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       gas mass - total gas mass - TMC(1,2,N)
!       oil mass - total oil mass - TMC(2,2,N)
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPW)/PX,
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Gas mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGC(1,2,N) +
     &      RHON(2,N)*SN(2,N)*XNC(1,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(1))/PX,
     &      ABS(RSDL(IEQGC(1),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(1)) ) THEN
            RSDLX(IEQGC(1)) = RSDX
            NSDLX(IEQGC(1)) = N
            NPHLX(IEQGC(1)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Oil mass equation residual  ---
!
          ACP = PORD(2,N)*(RHON(2,N)*SN(2,N)*XNC(2,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(2))/PX,
     &      ABS(RSDL(IEQGC(2),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(2)) ) THEN
            RSDLX(IEQGC(2)) = RSDX
            NSDLX(IEQGC(2)) = N
            NPHLX(IEQGC(2)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            CALL SOL_LS( T(2,N),XLSMX )
            RSDX = MIN( (ABS(DPS)/XLSMX),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #2  ---
!
!       SG = 0.0
!       SL > 0.0
!       SN > 0.0
!       Aqueous and nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPW),
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Gas mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGC(1,2,N) +
     &      RHON(2,N)*SN(2,N)*XNC(1,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(1)),
     &      ABS(RSDL(IEQGC(1),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(1)) ) THEN
            RSDLX(IEQGC(1)) = RSDX
            NSDLX(IEQGC(1)) = N
            NPHLX(IEQGC(1)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Oil mass equation residual  ---
!
          ACP = PORD(2,N)*(RHON(2,N)*SN(2,N)*XNC(2,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(2))/PX,
     &      ABS(RSDL(IEQGC(2),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(2)) ) THEN
            RSDLX(IEQGC(2)) = RSDX
            NSDLX(IEQGC(2)) = N
            NPHLX(IEQGC(2)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            CALL SOL_LS( T(2,N),XLSMX )
            RSDX = MIN( (ABS(DPS)/XLSMX),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #3  ---
!
!       SG > 0.0
!       SL > 0.0
!       SN > 0.0
!       Three-phase
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPW),
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Gas mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGC(1,2,N) +
     &      RHON(2,N)*SN(2,N)*XNC(1,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(1))/PX,
     &      ABS(RSDL(IEQGC(1),N)/(ACP+SMALL)) )
            IF( RSDX.GT.RSDLX(IEQGC(1)) ) THEN
              RSDLX(IEQGC(1)) = RSDX
              NSDLX(IEQGC(1)) = N
              NPHLX(IEQGC(1)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Oil mass equation residual  ---
!
          ACP = PORD(2,N)*(RHON(2,N)*SN(2,N)*XNC(2,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(2)),
     &      ABS(RSDL(IEQGC(2),N)/(ACP+SMALL)) )
            IF( RSDX.GT.RSDLX(IEQGC(2)) ) THEN
              RSDLX(IEQGC(2)) = RSDX
              NSDLX(IEQGC(2)) = N
              NPHLX(IEQGC(2)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            CALL SOL_LS( T(2,N),XLSMX )
            RSDX = MIN( (ABS(DPS)/XLSMX),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #4  ---
!
!       SG = 0.0
!       SL = 0.0
!       SN = 1.0
!       Nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPW),
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Gas mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGC(1,2,N) +
     &      RHON(2,N)*SN(2,N)*XNC(1,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(1)),
     &      ABS(RSDL(IEQGC(1),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(1)) ) THEN
            RSDLX(IEQGC(1)) = RSDX
            NSDLX(IEQGC(1)) = N
            NPHLX(IEQGC(1)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Oil mass equation residual  ---
!
          ACP = PORD(2,N)*(RHON(2,N)*SN(2,N)*XNC(2,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(2))/PX,
     &      ABS(RSDL(IEQGC(2),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(2)) ) THEN
            RSDLX(IEQGC(2)) = RSDX
            NSDLX(IEQGC(2)) = N
            NPHLX(IEQGC(2)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            RSDX = MIN( ABS(DPS),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #5  ---
!
!       SG > 0.0
!       SL = 0.0
!       SN > 0.0
!       Nonaqueous liquid and gas saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPW),
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Gas mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGC(1,2,N) +
     &      RHON(2,N)*SN(2,N)*XNC(1,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(1))/PX,
     &      ABS(RSDL(IEQGC(1),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(1)) ) THEN
            RSDLX(IEQGC(1)) = RSDX
            NSDLX(IEQGC(1)) = N
            NPHLX(IEQGC(1)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Oil mass equation residual  ---
!
          ACP = PORD(2,N)*(RHON(2,N)*SN(2,N)*XNC(2,2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(DPC(2)),
     &      ABS(RSDL(IEQGC(2),N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQGC(2)) ) THEN
            RSDLX(IEQGC(2)) = RSDX
            NSDLX(IEQGC(2)) = N
            NPHLX(IEQGC(2)) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            RSDX = MIN( ABS(DPS),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
        ENDIF
      ENDDO
!
!---  Maximum global residuals  ---
!
      CALL MPI_ALLREDUCE( RSDLX,RSD,ISVC,MPI_REAL8,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
!
!---  Identify processor with maximum residual  ---
!
      DO M = 1,ISVC
        IDLX(M) = -1
        IF( ABS((RSDLX(M)-RSD(M))/EPSL).LT.EPSL ) IDLX(M) = ID
        IF( ID.EQ.IDLX(M) ) THEN
          NSD(M) = ND( NSDLX(M) )
          NPHX(M) = NPHLX(M)
        ELSE
          NSD(M) = 0
          NPHX(M) = 0
        ENDIF
      ENDDO
      CALL MPI_ALLREDUCE( IDLX,IDX,ISVC,MPI_INTEGER,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
      DO M = 1,ISVC
        CALL MPI_BCAST( NSD(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
        CALL MPI_BCAST( NPHX(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
      ENDDO
!
!---  Assign a convergence index  ---
!
      RSDX = 1.D-20
      DO M = 1,ISVC
        IF( RSD(M).GT.RSDMX ) ICNV = 2
        RSDX = MAX( RSD(M),RSDX )
      ENDDO
      IF( ICNV.EQ.2 .AND. NITER.GE.NRIMX ) ICNV = 1
!
!---  Unconverged solution and Newton-Raphson iteration
!     limit exceeded  ---
!
      IF( ICNV.EQ.1 ) THEN
        OFFSET = IOFFSET_REF
        IF( ID.EQ.0 ) THEN
          IF( RSDX.GE.1.D+2 .AND. RSD_CW.LT.1.D+2 ) THEN
            PRINT *,'           ---  Excessive Residual  ---'
            IVARX(1) = -5
          ELSEIF( RSD_CW.LT.RSDMX ) THEN
            PRINT *,'           ---  Convergence Failure  ---'
            IVARX(1) = -1
          ENDIF
        ENDIF
!
!---    Debug printing to the screen  ---
!
        IF( ID.EQ.0 ) THEN
!
!---      Water mass equation  ---
!
          NX = NSD(IEQW)
          IF( NX.GT.0 ) THEN
            NPX = NPHX(IEQW)
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'  Water Mass Equation Maximum Residual = ',
     &        RSD(IEQW),': Node = ',NX,': Phase Condition = ',
     &        PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Gas mass equation  ---
!
          NX = NSD(IEQA)
          IF( NX.GT.0 ) THEN
            NPX = NPHX(IEQA)
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'  Gas Mass Equation Maximum Residual = ',
     &        RSD(IEQGC(1)),': Node = ',NX,': Phase Condition = ',
     &        PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Oil mass equation  ---
!
          NX = NSD(IEQA)
          IF( NX.GT.0 ) THEN
            NPX = NPHX(IEQA)
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'  Oil Mass Equation Maximum Residual = ',
     &        RSD(IEQGC(2)),': Node = ',NX,': Phase Condition = ',
     &        PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            NX = NSD(IEQS)
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQS)
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'  Salt Equation Maximum Residual = ',
     &          RSD(IEQS),': Node = ',NX,': Phase Condition = ',
     &          PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            POSM(2,N) = POSM(1,N)
            PSO(2,N) = PSO(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
            ENDDO
          ENDDO
          IVARX(1) = -1
          VARX(4) = DTX*CNVTM
          VARX(5) = DT*CNVTM
!
!---      Coupled-well pressure  ---
!
          IF( L_CW.EQ.1 ) THEN
            DO NCW = 1,N_CW
              P_CW(2,NCW) = P_CW(1,NCW)
            ENDDO
          ENDIF
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          RETURN
        ENDIF
!
!---    Write a convergence failure index in the NSTEP location
!       plus write the global node numbers and phase condition indices
!       for the location of maximum residuals for the water, CO2,
!       and salt equations to output.bin  ---
!
        NVAR = 9
        IVARX(2) = NSD(IEQW)
        IVARX(3) = NPHX(IEQW)
        IVARX(4) = NSD(IEQGC(1))
        IVARX(5) = NPHX(IEQGC(1))
        IVARX(6) = NSD(IEQGC(2))
        IVARX(7) = NPHX(IEQGC(2))
        IF( ISLC(32).EQ.0 ) THEN
          IVARX(8) = NSD(IEQS)
          IVARX(9) = NPHX(IEQS)
        ELSE
          IVARX(8) = 0
          IVARX(9) = 0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &    MPI_INTEGER,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTI
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---    Write maximum residuals for the water, CO2, and salt
!       equations and time step reductions to output.bin  ---
!
        NVAR = 6
        VARX(1) = RSD(IEQW)
        VARX(2) = RSD(IEQGC(1))
        VARX(3) = RSD(IEQGC(2))
        IF( ISLC(32).EQ.0 ) THEN
          VARX(4) = RSD(IEQS)
        ELSE
          VARX(4) = 0.D+0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &    MPI_REAL8,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTR
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RSDL_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RSDL_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute the maximum relative residuals
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE OUTPU
      USE JACOB
      USE GRID
      USE FILES
      USE FDVP
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(LUK*(1+LWELL+LSPILL)) :: RSDLX,RSDAVGLX	
      REAL*8, DIMENSION(5) :: VARX	
      REAL*8 DPC(LNGC)
      INTEGER MPC(LNGC)
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: NSDLX,NPHLX,NPHX
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: IDLX,IDX
      INTEGER, DIMENSION(NFCGC(ID+1)) :: IRSDX
      INTEGER, DIMENSION(9) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*128 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      DATA PH_CND /'Phase Condition #1, SL = 1.0, SG+SN = 0.0',
     &  'Phase Condition #2, SL < 1.0, ST > 0.0, SG = 0.0',
     &  'Phase Condition #3, SL < 1.0, ST > 0.0, SG > 0.0',
     &  'Phase Condition #4, SL = 0.0, ST = 1.0, SG = 0.0',
     &  'Phase Condition #5, SL = 0.0, ST = 1.0, SG > 0.0'/
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RSDL_EOR'
!
!---  Black-oil option  ---
!
      IF( ISLC(68).EQ.0 ) THEN
        CALL RSDL_BO
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Compositional option  ---
!
!
!---  Zero local and global maximum residuals  ---
!
      DO M = 1,ISVC
        RSD(M) = 0.D+0
        RSDLX(M) = 0.D+0
        RSDAVG(M) = 0.D+0
        RSDAVGLX(M) = 0.D+0
        NSD(M) = 0
        NSDLX(M) = 0
        NPHLX(M) = 0
      ENDDO
!
!---  Loop over local grid cells  ---
!
      NMD = 0
      DO N = 1,NFCGC(ID+1)
#ifdef lis
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Energy equation  ---
!
        IF( ISLC(30).EQ.0 ) THEN
          MPT = NMD + IEQT
          DPT = BLU(MPT)
        ELSE
          DPT = 0.D+0
        ENDIF
!
!---    Water mass equation  ---
!
        MPW = NMD + IEQW
        DPW = BLU(MPW)
!
!---    CO2 mass equation  ---
!
        IF( ISLC(45).EQ.0 ) THEN
          MPC(1) = NMD + IEQGC(1)
          DPC(1) = BLU(MPC(1))
        ELSE
          DPC(1) = 0.D+0
        ENDIF
!
!---    CH4 mass equation  ---
!
        IF( ISLC(64).EQ.0 ) THEN
          MPC(2) = NMD + IEQGC(2)
          DPC(2) = BLU(MPC(2))
        ELSE
          DPC(2) = 0.D+0
        ENDIF
!
!---    Petroleum component mass equation  ---
!
        DO IGC = 3,NGC+2
          MPC(IGC) = NMD + IEQGC(IGC)
          DPC(IGC) = BLU(MPC(IGC))
        ENDDO
!
!---    Salt mass equation  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ELSE
          DPS = 0.D+0
        ENDIF
!
!---    Total fluid and salt mass density, kg/m^3 rock volume  ---
!
        TMX = PORD(2,N)*(SL(2,N)*RHOL(2,N) + SG(2,N)*RHOG(2,N) + 
     &    SN(2,N)*RHON(2,N) + SS(2,N)*RHOSP(2,N))
!
!---    Skip selected nodes in the residual calculation  ---
!
        IF( ISKP(N).EQ.1 ) CYCLE
        IF( ZMC(1,2,N).GT.9.D-1 ) CYCLE
!
!---    Absolute system pressure  ---
!
        PX = PSO(2,N) + PATM
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
#ifdef petsc
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Phase condition #1  ---
!
!       SL = 1.0, SG+SN = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       CO2 mass - CO2 vapor pressure - PVA
!       CH4 mass - total CH4 mass - TMC
!       petroleum component mass - total petroleum component mass - TMC
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      Energy equation residual  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            RSDX = 1.D-2*ABS(DPT)/TABS
            RSDAVGLX(IEQT) = RSDAVGLX(IEQT) + RSDX
            IF( RSDX.GT.RSDLX(IEQT) ) THEN
              RSDLX(IEQT) = RSDX
              NSDLX(IEQT) = N
              NPHLX(IEQT) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          RSDX = 1.D-2*MIN( ABS(DPW)/PX,
     &      1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          RSDAVGLX(IEQW) = RSDAVGLX(IEQW) + RSDX
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      CO2 mass equation residual  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( PVA(2,N).GT.(1.D-6*PX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLA(2,N) +
     &          RHON(2,N)*SN(2,N)*XNC(1,2,N))*DTI*VOL(N)
              RSDX = 1.D-2*MIN( ABS(DPC(1))/PX,
     &          ABS(RSDL(IEQGC(1),N)/(ACP+SMALL)) )
              RSDAVGLX(IEQGC(1)) = RSDAVGLX(IEQGC(1)) + RSDX
              IF( RSDX.GT.RSDLX(IEQGC(1)) ) THEN
                RSDLX(IEQGC(1)) = RSDX
                NSDLX(IEQGC(1)) = N
                NPHLX(IEQGC(1)) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      CH4 mass equation residual  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGO(2,N) +
     &        RHON(2,N)*SN(2,N)*XNC(2,2,N))*DTI*VOL(N)
            ACP = TMX*DTI*VOL(N)
            RSDX = 1.D-2*MIN( ABS(DPC(2))/PX,
     &        1.D-1*ABS(RSDL(IEQGC(2),N)/(ACP+SMALL)) )
            RSDAVGLX(IEQGC(2)) = RSDAVGLX(IEQGC(2)) + RSDX
            IF( RSDX.GT.RSDLX(IEQGC(2)) ) THEN
              RSDLX(IEQGC(2)) = RSDX
              NSDLX(IEQGC(2)) = N
              NPHLX(IEQGC(2)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Petroleum component mass equation residual  ---
!
          DO IGC = 3,NGC+2
            ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGC(IGC,2,N) +
     &        RHON(2,N)*SN(2,N)*XNC(IGC,2,N))*DTI*VOL(N)
            ACP = TMX*DTI*VOL(N)
            RSDX = 1.D-2*MIN( ABS(DPC(IGC))/PX,
     &        1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
            RSDAVGLX(IEQGC(IGC)) = RSDAVGLX(IEQGC(IGC)) + RSDX
            IF( RSDX.GT.RSDLX(IEQGC(IGC)) ) THEN
              RSDLX(IEQGC(IGC)) = RSDX
              NSDLX(IEQGC(IGC)) = N
              NPHLX(IEQGC(IGC)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            IF( RSDX.GT.RSD(IEQGC(IGC)) ) THEN
              RSD(IEQGC(IGC)) = RSDX
              NSD(IEQGC(IGC)) = N
            ENDIF
          ENDDO
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            ACP = TMX*DTI*VOL(N)
            CALL SOL_LS( T(2,N),XLSMX )
            RSDX = 1.D-2*MIN( (ABS(DPS)/XLSMX),
     &        1.D-1*ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            RSDAVGLX(IEQS) = RSDAVGLX(IEQS) + RSDX
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #2  ---
!
!       SL < 1.0, ST > 0.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---      Energy equation residual  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            RSDX = ABS(DPT)/TABS
            RSDAVGLX(IEQT) = RSDAVGLX(IEQT) + RSDX
            IF( RSDX.GT.RSDLX(IEQT) ) THEN
              RSDLX(IEQT) = RSDX
              NSDLX(IEQT) = N
              NPHLX(IEQT) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          IF( NPHAZ(2,N).GT.100 ) THEN
            RSDX = MIN( 1.D-1*ABS(DPW)/PX,
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ELSE
            RSDX = MIN( 1.D-1*ABS(DPW),
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ENDIF
          RSDAVGLX(IEQW) = RSDAVGLX(IEQW) + RSDX
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N) +
     &      RHON(2,N)*SN(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Nonaqueous-liquid pressure  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                RSDX = MIN( ABS(DPC(IGC)),
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ELSE
                RSDX = MIN( 1.D-1*ABS(DPC(IGC))/PX,
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ENDIF
!
!---        Petroleum component mole fraction  ---
!
            ELSE
              RSDX = MIN( 1.D-2*ABS(DPC(IGC)),
     &          1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
            ENDIF
            RSDAVGLX(IEQGC(IGC)) = RSDAVGLX(IEQGC(IGC)) + RSDX
            IF( RSDX.GT.RSDLX(IEQGC(IGC)) ) THEN
              RSDLX(IEQGC(IGC)) = RSDX
              NSDLX(IEQGC(IGC)) = N
              NPHLX(IEQGC(IGC)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDDO
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            ACP = TMX*DTI*VOL(N)
            CALL SOL_LS( T(2,N),XLSMX )
            RSDX = MIN( (ABS(DPS)/XLSMX),
     &        1.D-1*ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            RSDAVGLX(IEQS) = RSDAVGLX(IEQS) + RSDX
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #3  ---
!
!       SL < 1.0, ST > 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---      Energy equation residual  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            RSDX = ABS(DPT)/TABS
            RSDAVGLX(IEQT) = RSDAVGLX(IEQT) + RSDX
            IF( RSDX.GT.RSDLX(IEQT) ) THEN
              RSDLX(IEQT) = RSDX
              NSDLX(IEQT) = N
              NPHLX(IEQT) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          IF( NPHAZ(2,N).GT.100 ) THEN
            RSDX = MIN( 1.D-1*ABS(DPW)/PX,
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ELSE
            RSDX = MIN( 1.D-1*ABS(DPW),
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ENDIF
          RSDAVGLX(IEQW) = RSDAVGLX(IEQW) + RSDX
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N) +
     &      RHON(2,N)*SN(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Nonaqueous-liquid pressure  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                RSDX = MIN( 1.D-1*ABS(DPC(IGC))/PX,
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ELSE
                RSDX = MIN( 1.D-1*ABS(DPC(IGC))/PX,
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ENDIF
!
!---        Petroleum component mole fraction  ---
!
            ELSE
              RSDX = MIN( 1.D-2*ABS(DPC(IGC)),
     &          1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
            ENDIF
            RSDAVGLX(IEQGC(IGC)) = RSDAVGLX(IEQGC(IGC)) + RSDX
            IF( RSDX.GT.RSDLX(IEQGC(IGC)) ) THEN
              RSDLX(IEQGC(IGC)) = RSDX
              NSDLX(IEQGC(IGC)) = N
              NPHLX(IEQGC(IGC)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDDO
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            ACP = TMX*DTI*VOL(N)
            CALL SOL_LS( T(2,N),XLSMX )
            RSDX = MIN( (ABS(DPS)/XLSMX),
     &        1.D-1*ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            RSDAVGLX(IEQS) = RSDAVGLX(IEQS) + RSDX
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #4  ---
!
!       SL = 0.0, ST = 1.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---      Energy equation residual  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            RSDX = ABS(DPT)/TABS
            RSDAVGLX(IEQT) = RSDAVGLX(IEQT) + RSDX
            IF( RSDX.GT.RSDLX(IEQT) ) THEN
              RSDLX(IEQT) = RSDX
              NSDLX(IEQT) = N
              NPHLX(IEQT) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          IF( NPHAZ(2,N).GT.100 ) THEN
            RSDX = MIN( 1.D-1*ABS(DPW)/PX,
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ELSE
            RSDX = MIN( 1.D-1*ABS(DPW),
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ENDIF
          RSDAVGLX(IEQW) = RSDAVGLX(IEQW) + RSDX
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N) +
     &      RHON(2,N)*SN(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Nonaqueous-liquid pressure  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                RSDX = MIN( ABS(DPC(IGC)),
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ELSE
                RSDX = MIN( 1.D-1*ABS(DPC(IGC))/PX,
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ENDIF
!
!---        Petroleum component mole fraction  ---
!
            ELSE
              RSDX = MIN( 1.D-2*ABS(DPC(IGC)),
     &          1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
            ENDIF
            RSDAVGLX(IEQGC(IGC)) = RSDAVGLX(IEQGC(IGC)) + RSDX
            IF( RSDX.GT.RSDLX(IEQGC(IGC)) ) THEN
              RSDLX(IEQGC(IGC)) = RSDX
              NSDLX(IEQGC(IGC)) = N
              NPHLX(IEQGC(IGC)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDDO
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            ACP = TMX*DTI*VOL(N)
            RSDX = MIN( ABS(DPS),
     &        1.D-1*ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            RSDAVGLX(IEQS) = RSDAVGLX(IEQS) + RSDX
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Phase condition #5  ---
!
!       SL = 0.0, ST >= 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---      Energy equation residual  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            RSDX = ABS(DPT)/TABS
            RSDAVGLX(IEQT) = RSDAVGLX(IEQT) + RSDX
            IF( RSDX.GT.RSDLX(IEQT) ) THEN
              RSDLX(IEQGT) = RSDX
              NSDLX(IEQGT) = N
              NPHLX(IEQGT) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Water mass equation residual  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          IF( NPHAZ(2,N).GT.100 ) THEN
            RSDX = MIN( 1.D-1*ABS(DPW)/PX,
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ELSE
            RSDX = MIN( 1.D-1*ABS(DPW),
     &        1.D-1*ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          ENDIF
          RSDAVGLX(IEQW) = RSDAVGLX(IEQW) + RSDX
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N) +
     &      RHON(2,N)*SN(2,N))*DTI*VOL(N)
          ACP = TMX*DTI*VOL(N)
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Nonaqueous-liquid pressure  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                RSDX = MIN( ABS(DPC(IGC)),
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ELSE
                RSDX = MIN( 1.D-1*ABS(DPC(IGC))/PX,
     &            1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
              ENDIF
!
!---        Petroleum component mole fraction  ---
!
            ELSE
              RSDX = MIN( 1.D-2*ABS(DPC(IGC)),
     &          1.D-1*ABS(RSDL(IEQGC(IGC),N)/(ACP+SMALL)) )
            ENDIF
            RSDAVGLX(IEQGC(IGC)) = RSDAVGLX(IEQGC(IGC)) + RSDX
            IF( RSDX.GT.RSDLX(IEQGC(IGC)) ) THEN
              RSDLX(IEQGC(IGC)) = RSDX
              NSDLX(IEQGC(IGC)) = N
              NPHLX(IEQGC(IGC)) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDDO
!
!---      Salt mass equation residual  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            ACP = TMX*DTI*VOL(N)
            RSDX = MIN( ABS(DPS),
     &        1.D-1*ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            RSDAVGLX(IEQS) = RSDAVGLX(IEQS) + RSDX
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
        ENDIF
      ENDDO
!
!---  Maximum global residuals  ---
!
      CALL MPI_ALLREDUCE( RSDLX,RSD,ISVC,MPI_REAL8,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
!
!---  Identify processor with maximum residual  ---
!
      DO M = 1,ISVC
        IDLX(M) = -1
        IF( ABS((RSDLX(M)-RSD(M))/EPSL).LT.EPSL ) IDLX(M) = ID
        IF( ID.EQ.IDLX(M) ) THEN
          NSD(M) = ND( NSDLX(M) )
          NPHX(M) = NPHLX(M)
        ELSE
          NSD(M) = 0
          NPHX(M) = 0
        ENDIF
      ENDDO
      CALL MPI_ALLREDUCE( IDLX,IDX,ISVC,MPI_INTEGER,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
      DO M = 1,ISVC
        CALL MPI_BCAST( NSD(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
        CALL MPI_BCAST( NPHX(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
      ENDDO
!
!---  Assign a convergence index  ---
!
      RSDX = 1.D-20
      DO M = 1,ISVC
        IF( RSD(M).GT.RSDMX ) ICNV = 2
        RSDX = MAX( RSD(M),RSDX )
      ENDDO
      IF( ICNV.EQ.2 .AND. NITER.GE.NRIMX ) ICNV = 1
!
!---  Unconverged solution and Newton-Raphson iteration
!     limit exceeded  ---
!
      IF( ICNV.EQ.1 ) THEN
        OFFSET = IOFFSET_REF
        IF( ID.EQ.0 ) THEN
          IF( RSDX.GE.1.D+2 .AND. RSD_CW.LT.1.D+2 ) THEN
            PRINT *,'           ---  Excessive Residual  ---'
            IVARX(1) = -5
          ELSEIF( RSD_CW.LT.RSDMX ) THEN
            PRINT *,'           ---  Convergence Failure  ---'
            IVARX(1) = -1
          ENDIF
        ENDIF
!
!---    Debug printing to the screen  ---
!
        IF( ID.EQ.0 ) THEN
!
!---      Energy equation  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            NX = NSD(IEQT)
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQT)
              PRINT *,'  Energy Equation Maximum Residual = ',
     &          RSD(IEQT),': Node = ',NX,': Phase Condition = ',
     &          TRIM(PH_CND(NPX))
            ENDIF
          ENDIF
!
!---      Water mass equation  ---
!
          NX = NSD(IEQW)
          IF( NX.GT.0 ) THEN
            NPX = NPHX(IEQW)
            PRINT *,'  Water Mass Equation Maximum Residual = ',
     &        RSD(IEQW),': Node = ',NX,': Phase Condition = ',
     &        TRIM(PH_CND(NPX))
          ENDIF
!
!---      CO2 mass equation  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            NX = NSD(IEQGC(1))
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQGC(1))
              PRINT *,'  CO2 Mass Equation Maximum Residual = ',
     &          RSD(IEQGC(1)),': Node = ',NX,': Phase Condition = ',
     &          TRIM(PH_CND(NPX))
            ENDIF
          ENDIF
!
!---      CH4 mass equation  ---
!
          IF( ISLC(64).EQ.0 ) THEN
            NX = NSD(IEQGC(2))
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQGC(2))
              PRINT *,'  CH4 Mass Equation Maximum Residual = ',
     &          RSD(IEQGC(2)),': Node = ',NX,': Phase Condition = ',
     &          TRIM(PH_CND(NPX))
            ENDIF
          ENDIF
!
!---      Petroleum component mass equation  ---
!
          DO IGC = 3,NGC+2
            NX = NSD(IEQGC(IGC))
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQGC(IGC))
              PRINT *,'  ',TRIM(GCNM(IGC)),' Mass Equation Maximum ',
     &          'Residual = ',RSD(IEQGC(IGC)),
     &          ': Node = ',NX,': Phase Condition = ',
     &          TRIM(PH_CND(NPX))
            ENDIF
          ENDDO
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            NX = NSD(IEQS)
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQS)
              PRINT *,'  Salt Equation Maximum Residual = ',
     &          RSD(IEQS),': Node = ',NX,': Phase Condition = ',
     &          TRIM(PH_CND(NPX))
            ENDIF
          ENDIF
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            DO M = 1,6
              BETA(M,N) = 0.D+0
            ENDDO
            IBETA(N) = 0
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            PVA(2,N) = PVA(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
              ZMC(IGC,2,N) = ZMC(IGC,1,N)
            ENDDO
          ENDDO
          IVARX(1) = -1
          VARX(4) = DTX*CNVTM
          VARX(5) = DT*CNVTM
!
!---      Coupled-well pressure  ---
!
          IF( L_CW.EQ.1 ) THEN
            DO NCW = 1,N_CW
              P_CW(2,NCW) = P_CW(1,NCW)
            ENDDO
          ENDIF
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          RETURN
        ENDIF
!
!---    Write a convergence failure index in the NSTEP location
!       plus write the global node numbers and phase condition indices
!       for the location of maximum residuals for the energy, water,
!       CO2, CH4, petroleum components and salt equations to 
!       output.bin  ---
!
        NVAR = 9
        IVARX(2) = NSD(IEQT)
        IVARX(3) = NPHX(IEQT)
        IVARX(4) = NSD(IEQW)
        IVARX(5) = NPHX(IEQW)
!
!---    CO2 mass equation  ---
!
        IF( ISLC(45).EQ.0 ) THEN
          IVARX(6) = NSD(IEQGC(1))
          IVARX(7) = NPHX(IEQGC(1))
        ELSE
          IVARX(6) = 0
          IVARX(7) = 0
        ENDIF
!
!---    CH4 mass equation  ---
!
        IF( ISLC(64).EQ.0 ) THEN
          IVARX(8) = NSD(IEQGC(2))
          IVARX(9) = NPHX(IEQGC(2))
        ELSE
          IVARX(8) = 0
          IVARX(9) = 0
        ENDIF
!
!---    Petroleum component mass equation  ---
!
        DO IGC = 3,NGC+2
          IVARX(NVAR+1) = NSD(IEQGC(IGC))
          IVARX(NVAR+2) = NPHX(IEQGC(IGC))
          NVAR = NVAR + 1
        ENDDO
!
!---      Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          IVARX(NVAR+1) = NSD(IEQS)
          IVARX(NVAR+2) = NPHX(IEQS)
          NVAR = NVAR + 2
        ELSE
          IVARX(NVAR+1) = 0
          IVARX(NVAR+2) = 0
          NVAR = NVAR + 2
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &    MPI_INTEGER,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTI
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---    Write maximum residuals for the water, CO2, and salt
!       equations and time step reductions to output.bin  ---
!
        NVAR = 4
        VARX(1) = RSD(IEQT)
        VARX(2) = RSD(IEQW)
!
!---    CO2 mass equation  ---
!
        IF( ISLC(45).EQ.0 ) THEN
          VARX(3) = RSD(IEQGC(1))
        ELSE
          VARX(3) = 0.D+0
        ENDIF
!
!---    CH4 mass equation  ---
!
        IF( ISLC(64).EQ.0 ) THEN
          VARX(4) = RSD(IEQGC(2))
        ELSE
          VARX(4) = 0.D+0
        ENDIF
!
!---    Petroleum component mass equation  ---
!
        DO IGC = 3,NGC+2
          VARX(NVAR+1) = RSD(IEQGC(IGC))
          NVAR = NVAR + 1
        ENDDO
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          VARX(NVAR+1) = RSD(IEQS)
          NVAR = NVAR + 1
        ELSE
          VARX(NVAR+1) = 0.D+0
          NVAR = NVAR + 1
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &    MPI_REAL8,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTR
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RSDL_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SORC_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute source terms.
!     Source types
!
!     1 - Power, W
!     2 - Power density, W/m^3
!     122 - Fluid mass, kg/s, state #1, salt rel. sat., CO2 rel. sat.
!     123 - Fluid mass, kg/s, state #1, salt rel. sat., CO2 mass frac.
!     132 - Fluid mass, kg/s, state #1, salt mass frac., CO2 rel. sat.
!     133 - Fluid mass, kg/s, state #1, salt mass frac., CO2 mass frac.
!     220 - Fluid mass, kg/s, state #2, salt rel. sat.
!     230 - Fluid mass, kg/s, state #2, salt mass frac.
!     300 - Fluid mass, kg/s, state #3
!     422 - Fluid vol., m^3/s, state #1, salt rel. sat., CO2 rel. sat.
!     423 - Fluid vol., m^3/s, state #1, salt rel. sat., CO2 mass frac.
!     432 - Fluid vol., m^3/s, state #1, salt mass frac., CO2 rel. sat.
!     433 - Fluid vol., m^3/s, state #1, salt mass frac., CO2 mass frac.
!     520 - Fluid vol., m^3/s, state #2, salt rel. sat.
!     530 - Fluid vol., m^3/s, state #2, salt mass frac.
!     600 - Fluid vol., m^3/s, state #3
!
!     Source variables
!
!     SRC(1,NTM,NSR) - time, s
!     SRC(2,NTM,NSR) - power, W
!     SRC(2,NTM,NSR) - power density, W/m^3
!     SRC(2,NTM,NSR) - fluid mass rate, kg/s
!     SRC(2,NTM,NSR) - fluid volumetric rate, m^3/s
!     SRC(3,NTM,NSR) - fluid temperature, C
!     SRC(4,NTM,NSR) - aqueous CO2 relative saturation
!     SRC(4,NTM,NSR) - aqueous CO2 mass fraction
!     SRC(4,NTM,NSR) - aqueous saturation
!     SRC(4,NTM,NSR) - solute rate, 1/s
!     SRC(4,NTM,NSR) - solute density rate, 1/s m^3
!     SRC(5,NTM,NSR) - aqueous salt relative saturation
!     SRC(5,NTM,NSR) - aqueous salt mass fraction
!     SRC(6,NTM,NSR) - CO2 nonaqueous mole fraction
!     SRC(7,NTM,NSR) - CH4 nonaqueous mole fraction
!     SRC(7+I,NTM,NSR) - petroleum component I nonaqueous mole fraction
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 December 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE REACT
      USE PROP
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 SRX(10+LSOLU+LNGC)
      REAL*8 ZMCX(LNGC)
      REAL*8 XGCX(LNGC),XNCX(LNGC),XMGCX(LNGC),XMNCX(LNGC)
      CHARACTER*132 CHMSGX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/SORC_EOR'
!
!---  K-factors computed from fugacity coefficients  ---
!
      IFK = 0
#ifdef ecke
      DO IGC = 1,NGC+2
!
!---  Load component sources for linked aqueous species   ---
!---                          or linked gaseous species   ---
!
        IF( ( ISPLK(14+NSPLK+IGC).NE.0 ) .OR.
     &      ( ISPLK(14+NSPLK+NGC+2+IGC).NE.0 ) ) THEN
!
!---    Load NGC sources associated with chemical
!       reactions, looping over grid cells  ---
!
          DO N = 1,NFCGC(ID+1)
!
!---        Skip for inactive grid cells or ghost cells  ---
!
            IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
            SRCGCX = SRCGC(IGC,1,N)*DTI
            DO M = 2,ISVC+2
              SRCGC(IGC,M,N) = SRCGCX
            ENDDO
          ENDDO
        ENDIF
      ENDDO
!
!---    Zero source terms  ---
!
      DO NS = 1,NSR(ID+1)
        N = ISRN(NS)
        DO M = 2,ISVC+2
          SRCW(M,N) = 0.D+0
          SRCS(M,N) = 0.D+0
          SRCT(M,N) = 0.D+0
        ENDDO
      ENDDO
#else
!
!---  Zero source terms  ---
!
      DO NS = 1,NSR(ID+1)
        N = ISRN(NS)
        DO M = 2,ISVC+2
          DO IGC = 1,NGC+2
            SRCGC(IGC,M,N) = 0.D+0
          ENDDO
          SRCW(M,N) = 0.D+0
          SRCS(M,N) = 0.D+0
          SRCT(M,N) = 0.D+0
        ENDDO
      ENDDO
#endif
!
!---  Loop over sources  ---
!
      DO NS = 1,NSR(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = ISRIN(NS)
        IF( TMZ.LE.SRC(1,1,MB) ) CYCLE
        IF( ISRM(NS).EQ.1 ) THEN
          DO N = 2,10+NSOLU+NGC
            SRX(N) = SRC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,ISRM(NS)
            IF( TMZ.LE.SRC(1,M,MB) ) THEN
             DTSR = MIN( SRC(1,M,MB)-TMZ,DT )
             TFSR = (TMZ-0.5D+0*DTSR-SRC(1,M-1,MB))/
     &         (SRC(1,M,MB)-SRC(1,M-1,MB))
             DO N = 2,10+NSOLU+NGC
               SRX(N) = SRC(N,M-1,MB) + TFSR*(SRC(N,M,MB)-SRC(N,M-1,MB))
             ENDDO
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
!
!---    Local node associated with processor-dependent source  ---
!
        N = ISRN(NS)
        N_DB = ND(N)
!
!---    Loop over increment indices  ---
!
        DO M = 2,ISVC+2
          TX = T(M,N)
          PX = PSO(M,N) + PATM
!
!---      Power  ---
!
          IF( ISRT(NS).EQ.1 ) THEN
            SRCT(M,N) = SRCT(M,N) + SRX(2)
!
!---      Power Density  ---
!
          ELSEIF( ISRT(NS).EQ.2 ) THEN
            SRCT(M,N) = SRCT(M,N) + SRX(2)*VOL(N)
!
!---      Fluid mass rate  ---
!
          ELSEIF( ISRT(NS)/100.GE.1 .AND. ISRT(NS)/100.LE.3 ) THEN
!
!---        Fluid withdrawl from grid cell  ---
!
            IF( SRX(2).LE.0.D+0 ) THEN
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
!
!---          Petroleum components from gas and 
!             nonaqueous liquid  ---
!
              DO IGC = 1,NGC+2
                SRCGC(IGC,M,N) = SRCGC(IGC,M,N) + SRX(2)*
     &            (XGC(IGC,M,N)*FMGX + XNC(IGC,M,N)*FMNX)/SFMX
              ENDDO
!
!---          CO2 from aqueous  ---
!
              SRCGC(1,M,N) = SRCGC(1,M,N) + SRX(2)*
     &          XLA(M,N)*FMLX/SFMX
!
!---          Water from aqueous and gas  ---
!
              SRCW(M,N) = SRCW(M,N) + SRX(2)*(XGW(M,N)*FMGX +
     &          XLW(M,N)*FMLX)/SFMX
!
!---          Salt from aqueous  ---
!
              SRCS(M,N) = SRCS(M,N) + SRX(2)*XLS(M,N)*FMLX/SFMX
!
!---        Fluid injection into grid cell  ---
!
            ELSE
              IF( ISLC(30).EQ.0 ) TX = SRX(3)
!
!---          Source state #1  ---
!
!             SL = 1.0
!             SG+SN = 0.0
!
!             Declared variables:
!
!             SRX(4) - aqueous CO2 relative saturation, or
!                      aqueous CO2 mass fraction
!             SRX(5) - aqueous salt relative saturation, or
!                      aqueous salt mass fraction
!
              IF( ISRT(NS)/100.EQ.1 ) THEN
                PVAX = SRX(4)
                TMSX = SRX(5)
                ISR4X = MOD(ISRT(NS),10)
                ISR5X = MOD(ISRT(NS)/10,10)
                CALL FLH_IC1( PX,PVAX,RHOLX,RHOMLX,TMSX,TX,XLAX,XLSX,
     &            XLWX,XMLAX,XMLSX,XMLWX,YLSX,ZMCX,ISR4X,ISR5X )
!
!---            CO2 from aqueous  ---
!
                SRCGC(1,M,N) = SRCGC(1,M,N) + SRX(2)*XLAX
!
!---            Salt from aqueous  ---
!
                SRCS(M,N) = SRCS(M,N) + SRX(2)*XLSX
!
!---            Water from aqueous  ---
!
                SRCW(M,N) = SRCW(M,N) + SRX(2)*XLWX
!
!---          Source state #2  ---
!
!             SL < 1.0
!             SG+SN > 0.0
!
!             Declared variables:
!
!             SRX(4) - aqueous saturation
!             SRX(5) - aqueous salt relative saturation, or
!                       aqueous salt mass fraction
!             SRX(6+) - total mole fraction of petroleum components
!
              ELSEIF( ISRT(NS)/100.EQ.2 ) THEN
                SLX = SRX(4)
                TMSX = SRX(5)
                ISR5X = MOD(ISRT(NS)/10,10)
                DO IGC = 1,NGC+2
                  JGC = 5 + IGC
                  ZMCX(IGC) = SRX(JGC)
                ENDDO
                IZNX = 0
                CALL FLH_IC2( PX,RHOGX,RHOMGX,RHOLX,RHOMLX,RHONX,
     &            RHOMNX,SGX,SLX,SNX,TMSX,TX,XGCX,XMGCX,XGWX,XMGWX,
     &            XLAX,XLSX,XLWX,XMLAX,XMLSX,XMLWX,XNCX,XMNCX,YLSX,
     &            ZGX,ZMCX,ZNX,ISR5X,IZNX,NPHAZX )
!
!---            Petroleum components from gas and 
!               nonaqueous liquid  ---
!
                DO IGC = 1,NGC+2
                  SRCGC(IGC,M,N) = SRCGC(IGC,M,N) + SRX(2)*
     &              (SGX*XGCX(IGC) + SNX*XNCX(IGC))
                ENDDO
!
!---            CO2 from aqueous  ---
!
                SRCGC(1,M,N) = SRCGC(1,M,N) + SRX(2)*SLX*XLAX
!
!---            Salt from aqueous  ---
!
                SRCS(M,N) = SRCS(M,N) + SRX(2)*SLX*XLSX
!
!---            Water from aqueous and gas  ---
!
                SRCW(M,N) = SRCW(M,N) + SRX(2)*(SGX*XGWX + SLX*XLWX)
!
!---          Source state #3  ---
!
!             SL = 0.0
!             SG+SN = 1.0
!
!             Declared variables:
!
!             SRX(5) - water vapor relative saturation
!             SRX(6+) - total mole fraction of petroleum comp.
!        
              ELSEIF( ISRT(NS)/100.EQ.3 ) THEN
                DO IGC = 1,NGC+2
                  JGC = 6 + IGC
                  ZMCX(IGC) = SRX(JGC)
                ENDDO
                PVWX = SRX(5)
                YLSX = 0.D+0
                IZNX = 0
                CALL FLH_IC3( PVWX,PX,RHOGX,RHOMGX,RHONX,RHOMNX,SGX,
     &            SNX,TX,XGCX,XGWX,XMGCX,XMGWX,XNCX,XMNCX,
     &            YLSX,ZGX,ZMCX,ZNX,IZNX,NPHAZX )
!
!---            Petroleum components from gas and 
!               nonaqueous liquid  ---
!
                DO IGC = 1,NGC+2
                  SRCGC(IGC,M,N) = SRCGC(IGC,M,N) + SRX(2)*
     &              (SGX*XGCX(IGC) + SNX*XNCX(IGC))
                ENDDO
              ENDIF
            ENDIF
!
!---      Fluid volumetric rate  ---
!
          ELSEIF( ISRT(NS)/100.GE.4 .AND. ISRT(NS)/100.LE.6 ) THEN
!
!---        Fluid withdrawl from grid cell  ---
!
            IF( SRX(2).LE.0.D+0 ) THEN
              FMGX = RKG(2,N)/VISG(2,N)
              FMLX = RKL(2,N)/VISL(2,N)
              FMNX = RKN(2,N)/VISN(2,N)
              SFMX = FMGX + FMLX + FMNX 
!
!---          Petroleum components from gas and 
!             nonaqueous liquid  ---
!
              DO IGC = 1,NGC+2
                SRCGC(IGC,M,N) = SRCGC(IGC,M,N) + SRX(2)*
     &            (XGC(IGC,M,N)*RHOG(M,N)*FMGX + 
     &            XNC(IGC,M,N)*RHON(M,N)*FMNX)/SFMX
              ENDDO
!
!---          CO2 from aqueous  ---
!
              SRCGC(1,M,N) = SRCGC(1,M,N) + SRX(2)*
     &          XLA(M,N)*RHOL(M,N)*FMLX/SFMX
!
!---          Water from aqueous and gas  ---
!
              SRCW(M,N) = SRCW(M,N) + SRX(2)*(XGW(M,N)*RHOG(M,N)*FMGX
     &          + XLW(M,N)*RHOL(M,N)*FMLX)/SFMX
!
!---          Salt from aqueous  ---
!
              SRCS(M,N) = SRCS(M,N) + SRX(2)*XLS(M,N)*RHOL(M,N)*
     &          FMLX/SFMX
!
!---        Fluid injection into grid cell  ---
!
            ELSE
              IF( ISLC(30).EQ.0 ) TX = SRX(3)
!
!---          Source state #1  ---
!
!             SL = 1.0
!             SG+SN = 0.0
!
!             Declared variables:
!
!             SRX(4) - aqueous CO2 relative saturation, or
!                      aqueous CO2 mass fraction
!             SRX(5) - aqueous salt relative saturation, or
!                      aqueous salt mass fraction
!
              IF( ISRT(NS)/100.EQ.4 ) THEN
                PVAX = SRX(4)
                TMSX = SRX(5)
                ISR4X = MOD(ISRT(NS),10)
                ISR5X = MOD(ISRT(NS)/10,10)
                CALL FLH_IC1( PX,PVAX,RHOLX,RHOMLX,TMSX,TX,XLAX,XLSX,
     &            XLWX,XMLAX,XMLSX,XMLWX,YLSX,ZMCX,ISR4X,ISR5X )
!
!---            CO2 from aqueous  ---
!
                SRCGC(1,M,N) = SRCGC(1,M,N) + SRX(2)*XLAX*RHOLX
!
!---            Salt from aqueous  ---
!
                SRCS(M,N) = SRCS(M,N) + SRX(2)*XLSX*RHOLX
!
!---            Water from aqueous  ---
!
                SRCW(M,N) = SRCW(M,N) + SRX(2)*XLWX*RHOLX
!
!---          Source state #2  ---
!
!             SL < 1.0
!             SG+SN > 0.0
!
!             Declared variables:
!
!             SRX(4) - aqueous saturation
!             SRX(5) - aqueous salt relative saturation, or
!                       aqueous salt mass fraction
!             SRX(6+) - total mole fraction of petroleum components
!
              ELSEIF( ISRT(NS)/100.EQ.5 ) THEN
                SLX = SRX(4)
                TMSX = SRX(5)
                ISR5X = MOD(ISRT(NS)/10,10)
                DO IGC = 1,NGC+2
                  JGC = 5 + IGC
                  ZMCX(IGC) = SRX(JGC)
                ENDDO
                IZNX = 0
                CALL FLH_IC2( PX,RHOGX,RHOMGX,RHOLX,RHOMLX,RHONX,
     &            RHOMNX,SGX,SLX,SNX,TMSX,TX,XGCX,XMGCX,XGWX,XMGWX,
     &            XLAX,XLSX,XLWX,XMLAX,XMLSX,XMLWX,XNCX,XMNCX,YLSX,
     &            ZGX,ZMCX,ZNX,ISR5X,IZNX,NPHAZX )
!
!---            Petroleum components from gas and 
!               nonaqueous liquid  ---
!
                DO IGC = 1,NGC+2
                  SRCGC(IGC,M,N) = SRCGC(IGC,M,N) + SRX(2)*
     &              (SGX*XGCX(IGC)*RHOGX + SNX*XNCX(IGC)*RHONX)
                ENDDO
!
!---            CO2 from aqueous  ---
!
                SRCGC(1,M,N) = SRCGC(1,M,N) + SRX(2)*SLX*XLAX*RHOLX
!
!---            Salt from aqueous  ---
!
                SRCS(M,N) = SRCS(M,N) + SRX(2)*SLX*XLSX*RHOLX
!
!---            Water from aqueous and gas  ---
!
                SRCW(M,N) = SRCW(M,N) + SRX(2)*(SGX*XGWX*RHOGX + 
     &            SLX*XLWX*RHOLX)
!
!---          Source state #3  ---
!
!             SL = 0.0
!             SG+SN = 1.0
!
!             Declared variables:
!
!             SRX(5) - water vapor relative saturation
!             SRX(6+) - total mole fraction of petroleum comp.
!        
              ELSEIF( ISRT(NS)/100.EQ.6 ) THEN
                DO IGC = 1,NGC+2
                  JGC = 6 + IGC
                  ZMCX(IGC) = SRX(JGC)
                ENDDO
                PVWX = SRX(5)
                YLSX = 0.D+0
                IZNX = 0
                CALL FLH_IC3( PVWX,PX,RHOGX,RHOMGX,RHONX,RHOMNX,SGX,
     &            SNX,TX,XGCX,XGWX,XMGCX,XMGWX,XNCX,XMNCX,
     &            YLSX,ZGX,ZMCX,ZNX,IZNX,NPHAZX )
!
!---            Petroleum components from gas and 
!               nonaqueous liquid  ---
!
                DO IGC = 1,NGC+2
                  SRCGC(IGC,M,N) = SRCGC(IGC,M,N) + SRX(2)*
     &              (SGX*XGCX(IGC)*RHOGX + SNX*XNCX(IGC)*RHONX)
                ENDDO
              ENDIF
            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of SORC_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SORIC_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Compute coupled-equation source integrals.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE PROP
      USE GRID
      USE FDVP
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/SORIC_EOR'
!
!---  Integrate coupled-well rates  ---
!
      IF( L_CW.EQ.1 ) THEN
        DO NCW = 1,N_CW
          QM_CW(2,NCW) = QM_CW(2,NCW) + QM_CW(1,NCW)*DT
          QM_CW(4,NCW) = QM_CW(4,NCW) + QM_CW(3,NCW)*DT
          QM_CW(6,NCW) = QM_CW(6,NCW) + QM_CW(5,NCW)*DT
          DO IGC = 1,NGC+2
            QM_CW((8+(IGC-1)*2),NCW) = QM_CW((8+(IGC-1)*2),NCW) + 
     &        QM_CW((7+(IGC-1)*2),NCW)*DT
          ENDDO
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of SORIC_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SP_EOR( PGX,PLX,PNX,SGX,SLX,SNX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Aqueous and gas saturations.
!
!     INDX = 0 : Trapped-gas saturation computed.
!     INDX = 1 : Trapped-gas saturation given.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 28 November 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 GX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/SP_EOR'
!
!---  Webb extension  ---
!
      IF( ISM(N).EQ.2 ) THEN
        SLMPX = SCHR(7,N)
        HLMPX = SCHR(8,N)
        SNMPX = SCHR(9,N)
        HNMPX = SCHR(10,N)
        STMPX = SCHR(11,N)
        HTMPX = SCHR(12,N)
      ENDIF
!
!---  Residual aqueous and nonaqueous saturation  ---
!
      SLRX = SCHR(4,N)
      SNRX = SCHR(5,N)
!
!---  Contact angle  ---
!
      THETAX = MIN( MAX( SCHR(6,N),0.D+0 ),GPI )
!
!---  Effective residual aqueous and nonaqueous saturation  ---
!
      ESLRX = 5.D-1*SLRX*(1.D+0+COS(THETAX))
      ESNRX = 5.D-1*SNRX*(1.D+0-COS(THETAX))
!
!---  Total-liquid pressure  ---
!
      PTX = MAX( PLX,PNX )
!
!---  van Genuchten saturation function  ---
!
      IF( ISCHR(N).EQ.1 ) THEN
        HGTX = MAX( 0.D+0,(PGX-PTX)/RHORL/GRAV )
        HNLX = (PNX-PLX)/RHORL/GRAV
        HLNX = (PLX-PNX)/RHORL/GRAV
        CNX = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( IRPL(N).EQ.2 ) THEN
            CMX = 1.D+0 - 2.D+0/CNX
          ELSE
            CMX = 1.D+0 - 1.D+0/CNX
         ENDIF
        ELSE
          CMX = SCHR(14,N)
        ENDIF
        BX = SCHR(13,N)
!
!---    Webb extension  ---
!
        IF( ISM(N).EQ.2 ) THEN
!
!---      Total-liquid head above matching-point
!         head, use Webb extension  ---
!
          IF( HGTX.GT.HTMPX ) THEN
            SMPX = SCHR(11,N)
            HGTX = MIN( HGTX,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HTMPX))
            STX = -(LOG10(HGTX)-LOG10(HDOD))*DMPX
!
!---      Total-liquid head below
!         matching-point head  ---
!
          ELSE
            ESTX = (1.D+0/(1.D+0 + (SCHR(1,N)*HGTX)**CNX))**CMX
            STX = ESTX*(1.D+0-ESLRX-ESNRX) + ESLRX + ESNRX
          ENDIF
!
!---      Nonaqueous-liquid to aqueous head above matching-point
!         head, use Webb extension  ---
!
          IF( HNLX.GT.HLMPX ) THEN
            SMPX = SCHR(7,N)
            HNLZ = MIN( HNLX,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HLMPX))
            SLPX = -(LOG10(HNLZ)-LOG10(HDOD))*DMPX
!
!---      Nonaqueous-liquid to aqueous head below
!         matching-point head  ---
!
          ELSE
            HNLZ = MAX( HNLX,0.D+0 )
            ESNLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HNLZ)**CNX))**CMX
            SLPX = ESNLX*(1.D+0-ESLRX) + ESLRX
          ENDIF
!
!---      Aqueous to nonaqueous-liquid head above matching-point
!         head, use Webb extension  ---
!
          IF( HLNX.GT.HNMPX ) THEN
            SMPX = SCHR(9,N)
            HLNZ = MIN( HLNX,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HNMPX))
            SNPX = -(LOG10(HLNZ)-LOG10(HDOD))*DMPX
!
!---      Nonaqueous-liquid to aqueous head below
!         matching-point head  ---
!
          ELSE
            HLNZ = MAX( HLNX,0.D+0 )
            ESLNX = (1.D+0/(1.D+0 + (SCHR(1,N)*HLNZ)**CNX))**CMX
            SNPX = ESLNX*(1.D+0-ESNRX) + ESNRX
          ENDIF
          SLX = 5.D-1*SLPX*(1.D+0+COS(THETAX)) +
     &      5.D-1*(1.D+0-SNPX)*(1.D+0-COS(THETAX))
!
!---    No extension  ---
!
        ELSE
          ESTX = (1.D+0/(1.D+0 + (SCHR(1,N)*HGTX)**CNX))**CMX
          STX = ESTX*(1.D+0-ESLRX-ESNRX) + ESLRX + ESNRX
          HNLZ = MAX( HNLX,0.D+0 )
          ESNLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HNLZ)**CNX))**CMX
          SLPX = ESNLX*(1.D+0-ESLRX) + ESLRX
          HLNZ = MAX( HLNX,0.D+0 )
          ESLNX = (1.D+0/(1.D+0 + (SCHR(1,N)*HLNZ)**CNX))**CMX
          SNPX = ESLNX*(1.D+0-ESNRX) + ESNRX
          SLX = 5.D-1*SLPX*(1.D+0+COS(THETAX)) +
     &      5.D-1*(1.D+0-SNPX)*(1.D+0-COS(THETAX))
        ENDIF
!
!---    Skip iteration for pure aqueous wet or pure nonaqueous-liquid
!       wet  ---
!
        IF( THETAX.GE.EPSL .AND. ABS(THETAX-GPI).GE.EPSL ) THEN
!
!---    Top of Newton-Raphson loop  ---
!
        NC = 0
        DO
          NC = NC + 1
          IF( NC.GT.32 ) THEN
            M_ERR(1) = 'Unconverged Aqueous Saturation for van ' // 
     &      'Genuchten, Nonaqueous-Liquid to Aqueous Capillary Head = '
            M_ERR(2) = ' at Node: '
            CALL PATH
            R_ERR = HNLX
            I_ERR(1) = ND(N)
            I_ERR(2) = 1
            I_ERR(3) = 2
            I_ERR(4) = ID
          ENDIF
          DSLY = SIGN( 1.D-6,5.D-1-SLX )
          DO M = 1,2
            SLY = SLX
            IF( M.EQ.2 ) SLY = SLX + DSLY
            SNY = 1.D+0 - SLY
!
!---        Webb extension  ---
!
            IF( ISM(N).EQ.2 ) THEN
!
!---          Aqueous saturation below the matching point,
!             use Webb extension  ---
!
              IF( SLY.LT.SLMPX ) THEN
                DMPX = -(LOG10(HDOD)-LOG10(HLMPX))/SLMPX
                HNLPX = 1.D+1**(DMPX*(SLY-SLMPX) + LOG10(HLMPX))
                SLLX = 0.D+0
!
!---          Aqueous saturation at or above the matching point,
!             use van Genuchten function
!
              ELSE
                ESLX = MAX( (SLY-ESLRX)/(1.D+0-ESLRX),0.D+0 )
                HNLPX = (((ESLX**(-1.D+0/CMX))-1.D+0)**(1.D+0/CNX))/
     &              SCHR(1,N)
                SLLX = ESLRX
              ENDIF
!
!---          Nonaqueous-liquid saturation below the matching point,
!             use Webb extension  ---
!
              IF( SNY.LT.SNMPX ) THEN
                DMPX = -(LOG10(HDOD)-LOG10(HNMPX))/SNMPX
                HLNPX = 1.D+1**(DMPX*(SNY-SNMPX) + LOG10(HNMPX))
                SULX = 1.D+0
!
!---          Aqueous saturation at or above the matching point,
!             use van Genuchten function
!
              ELSE
                ESNX = MAX( (SNY-ESNRX)/(1.D+0-ESNRX),0.D+0 )
                HLNPX = (((ESNX**(-1.D+0/CMX))-1.D+0)**(1.D+0/CNX))/
     &              SCHR(1,N)
                SULX = 1.D+0-ESNRX
              ENDIF
              HNLY = (((1.D+0+COS(THETAX))**BX)*HNLPX -
     &          ((1.D+0-COS(THETAX))**BX)*HLNPX)/
     &          (2.D+0**BX)
            ELSE
!
!---          Aqueous saturation at or below the effective 
!             aqueous residual saturation  ---
!
              IF( SLY.LE.ESLRX ) THEN
                HNLPX = HDOD
                SLLX = ESLRX
!
!---          Aqueous saturation above the effective aqueous residual 
!             saturation  ---
!
              ELSE
                ESLX = MAX( (SLY-ESLRX)/(1.D+0-ESLRX),0.D+0 )
                HNLPX = (((ESLX**(-1.D+0/CMX))-1.D+0)**(1.D+0/CNX))/
     &              SCHR(1,N)
                SLLX = ESLRX
              ENDIF
!
!---          Nonaqueous-liquid saturation at or below the effective  
!             nonaqueous-liquid residual saturation  ---
!
              IF( SNY.LE.ESNRX ) THEN
                HLNPX = HDOD
                SULX = 1.D+0-ESNRX
!
!---          Nonaqueous-liquid saturation above the effective 
!             nonaqueous-liquid residual saturation  ---
!
              ELSE
                ESNX = MAX( (SNY-ESNRX)/(1.D+0-ESNRX),0.D+0 )
                HLNPX = (((ESNX**(-1.D+0/CMX))-1.D+0)**(1.D+0/CNX))/
     &              SCHR(1,N)
                SULX = 1.D+0-ESNRX
              ENDIF
              HNLY = (((1.D+0+COS(THETAX))**BX)*HNLPX -
     &          ((1.D+0-COS(THETAX))**BX)*HLNPX)/
     &          (2.D+0**BX)
            ENDIF
            GX(M) = HNLX - HNLY
          ENDDO
          IF( ABS(GX(1)).LT.EPSL ) EXIT
          FX = GX(1)
          DFX = (GX(2)-GX(1))/DSLY
          DSLX = -FX/DFX
          SLX = SLX + DSLX
          SLX = MAX( MIN( SLX,SULX ),SLLX )
          IF( ABS(DSLX).LE.1.D-9 ) EXIT
        ENDDO
        ENDIF
!
!---    Gas, aqueous, and nonaqueous-liquid saturations  ---
!
        SGX = 1.D+0 - STX
        SLX = STX*SLX
        SNX = STX - SLX
!
!---  Brooks and Corey saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.2 ) THEN
        HGTX = MAX( 0.D+0,(PGX-PTX)/RHORL/GRAV )
        HNLX = (PNX-PLX)/RHORL/GRAV
        HLNX = (PLX-PNX)/RHORL/GRAV
        CLX = MAX( SCHR(3,N),SMALL )
        BX = SCHR(13,N)
!
!---    Webb extension  ---
!
        IF( ISM(N).EQ.2 ) THEN
!
!---      Total-liquid head above matching-point
!         head, use Webb extension  ---
!
          IF( HGTX.GT.HTMPX ) THEN
            SMPX = SCHR(11,N)
            HGTX = MIN( HGTX,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HTMPX))
            STX = -(LOG10(HGTX)-LOG10(HDOD))*DMPX
!
!---      Total-liquid head below
!         matching-point head  ---
!
          ELSE
            IF( HGTX-SCHR(2,N).LE.1.D-12 ) THEN
              ESTX = 1.D+0
            ELSE
              ESTX = (SCHR(2,N)/HGTX)**CLX
            ENDIF
            STX = ESTX*(1.D+0-ESLRX-ESNRX) + ESLRX + ESNRX
          ENDIF
!
!---      Nonaqueous-liquid to aqueous head above matching-point
!         head, use Webb extension  ---
!
          IF( HNLX.GT.HLMPX ) THEN
            SMPX = SCHR(7,N)
            HNLZ = MIN( HNLX,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HLMPX))
            SLPX = -(LOG10(HNLZ)-LOG10(HDOD))*DMPX
!
!---      Nonaqueous-liquid to aqueous head below
!         matching-point head  ---
!
          ELSE
            IF( HNLX-SCHR(2,N).LE.1.D-12 ) THEN
              ESNLX = 1.D+0
            ELSE
              ESNLX = (SCHR(2,N)/HNLX)**CLX
            ENDIF
            SLPX = ESNLX*(1.D+0-ESLRX) + ESLRX
          ENDIF
!
!---      Aqueous to nonaqueous-liquid head above matching-point
!         head, use Webb extension  ---
!
          IF( HLNX.GT.HNMPX ) THEN
            SMPX = SCHR(9,N)
            HLNZ = MIN( HLNX,HDOD )
            DMPX = SMPX/(LOG10(HDOD)-LOG10(HNMPX))
            SNPX = -(LOG10(HLNZ)-LOG10(HDOD))*DMPX
!
!---      Nonaqueous-liquid to aqueous head below
!         matching-point head  ---
!
          ELSE
            IF( HLNX-SCHR(2,N).LE.1.D-12 ) THEN
              ESLNX = 1.D+0
            ELSE
              ESLNX = (SCHR(2,N)/HLNX)**CLX
            ENDIF
            SNPX = ESLNX*(1.D+0-ESNRX) + ESNRX
          ENDIF
          SLX = 5.D-1*SLPX*(1.D+0+COS(THETAX)) +
     &      5.D-1*(1.D+0-SNPX)*(1.D+0-COS(THETAX))
!
!---    No extension  ---
!
        ELSE
          IF( HGTX-SCHR(2,N).LE.1.D-12 ) THEN
            ESTX = 1.D+0
          ELSE
            ESTX = (SCHR(2,N)/HGTX)**CLX
          ENDIF
          STX = ESTX*(1.D+0-ESLRX-ESNRX) + ESLRX + ESNRX
          IF( HNLX-SCHR(2,N).LE.1.D-12 ) THEN
            ESNLX = 1.D+0
          ELSE
            ESNLX = (SCHR(2,N)/HNLX)**CLX
          ENDIF
          SLPX = ESNLX*(1.D+0-ESLRX) + ESLRX
          IF( HLNX-SCHR(2,N).LE.1.D-12 ) THEN
            ESLNX = 1.D+0
          ELSE
            ESLNX = (SCHR(2,N)/HLNX)**CLX
          ENDIF
          SNPX = ESLNX*(1.D+0-ESNRX) + ESNRX
          SLX = 5.D-1*SLPX*(1.D+0+COS(THETAX)) +
     &      5.D-1*(1.D+0-SNPX)*(1.D+0-COS(THETAX))
        ENDIF
!
!---    Skip iteration for pure aqueous wet or pure nonaqueous-liquid
!       wet  ---
!
        IF( THETAX.GE.EPSL .AND. ABS(THETAX-GPI).GE.EPSL ) THEN
!
!---    Top of Newton-Raphson loop  ---
!
        NC = 0
        DO
          NC = NC + 1
          IF( NC.GT.32 ) THEN
            M_ERR(1) = 'Unconverged Aqueous Saturation for Brooks and '
     &      // ' Corey, Nonaqueous-Liquid to Aqueous Capillary Head = '
            M_ERR(2) = ' at Node: '
            CALL PATH
            R_ERR = HNLX
            I_ERR(1) = ND(N)
            I_ERR(2) = 1
            I_ERR(3) = 2
            I_ERR(4) = ID
          ENDIF
          DSLY = SIGN( 1.D-6,5.D-1-SLX )
          DO M = 1,2
            SLY = SLX
            IF( M.EQ.2 ) SLY = SLX + DSLY
            SNY = 1.D+0 - SLY
!
!---        Webb extension  ---
!
            IF( ISM(N).EQ.2 ) THEN
!
!---          Aqueous saturation below the matching point,
!             use Webb extension  ---
!
              IF( SLY.LT.SLMPX ) THEN
                DMPX = -(LOG10(HDOD)-LOG10(HLMPX))/SLMPX
                HNLPX = 1.D+1**(DMPX*(SLY-SLMPX) + LOG10(HLMPX))
                SLLX = 0.D+0
!
!---          Aqueous saturation at or above the matching point,
!             use Brooks and Corey function
!
              ELSE
                ESLX = MAX( (SLY-ESLRX)/(1.D+0-ESLRX),0.D+0 )
                HNLPX = SCHR(2,N)*(1.D+0/ESLX)**(1.D+0/CLX)
                SLLX = ESLRX
              ENDIF
!
!---          Nonaqueous-liquid saturation below the matching point,
!             use Webb extension  ---
!
              IF( SNY.LT.SNMPX ) THEN
                DMPX = -(LOG10(HDOD)-LOG10(HNMPX))/SNMPX
                HLNPX = 1.D+1**(DMPX*(SNY-SNMPX) + LOG10(HNMPX))
                SULX = 1.D+0
!
!---          Aqueous saturation at or above the matching point,
!             use van Genuchten function
!
              ELSE
                ESNX = MAX( (SNY-ESNRX)/(1.D+0-ESNRX),0.D+0 )
                HLNPX = SCHR(2,N)*(1.D+0/ESNX)**(1.D+0/CLX)
                SULX = 1.D+0-ESNRX
              ENDIF
              HNLY = (((1.D+0+COS(THETAX))**BX)*HNLPX -
     &          ((1.D+0-COS(THETAX))**BX)*HLNPX)/
     &          (2.D+0**BX)
            ELSE
!
!---          Aqueous saturation at or below the effective 
!             aqueous residual saturation  ---
!
              IF( SLY.LE.ESLRX ) THEN
                HNLPX = HDOD
                SLLX = ESLRX
!
!---          Aqueous saturation above the effective aqueous residual 
!             saturation  ---
!
              ELSE
                ESLX = MAX( (SLY-ESLRX)/(1.D+0-ESLRX),0.D+0 )
                HNLPX = SCHR(2,N)*(1.D+0/ESLX)**(1.D+0/CLX)
                SLLX = ESLRX
              ENDIF
!
!---          Nonaqueous-liquid saturation at or below the effective  
!             nonaqueous-liquid residual saturation  ---
!
              IF( SNY.LE.ESNRX ) THEN
                HLNPX = HDOD
                SULX = 1.D+0-ESNRX
!
!---          Nonaqueous-liquid saturation above the effective 
!             nonaqueous-liquid residual saturation  ---
!
              ELSE
                ESNX = MAX( (SNY-ESNRX)/(1.D+0-ESNRX),0.D+0 )
                HLNPX = SCHR(2,N)*(1.D+0/ESNX)**(1.D+0/CLX)
                SULX = 1.D+0-ESNRX
              ENDIF
              HNLY = (((1.D+0+COS(THETAX))**BX)*HNLPX -
     &          ((1.D+0-COS(THETAX))**BX)*HLNPX)/
     &          (2.D+0**BX)
            ENDIF
            GX(M) = HNLX - HNLY
          ENDDO
          IF( ABS(GX(1)).LT.EPSL ) EXIT
          FX = GX(1)
          DFX = (GX(2)-GX(1))/DSLY
          DSLX = -FX/DFX
          SLX = SLX + DSLX
          SLX = MAX( MIN( SLX,SULX ),SLLX )
          IF( ABS(DSLX).LE.1.D-9 ) EXIT
        ENDDO
        ENDIF
!
!---    Gas, aqueous, and nonaqueous-liquid saturations  ---
!
        SGX = 1.D+0 - STX
        SLX = STX*SLX
        SNX = STX - SLX
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of SP_EOR group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_BO
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Update the primary variables for the black-oil option.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 December 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE OUTPU
      USE JACOB
      USE GRID
      USE FILES
      USE FDVP
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(15) :: VARZ	
      REAL*8, DIMENSION(12) :: VARX	
      REAL*8 DPC(LNGC)
      INTEGER, DIMENSION(3) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      INTEGER MPC(LNGC)
      CHARACTER*64 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      SAVE PH_CND
      DATA PH_CND /'Phase Condition #1, SL = 1.0, SG+SN = 0.0',
     &  'Phase Condition #2, SL > 0.0, SN > 0.0, SG = 0.0',
     &  'Phase Condition #3, SL > 0.0, SN > 0.0, SG > 0.0',
     &  'Phase Condition #4, SL = 0.0, SN > 0.0, SG = 0.0',
     &  'Phase Condition #5, SL = 0.0, SN > 0.0, SG > 0.0'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_BO'
      OFFSET = IOFFSET_REF
      IF( ICNV.EQ.1 ) THEN
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ') - 1
          IF( ID.EQ.0 ) PRINT *,'Linear System Solver Failure: ' //
     &      'Time Step  Reduced from ',DTX*CNVTM,UNTM(1:NCH),' to ',
     &      DT*CNVTM,UNTM(1:NCH)
!
!---      Write a linear system solver failure index of -3 in the
!         NSTEP location plus time step reductions to output.bin  ---
!
          NVAR = 1
          IVARX(1) = -3
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          NVAR = 2
          VARX(1) = DTX*CNVTM
          VARX(2) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            POSM(2,N) = POSM(1,N)
            PSO(2,N) = PSO(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
            ENDDO
          ENDDO
!
!---      Coupled-well pressure  ---
!
          IF( L_CW.EQ.1 ) THEN
            DO NCW = 1,N_CW
              P_CW(2,NCW) = P_CW(1,NCW)
            ENDDO
          ENDIF
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            POSM(2,N) = POSM(1,N)
            PSO(2,N) = PSO(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
            ENDDO
          ENDDO
!
!---      Coupled-well pressure  ---
!
          IF( L_CW.EQ.1 ) THEN
            DO NCW = 1,N_CW
              P_CW(2,NCW) = P_CW(1,NCW)
            ENDDO
          ENDIF
          IF( ID.EQ.0 )  PRINT *,'          ---  Time Step ' //
     &      'Reduction Limit Exceeded  ---'
          ICNV = 4
          IVARX(1) = -2
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
!
!---    Reset subroutine string sequence  ---
!
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Update primary variables on field cells  ---
!
      IERR = 0
      IERRL = NFLD + 1
      IERRG = NFLD + 1
      NMD = 0
      DO N = 1,NFCGC(ID+1)
#ifdef lis
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
#ifdef petsc
!
!---    Skip for inactive nodes  ---
!
        IF( IXP(N).EQ.0 ) CYCLE
#endif
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        IF( IERRL.NE.(NFLD+1) ) CYCLE
        N_DB = ND(N)
!
!---    Water mass equation  ---
!
        MPW = NMD + IEQW
        DPW = BLU(MPW)
!
!---    Gas mass equation  ---
!
        MPC(1) = NMD + IEQGC(1)
        DPC(1) = BLU(MPC(1))
!
!---    Oil mass equation  ---
!
        MPC(2) = NMD + IEQGC(2)
        DPC(2) = BLU(MPC(2))
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ELSE
          DPS = 0.D+0
        ENDIF
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
!
!---    Phase condition #1  ---
!
!       SL = 1.0
!       SG+SN = 0.0
!       Aqueuous saturated
!
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       gas mass - total gas mass - TMC(1,2,N)
!       oil mass - total oil mass - TMC(2,2,N)
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      Limit changes in total pressure,
!         excessive primary variable change limit at 100 MPa  ---
!
          IF( ABS(DPW).GT.1.D+8 ) IERR = 1
          DPX = 2.5D-2*(PSO(2,N)+PATM)
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          PSO(2,N) = PSO(2,N) + DPW
          PSO(2,N) = MIN( PSO(2,N),5.D+8 )
!
!---      Zero negative corrections for zero gas mass  ---
!
          IF( TMC(1,2,N).LT.EPSL .AND. DPC(1).LT.EPSL ) THEN
            BLU(MPC(1)) = 0.D+0
            DPC(1) = 0.D+0
          ENDIF
          TMC(1,2,N) = MAX( (TMC(1,2,N)+DPC(1)),0.D+0 )
!
!---      Zero negative corrections for zero oil mass  ---
!
          IF( TMC(2,2,N).LT.EPSL .AND. DPC(2).LT.EPSL ) THEN
            BLU(MPC(2)) = 0.D+0
            DPC(2) = 0.D+0
          ENDIF
          TMC(2,2,N) = MAX( (TMC(2,2,N)+DPC(2)),0.D+0 )
!
!---      Limit salt mass fraction changes to 0.25 of the
!         maximum value if salt mass fraction is less than
!         the maximum, isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero dissolved salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. DPS/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.1.D-12 ) YLS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #2  ---
!
!       SG = 0.0
!       SL > 0.0
!       SN > 0.0
!       Aqueous and nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          DPX = 2.5D-2
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          SL(2,N) = SL(2,N) + DPW
          IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
!
!---      Limit changes in gas to oil ratio, and zero negative 
!         corrections for zero gas to oil ratios  ---
!
          DPX = 5.D-2/REAL(NITER)
          DPC(1) = SIGN( MIN(ABS(DPX),ABS(DPC(1))),DPC(1) )
          POSM(2,N) = POSM(2,N) + DPC(1)
!
!---      Limit changes in nonaqueous-liquid pressure (system pressure),
!         excessive primary variable change limit at 100 MPa  ---
!
          IF( ABS(DPC(2)).GT.1.D+8 ) IERR = 1
          DPX = MAX( 1.D+6,1.D-1*(PN(2,N)-PL(2,N)) )
          DPX = 2.5D-2*(PSO(2,N)+PATM)
          DPC(2) = SIGN( MIN(ABS(DPX),ABS(DPC(2))),DPC(2) )
!
!---      Bubble-point pressure as a function of gas to oil ratio
!         (m^3/m^3) and temperature (C)  ---
!
!          CALL BO_BP( PBPX,POSM(2,N),T(2,N) )
!
!---      Pressure below bubble-point pressure  ---
!
!          IF( PSO(2,N)+DPC(2).LT.PBPX-PATM ) DPC(2) = 6.D-1*DPC(2)
          PSO(2,N) = PSO(2,N) + DPC(2)
          PSO(2,N) = MIN( PSO(2,N),5.D+8 )
!
!---      Limit salt mass fraction changes to 0.25 of the
!         maximum value if salt mass fraction is less than
!         the maximum, isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero dissolved salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. DPS/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.1.D-12 ) YLS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #3  ---
!
!       SG > 0.0
!       SL > 0.0
!       SN > 0.0
!       Three-phase
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          DPX = 2.5D-2
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          SL(2,N) = SL(2,N) + DPW
          IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
!
!---      Limit changes in gas saturation  ---
!
          DPX = 2.5D-2
          DPC(1) = SIGN( MIN(ABS(DPX),ABS(DPC(1))),DPC(1) )
!          IF( SG(2,N)+DPC(1).LT.0.D+0 ) DPC(1) = 6.D-1*DPC(1)
          SG(2,N) = SG(2,N) + DPC(1)
          IF( SG(2,N).LT.EPSL ) SG(2,N) = 0.D+0
!
!---      Limit changes in gas pressure, excessive primary variable 
!         change limit at 100 MPa  ---
!
          IF( ABS(DPC(1)).GT.1.D+8 ) IERR = 1
          DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-MAX(PL(2,N),PN(2,N))) )
          DPX = 2.5D-2*(PSO(2,N)+PATM)
          DPC(2) = SIGN( MIN(ABS(DPX),ABS(DPC(2))),DPC(2) )
          PSO(2,N) = PSO(2,N) + DPC(2)
          PSO(2,N) = MIN( PSO(2,N),5.D+8 )
!
!---      Limit salt mass fraction changes to 0.25 of the
!         maximum value if salt mass fraction is less than
!         the maximum, isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero dissolved salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. DPS/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.1.D-12 ) YLS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #4  ---
!
!       SG = 0.0
!       SL = 0.0
!       SN = 1.0
!       Nonaqueous liquid saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas to oil ratio, POSM
!       oil mass - nonaqueous (system) pressure, Pa gauge - PN,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          DPX = 2.5D-2
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          SL(2,N) = SL(2,N) + DPW
          IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
!
!---      Limit changes in gas to oil ratio, and zero negative 
!         corrections for zero gas to oil ratios  ---
!
          DPX = 5.D-2/REAL(NITER)
          DPC(1) = SIGN( MIN(ABS(DPX),ABS(DPC(1))),DPC(1) )
          POSM(2,N) = POSM(2,N) + DPC(1)
!
!---      Limit changes in nonaqueous-liquid pressure (system pressure),
!         excessive primary variable change limit at 100 MPa  ---
!
          IF( ABS(DPC(2)).GT.1.D+8 ) IERR = 1
          DPX = MAX( 1.D+6,1.D-1*(PN(2,N)-PL(2,N)) )
          DPX = 2.5D-2*(PSO(2,N)+PATM)
          DPC(2) = SIGN( MIN(ABS(DPX),ABS(DPC(2))),DPC(2) )
!
!---      Bubble-point pressure as a function of gas to oil ratio
!         (m^3/m^3) and temperature (C)  ---
!
!          CALL BO_BP( PBPX,POSM(2,N),T(2,N) )
!
!---      Pressure below bubble-point pressure  ---
!
!          IF( PSO(2,N)+DPC(2).LT.PBPX-PATM ) DPC(2) = 6.D-1*DPC(2)
          PSO(2,N) = PSO(2,N) + DPC(2)
          PSO(2,N) = MIN( PSO(2,N),5.D+8 )
!
!---      Isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Zero negative corrections for zero total salt mass  ---
!
            IF( TMS(2,N).LT.EPSL .AND. DPS.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            TMS(2,N) = TMS(2,N) + DPS
            IF( TMS(2,N).LT.EPSL ) TMS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #5  ---
!
!       SG > 0.0
!       SL = 0.0
!       SN > 0.0
!       Nonaqueous liquid and gas saturated
!
!       water mass - aqueous saturation, SL
!       gas mass - gas saturation, SG
!       oil mass - gas (system) pressure, Pa gauge - PG,PSO
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          DPX = 2.5D-2
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          SL(2,N) = SL(2,N) + DPW
          IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
!
!---      Limit changes in gas saturation  ---
!
          DPX = 2.5D-2
          DPC(1) = SIGN( MIN(ABS(DPX),ABS(DPC(1))),DPC(1) )
!          IF( SG(2,N)+DPC(1).LT.0.D+0 ) DPC(1) = 6.D-1*DPC(1)
          SG(2,N) = SG(2,N) + DPC(1)
          IF( SG(2,N).LT.EPSL ) SG(2,N) = 0.D+0
!
!---      Limit changes in gas pressure, excessive primary variable 
!         change limit at 100 MPa  ---
!
          IF( ABS(DPC(1)).GT.1.D+8 ) IERR = 1
          DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-MAX(PL(2,N),PN(2,N))) )
          DPX = 2.5D-2*(PSO(2,N)+PATM)
          DPC(2) = SIGN( MIN(ABS(DPX),ABS(DPC(2))),DPC(2) )
          PSO(2,N) = PSO(2,N) + DPC(2)
          PSO(2,N) = MIN( PSO(2,N),5.D+8 )
!
!---      Isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Zero negative corrections for zero total salt mass  ---
!
            IF( TMS(2,N).LT.EPSL .AND. DPS.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            TMS(2,N) = TMS(2,N) + DPS
            IF( TMS(2,N).LT.EPSL ) TMS(2,N) = 0.D+0
          ENDIF
        ENDIF
#ifdef petsc
!
!---    Skip checks for excessive pressure or temperature for
!       ghost cells   ---
!
        IF( IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Check for excessive pressure or temperature   ---
!
        PX = PSO(2,N)+PATM
        TKX = T(2,N)+TABS
        IF( PX.GT.8.D+8 .OR. PX.LT.0.D+0 ) IERR = 1
        IF( TKX.GT.TCRW .OR. TKX.LT.TABS ) IERR = 1
!
!---    Excess changes in primary variables, skip updates  ---
!
        IF( IERR.EQ.1 .AND. IERRL.EQ.(NFLD+1) ) THEN
          IERRL = ND(N)
          VARZ(1) = REAL( N )
          VARZ(2) = REAL( NPHAZ(2,N) )
          VARZ(3) = DPW
          VARZ(4) = DPC(1)
          VARZ(5) = DPC(2)
          VARZ(6) = DPS
          VARZ(7) = PSO(2,N)+PATM
          VARZ(8) = PL(2,N)+PATM
          VARZ(9) = PG(2,N)+PATM
          VARZ(10) = PN(2,N)+PATM
          VARZ(11) = SL(2,N)
          VARZ(12) = SG(2,N)
          VARZ(13) = SN(2,N)
          VARZ(14) = YLS(2,N)
          VARZ(15) = TMS(2,N)
        ENDIF
      ENDDO
!
!---  Identify minimum global node with errors  ---
!
      CALL MPI_ALLREDUCE( IERRL,IERRG,1,MPI_INTEGER,MPI_MIN,
     &  MPI_COMM_WORLD,IERR )
!
!---  Node identified with an excessive primary variable change  ---
!
      IF( IERRG.NE.(NFLD+1) ) THEN
        ICNV = 1
        ID2X = 0
!
!---    Identify processor with error  ---
!
        DO MP = 1,NP
          IF( IERRL.EQ.IERRG ) ID2X = ID
        ENDDO
        CALL MPI_ALLREDUCE( ID2X,IDX,1,MPI_INTEGER,MPI_MAX,
     &    MPI_COMM_WORLD,IERR )
!
!---    Send node state to P0  ---
!
        IF( ID.EQ.IDX ) THEN
          CALL MPI_SEND( VARZ,15,MPI_REAL8,0,18,MPI_COMM_WORLD,IERR )
        ENDIF
        IF( ID.EQ.0 ) THEN
          CALL MPI_RECV( VARZ,15,MPI_REAL8,IDX,18,MPI_COMM_WORLD,
     &      STATUS,IERR )
          N = INT(VARZ(1))
          NPHZX = MOD(INT(VARZ(2)),100)
          PRINT *,'---  Excessive Primary Variable Change  ---'
          PRINT *,'  Node = ',ND(N)
          PRINT *,'  Phase Condition = ',PH_CND(NPHZX)
          PRINT *,'  DPW = ',VARZ(3)
          PRINT *,'  DPC(1) = ',VARZ(4)
          PRINT *,'  DPC(2) = ',VARZ(5)
          IF( ISLC(32).EQ.0 ) THEN
            PRINT *,'  DPS = ',VARZ(6)
          ENDIF
          PRINT *,'  System Pressure, Pa = ',VARZ(7)
          PRINT *,'  Aqueous Pressure, Pa = ',VARZ(8)
          PRINT *,'  Gas Pressure, Pa = ',VARZ(9)
          PRINT *,'  Nonaqueous Liquid Pressure, Pa = ',VARZ(10)
          PRINT *,'  Gas Saturation = ',VARZ(11)
          PRINT *,'  Aqueous Saturation = ',VARZ(12)
          PRINT *,'  Nonaqueous Liquid Saturation = ',VARZ(13)
          IF( ISLC(32).EQ.0 ) THEN
            PRINT *,'  Total-Salt Aqu. Mass Fraction = ',VARZ(14)
            PRINT *,'  Total-Salt Mass = ',VARZ(15)
          ENDIF
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            POSM(2,N) = POSM(1,N)
            PSO(2,N) = PSO(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
            ENDDO
          ENDDO
!
!---      Write a excessive primary variable index in the NSTEP location
!         plus write the global node numbers and phase condition indices
!         for the location of maximum residuals for the water, CO2,
!         and salt equations to output.bin  ---
!
          NVAR = 3
          IVARX(1) = -4
          IVARX(2) = ND(IERRG)
          IVARX(3) = NPHZX
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---      Write maximum residuals for the water, gas, oil, and salt
!         mass equations and time step reductions to output.bin  ---
!
          NVAR = 12
          VARX(1) = VARZ(6)
          VARX(2) = VARZ(7)
          VARX(3) = VARZ(8)
          VARX(4) = VARZ(9)
          VARX(5) = VARZ(10)
          VARX(6) = VARZ(11)
          VARX(7) = VARZ(12)
          VARX(8) = VARZ(13)
          VARX(9) = VARZ(14)
          VARX(10) = VARZ(15)
          VARX(11) = DTX*CNVTM
          VARX(12) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            POSM(2,N) = POSM(1,N)
            PSO(2,N) = PSO(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
            ENDDO
          ENDDO
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_BO group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Update the primary variables for the compositional option.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 December 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE OUTPU
      USE JACOB
      USE GRID
      USE FILES
      USE FDVP
      USE COUP_WELL
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(16) :: VARZ	
      REAL*8, DIMENSION(13) :: VARX	
      REAL*8 DPC(LNGC)
      INTEGER, DIMENSION(3) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      INTEGER MPC(LNGC)
      CHARACTER*64 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      SAVE PH_CND
      DATA PH_CND /'Phase Condition #1, SL = 1.0, SG+SN = 0.0',
     &  'Phase Condition #2, SL > 0.0, SN > 0.0, SG = 0.0',
     &  'Phase Condition #3, SL > 0.0, SN > 0.0, SG > 0.0',
     &  'Phase Condition #4, SL = 0.0, SN > 0.0, SG = 0.0',
     &  'Phase Condition #5, SL = 0.0, SN > 0.0, SG > 0.0'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_EOR'
!
!---  Black-oil option  ---
!
      IF( ISLC(68).EQ.0 ) THEN
        CALL UPDT_BO
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Compositional option  ---
!
      OFFSET = IOFFSET_REF
      IF( ICNV.EQ.1 ) THEN
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ') - 1
          IF( ID.EQ.0 ) PRINT *,'Linear System Solver Failure: ' //
     &      'Time Step  Reduced from ',DTX*CNVTM,UNTM(1:NCH),' to ',
     &      DT*CNVTM,UNTM(1:NCH)
!
!---      Write a linear system solver failure index of -3 in the
!         NSTEP location plus time step reductions to output.bin  ---
!
          NVAR = 1
          IVARX(1) = -3
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          NVAR = 2
          VARX(1) = DTX*CNVTM
          VARX(2) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            DO M = 1,6
              BETA(M,N) = 0.D+0
            ENDDO
            IBETA(N) = 0
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            PVA(2,N) = PVA(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
              ZMC(IGC,2,N) = ZMC(IGC,1,N)
            ENDDO
          ENDDO
!
!---      Coupled-well pressure  ---
!
          IF( L_CW.EQ.1 ) THEN
            DO NCW = 1,N_CW
              P_CW(2,NCW) = P_CW(1,NCW)
            ENDDO
          ENDIF
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            DO M = 1,6
              BETA(M,N) = 0.D+0
            ENDDO
            IBETA(N) = 0
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            PVA(2,N) = PVA(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
              ZMC(IGC,2,N) = ZMC(IGC,1,N)
            ENDDO
          ENDDO
!
!---      Coupled-well pressure  ---
!
          IF( L_CW.EQ.1 ) THEN
            DO NCW = 1,N_CW
              P_CW(2,NCW) = P_CW(1,NCW)
            ENDDO
          ENDIF
          IF( ID.EQ.0 )  PRINT *,'          ---  Time Step ' //
     &      'Reduction Limit Exceeded  ---'
          ICNV = 4
          IVARX(1) = -2
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
!
!---    Reset subroutine string sequence  ---
!
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Update primary variables on field cells  ---
!
      IERR = 0
      IERRL = NFLD + 1
      IERRG = NFLD + 1
      NMD = 0
      DO N = 1,NFCGC(ID+1)
#ifdef lis
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
#ifdef petsc
!
!---    Skip for inactive nodes  ---
!
        IF( IXP(N).EQ.0 ) CYCLE
#endif
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        IF( IERRL.NE.(NFLD+1) ) CYCLE
        N_DB = ND(N)
!
!---    Energy equation  ---
!
        IF( ISLC(30).EQ.0 ) THEN
          MPT = NMD + IEQT
          DPT = BLU(MPT)
        ELSE
          DPT = 0.D+0
        ENDIF
!
!---    Water mass equation  ---
!
        MPW = NMD + IEQW
        DPW = BLU(MPW)
!
!---    CO2 mass equation  ---
!
        IF( ISLC(45).EQ.0 ) THEN
          MPC(1) = NMD + IEQGC(1)
          DPC(1) = BLU(MPC(1))
        ELSE
          MPC(1) = 0
          DPC(1) = 0.D+0
        ENDIF
!
!---    CH4 mass equation  ---
!
        IF( ISLC(64).EQ.0 ) THEN
          MPC(2) = NMD + IEQGC(2)
          DPC(2) = BLU(MPC(2))
        ELSE
          MPC(2) = 0
          DPC(2) = 0.D+0
        ENDIF
!
!---    Petroleum component mass equation  ---
!
        DO IGC = 3,NGC+2
          MPC(IGC) = NMD + IEQGC(IGC)
          DPC(IGC) = BLU(MPC(IGC))
        ENDDO
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ELSE
          DPS = 0.D+0
        ENDIF
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
!
!---    Limit changes in temperature to 0.5 C,
!       excessive primary variable change limit at 100 C  ---
!
!        IF( ABS(DPT).GT.1.D+2 ) IERR = 1
        DPT = SIGN( MIN( 5.D-1,ABS(DPT) ),DPT )
        T(2,N) = MAX( (T(2,N)+DPT),1.D-1 )
!
!---    Phase condition #1  ---
!
!       SL = 1.0, SG+SN = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous (system) pressure, Pa gauge - PL,PSO
!       CO2 mass - CO2 vapor pressure - PVA
!       CH4 mass - total CH4 mass - TMC
!       petroleum component mass - total petroleum component mass - TMC
!       salt mass - total salt brine mass fraction - YLS
!
        IF( MOD(NPHAZ(2,N),10).EQ.1 ) THEN
!
!---      Limit changes in total pressure,
!         excessive primary variable change limit at 100 MPa  ---
!
!          IF( ABS(DPW).GT.1.D+8 ) IERR = 1
!          DPX = MAX( 5.D-2*(PSO(2,N)+PATM),1.D+6 )
          DPX = 1.D-2*(PSO(2,N)+PATM)
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          PSO(2,N) = PSO(2,N) + DPW
          PSO(2,N) = MIN( PSO(2,N),5.D+8 )
!
!---      Zero negative corrections for zero aqueous CO2  ---
!
          IF( ISLC(45).EQ.0 ) THEN
            IF( PVA(2,N).LT.EPSL .AND. BLU(MPC(1)).LT.EPSL ) THEN
              BLU(MPC(1)) = 0.D+0
              DPC(1) = 0.D+0
            ENDIF
            DPX = 1.D+6
            DPC(1) = SIGN( MIN(ABS(DPX),ABS(DPC(1))),DPC(1) )
            IF( (PVA(2,N)+DPC(1)).LT.0.D+0 ) DPC(1) = 6.D-1*DPC(1)
            PVA(2,N) = MAX( (PVA(2,N)+DPC(1)),0.D+0 )
          ENDIF
!
!---      Zero negative corrections for zero total petroleum
!         component mass  ---
!
          TMWX = PORD(2,N)*RHOL(2,N)*VOL(N)
          DPX = 1.D-4*TMWX
          DO IGC = 2,NGC+2
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
            IF( TMC(IGC,2,N).LT.EPSL .AND. BLU(MPC(IGC)).LT.EPSL ) THEN
              BLU(MPC(IGC)) = 0.D+0
              DPC(IGC) = 0.D+0
            ENDIF
            DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
            TMC(IGC,2,N) = MAX( (TMC(IGC,2,N)+DPC(IGC)),0.D+0 )
            IF( TMC(IGC,2,N).LT.1.D-12 ) TMC(IGC,2,N) = 0.D+0
          ENDDO
!
!---      Limit salt mass fraction changes to 0.25 of the
!         maximum value if salt mass fraction is less than
!         the maximum, isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero dissolved salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. DPS/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.1.D-12 ) YLS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #2  ---
!
!       SL < 1.0, ST > 0.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.2 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          IF( NPHAZ(2,N).GT.100 ) THEN
!            DPX = MAX( 1.D+6,1.D-1*(PN(2,N)-PL(2,N)) )
!            DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
            DPX = 1.D-2*(PSO(2,N)+PATM)
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            PSO(2,N) = PSO(2,N) + DPW
            PSO(2,N) = MIN( PSO(2,N),5.D+8 )
          ELSE
!            DPX = 5.D-2/SQRT(REAL(NITER))
            DPX = 1.D-2
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            SL(2,N) = SL(2,N) + DPW
            IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
          ENDIF
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          SZMCX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Maximum petroleum component, limit changes in nonaqueous
!           liquid pressure, excessive primary variable change 
!           limit at 100 MPa  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DPX = 1.D-2
!                DPX = 5.D-2/SQRT(REAL(NITER))
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                SL(2,N) = SL(2,N) + DPC(IGC)
                IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
              ELSE
!                IF( ABS(DPC(IGC)).GT.1.D+8 ) IERR = 1
                DPX = MAX( 1.D+6,1.D-1*(PN(2,N)-PL(2,N)) )
                DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                PSO(2,N) = PSO(2,N) + DPC(IGC)
                PSO(2,N) = MIN( PSO(2,N),5.D+8 )
              ENDIF
!
!---        Limit changes in petroleum component mole fraction, 
!           and zero negative corrections for zero mole fractions---
!
            ELSE
              DPX = 5.D-2/SQRT(REAL(NITER))
              DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
              IF( ZMC(IGC,2,N).GT.0.D+0 .AND. 
     &          ZMC(IGC,2,N)+DPC(IGC).LT.0.D+0 ) 
     &          DPC(IGC) = 6.D-1*DPC(IGC)
              ZMC(IGC,2,N) = ZMC(IGC,2,N) + DPC(IGC)
              IF( ZMC(IGC,2,N).LT.EPSL ) ZMC(IGC,2,N) = 0.D+0
              SZMCX = SZMCX + ZMC(IGC,2,N)
            ENDIF
          ENDDO
          ZMC(IZMC(N),2,N) = MAX( 1.D+0-SZMCX,0.D+0 )
!
!---      Limit salt mass fraction changes to 0.25 of the
!         maximum value if salt mass fraction is less than
!         the maximum, isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero dissolved salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. DPS/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.1.D-12 ) YLS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #3  ---
!
!       SL < 1.0, ST > 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt brine mass fraction - YLS
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.3 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          IF( NPHAZ(2,N).GT.100 ) THEN
!            DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
            DPX = 1.D-2*(PSO(2,N)+PATM)
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            PSO(2,N) = PSO(2,N) + DPW
            PSO(2,N) = MIN( PSO(2,N),5.D+8 )
          ELSE
            DPX = 5.D-2/SQRT(REAL(NITER))
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            SL(2,N) = SL(2,N) + DPW
            IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
          ENDIF
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          SZMCX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Maximum petroleum component, limit changes in
!           gas pressure, excessive primary variable change 
!           limit at 100 MPa  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
!                DPX = 5.D-2/SQRT(REAL(NITER))
                DPX = 1.D-2
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                SL(2,N) = SL(2,N) + DPC(IGC)
                IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
              ELSE
!                IF( ABS(DPC(IGC)).GT.1.D+8 ) IERR = 1
!                CPGTX = PG(2,N)-MAX(PL(2,N),PN(2,N))
!                DPX = MAX( 1.D+6,1.D-1*CPGTX )
!                DPX = 5.D-2*(PSO(2,N)+PATM)/REAL(NITER)
                DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                PSO(2,N) = PSO(2,N) + DPC(IGC)
                PSO(2,N) = MIN( PSO(2,N),5.D+8 )
              ENDIF
!
!---        Limit changes in petroleum component mole fraction, 
!           and zero negative corrections for zero mole fractions---
!
            ELSE
!              DPX = 5.D-2/SQRT(REAL(NITER))
              DPX = 1.D-2
              DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
              IF( ZMC(IGC,2,N).GT.0.D+0 .AND. 
     &          ZMC(IGC,2,N)+DPC(IGC).LT.0.D+0 ) 
     &          DPC(IGC) = 6.D-1*DPC(IGC)
              ZMC(IGC,2,N) = ZMC(IGC,2,N) + DPC(IGC)
              IF( ZMC(IGC,2,N).LT.EPSL ) ZMC(IGC,2,N) = 0.D+0
!
!---          Zero negative corrections for zero petroleum
!             component mole fraction  ---
!
              IF( ZMC(IGC,2,N).LT.EPSL.AND.BLU(MPC(IGC)).LT.EPSL ) THEN
                BLU(MPC(IGC)) = 0.D+0
                DPC(IGC) = 0.D+0
              ENDIF
              SZMCX = SZMCX + ZMC(IGC,2,N)
            ENDIF
          ENDDO
          ZMC(IZMC(N),2,N) = MAX( 1.D+0-SZMCX,0.D+0 )
!
!---      Limit salt mass fraction changes to 0.25 of the
!         maximum value if salt mass fraction is less than
!         the maximum, isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_LS( T(2,N),XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero dissolved salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. DPS/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.1.D-12 ) YLS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #4  ---
!
!       SL = 0.0, ST = 1.0, SG = 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - nonaqueous (system) pressure, Pa gauge - PN,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.4 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          IF( NPHAZ(2,N).GT.100 ) THEN
!            DPX = MAX( 1.D+6,1.D-1*(PN(2,N)-PL(2,N)) )
!            DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
            DPX = 1.D-2*(PSO(2,N)+PATM)
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            PSO(2,N) = PSO(2,N) + DPW
            PSO(2,N) = MIN( PSO(2,N),5.D+8 )
          ELSE
            DPX = 1.D-2
!            DPX = 5.D-2/SQRT(REAL(NITER))
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            SL(2,N) = SL(2,N) + DPW
            IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
          ENDIF
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          SZMCX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Maximum petroleum component, limit changes in nonaqueous
!           liquid pressure, excessive primary variable change 
!           limit at 100 MPa  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DPX = 1.D-2
!                DPX = 5.D-2/SQRT(REAL(NITER))
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                SL(2,N) = SL(2,N) + DPC(IGC)
                IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
              ELSE
!                IF( ABS(DPC(IGC)).GT.1.D+8 ) IERR = 1
                DPX = MAX( 1.D+6,1.D-1*(PN(2,N)-PL(2,N)) )
                DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                PSO(2,N) = PSO(2,N) + DPC(IGC)
                PSO(2,N) = MIN( PSO(2,N),5.D+8 )
              ENDIF
!
!---        Limit changes in petroleum component mole fraction, 
!           and zero negative corrections for zero mole fractions---
!
            ELSE
              DPX = 5.D-2/SQRT(REAL(NITER))
              DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
              IF( ZMC(IGC,2,N).GT.0.D+0 .AND. 
     &          ZMC(IGC,2,N)+DPC(IGC).LT.0.D+0 ) 
     &          DPC(IGC) = 6.D-1*DPC(IGC)
              ZMC(IGC,2,N) = ZMC(IGC,2,N) + DPC(IGC)
              IF( ZMC(IGC,2,N).LT.EPSL ) ZMC(IGC,2,N) = 0.D+0
              SZMCX = SZMCX + ZMC(IGC,2,N)
            ENDIF
          ENDDO
          ZMC(IZMC(N),2,N) = MAX( 1.D+0-SZMCX,0.D+0 )
!
!---      Isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Zero negative corrections for zero total salt mass  ---
!
            IF( TMS(2,N).LT.EPSL .AND. DPS.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            TMS(2,N) = TMS(2,N) + DPS
            IF( TMS(2,N).LT.EPSL ) TMS(2,N) = 0.D+0
          ENDIF
!
!---    Phase condition #5  ---
!
!       SL = 0.0, ST >= 0.0, SG > 0.0
!
!       energy - temperature, C - T
!       water mass - aqueous saturation, SL
!       CO2 mass
!         if( ZMC(1,2,N) > max( ZMC(J,2,N) ) J /= 1
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(1,2,N)
!         endif
!       CH4 mass
!         if( ZMC(2,2,N) > max( ZMC(J,2,N) ) J /= 2
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(2,2,N)
!         endif
!       petroleum component mass
!         if( ZMC(I,2,N) > max( ZMC(J,2,N) ) J /= I
!           - gas (system) pressure, Pa gauge - PG,PSO
!         else
!           - nonaqueous mole fraction of CO2 - ZMC(I,2,N)
!         endif
!       salt mass - total salt mass - TMS(2,N)
!
        ELSEIF( MOD(NPHAZ(2,N),10).EQ.5 ) THEN
!
!---      Limit changes in aqueous saturation  ---
!
          IF( NPHAZ(2,N).GT.100 ) THEN
!            DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-MAX(PL(2,N),PN(2,N))) )
!            DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
            DPX = 1.D-2*(PSO(2,N)+PATM)
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            PSO(2,N) = PSO(2,N) + DPW
            PSO(2,N) = MIN( PSO(2,N),5.D+8 )
          ELSE
            DPX = 5.D-2/SQRT(REAL(NITER))
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            SL(2,N) = SL(2,N) + DPW
            IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
          ENDIF
!
!---      Loop over all petroleum components, including CO2 and CH4  ---
!
          SZMCX = 0.D+0
          DO IGC = 1,NGC+2
            IF( ISLC(45).NE.0 .AND. IGC.EQ.1 ) CYCLE
            IF( ISLC(64).NE.0 .AND. IGC.EQ.2 ) CYCLE
!
!---        Maximum petroleum component, limit changes in
!           gas pressure, excessive primary variable change 
!           limit at 100 MPa  ---
!
            IF( IGC.EQ.IZMC(N) ) THEN
              IF( NPHAZ(2,N).GT.100 ) THEN
                DPX = 5.D-2/SQRT(REAL(NITER))
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                SL(2,N) = SL(2,N) + DPC(IGC)
                IF( SL(2,N).LT.EPSL ) SL(2,N) = 0.D+0
              ELSE
!                IF( ABS(DPC(IGC)).GT.1.D+8 ) IERR = 1
                DPX = MAX( 1.D+6,1.D-1*(PG(2,N)-MAX(PL(2,N),PN(2,N))) )
                DPX = 5.D-2*(PSO(2,N)+PATM)/SQRT(REAL(NITER))
                DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
                PSO(2,N) = PSO(2,N) + DPC(IGC)
                PSO(2,N) = MIN( PSO(2,N),5.D+8 )
              ENDIF
!
!---        Limit changes in petroleum component mole fraction, 
!           and zero negative corrections for zero mole fractions---
!
            ELSE
              DPX = 5.D-2/SQRT(REAL(NITER))
              DPC(IGC) = SIGN( MIN(ABS(DPX),ABS(DPC(IGC))),DPC(IGC) )
              IF( ZMC(IGC,2,N).GT.0.D+0 .AND. 
     &          ZMC(IGC,2,N)+DPC(IGC).LT.0.D+0 ) 
     &          DPC(IGC) = 6.D-1*DPC(IGC)
              ZMC(IGC,2,N) = ZMC(IGC,2,N) + DPC(IGC)
              IF( ZMC(IGC,2,N).LT.EPSL ) ZMC(IGC,2,N) = 0.D+0
              SZMCX = SZMCX + ZMC(IGC,2,N)
            ENDIF
          ENDDO
          ZMC(IZMC(N),2,N) = MAX( 1.D+0-SZMCX,0.D+0 )
!
!---      Isobrine option   ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Zero negative corrections for zero total salt mass  ---
!
            IF( TMS(2,N).LT.EPSL .AND. DPS.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            TMS(2,N) = TMS(2,N) + DPS
            IF( TMS(2,N).LT.EPSL ) TMS(2,N) = 0.D+0
          ENDIF
        ENDIF
#ifdef petsc
!
!---    Skip checks for excessive pressure or temperature for
!       ghost cells   ---
!
        IF( IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Check for excessive pressure or temperature   ---
!
        PX = PSO(2,N)+PATM
        TKX = T(2,N)+TABS
        IF( PX.GT.8.D+8 .OR. PX.LT.0.D+0 ) IERR = 1
        IF( TKX.GT.TCRW .OR. TKX.LT.TABS ) IERR = 1
!
!---    Excess changes in primary variables, skip updates  ---
!
        IF( IERR.EQ.1 .AND. IERRL.EQ.(NFLD+1) ) THEN
          IERRL = ND(N)
          VARZ(1) = REAL( N )
          VARZ(2) = REAL( NPHAZ(2,N) )
          VARZ(3) = DPW
          VARZ(4) = DPC(1)
          VARZ(5) = DPC(2)
          VARZ(6) = DPS
          VARZ(7) = T(2,N)
          VARZ(8) = PSO(2,N)+PATM
          VARZ(9) = PL(2,N)+PATM
          VARZ(10) = PG(2,N)+PATM
          VARZ(11) = PN(2,N)+PATM
          VARZ(12) = SL(2,N)
          VARZ(13) = SG(2,N)
          VARZ(14) = SN(2,N)
          VARZ(15) = YLS(2,N)
          VARZ(16) = TMS(2,N)
        ENDIF
      ENDDO
!
!---  Identify minimum global node with errors  ---
!
      CALL MPI_ALLREDUCE( IERRL,IERRG,1,MPI_INTEGER,MPI_MIN,
     &  MPI_COMM_WORLD,IERR )
!
!---  Node identified with an excessive primary variable change  ---
!
      IF( IERRG.NE.(NFLD+1) ) THEN
        ICNV = 1
        ID2X = 0
!
!---    Identify processor with error  ---
!
        DO MP = 1,NP
          IF( IERRL.EQ.IERRG ) ID2X = ID
        ENDDO
        CALL MPI_ALLREDUCE( ID2X,IDX,1,MPI_INTEGER,MPI_MAX,
     &    MPI_COMM_WORLD,IERR )
!
!---    Send node state to P0  ---
!
        IF( ID.EQ.IDX ) THEN
          CALL MPI_SEND( VARZ,16,MPI_REAL8,0,18,MPI_COMM_WORLD,IERR )
        ENDIF
        IF( ID.EQ.0 ) THEN
          CALL MPI_RECV( VARZ,16,MPI_REAL8,IDX,18,MPI_COMM_WORLD,
     &      STATUS,IERR )
          N = INT(VARZ(1))
          NPHZX = MOD(INT(VARZ(2)),100)
          PRINT *,'---  Excessive Primary Variable Change  ---'
          PRINT *,'  Node = ',ND(N)
          PRINT *,'  Phase Condition = ',PH_CND(NPHZX)
          PRINT *,'  DPW = ',VARZ(3)
          PRINT *,'  DPC(1) = ',VARZ(4)
          PRINT *,'  DPC(2) = ',VARZ(5)
          IF( ISLC(32).EQ.0 ) THEN
            PRINT *,'  DPS = ',VARZ(6)
          ENDIF
          PRINT *,'  Temperature, C = ',VARZ(7)
          PRINT *,'  System Pressure, Pa = ',VARZ(8)
          PRINT *,'  Aqueous Pressure, Pa = ',VARZ(9)
          PRINT *,'  Gas Pressure, Pa = ',VARZ(10)
          PRINT *,'  Nonaqueous Liquid Pressure, Pa = ',VARZ(11)
          PRINT *,'  Gas Saturation = ',VARZ(12)
          PRINT *,'  Aqueous Saturation = ',VARZ(13)
          PRINT *,'  Nonaqueous Liquid Saturation = ',VARZ(14)
          IF( ISLC(32).EQ.0 ) THEN
            PRINT *,'  Total-Salt Aqu. Mass Fraction = ',VARZ(15)
            PRINT *,'  Total-Salt Mass = ',VARZ(16)
          ENDIF
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            DO M = 1,6
              BETA(M,N) = 0.D+0
            ENDDO
            IBETA(N) = 0
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            PVA(2,N) = PVA(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
              ZMC(IGC,2,N) = ZMC(IGC,1,N)
            ENDDO
          ENDDO
!
!---      Write a excessive primary variable index in the NSTEP location
!         plus write the global node numbers and phase condition indices
!         for the location of maximum residuals for the water, CO2,
!         and salt equations to output.bin  ---
!
          NVAR = 3
          IVARX(1) = -4
          IVARX(2) = ND(IERRG)
          IVARX(3) = NPHZX
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---      Write maximum residuals for the water, gas, oil, and salt
!         mass equations and time step reductions to output.bin  ---
!
          NVAR = 13
          VARX(1) = VARZ(6)
          VARX(2) = VARZ(7)
          VARX(3) = VARZ(8)
          VARX(4) = VARZ(9)
          VARX(5) = VARZ(10)
          VARX(6) = VARZ(11)
          VARX(7) = VARZ(12)
          VARX(8) = VARZ(13)
          VARX(9) = VARZ(14)
          VARX(10) = VARZ(15)
          VARX(11) = VARZ(16)
          VARX(12) = DTX*CNVTM
          VARX(13) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          DO N = 1,NFCGC(ID+1)
            IF( IXP(N).EQ.0 ) CYCLE
            DO M = 1,6
              BETA(M,N) = 0.D+0
            ENDDO
            IBETA(N) = 0
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PN(2,N) = PN(1,N)
            PSO(2,N) = PSO(1,N)
            PVA(2,N) = PVA(1,N)
            SG(2,N) = SG(1,N)
            SL(2,N) = SL(1,N)
            SN(2,N) = SN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
            DO IGC = 1,NGC+2
              TMC(IGC,2,N) = TMC(IGC,1,N)
              ZMC(IGC,2,N) = ZMC(IGC,1,N)
            ENDDO
          ENDDO
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_EOR group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_GC_BO
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Update the primary variables on ghost cells for the black-oil
!     option
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 December 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
      USE JACOB
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_GC_BO'
!
!---  Number of variables sent and received  ---
!
      NPVX = 13 + NGC
!
!---  Load sending buffer for bottom ghost cells for processors
!     with bottom ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
        MCS = 0
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(1,ID+1)
          SBFB(NCS+1) = T(2,NLSGC(M+MCS))
          SBFB(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFB(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFB(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFB(NCS+5) = POSM(2,NLSGC(M+MCS))
          SBFB(NCS+6) = PSO(2,NLSGC(M+MCS))
          SBFB(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFB(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFB(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFB(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFB(NCS+11) = TMS(2,NLSGC(M+MCS))
          DO IGC = 1,NGC+2
            SBFB(NCS+11+IGC) = TMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(1,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(1,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFB,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Bottom Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending bottom ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(6,ID+1)*NPVX
        IDSNDX = NPGC(6,ID+1) - 1
        NRCVX = NCGC(1,IDSNDX+1)*NPVX
        IDRCVX = NPGC(1,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFB,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Bottom Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,5
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(6,ID+1)
          T(2,NLSGC(M+MCS))  = RBFB(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFB(NCR+2)
          PG(2,NLSGC(M+MCS)) = RBFB(NCR+3)
          PN(2,NLSGC(M+MCS)) = RBFB(NCR+4)
          POSM(2,NLSGC(M+MCS)) = RBFB(NCR+5)
          PSO(2,NLSGC(M+MCS)) = RBFB(NCR+6)
          SG(2,NLSGC(M+MCS)) = RBFB(NCR+7)
          SL(2,NLSGC(M+MCS)) = RBFB(NCR+8)
          SN(2,NLSGC(M+MCS)) = RBFB(NCR+9)
          YLS(2,NLSGC(M+MCS)) = RBFB(NCR+10)
          TMS(2,NLSGC(M+MCS)) = RBFB(NCR+11)
          DO IGC = 1,NGC+2
            TMC(IGC,2,NLSGC(M+MCS)) = RBFB(NCR+11+IGC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for south ghost cells for processors
!     with south ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
        MCS = NCGC(1,ID+1)
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(2,ID+1)
          SBFS(NCS+1) = T(2,NLSGC(M+MCS))
          SBFS(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFS(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFS(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFS(NCS+5) = POSM(2,NLSGC(M+MCS))
          SBFS(NCS+6) = PSO(2,NLSGC(M+MCS))
          SBFS(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFS(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFS(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFS(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFS(NCS+11) = TMS(2,NLSGC(M+MCS))
          DO IGC = 1,NGC+2
            SBFS(NCS+11+IGC) = TMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(2,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(2,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFS,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post South Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending south ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(5,ID+1)*NPVX
        IDSNDX = NPGC(5,ID+1) - 1
        NRCVX = NCGC(2,IDSNDX+1)*NPVX
        IDRCVX = NPGC(2,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFS,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post South Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,4
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(5,ID+1)
          T(2,NLSGC(M+MCS))  = RBFS(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFS(NCR+2)
          PG(2,NLSGC(M+MCS)) = RBFS(NCR+3)
          PN(2,NLSGC(M+MCS)) = RBFS(NCR+4)
          POSM(2,NLSGC(M+MCS)) = RBFS(NCR+5)
          PSO(2,NLSGC(M+MCS)) = RBFS(NCR+6)
          SG(2,NLSGC(M+MCS)) = RBFS(NCR+7)
          SL(2,NLSGC(M+MCS)) = RBFS(NCR+8)
          SN(2,NLSGC(M+MCS)) = RBFS(NCR+9)
          YLS(2,NLSGC(M+MCS)) = RBFS(NCR+10)
          TMS(2,NLSGC(M+MCS)) = RBFS(NCR+11)
          DO IGC = 1,NGC+2
            TMC(IGC,2,NLSGC(M+MCS)) = RBFS(NCR+11+IGC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for west ghost cells for processors
!     with west ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,2
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(3,ID+1)
!          IF( ID.EQ.2 )
!     &      PRINT *,'S2: ND(',NLSGC(M+MCS),') = ',ND(NLSGC(M+MCS))
          SBFW(NCS+1) = T(2,NLSGC(M+MCS))
          SBFW(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFW(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFW(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFW(NCS+5) = POSM(2,NLSGC(M+MCS))
          SBFW(NCS+6) = PSO(2,NLSGC(M+MCS))
          SBFW(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFW(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFW(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFW(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFW(NCS+11) = TMS(2,NLSGC(M+MCS))
          DO IGC = 1,NGC+2
            SBFW(NCS+11+IGC) = TMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(3,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(3,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFW,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post West Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending west ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(4,ID+1)*NPVX
        IDSNDX = NPGC(4,ID+1) - 1
        NRCVX = NCGC(3,IDSNDX+1)*NPVX
        IDRCVX = NPGC(3,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFW,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post West Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,3
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(4,ID+1)
!          IF( ID.EQ.1 )
!     &      PRINT *,'R1: ND(',NLSGC(M+MCR),') = ',ND(NLSGC(M+MCR))
          T(2,NLSGC(M+MCS))  = RBFW(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFW(NCR+2)
          PG(2,NLSGC(M+MCS)) = RBFW(NCR+3)
          PN(2,NLSGC(M+MCS)) = RBFW(NCR+4)
          POSM(2,NLSGC(M+MCS)) = RBFW(NCR+5)
          PSO(2,NLSGC(M+MCS)) = RBFW(NCR+6)
          SG(2,NLSGC(M+MCS)) = RBFW(NCR+7)
          SL(2,NLSGC(M+MCS)) = RBFW(NCR+8)
          SN(2,NLSGC(M+MCS)) = RBFW(NCR+9)
          YLS(2,NLSGC(M+MCS)) = RBFW(NCR+10)
          TMS(2,NLSGC(M+MCS)) = RBFW(NCR+11)
          DO IGC = 1,NGC+2
            TMC(IGC,2,NLSGC(M+MCS)) = RBFW(NCR+11+IGC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for east ghost cells for processors
!     with east ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,3
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(4,ID+1)
          SBFE(NCS+1) = T(2,NLSGC(M+MCS))
          SBFE(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFE(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFE(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFE(NCS+5) = POSM(2,NLSGC(M+MCS))
          SBFE(NCS+6) = PSO(2,NLSGC(M+MCS))
          SBFE(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFE(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFE(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFE(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFE(NCS+11) = TMS(2,NLSGC(M+MCS))
          DO IGC = 1,NGC+2
            SBFE(NCS+11+IGC) = TMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(4,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(4,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFE,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post East Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending east ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(3,ID+1)*NPVX
        IDSNDX = NPGC(3,ID+1) - 1
        NRCVX = NCGC(4,IDSNDX+1)*NPVX
        IDRCVX = NPGC(4,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFE,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post East Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,2
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(3,ID+1)
          T(2,NLSGC(M+MCS))  = RBFE(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFE(NCR+2)
          PG(2,NLSGC(M+MCS)) = RBFE(NCR+3)
          PN(2,NLSGC(M+MCS)) = RBFE(NCR+4)
          POSM(2,NLSGC(M+MCS)) = RBFE(NCR+5)
          PSO(2,NLSGC(M+MCS)) = RBFE(NCR+6)
          SG(2,NLSGC(M+MCS)) = RBFE(NCR+7)
          SL(2,NLSGC(M+MCS)) = RBFE(NCR+8)
          SN(2,NLSGC(M+MCS)) = RBFE(NCR+9)
          YLS(2,NLSGC(M+MCS)) = RBFE(NCR+10)
          TMS(2,NLSGC(M+MCS)) = RBFE(NCR+11)
          DO IGC = 1,NGC+2
            TMC(IGC,2,NLSGC(M+MCS)) = RBFE(NCR+11+IGC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for north ghost cells for processors
!     with north ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,4
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(5,ID+1)
          SBFN(NCS+1) = T(2,NLSGC(M+MCS))
          SBFN(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFN(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFN(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFN(NCS+5) = POSM(2,NLSGC(M+MCS))
          SBFN(NCS+6) = PSO(2,NLSGC(M+MCS))
          SBFN(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFN(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFN(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFN(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFN(NCS+11) = TMS(2,NLSGC(M+MCS))
          DO IGC = 1,NGC+2
            SBFN(NCS+11+IGC) = TMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(5,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(5,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFN,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post North Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending north ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(2,ID+1)*NPVX
        IDSNDX = NPGC(2,ID+1) - 1
        NRCVX = NCGC(5,IDSNDX+1)*NPVX
        IDRCVX = NPGC(5,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFN,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post North Receive: IERR = ',IERR,' ID = ',ID
        MCR = NCGC(1,ID+1)
!        PRINT *,' MCR = ',MCR,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(2,ID+1)
          T(2,NLSGC(M+MCS))  = RBFN(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFN(NCR+2)
          PG(2,NLSGC(M+MCS)) = RBFN(NCR+3)
          PN(2,NLSGC(M+MCS)) = RBFN(NCR+4)
          POSM(2,NLSGC(M+MCS)) = RBFN(NCR+5)
          PSO(2,NLSGC(M+MCS)) = RBFN(NCR+6)
          SG(2,NLSGC(M+MCS)) = RBFN(NCR+7)
          SL(2,NLSGC(M+MCS)) = RBFN(NCR+8)
          SN(2,NLSGC(M+MCS)) = RBFN(NCR+9)
          YLS(2,NLSGC(M+MCS)) = RBFN(NCR+10)
          TMS(2,NLSGC(M+MCS)) = RBFN(NCR+11)
          DO IGC = 1,NGC+2
            TMC(IGC,2,NLSGC(M+MCS)) = RBFN(NCR+11+IGC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for top ghost cells for processors
!     with top ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,5
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(6,ID+1)
          SBFT(NCS+1) = T(2,NLSGC(M+MCS))
          SBFT(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFT(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFT(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFT(NCS+5) = POSM(2,NLSGC(M+MCS))
          SBFT(NCS+6) = PSO(2,NLSGC(M+MCS))
          SBFT(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFT(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFT(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFT(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFT(NCS+11) = TMS(2,NLSGC(M+MCS))
          DO IGC = 1,NGC+2
            SBFT(NCS+11+IGC) = TMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(6,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(6,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFT,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Top Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending top ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(1,ID+1)*NPVX
        IDSNDX = NPGC(1,ID+1) - 1
        NRCVX = NCGC(6,IDSNDX+1)*NPVX
        IDRCVX = NPGC(6,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFT,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Top Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
!        PRINT *,' MCR = ',MCR,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(1,ID+1)
          T(2,NLSGC(M+MCS))  = RBFT(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFT(NCR+2)
          PG(2,NLSGC(M+MCS)) = RBFT(NCR+3)
          PN(2,NLSGC(M+MCS)) = RBFT(NCR+4)
          POSM(2,NLSGC(M+MCS)) = RBFT(NCR+5)
          PSO(2,NLSGC(M+MCS)) = RBFT(NCR+6)
          SG(2,NLSGC(M+MCS)) = RBFT(NCR+7)
          SL(2,NLSGC(M+MCS)) = RBFT(NCR+8)
          SN(2,NLSGC(M+MCS)) = RBFT(NCR+9)
          YLS(2,NLSGC(M+MCS)) = RBFT(NCR+10)
          TMS(2,NLSGC(M+MCS)) = RBFT(NCR+11)
          DO IGC = 1,NGC+2
            TMC(IGC,2,NLSGC(M+MCS)) = RBFT(NCR+11+IGC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_GC_BO group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_GC_EOR
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     STOMPX-EOR (Enhanced Oil Recovery and Carbon Utilization) Mode
!
!     Update the primary variables on ghost cells for the
!     compositional option
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 14 December 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
      USE JACOB
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_GC_EOR'
!
!---  Black-oil option  ---
!
      IF( ISLC(68).EQ.0 ) THEN
        CALL UPDT_GC_BO
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Compositional option, number of variables sent and received  ---
!
      NPVX = 15 + 2*NGC
!
!---  Load sending buffer for bottom ghost cells for processors
!     with bottom ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
        MCS = 0
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(1,ID+1)
          SBFB(NCS+1) = T(2,NLSGC(M+MCS))
          SBFB(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFB(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFB(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFB(NCS+5) = PSO(2,NLSGC(M+MCS))
          SBFB(NCS+6) = PVA(2,NLSGC(M+MCS))
          SBFB(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFB(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFB(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFB(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFB(NCS+11) = TMS(2,NLSGC(M+MCS))
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            SBFB(NCS+11+MC) = TMC(IGC,2,NLSGC(M+MCS))
            MC = MC + 1
            SBFB(NCS+11+MC) = ZMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(1,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(1,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFB,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Bottom Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending bottom ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(6,ID+1)*NPVX
        IDSNDX = NPGC(6,ID+1) - 1
        NRCVX = NCGC(1,IDSNDX+1)*NPVX
        IDRCVX = NPGC(1,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFB,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Bottom Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,5
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(6,ID+1)
          T(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          PG(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          PN(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          PSO(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          PVA(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          SG(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          SL(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          SN(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          YLS(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          TMS(2,NLSGC(M+MCS)) = RBFB(NCR+1)
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            TMC(IGC,2,NLSGC(M+MCS)) = RBFB(NCR+11+MC)
            MC = MC + 1
            ZMC(IGC,2,NLSGC(M+MCS)) = RBFB(NCR+11+MC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for south ghost cells for processors
!     with south ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
        MCS = NCGC(1,ID+1)
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(2,ID+1)
          SBFS(NCS+1) = T(2,NLSGC(M+MCS))
          SBFS(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFS(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFS(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFS(NCS+5) = PSO(2,NLSGC(M+MCS))
          SBFS(NCS+6) = PVA(2,NLSGC(M+MCS))
          SBFS(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFS(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFS(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFS(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFS(NCS+11) = TMS(2,NLSGC(M+MCS))
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            SBFS(NCS+11+MC) = TMC(IGC,2,NLSGC(M+MCS))
            MC = MC + 1
            SBFS(NCS+11+MC) = ZMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(2,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(2,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFS,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post South Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending south ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(5,ID+1)*NPVX
        IDSNDX = NPGC(5,ID+1) - 1
        NRCVX = NCGC(2,IDSNDX+1)*NPVX
        IDRCVX = NPGC(2,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFS,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post South Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,4
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(5,ID+1)
          T(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          PG(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          PN(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          PSO(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          PVA(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          SG(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          SL(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          SN(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          YLS(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          TMS(2,NLSGC(M+MCS)) = RBFS(NCR+1)
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            TMC(IGC,2,NLSGC(M+MCS)) = RBFS(NCR+11+MC)
            MC = MC + 1
            ZMC(IGC,2,NLSGC(M+MCS)) = RBFS(NCR+11+MC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for west ghost cells for processors
!     with west ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,2
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(3,ID+1)
!          IF( ID.EQ.2 )
!     &      PRINT *,'S2: ND(',NLSGC(M+MCS),') = ',ND(NLSGC(M+MCS))
          SBFW(NCS+1) = T(2,NLSGC(M+MCS))
          SBFW(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFW(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFW(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFW(NCS+5) = PSO(2,NLSGC(M+MCS))
          SBFW(NCS+6) = PVA(2,NLSGC(M+MCS))
          SBFW(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFW(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFW(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFW(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFW(NCS+11) = TMS(2,NLSGC(M+MCS))
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            SBFW(NCS+11+MC) = TMC(IGC,2,NLSGC(M+MCS))
            MC = MC + 1
            SBFW(NCS+11+MC) = ZMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(3,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(3,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFW,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post West Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending west ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(4,ID+1)*NPVX
        IDSNDX = NPGC(4,ID+1) - 1
        NRCVX = NCGC(3,IDSNDX+1)*NPVX
        IDRCVX = NPGC(3,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFW,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post West Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,3
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(4,ID+1)
!          IF( ID.EQ.1 )
!     &      PRINT *,'R1: ND(',NLSGC(M+MCR),') = ',ND(NLSGC(M+MCR))
          T(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          PG(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          PN(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          PSO(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          PVA(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          SG(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          SL(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          SN(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          YLS(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          TMS(2,NLSGC(M+MCS)) = RBFW(NCR+1)
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            TMC(IGC,2,NLSGC(M+MCS)) = RBFW(NCR+11+MC)
            MC = MC + 1
            ZMC(IGC,2,NLSGC(M+MCS)) = RBFW(NCR+11+MC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for east ghost cells for processors
!     with east ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,3
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(4,ID+1)
          SBFE(NCS+1) = T(2,NLSGC(M+MCS))
          SBFE(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFE(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFE(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFE(NCS+5) = PSO(2,NLSGC(M+MCS))
          SBFE(NCS+6) = PVA(2,NLSGC(M+MCS))
          SBFE(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFE(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFE(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFE(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFE(NCS+11) = TMS(2,NLSGC(M+MCS))
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            SBFE(NCS+11+MC) = TMC(IGC,2,NLSGC(M+MCS))
            MC = MC + 1
            SBFE(NCS+11+MC) = ZMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(4,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(4,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFE,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post East Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending east ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(3,ID+1)*NPVX
        IDSNDX = NPGC(3,ID+1) - 1
        NRCVX = NCGC(4,IDSNDX+1)*NPVX
        IDRCVX = NPGC(4,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFE,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post East Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,2
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(3,ID+1)
          T(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          PG(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          PN(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          PSO(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          PVA(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          SG(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          SL(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          SN(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          YLS(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          TMS(2,NLSGC(M+MCS)) = RBFE(NCR+1)
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            TMC(IGC,2,NLSGC(M+MCS)) = RBFE(NCR+11+MC)
            MC = MC + 1
            ZMC(IGC,2,NLSGC(M+MCS)) = RBFE(NCR+11+MC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for north ghost cells for processors
!     with north ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,4
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(5,ID+1)
          SBFN(NCS+1) = T(2,NLSGC(M+MCS))
          SBFN(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFN(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFN(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFN(NCS+5) = PSO(2,NLSGC(M+MCS))
          SBFN(NCS+6) = PVA(2,NLSGC(M+MCS))
          SBFN(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFN(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFN(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFN(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFN(NCS+11) = TMS(2,NLSGC(M+MCS))
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            SBFN(NCS+11+MC) = TMC(IGC,2,NLSGC(M+MCS))
            MC = MC + 1
            SBFN(NCS+11+MC) = ZMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(5,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(5,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFN,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post North Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending north ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(2,ID+1)*NPVX
        IDSNDX = NPGC(2,ID+1) - 1
        NRCVX = NCGC(5,IDSNDX+1)*NPVX
        IDRCVX = NPGC(5,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFN,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post North Receive: IERR = ',IERR,' ID = ',ID
        MCR = NCGC(1,ID+1)
!        PRINT *,' MCR = ',MCR,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(2,ID+1)
          T(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          PG(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          PN(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          PSO(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          PVA(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          SG(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          SL(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          SN(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          YLS(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          TMS(2,NLSGC(M+MCS)) = RBFN(NCR+1)
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            TMC(IGC,2,NLSGC(M+MCS)) = RBFN(NCR+11+MC)
            MC = MC + 1
            ZMC(IGC,2,NLSGC(M+MCS)) = RBFN(NCR+11+MC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for top ghost cells for processors
!     with top ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,5
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(6,ID+1)
          SBFT(NCS+1) = T(2,NLSGC(M+MCS))
          SBFT(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFT(NCS+3) = PG(2,NLSGC(M+MCS))
          SBFT(NCS+4) = PN(2,NLSGC(M+MCS))
          SBFT(NCS+5) = PSO(2,NLSGC(M+MCS))
          SBFT(NCS+6) = PVA(2,NLSGC(M+MCS))
          SBFT(NCS+7) = SG(2,NLSGC(M+MCS))
          SBFT(NCS+8) = SL(2,NLSGC(M+MCS))
          SBFT(NCS+9) = SN(2,NLSGC(M+MCS))
          SBFT(NCS+10) = YLS(2,NLSGC(M+MCS))
          SBFT(NCS+11) = TMS(2,NLSGC(M+MCS))
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            SBFT(NCS+11+MC) = TMC(IGC,2,NLSGC(M+MCS))
            MC = MC + 1
            SBFT(NCS+11+MC) = ZMC(IGC,2,NLSGC(M+MCS))
          ENDDO
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(6,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(6,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFT,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Top Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending top ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(1,ID+1)*NPVX
        IDSNDX = NPGC(1,ID+1) - 1
        NRCVX = NCGC(6,IDSNDX+1)*NPVX
        IDRCVX = NPGC(6,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFT,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Top Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
!        PRINT *,' MCR = ',MCR,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(1,ID+1)
          T(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          PL(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          PG(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          PN(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          PSO(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          PVA(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          SG(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          SL(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          SN(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          YLS(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          TMS(2,NLSGC(M+MCS)) = RBFT(NCR+1)
          MC = 0
          DO IGC = 1,NGC+2
            MC = MC + 1
            TMC(IGC,2,NLSGC(M+MCS)) = RBFT(NCR+11+MC)
            MC = MC + 1
            ZMC(IGC,2,NLSGC(M+MCS)) = RBFT(NCR+11+MC)
          ENDDO
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_GC_EOR group
!
      RETURN
      END


