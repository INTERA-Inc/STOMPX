!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CAP_FRC_GT( CPGLX,SLX,NFX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the gas/aqueous capillary pressure from the aqueous
!     saturation for a fracture triangle.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 25 July 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CAP_FRC_GT'
      SLRX = RKSP_FRC(4,NFX)
      ESLX = (SLX-SLRX)/(1.D+0-SLRX)
      CL = MAX( RKSP_FRC(3,NFX),SMALL )
      SMPX = RKSP_FRC(6,NFX)
!
!---  Aqueous saturation below the matching point,
!     use Webb extension  ---
!
      IF( SLX.LT.SMPX ) THEN
        HMPX = RKSP_FRC(7,NFX)
        DMPX = -(LOG10(RKSP_FRC(5,NFX))-LOG10(HMPX))/SMPX
        HDGL = 1.D+1**(DMPX*(SLX-SMPX) + LOG10(HMPX))
!
!---  Aqueous saturation at or above the matching point,
!     use Brooks and Corey function
!
      ELSE
        HDGL = RKSP_FRC(1,NFX)*(1.D+0/ESLX)**(1.D+0/CL)
      ENDIF
      CPGLX = HDGL*RHORL*GRAV
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CAP_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE COMM_FRC_GT( CPGLX,SLX,NFX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Communicate off-processor matrix node parameters to ghost
!     triangles.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 18 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE TRNSPT
      USE TRNS_FRC
      USE SOLTN
      USE PROP_FRC
      USE PROP
      USE GRID
      USE GEOM_FRC
      USE GEO_MECH
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/COMM_FRC_GT'
!
!---  Loop over local fracture triangles  ---
!
      DO NTX = 1,NFT(ID+1)
        N = ITNCM_FRC(NTX)
!
!---    Load local nodal values into local fracture arrays  ---
!
        IF( ITNPM_FRC(NTX).EQ.(ID+1) ) THEN
          PL_TN(NTX) = PL(1,N)
          PG_TN(NTX) = PG(1,N)
          T_TN(NTX) = T(1,N)
          DO K = 1,6
            SIG_GM_TN(K,NTX) = SIG_GM(K,N)
          ENDDO
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of COMM_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE DRCVG_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the gas-phase Darcy flux from pressure gradients
!     and gravitational body forces for fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 22 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 KGM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/DRCVG_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          NF2X = NF_FRC(NT2X)
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
!
!---      Apply fracture-fracture skin factor for inter-fracture
!         connections  ---
!
          SKFX = 0.D+0
          IF( NF2X.NE.NF2X ) THEN
            SKFX = MAX( SKF_FRC(NF2X),SKF_FRC(NF2X) )
          ENDIF
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
            HDGX = PG_FRC(MP,NT1X) - PG_FRC(MN,NT2X) +
     &        5.D-1*GRAV*(ZP_FRC(NT1X)-ZP_FRC(NT2X))*
     &       (RHOG_FRC(MP,NT1X)+RHOG_FRC(MN,NT2X))
            IF( M.EQ.1 ) HDG = HDGX
            INDX = 11
            KGM = DIFMN(PERM_FRC(MP,NT1X),PERM_FRC(MN,NT2X),
     &        DFF1X,DFF2X,HDG,INDX)
            IF( PERM_FRC(MP,NT1X)/EPSL.LT.EPSL ) KGM = 0.D+0
            IF( PERM_FRC(MN,NT2X)/EPSL.LT.EPSL ) KGM = 0.D+0
            INDX = 9
            RKGM = DIFMN(RKG_FRC(MP,NT1X),RKG_FRC(MN,NT2X),
     &        DFF1X,DFF2X,HDG,INDX)
            INDX = 6
            VGM = DIFMN(VISG_FRC(MP,NT1X),VISG_FRC(MN,NT2X),
     &        DFF1X,DFF2X,HDG,INDX)
            UFFG(M,NTC,NT1X) = KGM*RKGM*HDGX/DFF_FRC(NTC,NT1X)/
     &        VGM/(1.D+0+SKFX)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of DRCVG_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE DFFGW_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the water-vapor molar diffusion rates for fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 22 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 KGM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/DFFGW_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
          DXMGW = XMGW_FRC(2,NT1X)*RHOMG_FRC(2,NT1X)-
     &        XMGW_FRC(2,NT2X)*RHOMG_FRC(2,NT2X)
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
            DF1 = SG_FRC(MP,NT1X)*DFGW_FRC(MP,NT1X)
            DF2 = SG_FRC(MN,NT2X)*DFGW_FRC(MN,NT2X)
            INDX = 12
            DFM = DIFMN( DF1,DF2,DFF1X,DFF2X,DXMGW,INDX )
            UFFDGW(M,NTC,NT1X) = (XMGW_FRC(MP,NT1X)*RHOMG_FRC(MP,NT1X)-
     &        XMGW_FRC(MN,NT2X)*RHOMG_FRC(MN,NT2X))*
     &        DFM/DFF_FRC(NTC,NT1X)
            FGW1 = XGW_FRC(MP,NT1X)*RHOG_FRC(MP,NT1X)
            FGW2 = XGW_FRC(MN,NT2X)*RHOG_FRC(MN,NT2X)
            INDX = 3
            FGW = DIFMN( FGW1,FGW2,DFF1X,DFF2X,UFFG(1,NTC,NT1X),INDX )
            UFFGW(M,NTC,NT1X) = UFFG(M,NTC,NT1X)*FGW + 
     &        WTMW*UFFDGW(M,NTC,NT1X)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of DFFGW_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE DFFLA_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the dissolved air molar diffusion rates through the
!     aqueous phase for boreholes and fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 22 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 KGM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/DFFLA_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
          DXMLA = XMLA_FRC(2,NT1X)*RHOML_FRC(2,NT1X)-
     &      XMLA_FRC(2,NT2X)*RHOML_FRC(2,NT2X)
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
            DF1 = SL_FRC(MP,NT1X)*DFLA_FRC(MP,NT1X)
            DF2 = SL_FRC(MN,NT2X)*DFLA_FRC(MN,NT2X)
            INDX = 14
            DFM = DIFMN( DF1,DF2,DFF1X,DFF2X,DXMLA,INDX )
            UFFDLA(M,NTC,NT1X) = (XMLA_FRC(MP,NT1X)*RHOML_FRC(MP,NT1X)-
     &        XMLA_FRC(MN,NT2X)*RHOML_FRC(MN,NT2X))*
     &        DFM/DFF_FRC(NTC,NT1X)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of DFFLA_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE DFFLS_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute salt aqueous-phase fluxes for boreholes and fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 22 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 KGM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/DFFLS_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
!
!---        Diffusion coefficients  ---
!
            IF( IEDLS.EQ.1 ) THEN
              TCOR = (T_FRC(MP,NT1X)+TABS)/TSPRF
              SMDL1 = DFLS_FRC(MP,NT1X)*TCOR*(VISRL/VISL_FRC(MP,NT1X))
              DFC1 = SL_FRC(MP,NT1X)*SMDL1
              TCOR = (T_FRC(MN,NT2X)+TABS)/TSPRF
              SMDL2 = DFLS_FRC(MN,NT2X)*TCOR*(VISRL/VISL_FRC(MN,NT2X))
              DFC2 = SL_FRC(MN,NT2X)*SMDL2
            ELSEIF( IEDLS.EQ.3 ) THEN
              DFC1 = SL_FRC(MP,NT1X)*DFLS_FRC(MP,NT1X)
              DFC2 = SL_FRC(MN,NT2X)*DFLS_FRC(MN,NT2X)
            ENDIF
            INDX = 18
            DFC = DIFMN(DFC1,DFC2,DFF1X,DFF2X,UFFL(1,NTC,NT1X),INDX)
            DDL = DFC/DFF_FRC(NTC,NT1X)
            AL = MAX( UFFL(M,NTC,NT1X),ZERO ) +
     &        DDL*MAX((ONE-(TENTH*ABS(UFFL(M,NTC,NT1X))/
     &        (DDL+SMALL)))**5,ZERO)
            ALP = MAX( -UFFL(M,NTC,NT1X),ZERO ) +
     &        DDL*MAX((ONE-(TENTH*ABS(UFFL(M,NTC,NT1X))/
     &        (DDL+SMALL)))**5,ZERO)
            UFFS(M,NTC,NT1X) = XLS_FRC(MP,NT1X)*RHOL_FRC(MP,NT1X)*AL -
     &        XLS_FRC(MN,NT2X)*RHOL_FRC(MN,NT2X)*ALP
            UFFDS(M,NTC,NT1X) = DDL*(XLS_FRC(MP,NT1X)*RHOL_FRC(MP,NT1X)
     &        - XLS_FRC(MN,NT2X)*RHOL_FRC(MN,NT2X))
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of DFFLS_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE DRCVL_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the aqueous-phase Darcy flux from pressure gradients
!     and gravitational body forces for fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 22 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 KLM
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/DRCVL_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          NF2X = NF_FRC(NT2X)
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
!
!---      Apply fracture-fracture skin factor for inter-fracture
!         connections  ---
!
          SKFX = 0.D+0
          IF( NF2X.NE.NF2X ) THEN
            SKFX = MAX( SKF_FRC(NF2X),SKF_FRC(NF2X) )
          ENDIF
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
            HDLX = PL_FRC(MP,NT1X) - PL_FRC(MN,NT2X) +
     &        5.D-1*GRAV*(ZP_FRC(NT1X)-ZP_FRC(NT2X))*
     &       (RHOL_FRC(MP,NT1X)+RHOL_FRC(MN,NT2X))
            IF( M.EQ.1 ) HDL = HDLX
            INDX = 11
            KLM = DIFMN(PERM_FRC(MP,NT1X),PERM_FRC(MN,NT2X),
     &        DFF1X,DFF2X,HDL,INDX)
            IF( PERM_FRC(MP,NT1X)/EPSL.LT.EPSL ) KLM = 0.D+0
            IF( PERM_FRC(MN,NT2X)/EPSL.LT.EPSL ) KLM = 0.D+0
            INDX = 8
            RKLM = DIFMN(RKL_FRC(MP,NT1X),RKL_FRC(MN,NT2X),
     &        DFF1X,DFF2X,HDL,INDX)
            INDX = 5
            VLM = DIFMN(VISL_FRC(MP,NT1X),VISL_FRC(MN,NT2X),
     &        DFF1X,DFF2X,HDL,INDX)
            UFFL(M,NTC,NT1X) = KLM*RKLM*HDLX/DFF_FRC(NTC,NT1X)/
     &        VLM/(1.D+0+SKFX)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of DRCVL_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE INCRM_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute frature primary variable increments.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 25 July, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE PROP_FRC
      USE HYST
      USE GLB_PAR
      USE GRID
      USE GEOM_FRC
      USE FLUX
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      IF( NFGT(ID+1).EQ.0 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/INCRM_FRC_GT'
      EPSLX = 1.D-4
!
!---  Loop over fracture and ghost triangles  ---
!
      DO NTX = 1,NFGT(ID+1)
        NFX = NF_FRC(NTX)
!
!---    Absolute temperature  ---
!
        TKX = T_FRC(2,NTX) + TABS
!
!---    Saturated system w/o entrapped gas
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas air partial pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
!        PRINT *,'NTX = ',NTX,'TKX = ',TKX,' NPHAZ_FRC(2,NTX) = ',
!     &    NPHAZ_FRC(2,NTX),'ID = ',ID
        IF( NPHAZ_FRC(2,NTX).EQ.1 ) THEN
          PG_FRC(2,NTX) = PL_FRC(2,NTX) + ENPR
          PLX = PL_FRC(2,NTX) + PATM
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
          PWX = MAX( PSWX,PLX )
          CALL SCF_GL( BTGLX,PWX )
          CALL SOL_BRNS( T_FRC(2,NTX),PWX,XLSMX )
          XLSX = MIN( YLS_FRC(2,NTX),XLSMX )
          XLS_FRC(2,NTX) = XLSX
          CALL SP_B( T_FRC(2,NTX),XLSX,PSBX )
          PVBX = PSBX
          PLX = PL_FRC(2,NTX) + PATM
          PGAX = PVA_FRC(2,NTX)
!
!---      Isoair option no transition from aqueous
!         saturated conditions  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            PGX = PVBX + PGAX
          ELSE
            PGX = PLX
          ENDIF
          PX = MAX( PGX,PLX )
          CALL RKSP_FRC_GT( PGX,PLX,RKGX,RKLX,SGX,SLX,NFX )
!
!---      Transition from aqueous saturated conditions to
!         aqueous unsaturated conditions: PC1 -> PC2  ---
!
          IF( SGX.GT.1.D-3 ) THEN
            SGX = 1.D-3
            SLX = 1.D+0 - SGX
            CALL CAP_FRC_GT( CPGL,SLX,NFX )
            PCX = CPGL
            CALL P_IAPWS( T_FRC(2,NTX),PSWX,RHOX,RHOLWX,HGWX,HLWX,
     &        UGWX,ULWX )
            CALL VPL_B( T_FRC(2,NTX),PSWX,PCX,RHOLWX,PVW_FRC(2,NTX) )
            CALL SCF_GL( BTGLX,PVW_FRC(2,NTX) )
            CALL SOL_BRNS( T_FRC(2,NTX),PSWX,XLSMX )
            XLSX = MIN( YLS_FRC(2,NTX),XLSMX )
            XLS_FRC(2,NTX) = XLSX
            CALL DENS_B( XLSX,RHOBX,RHOLWX,T_FRC(2,NTX) )
            CALL SP_B( T_FRC(2,NTX),XLSX,PSBX )
            CALL VPL_B( T_FRC(2,NTX),PSBX,PCX,RHOBX,PVBX )
            PGX = PVBX + PGAX
            PG_FRC(2,NTX) = PGX - PATM
            PL_FRC(2,NTX) = PG_FRC(2,NTX) - CPGL
            NPHAZ_FRC(2,NTX) = 2
!
!---      No transition from aqueous saturated conditions  ---
!
          ELSE
            NPHAZ_FRC(2,NTX) = 1
          ENDIF
!
!---    Unsaturated system
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.2 ) THEN
          PLX = PL_FRC(2,NTX) + PATM
          PGX = PG_FRC(2,NTX) + PATM
          PX = MAX( PGX,PLX )
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
          CALL P_IAPWS( T_FRC(2,NTX),PSWX,RHOGWX,RHOLWX,HGWX,HLWX,
     &      UGWX,ULWX )
          PCX = PGX - PLX
          CALL VPL_B( T_FRC(2,NTX),PSWX,PCX,RHOLWX,PVW_FRC(2,NTX) )
          CALL SCF_GL( BTGLX,PVW_FRC(2,NTX) )
          CALL SOL_BRNS( T_FRC(2,NTX),PSWX,XLSMX )
          XLSX = MIN( YLS_FRC(2,NTX),XLSMX )
          XLS_FRC(2,NTX) = XLSX
          CALL DENS_B( XLSX,RHOBX,RHOLWX,T_FRC(2,NTX) )
          CALL SP_B( T_FRC(2,NTX),XLSX,PSBX )
          CALL VPL_B( T_FRC(2,NTX),PSBX,PCX,RHOBX,PVW_FRC(2,NTX) )
          PGAX = PGX - PVW_FRC(2,NTX)
          CALL RKSP_FRC_GT( PGX,PLX,RKGX,RKLX,SGX,SLX,NFX )
!
!---      Aqueous saturation = 1.0, transition to saturation
!         conditions  ---
!
          IF( ABS(1.D+0-SLX).LT.EPSL ) THEN
            PX = PL_FRC(2,NTX)+PATM
            CALL SP_B( T_FRC(2,NTX),XLSX,PSBX )
            PVBX = PSBX
            PG_FRC(2,NTX) = PL_FRC(2,NTX) + ENPR - EPSLX
            NPHAZ_FRC(2,NTX) = 1
!
!---      No aqueous phase, transition
!         to fully unsaturated condition: PC2 -> PC4  ---
!
          ELSEIF( ( SLX.LT.EPSL .AND. (1.D+0-SL_FRC(1,NTX)).GT.EPSL )
     &      .OR. TKX.GT.TCRW ) THEN
            PGX = PG_FRC(2,NTX) + PATM
            INDX = 0
            CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
            CALL SOL_BRNS( T_FRC(2,NTX),PSWX,XLSMX )
            IF( TMS_FRC(2,NTX).GT.EPSL ) THEN
              XLSX = XLSMX
            ELSE
              XLSX = 0.D+0
            ENDIF
            XLS_FRC(2,NTX) = XLSX
            SL_FRC(2,NTX) = 0.D+0
            CALL CAP_FRC_GT( CPGL,SL_FRC(2,NTX),NFX )
            PL_FRC(2,NTX) = PG_FRC(2,NTX) - PCX
            PLX = PGX - PCX
            CALL SP_B( T_FRC(2,NTX),XLSX,PSBX )
            PX = MAX( PGX,PSBX )
            CALL P_IAPWS( T_FRC(2,NTX),PX,RHOX,RHOLWX,HGWX,HLWX,
     &        UGWX,ULWX )
            CALL DENS_B( XLSX,RHOBX,RHOLWX,T_FRC(2,NTX) )
            PCX = PGX - PLX
            CALL VPL_B( T_FRC(2,NTX),PSBX,PCX,RHOBX,PVW_FRC(2,NTX) )
            PVA_FRC(2,NTX) = PGX - PVW_FRC(2,NTX)
            NPHAZ_FRC(2,NTX) = 4
!
!---      Gas pressure remains above gas-entry pressure, remain
!         as unsaturated condition  ---
!
          ELSE
            NPHAZ_FRC(2,NTX) = 2
          ENDIF
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - gas pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.4 ) THEN
          PGX = PG_FRC(2,NTX) + PATM
!
!---      Maximum salt solubility if aqueous phase existed  ---
!
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
          CALL SOL_BRNS( T_FRC(2,NTX),PSWX,XLSMX )
          IF( TMS_FRC(2,NTX).GT.EPSL ) THEN
            XLSX = XLSMX
          ELSE
            XLSX = 0.D+0
          ENDIF
          XLS_FRC(2,NTX) = XLSX
          PVA_FRC(2,NTX) = PGX - PVW_FRC(2,NTX)
          CALL SCF_GL( BTGLX,PVW_FRC(2,NTX) )
          SL_FRC(2,NTX) = 0.D+0
          CALL CAP_FRC_GT( CPGL,SL_FRC(2,NTX),NFX )
          PL_FRC(2,NTX) = PG_FRC(2,NTX) - PCX
          PLX = PGX - PCX
          CALL P_IAPWS( T_FRC(2,NTX),PVW_FRC(2,NTX),RHOGWX,RHOLWX,
     &      HGWX,HLWX,UGWX,ULWX )
!
!---      Saturated water vapor pressure given temperature and
!         capillary pressure  ---
!
          CALL SP_B( T_FRC(2,NTX),XLSX,PSBX )
          CALL DENS_B( XLSX,RHOBX,RHOLWX,T_FRC(2,NTX) )
          PCX = PGX - PLX
          CALL VPL_B( T_FRC(2,NTX),PSBX,PCX,RHOBX,PVBX )
!
!---      Aqueous phase appears, transition to
!         unsaturated conditions: PC4 -> PC2  ---
!
          IF( PVW_FRC(2,NTX).GT.PSBX .AND. TKX.LE.TCRW ) THEN
            SLX = 1.D-4
            CALL CAP_FRC_GT( CPGL,SLX,NFX )
            PCX = CPGL
            CALL P_IAPWS( T_FRC(2,NTX),PSWX,RHOX,RHOLWX,HX,HLWX,
     &        UX,ULWX )
            CALL VPL_B( T_FRC(2,NTX),PSWX,PCX,RHOLWX,PVWX )
            CALL SCF_GL( BTGLX,PVWX )
            CALL SOL_BRNS( T_FRC(2,NTX),PSWX,XLSMX )
            YLS_FRC(2,NTX) = TMS_FRC(2,NTX)/
     &        (RHOLWX*SLX+TMS_FRC(2,NTX))
            XLSX = MIN( YLS_FRC(2,NTX),XLSMX )
            XLS_FRC(2,NTX) = XLSX
            CALL DENS_B( XLSX,RHOBX,RHOLWX,T_FRC(2,NTX) )
            CALL SP_B( T_FRC(2,NTX),XLSX,PSBX )
            CALL VPL_B( T_FRC(2,NTX),PSBX,PCX,RHOBX,PVBX )
            PGX = PVBX + PVA_FRC(2,NTX)
            PG_FRC(2,NTX) = PGX - PATM
            PL_FRC(2,NTX) = PG_FRC(2,NTX) - CPGL
            NPHAZ_FRC(2,NTX) = 2
!
!---      No aqueous phase, no transition from
!         fully unsaturated condition  ---
!
          ELSE
            NPHAZ_FRC(2,NTX) = 4
          ENDIF
        ENDIF
!
!---    Compute increments  ---
!
!
!---    Saturated system w/o entrapped gas
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - aqueous-air mole fraction
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ_FRC(2,NTX).EQ.1 ) THEN
!
!---      Energy - temperature
!
          DNR_FRC(IEQT,NTX) = -1.D-7
!
!---      Water mass - aqueous pressure
!
          PLX = PL_FRC(2,NTX) + PATM
          DNR_FRC(IEQW,NTX) = MAX( 1.D-4,1.D-12*PLX )
!
!---      Air mass - aqueous-air mole fraction
!
          IF( ISLC(37).EQ.0 ) THEN
            DNR_FRC(IEQA,NTX) = 1.D-1
          ENDIF
!
!---      NaCl mass - total NaCl brine mass fraction
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_BRNS( T_FRC(2,NTX),PLX,XLSMX )
            DNR_FRC(IEQS,NTX) = 1.D-5*XLSMX
          ENDIF
!
!---    Unsaturated system
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.2 ) THEN
!
!---      Energy - temperature
!
          DNR_FRC(IEQT,NTX) = -1.D-7
!
!---      Water mass - aqueous pressure
!
          DNRX = MAX( 1.D-4,1.D-12*ABS(PG_FRC(2,NTX)-PL_FRC(2,NTX)) )
          DNR_FRC(IEQW,NTX) = -DNRX
!
!---      Air mass - gas pressure
!
          IF( ISLC(37).EQ.0 ) THEN
            DNR_FRC(IEQA,NTX) = DNRX
          ENDIF
!
!---      NaCl mass - total NaCl brine mass fraction
!
          IF( ISLC(32).EQ.0 ) THEN
            INDX = 0
            CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
            CALL SOL_BRNS( T_FRC(2,NTX),PSWX,XLSMX )
            DNR_FRC(IEQS,NTX) = 1.D-5*XLSMX
          ENDIF
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - gas pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.4 ) THEN
!
!---      Energy - temperature  ---
!
          DNR_FRC(IEQT,NTX) = -1.D-7
!
!---      Water mass - water vapor partial pressure  ---
!
          DPX = SIGN( MAX( 1.D-4,1.D-6*PVW_FRC(2,NTX) ),
     &      1.D+0-PVW_FRC(2,NTX) )
          DNR_FRC(IEQW,NTX) = DPX
!
!---      Air mass - gas pressure  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            DNR_FRC(IEQA,NTX) = MAX( 1.D-4,1.D-6*PVA_FRC(2,NTX) )
          ENDIF
!
!---      NaCl mass - salt mass  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            DNR_FRC(IEQS,NTX) = 1.D-6
          ENDIF
        ENDIF
!
!---    Increment the primary variables  ---
!
        DO M = 3,ISVC+2
          T_FRC(M,NTX) = T_FRC(2,NTX)
          PL_FRC(M,NTX) = PL_FRC(2,NTX)
          PG_FRC(M,NTX) = PG_FRC(2,NTX)
          PVW_FRC(M,NTX) = PVW_FRC(2,NTX)
          PVA_FRC(M,NTX) = PVA_FRC(2,NTX)
          XMLA_FRC(M,NTX) = XMLA_FRC(2,NTX)
          SG_FRC(M,NTX) = SG_FRC(2,NTX)
          SL_FRC(M,NTX) = SL_FRC(2,NTX)
          YLS_FRC(M,NTX) = YLS_FRC(2,NTX)
          TMS_FRC(M,NTX) = TMS_FRC(2,NTX)
!
!---      Saturated system w/o entrapped gas
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - aqueous-air mole fraction
!         NaCl mass - total NaCl brine mass fraction  ---
!
          IF( NPHAZ_FRC(2,NTX).EQ.1 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T_FRC(M,NTX) = T_FRC(M,NTX) + DNR_FRC(IEQT,NTX)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PL_FRC(M,NTX) = PL_FRC(M,NTX) + DNR_FRC(IEQW,NTX)
              PG_FRC(M,NTX) = PL_FRC(M,NTX) + ENPR - EPSLX
            ELSEIF( M.EQ.IEQA+2 .AND. ISLC(37).EQ.0 ) THEN
!              XMLA_FRC(M,NTX) = XMLA_FRC(M,NTX) + DNR_FRC(IEQA,NTX)
!              PVA_FRC(M,NTX) = PVA_FRC(M,NTX) + DNR_FRC(IEQA,NTX)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS_FRC(M,NTX) = YLS_FRC(M,NTX) + DNR_FRC(IEQS,NTX)
            ENDIF
!
!---      Unsaturated system
!
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - gas pressure
!         NaCl mass - total NaCl brine mass fraction  ---
!
          ELSEIF( NPHAZ_FRC(2,NTX).EQ.2 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T_FRC(M,NTX) = T_FRC(M,NTX) + DNR_FRC(IEQT,NTX)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PL_FRC(M,NTX) = PL_FRC(M,NTX) + DNR_FRC(IEQW,NTX)
            ELSEIF( M.EQ.IEQA+2 .AND. ISLC(37).EQ.0 ) THEN
              PG_FRC(M,NTX) = PG_FRC(M,NTX) + DNR_FRC(IEQA,NTX)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS_FRC(M,NTX) = YLS_FRC(M,NTX) + DNR_FRC(IEQS,NTX)
            ENDIF
!
!---      Fully unsaturated conditions
!
!         Energy - temperature
!         Water mass - water vapor partial pressure
!         Air mass - gas pressure
!         NaCl mass - salt mass  ---
!
          ELSEIF( NPHAZ_FRC(2,NTX).EQ.4 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T_FRC(M,NTX) = T_FRC(M,NTX) + DNR_FRC(IEQT,NTX)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PVW_FRC(M,NTX) = PVW_FRC(M,NTX) + DNR_FRC(IEQW,NTX)
            ELSEIF( M.EQ.IEQA+2 .AND. ISLC(37).EQ.0 ) THEN
              PG_FRC(M,NTX) = PG_FRC(M,NTX) + DNR_FRC(IEQA,NTX)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              TMS_FRC(M,NTX) = TMS_FRC(M,NTX) + DNR_FRC(IEQS,NTX)
            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of INCRM_FRC_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBL_FRC_GT( RSS,RSP,RSA,NT1X,MEQ )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Load the fracture Jacobian matrix
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 24 August 2022.
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FDVP_FRC
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 RSP(LUK),RSA(LUK,3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBL_FRC_GT'
#ifdef lis
!
!---  Lis solver  ---
!
!
!---  Fracture triangle  ---
!
      NMD = (IXP_FRC(NT1X)-1)*ISVC
      IROW = NMD + MEQ
      MA = 0
      DO M = 1,ISVC
        MCOL = KLU_FRC(IROW-IEQ_OFFSET_FRC,M+MA)
        DLU(MCOL) = DLU(MCOL) + (RSP(M)-RSS)/DNR_FRC(M,NT1X)
      ENDDO
      BUFFER = -RSS
      CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &    F_RHS_VEC,IERR )
      RSDL_FRC(MEQ,NT1X) = RSDL_FRC(MEQ,NT1X) - RSS
!
!---  Loop over active fracture triangle connections  ---
!
      DO NTC = 1,3
        NT2X = ITTCM_FRC(NTC,NT1X)
        IF( NT2X.EQ.0 ) CYCLE
        MA = MA + ISVC
        DO M = 1,ISVC
          MCOL = KLU_FRC(IROW-IEQ_OFFSET_FRC,M+MA)
          DLU(MCOL) = DLU(MCOL) + (RSA(M,NTC)-RSS)/DNR_FRC(M,NT2X)
        ENDDO
      ENDDO
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBL_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBA_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Load the Jacobian matrix for the fracture air equation with
!     aqueous-phase and gas-phase contributions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 26 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STAX(LUK+1),RAP(LUK),RAA(LUK,3),FA(LSFV,3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBA_FRC_GT'
!
!---  Loop over fracture triangles (without ghost triangles)  ---
!
      L1:DO NT1X = 1,NFT(ID+1)
        NFX = NF_FRC(NT1X)
!
!---    First-order, forward-difference, time differential  ---
!
        STA1 = (XLA_FRC(1,NT1X)*RHOL_FRC(1,NT1X)*SL_FRC(1,NT1X) +
     &      XGA_FRC(1,NT1X)*RHOG_FRC(1,NT1X)*SG_FRC(1,NT1X))
        DO M = 1,ISVC+1
          MP = M + 1
          STA0 = (XLA_FRC(MP,NT1X)*RHOL_FRC(MP,NT1X)*SL_FRC(MP,NT1X) +
     &      XGA_FRC(MP,NT1X)*RHOG_FRC(MP,NT1X)*SG_FRC(MP,NT1X))
          STAX(M) = (STA0*APM_FRC(MP,NT1X)-STA1*APM_FRC(1,NT1X))*
     &      DTI*AF_FRC(NT1X)
        ENDDO
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
!
!---      Fracture triangle surface fluxes  ---
!
          DO M = 1,ISVF
            INDX = -3
            M1 = MNOD(M)
            M2 = MADJ(M)
            FLA1 = XLA_FRC(M1,NT1X)*RHOL_FRC(M1,NT1X)
            FLA2 = XLA_FRC(M2,NT2X)*RHOL_FRC(M2,NT2X)
            INDX = 2
            FLA = DIFMN( FLA1,FLA2,DFF1X,DFF2X,UFFL(1,NTC,NT1X),INDX )
            FGA1 = XGA_FRC(M1,NT1X)*RHOG_FRC(M1,NT1X)
            FGA2 = XGA_FRC(M2,NT2X)*RHOG_FRC(M2,NT2X)
            INDX = 3
            FGA = DIFMN( FGA1,FGA2,DFF1X,DFF2X,UFFG(1,NTC,NT1X),INDX )
            INDX = -3
            APX = DIFMN( APM_FRC(M1,NT1X),APM_FRC(M2,NT2X),
     &        DFF1X,DFF2X,ZERO,INDX )
            FA(M,NTC) = AFF_FRC(NTC,NT1X)*APX*
     &        (UFFL(M,NTC,NT1X)*FLA + UFFG(M,NTC,NT1X)*FGA
     &        - WTMA*UFFDGA(M,NTC,NT1X) - WTMA*UFFDLA(M,NTC,NT1X))
          ENDDO
        ENDDO
!
!---    Compute fracture triangle energy equation residuals  ---
!
        RAS = STAX(1) - SRCA_FRC(2,NT1X)
        DO MD = 1,3
          NT2X = ITTCM_FRC(MD,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          RAS = RAS + FA(1,MD)
        ENDDO
        DO M = 1,ISVC
          RAP(M) = STAX(M+1) - SRCA_FRC(M+2,NT1X)
          MM = 2*M
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RAP(M) = RAP(M) + FA(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RAA(M,MD) = RAS - FA(1,MD) + FA(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_FRC_GT( RAS,RAP,RAA,NT1X,IEQA )
        IF( NT1X.EQ.1 .AND. ID.EQ.0 ) THEN
          DO M = 1,ISVC
            MM = 2*M + 1
            DO MD = 1,3
              NT2X = ITTCM_FRC(MD,NT1X)
              IF( NT2X.EQ.0 ) CYCLE
            ENDDO
          ENDDO
        ENDIF
      ENDDO L1
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBA_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBS_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Load the Jacobian matrix for the fracture salt equation with
!     aqueous-phase and gas-phase contributions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 26 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STSX(LUK+1),RSP(LUK),RSA(LUK,3),FS(LSFV,3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBS_FRC_GT'
!
!---  Loop over fracture triangles (without ghost triangles)  ---
!
      L1:DO NT1X = 1,NFT(ID+1)
        NFX = NF_FRC(NT1X)
!
!---    First-order, forward-difference, time differential  ---
!
        DO M = 1,ISVC+1
          MP = M + 1
          STSX(M) = (TMS_FRC(MP,NT1X)*APM_FRC(MP,NT1X)-
     &      TMS_FRC(1,NT1X)*APM_FRC(1,NT1X))*DTI*AF_FRC(NT1X)
        ENDDO
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
!
!---      Fracture triangle surface fluxes  ---
!
          DO M = 1,ISVF
            INDX = -3
            M1 = MNOD(M)
            M2 = MADJ(M)
            INDX = -3
            APX = DIFMN( APM_FRC(M1,NT1X),APM_FRC(M2,NT2X),
     &        DFF1X,DFF2X,ZERO,INDX )
            FS(M,NTC) = AFF_FRC(NTC,NT1X)*APX*UFFS(M,NTC,NT1X)
          ENDDO
        ENDDO
!
!---    Compute fracture triangle energy equation residuals  ---
!
        RSS = STSX(1) - SRCS_FRC(2,NT1X)
        DO MD = 1,3
          NT2X = ITTCM_FRC(MD,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          RSS = RSS + FS(1,MD)
        ENDDO
        DO M = 1,ISVC
          RSP(M) = STSX(M+1) - SRCS_FRC(M+2,NT1X)
          MM = 2*M
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RSP(M) = RSP(M) + FS(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RSA(M,MD) = RSS - FS(1,MD) + FS(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_FRC_GT( RSS,RSP,RSA,NT1X,IEQS )
      ENDDO L1
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBS_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBT_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Load the Jacobian matrix for the fracture energy equation with
!     aqueous-phase and gas-phase contributions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 24 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STTX(LUK+1),RTP(LUK),RTA(LUK,3),FT(LSFV,3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBT_FRC_GT'
!
!---  Loop over fracture triangles (without ghost triangles)  ---
!
      L1:DO NT1X = 1,NFT(ID+1)
        NFX = NF_FRC(NT1X)
!
!---    First-order, forward-difference, time differential  ---
!
        STT1 = SS_FRC(1,NT1X)*RHOSP_FRC(1,NT1X)*HSP_FRC(1,NT1X) +
     &    SL_FRC(1,NT1X)*RHOL_FRC(1,NT1X)*HL_FRC(1,NT1X) +
     &    SG_FRC(1,NT1X)*RHOG_FRC(1,NT1X)*UEG_FRC(1,NT1X) +
     &    DTHCP_FRC(NFX)*AF_FRC(NT1X)*THCP_FRC(NT1X)*T_FRC(1,NT1X)
        DO M = 1,ISVC+1
          MP = M + 1
          STT0 = SS_FRC(MP,NT1X)*RHOSP_FRC(MP,NT1X)*HSP_FRC(MP,NT1X) +
     &      SL_FRC(MP,NT1X)*RHOL_FRC(MP,NT1X)*HL_FRC(MP,NT1X) +
     &      SG_FRC(MP,NT1X)*RHOG_FRC(MP,NT1X)*UEG_FRC(MP,NT1X) +
     &      DTHCP_FRC(NFX)*AF_FRC(NT1X)*THCP_FRC(NT1X)*T_FRC(MP,NT1X)
          STTX(M) = (STT0*APM_FRC(MP,NT1X)-STT1*APM_FRC(1,NT1X))*
     &      DTI*AF_FRC(NT1X)
        ENDDO
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
!
!---      Fracture triangle surface fluxes  ---
!
          DO M = 1,ISVF
            INDX = -3
            M1 = MNOD(M)
            M2 = MADJ(M)
            APX = DIFMN( APM_FRC(M1,NT1X),APM_FRC(M2,NT2X),
     &        DFF1X,DFF2X,ZERO,INDX )
            FT(M,NTC) = AFF_FRC(NTC,NT1X)*APX*UFFQ(M,NTC,NT1X)
          ENDDO
        ENDDO
!
!---    Compute fracture triangle energy equation residuals  ---
!
        RTS = STTX(1) - SRCT_FRC(2,NT1X)
        DO MD = 1,3
          NT2X = ITTCM_FRC(MD,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          RTS = RTS + FT(1,MD)
        ENDDO
        DO M = 1,ISVC
          RTP(M) = STTX(M+1) - SRCT_FRC(M+2,NT1X)
          MM = 2*M
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RTP(M) = RTP(M) + FT(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RTA(M,MD) = RTS - FT(1,MD) + FT(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_FRC_GT( RTS,RTP,RTA,NT1X,IEQT )
      ENDDO L1
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBT_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBW_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Load the Jacobian matrix for the fracture water equation with
!     aqueous-phase and gas-phase contributions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 26 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 STWX(LUK+1),RWP(LUK),RWA(LUK,3),FW(LSFV,3)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBW_FRC_GT'
!
!---  Loop over fracture triangles (without ghost triangles)  ---
!
      L1:DO NT1X = 1,NFT(ID+1)
        NFX = NF_FRC(NT1X)
!
!---    First-order, forward-difference, time differential  ---
!
        STW1 = (XLW_FRC(1,NT1X)*RHOL_FRC(1,NT1X)*SL_FRC(1,NT1X) +
     &      XGW_FRC(1,NT1X)*RHOG_FRC(1,NT1X)*SG_FRC(1,NT1X))
        DO M = 1,ISVC+1
          MP = M + 1
          STW0 = (XLW_FRC(MP,NT1X)*RHOL_FRC(MP,NT1X)*SL_FRC(MP,NT1X) +
     &      XGW_FRC(MP,NT1X)*RHOG_FRC(MP,NT1X)*SG_FRC(MP,NT1X))
          STWX(M) = (STW0*APM_FRC(MP,NT1X)-STW1*APM_FRC(1,NT1X))*
     &      DTI*AF_FRC(NT1X)
        ENDDO
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
!
!---      Fracture triangle surface fluxes  ---
!
          DO M = 1,ISVF
            INDX = -3
            M1 = MNOD(M)
            M2 = MADJ(M)
            FLW1 = XLW_FRC(M1,NT1X)*RHOL_FRC(M1,NT1X)
            FLW2 = XLW_FRC(M2,NT2X)*RHOL_FRC(M2,NT2X)
            INDX = 2
            FLW = DIFMN( FLW1,FLW2,DFF1X,DFF2X,UFFL(1,NTC,NT1X),INDX )
            FGW1 = XGW_FRC(M1,NT1X)*RHOG_FRC(M1,NT1X)
            FGW2 = XGW_FRC(M2,NT2X)*RHOG_FRC(M2,NT2X)
            INDX = 3
            FGW = DIFMN( FGW1,FGW2,DFF1X,DFF2X,UFFG(1,NTC,NT1X),INDX )
            INDX = -3
            APX = DIFMN( APM_FRC(M1,NT1X),APM_FRC(M2,NT2X),
     &        DFF1X,DFF2X,ZERO,INDX )
            FW(M,NTC) = AFF_FRC(NTC,NT1X)*APX*
     &        (UFFL(M,NTC,NT1X)*FLW + UFFG(M,NTC,NT1X)*FGW
     &        + WTMW*UFFDGW(M,NTC,NT1X) - WTMW*UFFDLA(M,NTC,NT1X)
     &        - WTMW*UFFDS(M,NTC,NT1X))
          ENDDO
        ENDDO
!
!---    Compute fracture triangle energy equation residuals  ---
!
        RWS = STWX(1) - SRCW_FRC(2,NT1X)
        DO MD = 1,3
          NT2X = ITTCM_FRC(MD,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          RWS = RWS + FW(1,MD)
        ENDDO
        DO M = 1,ISVC
          RWP(M) = STWX(M+1) - SRCW_FRC(M+2,NT1X)
          MM = 2*M
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RWP(M) = RWP(M) + FW(MM,MD)
          ENDDO
        ENDDO
        DO M = 1,ISVC
          MM = 2*M + 1
          DO MD = 1,3
            NT2X = ITTCM_FRC(MD,NT1X)
            IF( NT2X.EQ.0 ) CYCLE
            RWA(M,MD) = RWS - FW(1,MD) + FW(MM,MD)
          ENDDO
        ENDDO
!
!---    Load Jacobian Matrix  ---
!
        CALL JCBL_FRC_GT( RWS,RWP,RWA,NT1X,IEQW )
      ENDDO L1
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBW_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBA_MFB_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Modify Jacobian matrix for matrix grid cells,
!     fracture triangles, and borehole nodes for transfer of air mass
!     between matrix grid cells and fracture triangles and
!     borehole nodes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 26 August 2022.
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBA_MFB_GT'
#ifdef lis
!
!---  Lis solver  ---
!
!
!---  Matrix equations, fracture connections, loop over local nodes,
!     skipping inactive and ghost cells  ---
!
      L1:DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        IROW = NMD + IEQA
!
!---    Check for connection with fracture triangle(s), with
!       multiple connections possible  ---
!
        IF( INTP_FRC(1,N).NE.0 ) THEN
          DO NT = INTP_FRC(1,N),INTP_FRC(2,N)
            NTX = INTCM_FRC(NT)
            NMDF = (IXP_FRC(NTX)-1)*ISVC
!
!---        Field node, noting that TRNSA_FRC is positive
!           from the fracture triangle to the field node  ---
!
            DO M = 1,ISVC
              IF( ISLC(38).EQ.1 .AND. M.NE.IEQA ) CYCLE
!
!---          Partial derivative of energy residual with
!             respect to field node primary variables  ---
!
              MCOL = KLU(NMD+IEQA-IEQ_OFFSET,M)
              MX = 2*M
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSA_FRC(1,NTX)-TRNSA_FRC(MX,NTX))/DNR(M,N)
!
!---          Partial derivative of energy residual with
!             respect to fracture triangle primary variables  ---
!
              MCOL = KLU_MCF(NMDF+IEQA-IEQ_OFFSET_FRC,M)
              MX = 2*M + 1
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSA_FRC(1,NTX)-TRNSA_FRC(MX,NTX))/DNR_FRC(M,NTX)
            ENDDO
            BUFFER = TRNSA_FRC(1,NTX)
            CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &        F_RHS_VEC,IERR )
            RSDL(IEQA,N) = RSDL(IEQA,N) + BUFFER
          ENDDO
        ENDIF
      ENDDO L1
!
!---  Fracture equations, loop over fracture triangles, skipping
!     ghost triangles  ---
!
      DO NTX = 1,NFT(ID+1)
        NMD_FRC = (IXP_FRC(NTX)-1)*ISVC
        IROW = NMD_FRC + IEQA
!
!---    Matrix node connected to fracture triangle  ---
!
        N = ITNCM_FRC(NTX)
        DO M = 1,ISVC
!
!---      Partial derivative of air mass residual with
!         respect to fracture triangle primary variables  ---
!
          MCOL = KLU_FRC(NMD_FRC+IEQA-IEQ_OFFSET_FRC,M)
          MX = 2*M + 1
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSA_FRC(MX,NTX)-TRNSA_FRC(1,NTX))/DNR_FRC(M,NTX)
!
!---      Partial derivative of air mass residual with
!             respect to field node primary variables  ---
!
          MCOL = KLU_FCM(NMD_FRC+IEQA-IEQ_OFFSET_FRC,M)
          MX = 2*M
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSA_FRC(MX,NTX)-TRNSA_FRC(1,NTX))/DNR(M,N)
        ENDDO
        BUFFER = -TRNSA_FRC(1,NTX)
        CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &    F_RHS_VEC,IERR )
        RSDL_FRC(IEQA,NTX) = RSDL_FRC(IEQA,NTX) + BUFFER
      ENDDO
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBA_MFB_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBS_MFB_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Modify Jacobian matrix for matrix grid cells,
!     fracture triangles, and borehole nodes for transfer of salt mass
!     between matrix grid cells and fracture triangles and
!     borehole nodes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 26 August 2022.
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBS_MFB_GT'
#ifdef lis
!
!---  Lis solver  ---
!
!
!---  Matrix equations, fracture connections, loop over local nodes,
!     skipping inactive and ghost cells  ---
!
      L1:DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        IROW = NMD + IEQS
!
!---    Check for connection with fracture triangle(s), with
!       multiple connections possible  ---
!
        IF( INTP_FRC(1,N).NE.0 ) THEN
          DO NT = INTP_FRC(1,N),INTP_FRC(2,N)
            NTX = INTCM_FRC(NT)
            NMDF = (IXP_FRC(NTX)-1)*ISVC
!
!---        Field node, noting that TRNSS_FRC is positive
!           from the fracture triangle to the field node  ---
!
            DO M = 1,ISVC
              IF( ISLC(38).EQ.1 .AND. M.NE.IEQS ) CYCLE
!
!---          Partial derivative of energy residual with
!             respect to field node primary variables  ---
!
              MCOL = KLU(NMD+IEQS-IEQ_OFFSET,M)
              MX = 2*M
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSS_FRC(1,NTX)-TRNSS_FRC(MX,NTX))/DNR(M,N)
!
!---          Partial derivative of energy residual with
!             respect to fracture triangle primary variables  ---
!
              MCOL = KLU_MCF(NMDF+IEQS-IEQ_OFFSET_FRC,M)
              MX = 2*M + 1
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSS_FRC(1,NTX)-TRNSS_FRC(MX,NTX))/DNR_FRC(M,NTX)
            ENDDO
            BUFFER = TRNSS_FRC(1,NTX)
            CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &        F_RHS_VEC,IERR )
            RSDL(IEQS,N) = RSDL(IEQS,N) + BUFFER
          ENDDO
        ENDIF
      ENDDO L1
!
!---  Fracture equations, loop over fracture triangles, skipping
!     ghost triangles  ---
!
      DO NTX = 1,NFT(ID+1)
        NMD_FRC = (IXP_FRC(NTX)-1)*ISVC
        IROW = NMD_FRC + IEQS
!
!---    Matrix node connected to fracture triangle  ---
!
        N = ITNCM_FRC(NTX)
        DO M = 1,ISVC
!
!---      Partial derivative of air mass residual with
!         respect to fracture triangle primary variables  ---
!
          MCOL = KLU_FRC(NMD_FRC+IEQS-IEQ_OFFSET_FRC,M)
          MX = 2*M + 1
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSS_FRC(MX,NTX)-TRNSS_FRC(1,NTX))/DNR_FRC(M,NTX)
!
!---      Partial derivative of air mass residual with
!             respect to field node primary variables  ---
!
          MCOL = KLU_FCM(NMD_FRC+IEQS-IEQ_OFFSET_FRC,M)
          MX = 2*M
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSS_FRC(MX,NTX)-TRNSS_FRC(1,NTX))/DNR(M,N)
        ENDDO
        BUFFER = -TRNSS_FRC(1,NTX)
        CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &    F_RHS_VEC,IERR )
        RSDL_FRC(IEQS,NTX) = RSDL_FRC(IEQS,NTX) + BUFFER
      ENDDO
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBS_MFB_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBT_MFB_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Modify Jacobian matrix for matrix grid cells,
!     fracture triangles, and borehole nodes for transfer of energy
!     between matrix grid cells and fracture triangles and
!     borehole nodes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 25 August 2022.
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBT_MFB_GT'
#ifdef lis
!
!---  Lis solver  ---
!
!
!---  Matrix equations, fracture connections, loop over local nodes,
!     skipping inactive and ghost cells  ---
!
      L1:DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        IROW = NMD + IEQT
!
!---    Check for connection with fracture triangle(s), with
!       multiple connections possible  ---
!
        IF( INTP_FRC(1,N).NE.0 ) THEN
          DO NT = INTP_FRC(1,N),INTP_FRC(2,N)
            NTX = INTCM_FRC(NT)
            NMDF = (IXP_FRC(NTX)-1)*ISVC
!
!---        Field node, noting that TRNSQ_FRC is positive
!           from the fracture triangle to the field node  ---
!
            DO M = 1,ISVC
              IF( ISLC(38).EQ.1 .AND. M.NE.IEQT ) CYCLE
!
!---          Partial derivative of energy residual with
!             respect to field node primary variables  ---
!
              MCOL = KLU(NMD+IEQT-IEQ_OFFSET,M)
              MX = 2*M
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSQ_FRC(1,NTX)-TRNSQ_FRC(MX,NTX))/DNR(M,N)
!
!---          Partial derivative of energy residual with
!             respect to fracture triangle primary variables  ---
!
              MCOL = KLU_MCF(NMDF+IEQT-IEQ_OFFSET_FRC,M)
              MX = 2*M + 1
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSQ_FRC(1,NTX)-TRNSQ_FRC(MX,NTX))/DNR_FRC(M,NTX)
            ENDDO
            BUFFER = TRNSQ_FRC(1,NTX)
            CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &        F_RHS_VEC,IERR )
            RSDL(IEQT,N) = RSDL(IEQT,N) + BUFFER
          ENDDO
        ENDIF
      ENDDO L1
!
!---  Fracture equations, loop over fracture triangles, skipping
!     ghost triangles  ---
!
      DO NTX = 1,NFT(ID+1)
        NMD_FRC = (IXP_FRC(NTX)-1)*ISVC
        IROW = NMD_FRC + IEQT
!
!---    Matrix node connected to fracture triangle  ---
!
        N = ITNCM_FRC(NTX)
        DO M = 1,ISVC
!
!---      Partial derivative of air mass residual with
!         respect to fracture triangle primary variables  ---
!
          MCOL = KLU_FRC(NMD_FRC+IEQT-IEQ_OFFSET_FRC,M)
          MX = 2*M + 1
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSQ_FRC(MX,NTX)-TRNSQ_FRC(1,NTX))/DNR_FRC(M,NTX)
!
!---      Partial derivative of air mass residual with
!         respect to field node primary variables  ---
!
          MCOL = KLU_FCM(NMD_FRC+IEQT-IEQ_OFFSET_FRC,M)
          MX = 2*M
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSQ_FRC(MX,NTX)-TRNSQ_FRC(1,NTX))/DNR(M,N)
        ENDDO
        BUFFER = -TRNSQ_FRC(1,NTX)
        CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &    F_RHS_VEC,IERR )
        RSDL_FRC(IEQT,NTX) = RSDL_FRC(IEQT,NTX) + BUFFER
      ENDDO
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBT_MFB_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE JCBW_MFB_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Modify Jacobian matrix for matrix grid cells,
!     fracture triangles, and borehole nodes for transfer of water mass
!     between matrix grid cells and fracture triangles and
!     borehole nodes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 26 August 2022.
!
#ifdef lis
!----------------------LIS Modules-------------------------------------!
!
      USE LIS_STOMP
!
#endif
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE JACOB
      USE JACOB_FRC
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/JCBW_MFB_GT'
#ifdef lis
!
!---  Lis solver  ---
!
!
!---  Matrix equations, fracture connections, loop over local nodes,
!     skipping inactive and ghost cells  ---
!
      L1:DO N = 1,NFCGC(ID+1)
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        NMD = (IXP(N)-1)*ISVC
        IROW = NMD + IEQW
!
!---    Check for connection with fracture triangle(s), with
!       multiple connections possible  ---
!
        IF( INTP_FRC(1,N).NE.0 ) THEN
          DO NT = INTP_FRC(1,N),INTP_FRC(2,N)
            NTX = INTCM_FRC(NT)
            NMDF = (IXP_FRC(NTX)-1)*ISVC
!
!---        Field node, noting that TRNSW_FRC is positive
!           from the fracture triangle to the field node  ---
!
            DO M = 1,ISVC
              IF( ISLC(38).EQ.1 .AND. M.NE.IEQW ) CYCLE
!
!---          Partial derivative of energy residual with
!             respect to field node primary variables  ---
!
              MCOL = KLU(NMD+IEQW-IEQ_OFFSET,M)
              MX = 2*M
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSW_FRC(1,NTX)-TRNSW_FRC(MX,NTX))/DNR(M,N)
!
!---          Partial derivative of energy residual with
!             respect to fracture triangle primary variables  ---
!
              MCOL = KLU_MCF(NMDF+IEQW-IEQ_OFFSET_FRC,M)
              MX = 2*M + 1
              DLU(MCOL) = DLU(MCOL) +
     &          (TRNSW_FRC(1,NTX)-TRNSW_FRC(MX,NTX))/DNR_FRC(M,NTX)
            ENDDO
            BUFFER = TRNSW_FRC(1,NTX)
            CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &        F_RHS_VEC,IERR )
            RSDL(IEQW,N) = RSDL(IEQW,N) + BUFFER
          ENDDO
        ENDIF
      ENDDO L1
!
!---  Fracture equations, loop over fracture triangles, skipping
!     ghost triangles  ---
!
      DO NTX = 1,NFT(ID+1)
        NMD_FRC = (IXP_FRC(NTX)-1)*ISVC
        IROW = NMD_FRC + IEQW
!
!---    Matrix node connected to fracture triangle  ---
!
        N = ITNCM_FRC(NTX)
        DO M = 1,ISVC
!
!---      Partial derivative of air mass residual with
!         respect to fracture triangle primary variables  ---
!
          MCOL = KLU_FRC(NMD_FRC+IEQW-IEQ_OFFSET_FRC,M)
          MX = 2*M + 1
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSW_FRC(MX,NTX)-TRNSW_FRC(1,NTX))/DNR_FRC(M,NTX)
!
!---      Partial derivative of air mass residual with
!             respect to field node primary variables  ---
!
          MCOL = KLU_FCM(NMD_FRC+IEQW-IEQ_OFFSET_FRC,M)
          MX = 2*M
          DLU(MCOL) = DLU(MCOL) +
     &      (TRNSW_FRC(MX,NTX)-TRNSW_FRC(1,NTX))/DNR(M,N)
        ENDDO
        BUFFER = -TRNSW_FRC(1,NTX)
        CALL LIS_VECTOR_SET_VALUE( LIS_ADD_VALUE,IROW,BUFFER,
     &    F_RHS_VEC,IERR )
        RSDL_FRC(IEQW,NTX) = RSDL_FRC(IEQW,NTX) + BUFFER
      ENDDO
#endif
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of JCBW_MFB_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LDO_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Load the current time step values into the old time step
!     variables for fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 22 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TRNS_FRC
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE GRID
      USE GEOM_FRC
      USE FDVP_FRC
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LDO_FRC_GT'
!
!---  Loop over fracture and ghost triangles  ---
!
      DO NTX = 1,NFGT(ID+1)
        NFX = NF_FRC(NTX)
        APH_FRC(1,NTX) = APH_FRC(2,NTX)
        APM_FRC(1,NTX) = APM_FRC(2,NTX)
        T_FRC(1,NTX) = T_FRC(2,NTX)
        PL_FRC(1,NTX) = PL_FRC(2,NTX)
        PG_FRC(1,NTX) = PG_FRC(2,NTX)
        SL_FRC(1,NTX) = SL_FRC(2,NTX)
        SG_FRC(1,NTX) = SG_FRC(2,NTX)
        PVA_FRC(1,NTX) = PVA_FRC(2,NTX)
        PVW_FRC(1,NTX) = PVW_FRC(2,NTX)
        XGA_FRC(1,NTX) = XGA_FRC(2,NTX)
        XGW_FRC(1,NTX) = XGW_FRC(2,NTX)
        XMGA_FRC(1,NTX) = XMGA_FRC(2,NTX)
        XMGW_FRC(1,NTX) = XMGW_FRC(2,NTX)
        XLA_FRC(1,NTX) = XLA_FRC(2,NTX)
        XLW_FRC(1,NTX) = XLW_FRC(2,NTX)
        XMLA_FRC(1,NTX) = XMLA_FRC(2,NTX)
        XMLW_FRC(1,NTX) = XMLW_FRC(2,NTX)
        RHOL_FRC(1,NTX) = RHOL_FRC(2,NTX)
        RHOG_FRC(1,NTX) = RHOG_FRC(2,NTX)
        RHOSP_FRC(1,NTX) = RHOSP_FRC(2,NTX)
        VISL_FRC(1,NTX) = VISL_FRC(2,NTX)
        VISG_FRC(1,NTX) = VISG_FRC(2,NTX)
        RKL_FRC(1,NTX) = RKL_FRC(2,NTX)
        RKG_FRC(1,NTX) = RKG_FRC(2,NTX)
        DFGW_FRC(1,NTX) = DFGW_FRC(2,NTX)
        DFLA_FRC(1,NTX) = DFLA_FRC(2,NTX)
        THKG_FRC(1,NTX) = THKG_FRC(2,NTX)
        THKL_FRC(1,NTX) = THKL_FRC(2,NTX)
        HL_FRC(1,NTX) = HL_FRC(2,NTX)
        HGW_FRC(1,NTX) = HGW_FRC(2,NTX)
        HGA_FRC(1,NTX) = HGA_FRC(2,NTX)
        HG_FRC(1,NTX) = HG_FRC(2,NTX)
        UEG_FRC(1,NTX) = UEG_FRC(2,NTX)
        HSP_FRC(1,NTX) = HSP_FRC(2,NTX)
        NPHAZ_FRC(1,NTX) = NPHAZ_FRC(2,NTX)
        SS_FRC(1,NTX) = SS_FRC(2,NTX)
        TMS_FRC(1,NTX) = TMS_FRC(2,NTX)
        XLS_FRC(1,NTX) = XLS_FRC(2,NTX)
        YLS_FRC(1,NTX) = YLS_FRC(2,NTX)
        DO NSL = 1,NSOLU
          CO_FRC(NTX,NSL) = C_FRC(NTX,NSL)
        ENDDO
#ifdef ecke
        DO NEQ = 1,NEQC+NEQK
          NSL = NEQ + NSOLU
          CO_FRC(NTX,NSL) = C_FRC(NTX,NSL)
        ENDDO
        DO NSP = 1,NSPR
          SP_CO_FRC(NTX,NSP) = SP_C_FRC(NTX,NSP)
        ENDDO
#endif
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LDO_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE PROP_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute hydrologic, thermodynamic and physical properties for
!     fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 11 August, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE PROP_FRC
      USE HYST
      USE GLB_PAR
      USE GRID
      USE GEOM_FRC
      USE FDVP
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 DFEFX(5)
      REAL*8, DIMENSION(3,3) :: SIGX
      REAL*8, DIMENSION(1) :: SIGNX
      REAL*8, DIMENSION(3) :: VCX
      REAL*8, DIMENSION(4) :: PROP_GMX
      REAL*8 KNX
!
!----------------------Executable Lines--------------------------------!
!
      IF( NFGT(ID+1).EQ.0 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/PROP_FRC_GT'
!
!---  Loop over fracture triangles (including ghost triangles)  ---
!
      L1:DO NTX = 1,NFGT(ID+1)
        NFX = NF_FRC(NTX)
!
!---    Assign gas entry pressure and minimum gas saturation
!       for transition to unsaturated conditions  ---
!
        ENPR = RKSP_FRC(1,NFX)*RHORL*GRAV
!
!---    Skip inactive triangles  ---
!
        IF( IXP_FRC(NTX).EQ.0 ) CYCLE
#ifdef ecke
        POR0_FRC(1,NTX) = POR0_FRC(1,NTX)
        POR0_FRC(2,NTX) = POR0_FRC(2,NTX)
#endif
!
!---    Loop over increment indices  ---
!
        DO M = 2,ISVC+2
          PLX = PL_FRC(M,NTX)+PATM
          PGX = PG_FRC(M,NTX)+PATM
          INDX = 0
          CALL REGION_4( T_FRC(M,NTX),PSW_FRC(M,NTX),INDX )
!
!---      Saturated system w/o entrapped gas
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - aqueous-air mole fraction
!         NaCl mass - total NaCl brine mass fraction  ---
!
          IF( NPHAZ_FRC(2,NTX).EQ.1 ) THEN
            PX = PLX
            PWX = PLX
            PCX = 0.D+0
            SL_FRC(M,NTX) = 1.D+0
            CALL SOL_BRNS( T_FRC(M,NTX),PWX,XLSMX )
            XLS_FRC(M,NTX) = MIN(YLS_FRC(M,NTX),XLSMX)
            CALL SP_B( T_FRC(M,NTX),XLS_FRC(M,NTX),PSBX )
            CALL P_IAPWS( T_FRC(M,NTX),PWX,RHOGWX,RHOLWX,HGWX,HLWX,
     &        UGWX,ULWX )
            CALL DENS_B( XLS_FRC(M,NTX),RHOBX,RHOLWX,T_FRC(M,NTX) )
            PVBX = PSBX
!            PVA_FRC(M,NTX) = XMLA_FRC(M,NTX)*HCAW
            XMLA_FRC(M,NTX) = PVA_FRC(M,NTX)/HCAW
            PVW_FRC(M,NTX) = PVBX
            XMGA_FRC(M,NTX) = PVA_FRC(M,NTX)/
     &        (PVA_FRC(M,NTX)+PVW_FRC(M,NTX))
            CALL EQUIL( XGA_FRC(M,NTX),XGW_FRC(M,NTX),XLA_FRC(M,NTX),
     &        XLS_FRC(M,NTX),XLW_FRC(M,NTX),XMGA_FRC(M,NTX),
     &        XMGW_FRC(M,NTX),XMLA_FRC(M,NTX),XMLS_FRC(M,NTX),
     &        XMLW_FRC(M,NTX) )
!
!---      Unsaturated system w/ or w/o entrapped gas
!
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - gas pressure
!         NaCl mass - total NaCl brine mass fraction  ---
!
          ELSEIF( NPHAZ_FRC(2,NTX).EQ.2 ) THEN
            PX = PG_FRC(M,NTX) + PATM
            CALL P_IAPWS( T_FRC(M,NTX),PSW_FRC(M,NTX),RHOX,RHOLWX,
     &        HX,HLWX,UX,ULWX )
            PCX = PG_FRC(M,NTX)-PL_FRC(M,NTX)
            CALL VPL_B( T_FRC(M,NTX),PSW_FRC(M,NTX),PCX,RHOLWX,PVWX )
            CALL SOL_BRNS( T_FRC(M,NTX),PSW_FRC(M,NTX),XLSMX )
            XLS_FRC(M,NTX) = MIN(YLS_FRC(M,NTX),XLSMX)
            CALL DENS_B( XLS_FRC(M,NTX),RHOBX,RHOLWX,T_FRC(M,NTX) )
            CALL SP_B( T_FRC(M,NTX),XLS_FRC(M,NTX),PSBX )
            CALL VPL_B( T_FRC(M,NTX),PSBX,PCX,RHOBX,PVBX )
            CALL P_IAPWS( T_FRC(M,NTX),PVBX,RHOGWX,RHOX,HGWX,HX,
     &        UGWX,UX )
            PVA_FRC(M,NTX) = PGX-PVBX
            IF( PVA_FRC(M,NTX).LT.1.D-6 ) PVA_FRC(M,NTX) = 0.D+0
            PVW_FRC(M,NTX) = PVBX
            XMLA_FRC(M,NTX) = PVA_FRC(M,NTX)/HCAW
            XMGA_FRC(M,NTX) = PVA_FRC(M,NTX)/PGX
            CALL EQUIL( XGA_FRC(M,NTX),XGW_FRC(M,NTX),XLA_FRC(M,NTX),
     &        XLS_FRC(M,NTX),XLW_FRC(M,NTX),XMGA_FRC(M,NTX),
     &        XMGW_FRC(M,NTX),XMLA_FRC(M,NTX),XMLS_FRC(M,NTX),
     &        XMLW_FRC(M,NTX) )
!
!---      Fully unsaturated conditions
!
!         Energy - temperature
!         Water mass - water vapor partial pressure
!         Air mass - gas pressure
!         NaCl mass - salt mass  ---
!
          ELSEIF( NPHAZ_FRC(2,NTX).EQ.4 ) THEN
            PGX = PG_FRC(M,NTX) + PATM
            PX = PGX
            INDX = 0
            CALL REGION_4( T_FRC(M,NTX),PSW_FRC(M,NTX),INDX )
            CALL SOL_BRNS( T_FRC(M,NTX),PSW_FRC(M,NTX),XLSMX )
            IF( TMS_FRC(M,NTX).GT.EPSL ) THEN
              XLS_FRC(M,NTX) = XLSMX
            ELSE
              XLS_FRC(M,NTX) = 0.D+0
            ENDIF
            PVA_FRC(M,NTX) = PGX - PVW_FRC(M,NTX)
            SL_FRC(M,NTX) = 0.D+0
            CALL CAP_FRC_GT( CPGLX,SL_FRC(M,NTX),NFX )
            PL_FRC(M,NTX) = PG_FRC(M,NTX) - PCX
            PLX = PGX - PCX
            CALL P_IAPWS( T_FRC(M,NTX),PVW_FRC(M,NTX),RHOGWX,RHOLWX,
     &        HGWX,HLWX,UGWX,ULWX )
            CALL DENS_B( XLS_FRC(M,NTX),RHOBX,RHOLWX,T_FRC(M,NTX) )
            XMLA_FRC(M,NTX) = PVA_FRC(M,NTX)/HCAW
            XMGA_FRC(M,NTX) = PVA_FRC(M,NTX)/PGX
            CALL EQUIL( XGA_FRC(M,NTX),XGW_FRC(M,NTX),XLA_FRC(M,NTX),
     &        XLS_FRC(M,NTX),XLW_FRC(M,NTX),XMGA_FRC(M,NTX),
     &        XMGW_FRC(M,NTX),XMLA_FRC(M,NTX),XMLS_FRC(M,NTX),
     &        XMLW_FRC(M,NTX) )
          ENDIF
!
!---      Constant fracture aperture model  ---
!
          IF( IJM_FRC(NFX).EQ.0 ) THEN
            APM_FRC(M,NTX) = MAX( JRC_FRC(NTX),1.D-9 )
            APH_FRC(M,NTX) = MAX( JRC_FRC(NTX),1.D-12 )
!            IF( M.EQ.2 ) THEN
!!
!!---          Fracture triangle only connected to one grid cell  ---
!!
!              SIGX(1,1) = SIG_GM_FRC(1,NTX)
!              SIGX(1,2) = SIG_GM_FRC(6,NTX)
!              SIGX(1,3) = SIG_GM_FRC(5,NTX)
!              SIGX(2,1) = SIG_GM_FRC(6,NTX)
!              SIGX(2,2) = SIG_GM_FRC(2,NTX)
!              SIGX(2,3) = SIG_GM_FRC(4,NTX)
!              SIGX(3,1) = SIG_GM_FRC(5,NTX)
!              SIGX(3,2) = SIG_GM_FRC(4,NTX)
!              SIGX(3,3) = SIG_GM_FRC(3,NTX)
!              CYCLE L1
!              DO I = 1,4
!                PROP_GMX(I) = PROP_GM_FRC(I,NTX)
!              ENDDO
!!
!!---          DPN_FRC(NTX) and DTN_FRC(NTX) need to be computed from
!!             values of matrix nodal pressure and temperature,
!!             including for ghost triangles with connections to
!!             matrix nodes that might not be ghost nodes  ---
!!
!              DELTAPX = DPN_FRC(NTX)
!              DELTATX = DTN_FRC(NTX)
!            ENDIF
!!
!!---        Normal stress (Pa) on fracture triangle, where
!!           fracture triangle normal vector has been aligned
!!           with the local stress vector via the rotation matrix
!!           ROTMAT defined through the Grid Rotation Card  ---
!!
!            CALL MATMUL( SIGN_FRC(1,NTX),SIGX,VCX,1,3,3 )
!            CALL MATMUL( VCX,SIGN_FRC(1,NTX),SIGNX(1),1,3,1 )
!            SIG_NMX = SIGNX(1)
!!
!!---        Poroelasticity  ---
!!
!            POROX = PROP_GMX(3)*DELTAPX
!!
!!---        Bulk modulus times 3  ---
!!
!            BLK3X = PROP_GMX(1)/(1.D+0-2.D+0*PROP_GMX(2))
!!
!!---        Thermoelasticity  ---
!!
!            THERMOX = PROP_GMX(4)*DELTATX/BLK3X
!!
!!---        Net normal pressure on fracture surfaces, MPa  ---
!!
!            PN_FRC(M,NTX) = PX - SIG_NMX - POROX - THERMOX - PATM
!
!---      Barton-Bandis Joint Model  ---
!
          ELSEIF( IJM_FRC(NFX).GE.1 .AND. IJM_FRC(NFX).LE.3 ) THEN
!
!---        Initial joint aperture (mm), eqn. (5),
!           Rock Mech Rock Eng. (2016) 49:837-853  ---
!
            AJX = 2.D-1*JRC_FRC(NTX)*(2.D-1*UCS_FRC(NTX)/
     &        JCS_FRC(NTX) - 1.D-1)
!
!---        Maximum joint closure (mm), eqn. (4),
!           Rock Mech Rock Eng.(2016) 49:837-853, using joint
!           compressive strength in untis of MPa  ---
!
            CSJX = 1.D-6*JCS_FRC(NTX)
            VMX = -2.96D-1 - 5.6D-3*JRC_FRC(NTX) +
     &        2.241D+0*((CSJX/AJX)**(-2.45D-1))
!
!---        Normal stifness (MPa/mm), eqn. (3), Rock Mech Rock Eng.
!           (2016) 49:837-853, using joint compressive strength
!           in untis of MPa  ---
!
            SNX = 1.78D-2*(CSJX/AJX) + 1.748D+0*JRC_FRC(NTX)
     &        - 7.155D+0
!
!---        Total normal stress (Pa) on the fracture  ---
!
            SIG_NMX = SQRT((SIGN_FRC(1,NTX)**2) + 
     &        (SIGN_FRC(2,NTX)**2) + (SIGN_FRC(3,NTX)**2))
!
!---        Effective normal stress (MPa) on the fracture  ---
!
            ESIGNX = 1.D-6*(SIG_NMX-PX)
!
!---        Mechanical aperture (micron)  ---
!
            APMX = 1.D+3*MAX(AJX-(VMX*ESIGNX/(VMX*SNX+ESIGNX)),0.D+0)
!
!---        Hydraulic aperture (micron), eqn. 7, International Journal
!           of Rock Mechanics & Mining Sciences 38 (2001) 317329  ---
!
            APHX = MIN( (APMX**2)/(JRC_FRC(NTX)**2.5D+0),APMX )
!
!---        Mechanical and hydraulic aperture (m)  ---
!
            APM_FRC(M,NTX) = MAX( 1.D-6*APMX,1.D-9 )
            APH_FRC(M,NTX) = MAX( 1.D-6*APHX,1.D-12 )
!
!---      Dynamic Sneddon-Barton-Bandis Joint Model  ---
!
!          ELSEIF( IJM_FRC(NFX).EQ.11 ) THEN
!            IF( M.EQ.2 ) THEN
!!
!!---          Fracture triangle only connected to one grid cell  ---
!!
!              SIGX(1,1) = SIG_GM_FRC(1,NTX)
!              SIGX(1,2) = SIG_GM_FRC(6,NTX)
!              SIGX(1,3) = SIG_GM_FRC(5,NTX)
!              SIGX(2,1) = SIG_GM_FRC(6,NTX)
!              SIGX(2,2) = SIG_GM_FRC(2,NTX)
!              SIGX(2,3) = SIG_GM_FRC(4,NTX)
!              SIGX(3,1) = SIG_GM_FRC(5,NTX)
!              SIGX(3,2) = SIG_GM_FRC(4,NTX)
!              SIGX(3,3) = SIG_GM_FRC(3,NTX)
!              DO I = 1,4
!                PROP_GMX(I) = PROP_GM_FRC(I,NTX)
!              ENDDO
!!
!!---          DPN_FRC(NTX) and DTN_FRC(NTX) need to be computed from
!!             values of matrix nodal pressure and temperature,
!!             including for ghost triangles with connections to
!!             matrix nodes that might not be ghost nodes  ---
!!
!              DELTAPX = DPN_FRC(NTX)
!              DELTATX = DTN_FRC(NTX)
!            ENDIF
!!
!!---        Normal stress (Pa) on fracture triangle, where
!!           fracture triangle normal vector has been aligned
!!           with the local stress vector via the rotation matrix
!!           ROTMAT defined through the Grid Rotation Card  ---
!!
!            CALL MATMUL( SIGN_FRC(1,NTX),SIGX,VCX,1,3,3 )
!            CALL MATMUL( VCX,SIGN_FRC(1,NTX),SIGNX(1),1,3,1 )
!            SIG_NMX = SIGNX(1)
!!
!!---        Poroelasticity  ---
!!
!            POROX = PROP_GMX(3)*DELTAPX
!!
!!---        Bulk modulus times 3  ---
!!
!            BLK3X = PROP_GMX(1)/(1.D+0-2.D+0*PROP_GMX(2))
!!
!!---        Thermoelasticity  ---
!!
!            THERMOX = PROP_GMX(4)*DELTATX/BLK3X
!!
!!---        Net normal pressure on fracture surfaces, MPa  ---
!!
!            PN_FRC(M,NTX) = PX - SIG_NMX - POROX - THERMOX - PATM
!            SNX = 1.D-6*(PX - SIG_NMX - POROX - THERMOX)
!!
!!---        Aperture at zero net pressure, mm  ---
!!
!            BMAX = 1.D+3*DSBB_FRC(1,NFX)
!!
!!---        Young's modulus, MPa  ---
!!
!            YGMX = 1.D-6*PROP_GMX(1)
!!
!!---        Poisson's ratio  ---
!!
!            PRX = PROP_GMX(2)
!!
!!---        Fracture toughness, MPa/mm  ---
!!
!            KNX = 1.D-9*DSBB_FRC(2,NFX)
!!
!!---        Sneddon radius, mm  ---
!!
!            SRX = 1.D+3*JRC_FRC(NTX)
!!
!!---        Sneddon fractional radius, mm  ---
!!
!            SFRX = SRX*JCS_FRC(NTX)
!!
!!---        Sneddon radial scaling factor  ---
!!
!            SRSFX = SQRT(SRX**2-SFRX**2)
!!
!!---        Sigmoid function parameters  ---
!!     
!            PAX = 0.D+0
!            PBX = 1.D+0
!            STFX = 1.D+0/(1.D+0 + EXP(-(SNX-PAX)/PBX))
!!
!!---        Closure displacement  ---
!!     
!!            UNCX = MIN( MAX( SRSFX*(SNX*BMAX)/(SNX-BMAX*KNX)/SRX,
!!     &          0.D+0 ),BMAX )
!            UNCX = MIN( MAX( (SNX*BMAX)/(SNX-BMAX*KNX),
!     &        0.D+0 ),BMAX )
!!
!!---        Closure aperture  ---
!!     
!            BCX = BMAX - UNCX
!!
!!---        Opening displacement  ---
!!     
!            UNOX = MAX( 8.D+0*(1.D+0-(PRX**2))*SNX*SRSFX/(GPI*YGMX),
!     &        0.D+0 )
!!
!!---        Opening aperture  ---
!!     
!            BOX = BMAX + UNOX
!!
!!---        Model mechanical aperture, mm  ---
!!
!            APMX = (STFX*BOX + (1.D+0-STFX)*BCX)
!!
!!---        Model hydraulic aperture, mm  ---
!!
!            APHX = (STFX*BOX + (1.D+0-STFX)*BCX*SRSFX/SRX)
!!
!!---        Mechanical and hydraulic aperture, m  ---
!!
!            APM_FRC(M,NTX) = MAX( 1.D-3*APMX,1.D-12 )
!            APH_FRC(M,NTX) = MAX( 1.D-3*APHX,1.D-12 )
          ENDIF
!
!---      Fracture permeability  ---
!
          PORD_FRC(M,NTX) = 1.D+0
          PERM_FRC(M,NTX) = (APH_FRC(M,NTX)**2)/12.D+0
!
!---      Saturation, relative permeability  ---
!
          CALL RKSP_FRC_GT( PG_FRC(M,NTX),PL_FRC(M,NTX),
     &      RKG_FRC(M,NTX),RKL_FRC(M,NTX),SG_FRC(M,NTX),
     &      SL_FRC(M,NTX),NFX )
!
!---      Gas density and component fractions  ---
!
          CALL AIRGSD( T_FRC(M,NTX),PVA_FRC(M,NTX),RHOGAX )
          RHOG_FRC(M,NTX) = XGA_FRC(M,NTX)*RHOGAX +
     &      XGW_FRC(M,NTX)*RHOGWX
          WTMGX = XMGA_FRC(M,NTX)*WTMA + XMGW_FRC(M,NTX)*WTMW
          RHOMG_FRC(M,NTX) = RHOG_FRC(M,NTX)/WTMGX
!
!---      Gas viscosity  ---
!
          CALL AIRGSV( T_FRC(M,NTX),VISGAX )
          CALL VISC_W( T_FRC(M,NTX),PVBX,RHOGWX,VISGWX )
          CALL VISC_G( VISGAX,VISGWX,XMGA_FRC(M,NTX),XMGW_FRC(M,NTX),
     &      VISG_FRC(M,NTX) )
!
!---      Aqueous density and molar density  ---
!
          RHOL_FRC(M,NTX) = RHOBX
          WTMLX = XMLA_FRC(M,NTX)*WTMA + XMLS_FRC(M,NTX)*WTMS +
     &      XMLW_FRC(M,NTX)*WTMW
          RHOML_FRC(M,NTX) = RHOL_FRC(M,NTX)/WTMLX
!
!---      Aqueous viscosity  ---
!
          CALL VISC_W( T_FRC(M,NTX),PX,RHOLWX,VISLWX )
          CALL VISC_B( T_FRC(M,NTX),XLS_FRC(M,NTX),VISLWX,VISBX )
          CALL VISC_L( XMLA_FRC(M,NTX),VISBX,VISGAX,VISL_FRC(M,NTX) )
!
!---      Gas-water diffusion coefficients  ---
!
          IF( ISLC(2).EQ.1 ) THEN
            DFGW_FRC(M,NTX) = DFGWC
          ELSEIF( ISLC(2).EQ.2 ) THEN
            CALL BNDFAW( T_FRC(M,NTX),PGX,DFGW_FRC(M,NTX) )
          ELSEIF( ISLC(2).EQ.3 ) THEN
            CALL BNDFAW( T_FRC(M,NTX),PGX,DFGW_FRC(M,NTX) )
            CMFF = 1.D+0 + 2.6D+0/(DFGWC**0.5)
            AMC = SL_FRC(M,NTX)
            ENHF = 9.5D+0 + 6.D+0*(AMC) -
     &        8.5D+0/EXP((CMFF*AMC)**4)
            DFGW_FRC(M,NTX) = ENHF*DFGW_FRC(M,NTX)
          ELSEIF( ISLC(2).EQ.4 ) THEN
            CALL BNDFAW( T_FRC(M,NTX),PGX,DFGW_FRC(M,NTX) )
            DFEFX(1) = 9.5D+0
            DFEFX(2) = 2.0D+0
            DFEFX(3) = 8.0D+0
            DFEFX(4) = 0.5D+0
            DFEFX(5) = 3.0D+0
            ENHF = DFEFX(1)+DFEFX(2)*SL_FRC(M,NTX)-
     &        (DFEFX(1)-DFEFX(4))
     &        *EXP(-((DFEFX(3)*SL_FRC(M,NTX))**DFEFX(5)))
            DFGW_FRC(M,NTX) = ENHF*DFGW_FRC(M,NTX)
          ENDIF
!
!---      Aqueous-air diffusion coefficients  ---
!
          IF( ISLC(4).EQ.1 ) THEN
           DFLA_FRC(M,NTX) = DFLAC
          ELSEIF( ISLC(4).EQ.2 ) THEN
           CALL AIRDFL( T_FRC(M,NTX),VISL_FRC(M,NTX),DFLA_FRC(M,NTX) )
          ENDIF
!
!---      Aqueous-salt diffusion coefficient  ---
!
          IF( ISLC(4).EQ.1 ) THEN
            DFLS_FRC(M,NTX) = DFLSC
          ELSEIF( ISLC(4).EQ.2 ) THEN
            CALL DIFC_LS( T_FRC(M,NTX),XLS_FRC(M,NTX),VISL_FRC(M,NTX),
     &        DFLS_FRC(M,NTX) )
          ENDIF
!
!---      Precipitated NaCl density and saturation  ---
!
          CALL DENS_S( T_FRC(M,NTX),PX,RHOSP_FRC(M,NTX) )
!
!---      Fully unsaturated system w/ or w/o entrapped gas
!         Water mass - aqueous saturation
!         air mass - gas pressure
!         NaCl mass - total NaCl brine mass fraction  ---
!
          IF( NPHAZ_FRC(2,NTX).EQ.4 ) THEN
            SS_FRC(M,NTX) = TMS_FRC(M,NTX)/RHOSP_FRC(M,NTX)
            SLX = EPSL
            YLS_FRC(M,NTX) = TMS_FRC(M,NTX)*RHOBX*SLX
          ELSE
!
!---        Precipitated salt saturation  ---
!
            SS_FRC(M,NTX) = MAX(YLS_FRC(M,NTX)-XLSMX,0.D+0)*RHOBX*
     &        SL_FRC(M,NTX)/RHOSP_FRC(M,NTX)
!
!---        NaCl volumetric concentration  ---
!
            TMS_FRC(M,NTX) = YLS_FRC(M,NTX)*RHOBX*SL_FRC(M,NTX)
          ENDIF
!
!---      Nonisothermal simulation  ---
!
          IF( ISLC(30).EQ.0 ) THEN
!
!---        Gas enthalpy and internal energy  ---
!
            CALL AIRGSH( T_FRC(M,NTX),PVA_FRC(M,NTX),HGA_FRC(M,NTX),
     &        UEGAX )
            UEG_FRC(M,NTX) = XGA_FRC(M,NTX)*UEGAX+XGW_FRC(M,NTX)*UGWX
            HGW_FRC(M,NTX) = HGWX
            HG_FRC(M,NTX) = XGA_FRC(M,NTX)*HGA_FRC(M,NTX) +
     &        XGW_FRC(M,NTX)*HGW_FRC(M,NTX)
!
!---        Gas thermal conductivity  ---
!
            CALL AIRGSK( T_FRC(M,NTX),THKGAX )
            CALL THK_W( T_FRC(M,NTX),PGX,RHOGWX,THKGWX )
            CALL THK_G( T_FRC(M,NTX),THKGAX,THKGWX,XMGA_FRC(M,NTX),
     &        XMGW_FRC(M,NTX),THKG_FRC(M,NTX) )
!
!---        Aqueous enthalpy and internal energy  ---
!
            CALL ENTH_B( T_FRC(M,NTX),XLS_FRC(M,NTX),HLWX,HBX )
            HL_FRC(M,NTX) = MAX(1.D+0-XLA_FRC(M,NTX),0.D+0)*HBX +
     &        XLA_FRC(M,NTX)*HGA_FRC(M,NTX)
!
!---        Aqueous thermal conductivity  ---
!
            CALL THK_W( T_FRC(M,NTX),PX,RHOLWX,THKLWX )
            CALL THK_B( T_FRC(M,NTX),XLS_FRC(M,NTX),THKLWX,
     &        THKL_FRC(M,NTX) )
!
!---        Precipitated NaCl enthalpy  ---
!
            CALL ENTH_S( T_FRC(M,NTX),HSP_FRC(M,NTX) )
          ENDIF
        ENDDO
        VOL_FRC(NTX) = AF_FRC(NTX)*APM_FRC(2,NTX)
      ENDDO L1
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of PROP_FRC_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_FBIN_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary fracture.bin file.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 20 July, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE JACOB
      USE GRID
      USE GLB_PAR
      USE GEOM_FRC
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER IVARX(10)
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_FBIN_GT'
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
!
!---  Open input.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'fracture.bin',MPI_MODE_RDONLY,
     &  MPI_INFO_NULL,IFRD,IERR )
!
!---  Read fracture.bin for grid data  ---
!
      CALL READ_FGRID_GT
!      PRINT *,'Post READ_FGRID_GT: ID = ',ID
!
!---  Read fracture.bin for property data  ---
!
      CALL READ_FPROP_GT
!      PRINT *,'Post READ_FPROP_GT: ID = ',ID
!
!---  Read fracture.bin for state condition data  ---
!
      CALL READ_FSTATE_GT
!      PRINT *,'Post READ_FSTATE_GT: ID = ',ID
!
!---  Close fracture.bin file  ---
!
      CALL MPI_FILE_CLOSE( IFRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_FBIN_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_FGRID_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary fracture.bin file for grid data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 20 July, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE GRID
      USE GLB_PAR
      USE GEOM_FRC
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER IVARX(10)
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_FGRID_GT'
!
!---  Allocate memory for NFGT, number of fracture triangles and ghost
!     triangles on each processor  ---
!
      ALLOCATE( NFGT(1:NP),STAT=ISTAT )
      CHMSG = 'NFGT'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NFT, number of fracture triangles on each
!     processor  ---
!
      ALLOCATE( NFT(1:NP),STAT=ISTAT )
      CHMSG = 'NFT'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NGT, number of ghost triangles on each
!     processor  ---
!
      ALLOCATE( NGT(1:NP),STAT=ISTAT )
      CHMSG = 'NGT'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NCSGT_FRC, number of ghost triangles sent 
!     from processor NPS  ---
!
      ALLOCATE( NCSGT_FRC(1:NP),STAT=ISTAT )
      CHMSG = 'NCSGT_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NCRGT_FRC, number of ghost triangles 
!     received by processor NPR  ---
!
      ALLOCATE( NCRGT_FRC(1:NP),STAT=ISTAT )
      CHMSG = 'NCRGT_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NFGT array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NFGT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      MFGT_G = 0
      NFGT_G = 0
      DO N = 1,NP
        MFGT_G = MFGT_G + MAX(1,NFGT(N))
        NFGT_G = NFGT_G + NFGT(N)
      ENDDO
!
!---  Read NFT array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NFT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      MFT_G = 0
      NFT_G = 0
      DO N = 1,NP
        MFT_G = MFT_G + MAX(1,NFT(N))
        NFT_G = NFT_G + NFT(N)
      ENDDO
!
!---  Read NGT array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NGT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      MGT_G = 0
      NGT_G = 0
      DO N = 1,NP
        MGT_G = MGT_G + MAX(1,NGT(N))
        NGT_G = NGT_G + NGT(N)
      ENDDO
!
!---  Read NCSGT_FRC array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NCSGT_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read NCRGT_FRC array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NCRGT_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for NDSGT_FRC and NPSGT_FRC local fracture 
!     triangle number being sent to other processors and processor
!     number  ---
!
      NCS = NCSGT_FRC(ID+1)
      NCS_G = 0
      DO NPSX = 1,NP
        NCS_G = NCS_G + NCSGT_FRC(NPSX)
      ENDDO
!      PRINT *,'NCS = ',NCS,'ID = ',ID
!      PRINT *,'NCS_G = ',NCS_G,'ID = ',ID
      ALLOCATE( NDSGT_FRC(1:NCS),STAT=ISTAT )
      CHMSG = 'NDSGT_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( NPSGT_FRC(1:NCS),STAT=ISTAT )
      CHMSG = 'NPSGT_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Set local starting point for local copies of NDSGT_FRC and 
!     NPSGT_FRC local fracture triangle number
!     being sent to other processors and processor number  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NCSGT_FRC(I)
      ENDDO
!      PRINT *,'NC = ',NC,'ID = ',ID
!
!---  Read local copies of NDSGT_FRC array  ---
!
      NVAR = NCS
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NCS_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NDSGT_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of NPSGT_FRC array  ---
!
      NVAR = NCS
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NCS_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NPSGT_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'NPSGT_FRC(1) = ',NPSGT_FRC(1),'ID = ',ID
!
!---  Allocate memory for NDRGT_FRC and NPRGT local fracture 
!     triangle number being received from other processors
!     and processor number  ---
!
      NCR = NCRGT_FRC(ID+1)
      NCR_G = 0
      DO NPRX = 1,NP
        NCR_G = NCR_G + NCRGT_FRC(NPRX)
      ENDDO
!      PRINT *,'NCR = ',NCR,'ID = ',ID
!      PRINT *,'NCR_G = ',NCR_G,'ID = ',ID
      ALLOCATE( NDRGT_FRC(1:NCR),STAT=ISTAT )
      CHMSG = 'NDRGT_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( NPRGT_FRC(1:NCR),STAT=ISTAT )
      CHMSG = 'NPRGT_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Set local starting point for local copies of NDRGT_FRC and
!     NPRGT_FRC local fracture triangle number
!     being received from other processors and processor number  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NCRGT_FRC(I)
      ENDDO
!      PRINT *,'NC = ',NC,'ID = ',ID
!
!---  Read local copies of NDRGT_FRC array  ---
!
      NVAR = NCR
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NCR_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NDRGT_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of NPRGT_FRC array  ---
!
      NVAR = NCR
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NCR_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NPRGT_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'NPRGT_FRC(1) = ',NPRGT_FRC(1),'ID = ',ID
!
!---  Allocate memory for fracture geometry arrays 
!     (including ghost triangles)  ---
!
      CALL ALLOC_GEOM_FRC
      CALL INTLZ_GEOM_FRC
!
!---  Allocate memory for local array storage on triangles of 
!     nodal variables (including ghost triangles)  ---
!
      CALL ALLOC_TRNS_FRC
      CALL INTLZ_TRNS_FRC
!
!---  Allocate memory for local array storage on triangles of 
!     flux variables (without ghost triangles)  ---
!
      CALL ALLOC_FLUX_FRC
      CALL INTLZ_FLUX_FRC
!
!---  Set local starting point for local copies of fracture
!     triangle variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + MAX(1,NFT(I))
      ENDDO
!      PRINT *,'NFT(ID+1) = ',NFT(ID+1),'ID = ',ID
!
!---  Read local copies of ITTCM_FRC array (without ghost triangles)  ---
!
      NVAR = 3*MAX(1,NFT(ID+1))
      OFFSET = IOFFSET + NBYTB + 3*NC*NBYTI
      IOFFSET = IOFFSET + 3*MFT_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,ITTCM_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      DO M = 1,MAX(1,NFT(ID+1))
!        PRINT *,'ITTCM_FRC(1,',M,') = ',ITTCM_FRC(1,M),
!     &    'ITTCM_FRC(2,',M,') = ',ITTCM_FRC(2,M),
!     &    'ITTCM_FRC(3,',M,') = ',ITTCM_FRC(3,M),'ID = ',ID
!      ENDDO
!
!---  Read local copies of AFF_FRC array (without ghost triangles)  ---
!
      NVAR = 3*MAX(1,NFT(ID+1))
      OFFSET = IOFFSET + NBYTB + 3*NC*NBYTR
      IOFFSET = IOFFSET + 3*MFT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,AFF_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'AFF_FRC(1,1) = ',AFF_FRC(1,1),'ID = ',ID
!
!---  Read local copies of DFF_FRC array (without ghost triangles)  ---
!
      NVAR = 3*MAX(1,NFT(ID+1))
      OFFSET = IOFFSET + NBYTB + 3*NC*NBYTR
      IOFFSET = IOFFSET + 3*MFT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,DFF_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'DFF_FRC(1,1) = ',DFF_FRC(1,1),'ID = ',ID
!
!---  Read local copies of DFFM_FRC array (without ghost triangles)  ---
!
      NVAR = 3*MAX(1,NFT(ID+1))
      OFFSET = IOFFSET + NBYTB + 3*NC*NBYTR
      IOFFSET = IOFFSET + 3*MFT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,DFFM_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'DFFM_FRC(1,1) = ',DFFM_FRC(1,1),'ID = ',ID
!
!---  Set local starting point for local copies of fracture/ghost
!     triangle variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + MAX(1,NFGT(I))
      ENDDO
!
!---  Read local copies of ITNCM_FRC array 
!     (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + MFGT_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,ITNCM_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of ITNPM_FRC array 
!     (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + MFGT_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,ITNPM_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of IXP_FRC array 
!     (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + MFGT_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,IXP_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'IXP_FRC(1) = ',IXP_FRC(1),'ID = ',ID
!
!---  Read local copies of ND_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + MFGT_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,ND_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'ND_FRC(1) = ',ND_FRC(1),'ID = ',ID
!
!---  Read local copies of NF_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + MFGT_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,NF_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'NF_FRC(1) = ',NF_FRC(1),'ID = ',ID
!
!---  Read local copies of XP_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,XP_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'XP_FRC(1) = ',XP_FRC(1),'ID = ',ID
!
!---  Read local copies of YP_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,YP_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'YP_FRC(1) = ',YP_FRC(1),'ID = ',ID
!
!---  Read local copies of ZP_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,ZP_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'ZP_FRC(1) = ',ZP_FRC(1),'ID = ',ID
!
!---  Read local copies of AF_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,AF_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'AF_FRC(1) = ',AF_FRC(1),'ID = ',ID
!
!---  Read local copies of AFN_FRC array 
!     (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,AFN_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'AFN_FRC(1) = ',AFN_FRC(1),'ID = ',ID
!
!---  Read local copies of SFNT_FRC array 
!     (including ghost triangles)  ---
!
      NVAR = 3*MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + 3*NC*NBYTR
      IOFFSET = IOFFSET + 3*MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,SFNT_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'SFNT_FRC(1,1) = ',SFNT_FRC(1,1),
!     &  'SFNT_FRC(2,1) = ',SFNT_FRC(2,1),
!     &  'SFNT_FRC(3,1) = ',SFNT_FRC(3,1),'ID = ',ID
!
!---  Read local copies of DFN_FRC array 
!     (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,DFN_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'DFN_FRC(1) = ',DFN_FRC(1),'ID = ',ID
!
!---  Create a matrix node to fracture triangle map, using a pointer
!     array and indexing array, with both matrix node and fracture
!     triangle indices being local (skipping ghost matrix cells,
!     ghost fracture triangles), and setting pointers to zero
!     for no matrix node to fracture triangle connection(s)  ---
!
!      PRINT *,'NFCGC(ID+1) = ',NFCGC(ID+1),'NFT(ID+1) = ',NFT(ID+1),
!     &  'ID = ',ID
      NC = 0
      DO N = 1,NFCGC(ID+1)
        INTP_FRC(1,N) = 0
        INTP_FRC(2,N) = 0
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
!
!---    Loop over local fracture triangles, 
!       skipping ghost triangles  ---
!
        IFIND = 0
        DO NTX = 1,NFT(ID+1)
          IF( ITNCM_FRC(NTX).EQ.N ) THEN
            NC = NC + 1
            INTCM_FRC(NC) = NTX
            IF( IFIND.EQ.0 ) INTP_FRC(1,N) = NC
            IFIND = 1
          ENDIF
        ENDDO
        IF( IFIND.EQ.1 ) INTP_FRC(2,N) = NC
      ENDDO
!
!---  Determine size of sending and receiving buffers
!     for ghost triangle updating  ---
!
      NPVX = 20
      LCSX = 1
      LCRX = 1
!
!---  Loop over receiving processors  ---
!
      IF( NPSGT_FRC(1).GT.0 ) THEN
        DO NPRX = 1,NP
          NCS = 0
          DO M = 1,NCSGT_FRC(ID+1)
            NTX = NDSGT_FRC(M)
            NPX = NPSGT_FRC(M)
            IF( NPRX.EQ.NPX ) THEN
              NCS = NCS + NPVX
            ENDIF
          ENDDO
          LCSX = MAX( NCS,LCSX )
        ENDDO
      ENDIF
!
!---  Loop over sending processors  ---
!
      IF( NPRGT_FRC(1).GT.0 ) THEN
        DO NPSX = 1,NP
          NCR = 0
          DO M = 1,NCRGT_FRC(ID+1)
            NTX = NDRGT_FRC(M)
            NPX = NPRGT_FRC(M)
            IF( NPSX.EQ.NPX ) THEN
              NCR = NCR + NPVX
            ENDIF
          ENDDO
          LCRX = MAX( NCR,LCRX )
        ENDDO
      ENDIF
!
!---  Allocate memory for sending and receiving buffers for
!     ghost triangle updating  ---
!
!      PRINT *,'LCSX = ',LCSX,'LCRX = ',LCRX,'ID = ',ID
      ALLOCATE( SBF_FRC(1:LCSX),STAT=ISTAT )
      CHMSG = 'SBF_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( RBF_FRC(1:LCRX),STAT=ISTAT )
      CHMSG = 'RBF_FRC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      DO M = 1,LCSX
        SBF_FRC(M) = 0.D+0
      ENDDO
      DO M = 1,LCRX
        RBF_FRC(M) = 0.D+0
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_FGRID_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_FPROP_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary fracture.bin file for property data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 21 July, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNS_FRC
      USE SOLTN
      USE PROP_FRC
      USE GRID
      USE GLB_PAR
      USE GEOM_FRC
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:,:), ALLOCATABLE :: VARX
      INTEGER IVARX(10)
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_FPROP_GT'
!
!---  Allocate memory for fracture property arrays 
!     (including ghost triangles)  ---
!
      CALL ALLOC_PROP_FRC
      CALL INTLZ_PROP_FRC
!
!---  Allocate temporary memory for loading solute and species
!     transport property data  ---
!
      NFGTX = MAX(1,NFGT(ID+1))
      ALLOCATE( VARX(1:5,1:NFGTX),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Set local starting point for local copies of fracture/ghost
!     triangle variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + MAX(1,NFGT(I))
      ENDDO
!
!---  Read local copies of JRC_FRC array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,JRC_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'JRC_FRC(1) = ',JRC_FRC(1),'ID = ',ID
!
!---  Read local copies of JCS_FRC array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,JCS_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'JCS_FRC(1) = ',JCS_FRC(1),'ID = ',ID
!
!---  Read local copies of UCS_FRC array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,UCS_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'UCS_FRC(1) = ',UCS_FRC(1),'ID = ',ID
!
!---  Read local copies of THCP_FRC array (including ghost triangles)  -
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,THCP_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'THCP_FRC(1) = ',THCP_FRC(1),'ID = ',ID
!
!---  Read DTHCP_FRC array (duplicated across processors)  ---
!
      NVAR = LF_FRC
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,DTHCP_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'DTHCP_FRC(1) = ',DTHCP_FRC(1),'ID = ',ID
!
!---  Read SKF_FRC array (duplicated across processors)  ---
!
      NVAR = LF_FRC
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,SKF_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'SKF_FRC(1) = ',SKF_FRC(1),'ID = ',ID
!
!---  Read RKSP_FRC array (duplicated across processors)  ---
!
      NVAR = 7*LF_FRC
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,RKSP_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'RKSP_FRC(1,1) = ',RKSP_FRC(1,1),'ID = ',ID
!
!---  Read DSBB_FRC array (duplicated across processors)  ---
!
      NVAR = 2*LF_FRC
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,DSBB_FRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'DSBB_FRC(1,1) = ',DSBB_FRC(1,1),'ID = ',ID
!
!---  Read IJM_FRC array (duplicated across processors)  ---
!
      NVAR = LF_FRC
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,IJM_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'IJM_FRC(1) = ',IJM_FRC(1),'ID = ',ID
!
!---  Read local copies of PL_TN array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,PL_TN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'PL_TN(1) = ',PL_TN(1),'ID = ',ID
!
!---  Read local copies of PG_TN array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,PG_TN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'PG_TN(1) = ',PG_TN(1),'ID = ',ID
!
!---  Read local copies of T_TN array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,T_TN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'T_TN(1) = ',T_TN(1),'ID = ',ID
!
!---  Read local copies of SIG_GM_TN array 
!     (including ghost triangles)  ---
!
      NVAR = 6*MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + 6*NC*NBYTR
      IOFFSET = IOFFSET + 6*MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,SIG_GM_TN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'SIG_GM_TN(1,1) = ',SIG_GM_TN(1,1),'ID = ',ID
!
!---  Read local copies of RHOS_TN array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,RHOS_TN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'RHOS_TN(1) = ',RHOS_TN(1),'ID = ',ID
!
!---  Read local copies of POR_TN array 
!     (including ghost triangles)  ---
!
      NVAR = 2*MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + 2*NC*NBYTR
      IOFFSET = IOFFSET + 2*MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,POR_TN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'POR_TN(1,1) = ',POR_TN(1,1),'ID = ',ID
!
!---  Read local copies of PCSL_TN array 
!     (including ghost triangles)  ---
!
      DO L = 1,LSOLU
        NVAR = 5*MAX(1,NFGT(ID+1))
        OFFSET = IOFFSET + NBYTB + 5*NC*NBYTR
        IOFFSET = IOFFSET + 5*MFGT_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO K = 1,MAX(1,NFGT(ID+1))
          DO J = 1,5
            PCSL_TN(J,K,L) = VARX(J,K)
          ENDDO
        ENDDO
      ENDDO
!      PRINT *,'PCSL_TN(1,1,1) = ',PCSL_TN(1,1,1),'ID = ',ID
!      PRINT *,'PCSL_TN(1,1,LSOLU) = ',PCSL_TN(1,1,LSOLU),'ID = ',ID
!
!---  Read local copies of SDCL_TN array 
!     (including ghost triangles)  ---
!
      DO L = 1,LSOLU+LSPT
        NVAR = 3*MAX(1,NFGT(ID+1))
        OFFSET = IOFFSET + NBYTB + 3*NC*NBYTR
        IOFFSET = IOFFSET + 3*MFGT_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO K = 1,MAX(1,NFGT(ID+1))
          DO J = 1,3
            SDCL_TN(J,K,L) = VARX(J,K)
          ENDDO
        ENDDO
      ENDDO
!      PRINT *,'SDCL_TN(1,1,1) = ',SDCL_TN(1,1,1),'ID = ',ID
!      PRINT *,'SDCL_TN(1,1,LSOLU+LSPT) = ',SDCL_TN(1,1,LSOLU+LSPT),
!     &  'ID = ',ID
!
!---  Read local copies of PROP_GM_TN array 
!     (including ghost triangles)  ---
!
      NVAR = 4*MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + 4*NC*NBYTR
      IOFFSET = IOFFSET + 4*MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,PROP_GM_TN,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'PROP_GM_TN(1,1) = ',PROP_GM_TN(1,1),'ID = ',ID
!
!---  Deallocate temporary memory  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_FPROP_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_FSTATE_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary fracture.bin file for state condition data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 21 July, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNS_FRC
      USE SOLTN
      USE GRID
      USE GLB_PAR
      USE GEOM_FRC
      USE FDVP_FRC
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_FSTATE_GT'
!
!---  Allocate memory for fracture state condition arrays 
!     (including ghost triangles)  ---
!
      CALL ALLOC_FDVP_FRC
!      PRINT *,'Post ALLOC_FDVP_FRC: ID = ',ID
      CALL INTLZ_FDVP_FRC
!      PRINT *,'Post INTLZ_FDVP_FRC: ID = ',ID
!
!---  Allocate local temporary state condition arrays
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:MAX(1,NFGT(ID+1))),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:MAX(1,NFGT(ID+1))),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Set local starting point for local copies of fracture/ghost
!     triangle variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + MAX(1,NFGT(I))
      ENDDO
!
!---  Read local copies of T_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        T_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'T_FRC(2,1) = ',T_FRC(2,1),'NFGT(ID+1) = ',NFGT(ID+1),
!     &  'ID = ',ID
!
!---  Read local copies of PL_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        PL_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PL_FRC(2,1) = ',PL_FRC(2,1),'ID = ',ID
!
!---  Read local copies of PG_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        PG_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PG_FRC(2,1) = ',PG_FRC(2,1),'ID = ',ID
!
!---  Read local copies of SG_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        SG_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'SG_FRC(2,1) = ',SG_FRC(2,1),'ID = ',ID
!
!---  Read local copies of SL_FRC array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        SL_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'SL_FRC(2,1) = ',SL_FRC(2,1),'ID = ',ID
!
!---  Read local copies of TMS_FRC array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        TMS_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'TMS_FRC(2,1) = ',TMS_FRC(2,1),'ID = ',ID
!
!---  Read local copies of YLS_FRC array (including ghost triangles)  --
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        YLS_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'YLS_FRC(2,1) = ',YLS_FRC(2,1),'ID = ',ID
!
!---  Read local copies of PVA array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        PVA_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PVA_FRC(2,1) = ',PVA_FRC(2,1),'ID = ',ID
!
!---  Read local copies of PVW array (including ghost triangles)  ---
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        PVW_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PVW_FRC(2,1) = ',PVW_FRC(2,1),'ID = ',ID
!
!---  Read local copies of XMLA_FRC array (including ghost triangles)  -
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        XMLA_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'XMLA_FRC(2,1) = ',XMLA_FRC(2,1),'ID = ',ID
!
!---  Read local copies of PORD_FRC array (including ghost triangles)  -
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        PORD_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PORD_FRC(2,1) = ',PORD_FRC(2,1),'ID = ',ID
!
!---  Read local copies of PORT_FRC array (including ghost triangles)  -
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        PORT_FRC(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PORT_FRC(2,1) = ',PORT_FRC(2,1),'ID = ',ID
!
!---  Read local copies of NPHAZ_FRC array (including ghost triangles)
!
      NVAR = MAX(1,NFGT(ID+1))
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + MFGT_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      DO N = 1,MAX(1,NFGT(ID+1))
        NPHAZ_FRC(2,N) = IVARX(N)
      ENDDO
!      PRINT *,'NPHAZ_FRC(2,1) = ',NPHAZ_FRC(2,1),'ID = ',ID
!
!---  Read local copies of C_FRC array (including ghost triangles)
!
      DO L = 1,LSOLU+LSPT
        NVAR = MAX(1,NFGT(ID+1))
        OFFSET = IOFFSET + NBYTB + NC*NBYTI
        IOFFSET = IOFFSET + MFGT_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IFRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        DO N = 1,MAX(1,NFGT(ID+1))
          C_FRC(N,L) = VARX(N)
        ENDDO
!        PRINT *,'C_FRC(1,',L,') = ',C_FRC(1,L),'ID = ',ID
      ENDDO
!
!---  Read ICT_FRC array (duplicated across processors)
!
      NVAR = (LSOLU+LSPT)*LF_FRC
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IFRD,OFFSET,ICT_FRC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'ICT_FRC(1,1) = ',ICT_FRC(1,1),'ID = ',ID
!
!---  Deallocate local temporary state condition arrays
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_FSTATE_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKSP_FRC_GT( PGX,PLX,RKGX,RKLX,SGX,SLX,NFX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Relative permeability and saturations.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 25 July 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RKSP_FRC_GT'
      HDGL = MAX( (PGX-PLX)/RHORL/GRAV,1.D-14 )
      HMPX = RKSP_FRC(7,NFX)
      SLRX = RKSP_FRC(4,NFX)
      CL = MAX( RKSP_FRC(3,NFX),SMALL )
!
!---  Capillary head above the matching point head,
!     use Webb extension  ---
!
      IF( HDGL.GT.HMPX ) THEN
        SMPX = RKSP_FRC(6,NFX)
        HDGL = MIN( HDGL,RKSP_FRC(5,NFX) )
        DMPX = SMPX/(LOG10(RKSP_FRC(5,NFX))-LOG10(HMPX))
        SLX = -(LOG10(HDGL)-LOG10(RKSP_FRC(5,NFX)))*DMPX
        ASLX = SLX
!
!---  Capillary head at or below the matching point head,
!     use Brooks-Corey function
!
      ELSE
        IF( HDGL.LE.RKSP_FRC(1,NFX) ) THEN
          ASLX = 1.D+0
        ELSE
          ASLX = (RKSP_FRC(1,NFX)/HDGL)**CL
        ENDIF
        SLRX = RKSP_FRC(4,NFX)
        SLX = ASLX*(1.D+0-SLRX) + SLRX
        ASLX = SLX
      ENDIF
      SGX = 1.D+0-SLX
      IF( SGX.LT.EPSL ) SGX = 0.D+0
      ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
!
!---  Aqueous relative permeability, Brooks and Corey function  ---
!
      RKLX = ESLX**((2.D+0 + 3.D+0*CL)/CL)
!
!---  Gas relative permeability, Brooks and Corey function  ---
!
      RKGX = ((1.D+0-ESLX)**2)*(1.D+0-(ESLX**((2.D+0+CL)/CL)))
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKSP_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RSDL_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the maximum fracture and borehole relative residuals.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 14 September 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP_FRC
      USE PROP
      USE OUTPU
      USE JACOB_FRC
      USE JACOB
      USE HYST
      USE GRID
      USE GEOM_FRC
      USE FILES
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(1:LUK) :: RSDLX_FRC
      REAL*8, DIMENSION(6) :: VARX	
      INTEGER, DIMENSION(1:LUK) :: NSDLX_FRC,NPHLX_FRC,NPHX_FRC
      INTEGER, DIMENSION(LUK) :: IDLX,IDX
      INTEGER, DIMENSION(9) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*64 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      SAVE PH_CND
      DATA PH_CND /'Saturated w/o Entrapped Gas',
     &   'Unsaturated w/ or w/o Entrapped Gas',
     &   'Saturated w/ Trapped Gas',
     &   'Fully Unsaturated',
     &   'Supercritical Water'/
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RSDL_BF_GT'
!
!---  Zero local and global maximum residuals  ---
!
      DO M = 1,ISVC
        RSD_FRC(M) = 0.D+0
        RSDLX_FRC(M) = 0.D+0
        NSD_FRC(M) = 0
        NSDLX_FRC(M) = 0
        NPHLX_FRC(M) = 0
      ENDDO
!
!---  Loop over fracture triangles (without ghost triangles)  ---
!
      DO NTX = 1,NFT(ID+1)
        NFX = NF_FRC(NTX)
        IF( IERRL.NE.(NFT_G+1) ) CYCLE
        NMD = (IXP_FRC(NTX)-1)*ISVC
!
!---    Nonisothermal simulations  ---
!
        IF( ISLC(30).EQ.0 ) MPT = NMD + IEQT
        MPW = NMD + IEQW
        IF( ISLC(37).EQ.0 ) MPA = NMD + IEQA
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) MPS = NMD + IEQS
!
!---    Nonisothermal simulations  ---
!
        IF( ISLC(30).EQ.0 ) THEN
!
!---      Energy equation  ---
!
          ACP = (SL_FRC(2,NTX)*RHOL_FRC(2,NTX)*HL_FRC(2,NTX) +
     &      SS_FRC(2,NTX)*RHOSP_FRC(2,NTX)*HSP_FRC(2,NTX) +
     &      SG_FRC(2,NTX)*RHOG_FRC(2,NTX)*UEG_FRC(2,NTX))*DTI*
     &      AF_FRC(NTX)*APM_FRC(2,NTX)
          RSDX = MIN( ABS(BLU(MPT))/TABS,
     &      ABS(RSDL_FRC(IEQT,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX_FRC(IEQT) ) THEN
            RSDLX_FRC(IEQT) = RSDX
            NSDLX_FRC(IEQT) = NTX
            NPHLX_FRC(IEQT) = NPHAZ_FRC(2,NTX)
          ENDIF
        ENDIF
!
!---    Saturated system w/o entrapped gas
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - aqueous-air mole fraction
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ_FRC(2,NTX).EQ.1 ) THEN
!
!---      Water mass equation  ---
!
          ACP = (RHOL_FRC(2,NTX)*SL_FRC(2,NTX)*
     &      XLW_FRC(2,NTX) + RHOG_FRC(2,NTX)*SG_FRC(2,NTX)*
     &      XGW_FRC(2,NTX))*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
          RSDX = MIN( ABS(BLU(MPL))/(ABS(PL_FRC(2,NTX))+PATM),
     &      ABS(RSDL_FRC(IEQW,NTX)/(ACP+SMALL)) )
          RSDX = 1.D-1*RSDX
          IF( RSDX.GT.RSDLX_FRC(IEQW) ) THEN
            RSDLX_FRC(IEQW) = RSDX
            NSDLX_FRC(IEQW) = NTX
            NPHLX_FRC(IEQW) = NPHAZ_FRC(2,NTX)
          ENDIF
!
!---    Air mass equation, ignore residual for small aqueous-air  ---
!
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
          PWX = MAX( PSWX,PL_FRC(2,NTX)+PATM )
          CALL SOL_BRNS( T_FRC(2,NTX),PWX,XLSMX )
          XLSX = MIN( YLS_FRC(2,NTX),XLSMX )
          XLS_FRC(2,NTX) = XLSX
          CALL SP_B( T_FRC(2,NTX),XLS_FRC(2,NTX),PSBX )
          IF( ISLC(37).EQ.0 ) THEN
            PVAX = MAX( PWX-PSBX,0.D+0 )
            XMLAX = PVAX/HCAW
            XMLA_FRC(2,NTX) = PVA_FRC(2,NTX)/HCAW
            IF( XMLA_FRC(2,NTX).GT.(1.D-6*XMLAX) ) THEN
              ACP = (RHOG_FRC(2,NTX)*SG_FRC(2,NTX)*
     &          XGA_FRC(2,NTX) + RHOL_FRC(2,NTX)*SL_FRC(2,NTX)*
     &          XLA_FRC(2,NTX))*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
              RSDX = MIN( ABS(BLU(MPG))/MAX( XMLAX,PATM/HCAW ),
     &          ABS(RSDL_FRC(IEQA,NTX)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX_FRC(IEQA) ) THEN
                RSDLX_FRC(IEQA) = RSDX
                NSDLX_FRC(IEQA) = NTX
                NPHLX_FRC(IEQA) = NPHAZ_FRC(2,NTX)
              ENDIF
            ENDIF
          ENDIF
!
!---      Salt mass equation, isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS_FRC(2,NTX)*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
            RSDX = MIN( (ABS(BLU(MPS))/XLSMX),
     &        ABS(RSDL_FRC(IEQS,NTX)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX_FRC(IEQS) ) THEN
              RSDLX_FRC(IEQS) = RSDX
              NSDLX_FRC(IEQS) = NTX
              NPHLX_FRC(IEQS) = NPHAZ_FRC(2,NTX)
            ENDIF
          ENDIF
!
!---    Unsaturated system
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.2 ) THEN
!
!---      Water mass equation  ---
!
          ACP = (RHOL_FRC(2,NTX)*SL_FRC(2,NTX)*
     &      XLW_FRC(2,NTX) + RHOG_FRC(2,NTX)*SG_FRC(2,NTX)*
     &      XGW_FRC(2,NTX))*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
          RSDX = MIN( ABS(BLU(MPL))/(ABS(PL_FRC(2,NTX))+PATM),
     &      ABS(RSDL_FRC(IEQW,NTX)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX_FRC(IEQW) ) THEN
            RSDLX_FRC(IEQW) = RSDX
            NSDLX_FRC(IEQW) = NTX
            NPHLX_FRC(IEQW) = NPHAZ_FRC(2,NTX)
          ENDIF
!
!---      Air mass equation  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            IF( SG_FRC(2,NTX).GT.1.D-3 ) THEN
              ACP = (RHOG_FRC(2,NTX)*SG_FRC(2,NTX)*
     &          XGA_FRC(2,NTX) + RHOL_FRC(2,NTX)*SL_FRC(2,NTX)*
     &          XLA_FRC(2,NTX))*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
              RSDX = MIN( ABS(BLU(MPG))/(ABS(PG_FRC(2,NTX))+PATM),
     &          ABS(RSDL_FRC(IEQA,NTX)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX_FRC(IEQA) ) THEN
                RSDLX_FRC(IEQA) = RSDX
                NSDLX_FRC(IEQA) = NTX
                NPHLX_FRC(IEQA) = NPHAZ_FRC(2,NTX)
              ENDIF
            ENDIF
          ENDIF
!
!---      Salt mass equation, isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS_FRC(2,NTX)*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
            INDX = 0
            CALL REGION_4( T_FRC(2,NTX),PWX,INDX )
            CALL SOL_BRNS( T_FRC(2,NTX),PWX,XLSMX )
            RSDX = MIN( (ABS(BLU(MPS))/XLSMX),
     &        ABS(RSDL_FRC(IEQS,NTX)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX_FRC(IEQS) ) THEN
              RSDLX_FRC(IEQS) = RSDX
              NSDLX_FRC(IEQS) = NTX
              NPHLX_FRC(IEQS) = NPHAZ_FRC(2,NTX)
            ENDIF
          ENDIF
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - gas pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.4 ) THEN
!
!---      Water mass equation  ---
!
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PWX,INDX )
          PWX = MIN( PWX,PCRW )
          ACP = RHOG_FRC(2,NTX)*SG_FRC(2,NTX)*
     &      XGW_FRC(2,NTX)*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
          RSDX = MIN( ABS(BLU(MPL))/PWX,
     &      ABS(RSDL_FRC(IEQW,NTX)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX_FRC(IEQW) ) THEN
            RSDLX_FRC(IEQW) = RSDX
            NSDLX_FRC(IEQW) = NTX
            NPHLX_FRC(IEQW) = NPHAZ_FRC(2,NTX)
          ENDIF
!
!---      Air mass equation  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            PGX = PG_FRC(2,NTX) + PATM
            ACP = RHOG_FRC(2,NTX)*SG_FRC(2,NTX)*
     &        XGA_FRC(2,NTX)*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
            RSDX = MIN( ABS(BLU(MPG))/ABS(PGX),
     &        ABS(RSDL_FRC(IEQA,NTX)/(ACP+SMALL)) )
            IF( RSDX.GT.RSDLX_FRC(IEQA) ) THEN
              RSDLX_FRC(IEQA) = RSDX
              NSDLX_FRC(IEQA) = NTX
              NPHLX_FRC(IEQA) = NPHAZ_FRC(2,NTX)
            ENDIF
          ENDIF
!
!---      Salt mass equation, isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL DENS_S( T_FRC(2,NTX),PGX,RHOSPX )
            ACP = TMS_FRC(2,NTX)*DTI*AF_FRC(NTX)*APM_FRC(2,NTX)
            RSDX = MIN( (ABS(BLU(MPS))/RHOSPX),
     &        ABS(RSDL_FRC(IEQS,NTX)/(ACP+SMALL)) )
            IF( RSDX.GT.RSDLX_FRC(IEQS) ) THEN
              RSDLX_FRC(IEQS) = RSDX
              NSDLX_FRC(IEQS) = NTX
              NPHLX_FRC(IEQS) = NPHAZ_FRC(2,NTX)
            ENDIF
          ENDIF
        ENDIF
      ENDDO
!
!---  Maximum global residuals  ---
!
      CALL MPI_ALLREDUCE( RSDLX_FRC,RSD_FRC,ISVC,MPI_REAL8,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
!
!---  Identify processor with maximum residual  ---
!
      DO M = 1,ISVC
        IDLX(M) = -1
        IF( ABS((RSDLX_FRC(M)-RSD_FRC(M))/EPSL).LT.EPSL ) IDLX(M) = ID
        IF( ID.EQ.IDLX(M) ) THEN
          NSD_FRC(M) = ND_FRC( NSDLX_FRC(M) )
          NPHX_FRC(M) = NPHLX_FRC(M)
        ELSE
          NSD_FRC(M) = 0
          NPHX_FRC(M) = 0
        ENDIF
      ENDDO
      CALL MPI_ALLREDUCE( IDLX,IDX,ISVC,MPI_INTEGER,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
      DO M = 1,ISVC
        CALL MPI_BCAST( NSD_FRC(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
        CALL MPI_BCAST( NPHX_FRC(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
      ENDDO
!
!---  Assign a convergence index  ---
!
      RSDX = 1.D-20
      DO M = 1,ISVC
        IF( RSD_FRC(M).GT.RSDMX ) ICNV = 2
        RSDX = MAX( RSD_FRC(M),RSDX )
      ENDDO
      IF( ICNV.EQ.2 .AND. NITER.GE.NRIMX ) ICNV = 1
!
!---  Unconverged solution and Newton-Raphson iteration
!     limit exceeded  ---
!
      IF( ICNV.EQ.1 ) THEN
        OFFSET = IOFFSET_REF
        IF( ID.EQ.0 ) THEN
          IF( RSDX.GE.1.D+2 ) THEN
            PRINT *,'           ---  Excessive Residual in Fracture' //
     &        '  ---'
            IVARX(1) = -5
          ENDIF
        ENDIF
!
!---    Debug printing to the screen  ---
!
        IF( ID.EQ.0 ) THEN
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            NTX = NSD_FRC(IEQW)
            IF( NX.GT.0 ) THEN
              NPX = NPHX_FRC(IEQT)
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'  Energy Equation Maximum Residual = ',
     &          RSD_FRC(IEQT),': Fracture Triangle = ',NTX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Water mass equation  ---
!
          NTX = NSD_FRC(IEQW)
          IF( NX.GT.0 ) THEN
            NPX = NPHX_FRC(IEQW)
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'  Water Mass Equation Maximum Residual = ',
     &        RSD_FRC(IEQW),': Fracture Triangle = ',NTX,
     &        ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Air mass equation  ---
!
          NX = NSD_FRC(IEQA)
          IF( NX.GT.0 ) THEN
            NPX = NPHX_FRC(IEQA)
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'  Air Mass Equation Maximum Residual = ',
     &        RSD_FRC(IEQA),': Fracture Triangle = ',NTX,
     &        ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            NX = NSD_FRC(IEQS)
            IF( NX.GT.0 ) THEN
              NPX = NPHX_FRC(IEQS)
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'  Salt Equation Maximum Residual = ',
     &          RSD_FRC(IEQS),': Fracture Triangle = ',NTX,
     &          ': Phase Condition = ',PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            XMLA(2,N) = XMLA(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Loop over fracture triangles (without ghost triangles)  ---
!
          DO NTX = 1,NFT(ID+1)
            T_FRC(2,NTX) = T_FRC(1,NTX)
            PL_FRC(2,NTX) = PL_FRC(1,NTX)
            PG_FRC(2,NTX) = PG_FRC(1,NTX)
            PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
            PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
            XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
            SL_FRC(2,NTX) = SL_FRC(1,NTX)
            SG_FRC(2,NTX) = SG_FRC(1,NTX)
            YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
            TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
            NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
          ENDDO
          IVARX(1) = -1
          VARX(5) = DTX*CNVTM
          VARX(6) = DT*CNVTM
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          RETURN
        ENDIF
!
!---    Write a convergence failure index in the NSTEP location
!       plus write the global node numbers and phase condition indices
!       for the location of maximum residuals for the water, air,
!       and salt equations to output.bin  ---
!
        NVAR = 9
        IF( ISLC(30).EQ.0 ) THEN
          IVARX(2) = NSD_FRC(IEQT)
          IVARX(3) = NPHX_FRC(IEQT)
        ELSE
          IVARX(2) = 0
          IVARX(3) = 0
        ENDIF
        IVARX(4) = NSD_FRC(IEQW)
        IVARX(5) = NPHX_FRC(IEQW)
        IVARX(6) = NSD_FRC(IEQA)
        IVARX(7) = NPHX_FRC(IEQA)
        IF( ISLC(32).EQ.0 ) THEN
          IVARX(8) = NSD_FRC(IEQS)
          IVARX(9) = NPHX_FRC(IEQS)
        ELSE
          IVARX(8) = 0
          IVARX(9) = 0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &    MPI_INTEGER,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTI
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---    Write maximum residuals for the water, air, and salt
!       equations and time step reductions to output.bin  ---
!
        NVAR = 6
        IF( ISLC(32).EQ.0 ) THEN
          VARX(1) = RSD_FRC(IEQT)
        ELSE
          VARX(1) = 0.D+0
        ENDIF
        VARX(2) = RSD_FRC(IEQW)
        VARX(3) = RSD_FRC(IEQA)
        IF( ISLC(32).EQ.0 ) THEN
          VARX(4) = RSD_FRC(IEQS)
        ELSE
          VARX(4) = 0.D+0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &    MPI_REAL8,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTR
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RSDL_BF_GT group ---
!
      RETURN
      END


!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE THA_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the contribution to the energy flux by aqueous and
!     gas advection for boreholes and fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 23 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/THA_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
            HG1 = HG_FRC(MP,NT1X)*RHOG_FRC(MP,NT1X)
            HG2 = HG_FRC(MN,NT2X)*RHOG_FRC(MN,NT2X)
            HL1 = HL_FRC(MP,NT1X)*RHOL_FRC(MP,NT1X)
            HL2 = HL_FRC(MN,NT2X)*RHOL_FRC(MN,NT2X)
            UFFQ(M,NTC,NT1X) = UFFQ(M,NTC,NT1X)
     &        + HG1*MAX(UFFG(M,NTC,NT1X),ZERO)
     &        - HG2*MAX(-UFFG(M,NTC,NT1X),ZERO)
     &        + HL1*MAX(UFFL(M,NTC,NT1X),ZERO)
     &        - HL2*MAX(-UFFL(M,NTC,NT1X),ZERO)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of THA_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE THD_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the contribution to the energy flux by thermal conduction
!     for boreholes and fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 23 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/THD_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
          DFF1X = DFFM_FRC(NTC,NT1X)
          DFF2X = (DFF_FRC(NTC,NT1X)-DFFM_FRC(NTC,NT1X))
          DTK = T_FRC(2,NT1X)-T_FRC(2,NT2X)
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
            TK1 = THKL_FRC(MP,NT1X)*SL_FRC(MP,NT1X) +
     &        THKG_FRC(MP,NT1X)*SG_FRC(MP,NT1X)
            TK2 = THKL_FRC(MN,NT2X)*SL_FRC(MN,NT2X) +
     &        THKG_FRC(MN,NT2X)*SG_FRC(MN,NT2X)
            INDX = 1
            TK = DIFMN( TK1,TK2,DFF1X,DFF2X,DTK,INDX )
            UFFQ(M,NTC,NT1X) = TK*(T_FRC(MP,NT1X)-T_FRC(MN,NT2X))/
     &        DFF_FRC(NTC,NT1X)
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of THD_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE THDG_BF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the contribution to the energy flux energy flux by
!     water vapor and air molecular diffusion for fractures.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 23 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/THDG_BF_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NT1X = 1,NFT(ID+1)
        NF1X = NF_FRC(NT1X)
!
!---    Loop over active fracture triangle connections  ---
!
        DO NTC = 1,3
          NT2X = ITTCM_FRC(NTC,NT1X)
          IF( NT2X.EQ.0 ) CYCLE
!
!---      Loop over flux increments ---
!
          DO M = 1,ISVF
            MN = MNEG(M)
            MP = MPOS(M)
            UDGAX = -UFFDGW(M,NTC,NT1X)
            UFFQ(M,NTC,NT1X) = UFFQ(M,NTC,NT1X)
     &        + HGW_FRC(MP,NT1X)*MAX(UFFDGW(M,NTC,NT1X),ZERO)*WTMW
     &        - HGW_FRC(MN,NT2X)*MAX(-UFFDGW(M,NTC,NT1X),ZERO)*WTMW
     &        + HGA_FRC(MP,NT1X)*MAX(UDGAX,ZERO)*WTMA
     &        - HGA_FRC(MN,NT2X)*MAX(-UDGAX,ZERO)*WTMA
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of THDG_BF_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE TRNS_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Fracture to matrix transfer functions (fracture triangle is
!     considered the lower node for flux indexing).
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 23 August 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE JACOB
      USE GRID
      USE GEOM_FRC
      USE FLUX_FRC
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 NULX,NUGX
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/TRNS_FRC_GT'
!
!---  Loop over local fracture triangles, skipping ghost triangles  ---
!
      DO NTX = 1,NFT(ID+1)
        NFX = NF_FRC(NTX)
!
!---    Matrix node connection  ---
!
        N = ITNCM_FRC(NTX)
        IF( N.EQ.0 ) CYCLE
!
!---    Unit surface normal magnitudes ---
!
        XLX = ABS(SFNT_FRC(1,NTX))
        YLX = ABS(SFNT_FRC(2,NTX))
        ZLX = ABS(SFNT_FRC(3,NTX))
!
!---    Loop over flux increments ---
!
        DO M = 1,ISVF
          MN = MNEG(M)
          MP = MPOS(M)
!
!---      Matrix permeability, m^2  ---
!
          PERMX = SQRT((XLX*PERM(1,N))**2 + (YLX*PERM(2,N))**2 +
     &      (ZLX*PERM(3,N))**2)/SQRT(XLX**2 + YLX**2 + ZLX**2)
          PERMX = PERMX*PERMRF(MP,N)
!
!---      Aqueous head difference for fracture and grid cell, m  ---
!
          HDLX = PL_FRC(MN,NTX) - PL(MP,N) +
     &      5.D-1*GRAV*(ZP_FRC(NTX)-ZP(N))*
     &      (RHOL_FRC(MN,NTX)+RHOL(MP,N))
!
!---      Aqueous relative permeability  ---
!
          INDX = 8
          RKLM = DIFMN( RKL_FRC(MN,NTX),RKL(MP,N),DFN_FRC(NTX),
     &      DFN_FRC(NTX),HDLX,INDX )
!
!---      Aqueous viscosity Pa s  ---
!
          INDX = 5
          VLM = DIFMN( VISL_FRC(MN,NTX),VISL(MP,N),DFN_FRC(NTX),
     &      DFN_FRC(NTX),HDLX,INDX )
!
!---      Aqueous volumetric rate fracture to matrix, m^3/s  ---
!
          IF( ISLC(38).EQ.0 ) THEN
            QLX = 2.D+0*AFN_FRC(NTX)*PERMX*RKLM*HDLX/DFN_FRC(NTX)/VLM
          ELSE
            QLX = 0.D+0
          ENDIF
!
!---      Gas head difference for fracture and grid cell, m  ---
!
          HDGX = PG_FRC(MN,NTX) - PG(MP,N) +
     &      5.D-1*GRAV*(ZP_FRC(NTX)-ZP(N))*
     &      (RHOG_FRC(MN,NTX)+RHOG(MP,N))
!
!---      Gas relative permeability  ---
!
          INDX = 9
          RKGM = DIFMN( RKG_FRC(MN,NTX),RKG(MP,N),DFN_FRC(NTX),
     &      DFN_FRC(NTX),HDGX,INDX )
!
!---      Gas viscosity Pa s  ---
!
          INDX = 6
          VGM = DIFMN( VISG_FRC(MN,NTX),VISG(MP,N),DFN_FRC(NTX),
     &      DFN_FRC(NTX),HDGX,INDX )
!
!---      Gas volumetric rate fracture to matrix, m^3/s  ---
!
          IF( ISLC(38).EQ.0 ) THEN
            QGX = 2.D+0*AFN_FRC(NTX)*PERMX*RKGM*HDGX/DFN_FRC(NTX)/VGM
          ELSE
            QGX = 0.D+0
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 ) THEN
!
!---        Thermal conductivity  ---
!
            THKX = SQRT((XLX*THKS(1,N))**2 + (YLX*THKS(2,N))**2 +
     &        (ZLX*THKS(3,N))**2)/SQRT(XLX**2 + YLX**2 + ZLX**2)
            THKX = THKX*MAX(1.D+0-PORD(MP,N),0.D+0) +
     &        PORD(MP,N)*(THKL(MP,N)*SL(MP,N) + THKG(MP,N)*SG(MP,N))
!
!---        Heat transfer coefficient, Zhang et al. 2015. "The
!           analytical solution of the water-rock heat transfer
!           coefficient and sensitivity analyses of paramters."
!           Proceedings World Geothermal Congress 2015, Melbourne,
!           Australia, 19-25, April 2015  ---
!
            UFLX = 0.D+0
            UFGX = 0.D+0
!
!---        Loop over fracture triangle to triangle connections ---
!
            NC = 0
            DO NTC = 1,3
              NT2X = ITTCM_FRC(NTC,NTX)
              IF( NT2X.EQ.0 ) CYCLE
              UFLX = UFLX + ABS(UFFL(1,NTC,NTX))
              UFGX = UFGX + ABS(UFFG(1,NTC,NTX))
              NC = NC + 1
            ENDDO
            NC = 0
!
!---        Aqueous and gas fluid velocity ---
!
            UFLX = UFLX/(REAL(NC) + SMALL)
            UFGX = UFGX/(REAL(NC) + SMALL)
!
!---        Aqueous and gas Reynolds number ---
!
            RELX = UFLX*APH_FRC(MN,NTX)*RHOL_FRC(MN,NTX)/
     &        VISL_FRC(MN,NTX)
            REGX = UFGX*APH_FRC(MN,NTX)*RHOG_FRC(MN,NTX)/
     &        VISG_FRC(MN,NTX)
!
!---        Aqueous and gas Prandtl number ---
!
            CPLX = (HL_FRC(3,NTX)-HL_FRC(2,NTX))/
     &        (T_FRC(3,NTX)-T_FRC(2,NTX))
            CPGX = (HG_FRC(3,NTX)-HG_FRC(2,NTX))/
     &        (T_FRC(3,NTX)-T_FRC(2,NTX))
            PRLX = CPLX*VISL_FRC(MN,NTX)/THKL_FRC(MN,NTX)
            PRGX = CPGX*VISG_FRC(MN,NTX)/THKG_FRC(MN,NTX)
!
!---        Aqueous and gas Nusselt number ---
!
            NULX = 8.7D-5*(RELX**0.92D+0)*(PRLX**1.89D+0)
            NUGX = 8.7D-5*(RELX**0.92D+0)*(PRLX**1.89D+0)
!
!---        Aqueous and gas Nusselt number for laminar flow
!           in channels with infinite cross section ratios ---
!
            NULX = 7.54D+0
            NUGX = 7.54D+0
!
!---        Aqueous and gas heat transfer coefficient ---
!
            IF( APH_FRC(MN,NTX).GE.EPSL ) THEN
              HCLX = NULX*THKL_FRC(MN,NTX)/(2.D+0*APH_FRC(MN,NTX))
              HCGX = NUGX*THKG_FRC(MN,NTX)/(2.D+0*APH_FRC(MN,NTX))
            ELSE
              HCLX = 0.D+0
              HCGX = 0.D+0
            ENDIF
!
!---        Advective heat transfer coefficient, W/m^2 ---
!
            HCAX = SL_FRC(MN,NTX)*HCLX + SG_FRC(MN,NTX)*HCGX
!
!---        Conduction heat transfer coefficient, W/m^2 ---
!
            HCCX = THKX/DFN_FRC(NTX)
!
!---        Overall heat transfer coefficient, W/m^2 ---
!
            IF( HCAX.GE.EPSL .AND. HCCX.GE.EPSL ) THEN
              HCOX = 1.D+0/((1.D+0/HCAX)+(1.D+0/HCCX))
            ELSEIF( HCAX.GE.EPSL ) THEN
              HCOX = HCAX
            ELSEIF( HCCX.GE.EPSL ) THEN
              HCOX = HCCX
            ELSE
              HCOX = 0.D+0
            ENDIF
!
!---        Overall heat transfer, W  ---
!
            QTCX = 2.D+0*AFN_FRC(NTX)*HCOX*(T_FRC(MN,NTX)-T(MP,N))
          ENDIF
!
!---      Store aqueous, gas, and heat flow from fracture
!         to grid cell  ---
!
          IF( M.EQ.1 ) THEN
            UFMG(NTX) = QGX
            UFML(NTX) = QLX
            UFMT(NTX) = QTCX
          ENDIF
!
!---      Air mass flow rate from fracture to grid cell, kg/s  ---
!
          TRNSA_FRC(M,NTX) =
     &      XLA_FRC(MN,NTX)*RHOL_FRC(MN,NTX)*MAX(QLX,ZERO) -
     &      XLA(MP,N)*RHOL(MP,N)*MAX(-QLX,ZERO) +
     &      XGA_FRC(MN,NTX)*RHOG_FRC(MN,NTX)*MAX(QGX,ZERO) -
     &      XGA(MP,N)*RHOG(MP,N)*MAX(-QGX,ZERO)
!
!---      Water mass flow rate from fracture to grid cell, kg/s  ---
!
          TRNSW_FRC(M,NTX) =
     &      XLW_FRC(MN,NTX)*RHOL_FRC(MN,NTX)*MAX(QLX,ZERO) -
     &      XLW(MP,N)*RHOL(MP,N)*MAX(-QLX,ZERO) +
     &      XGW_FRC(MN,NTX)*RHOG_FRC(MN,NTX)*MAX(QGX,ZERO) -
     &      XGW(MP,N)*RHOG(MP,N)*MAX(-QGX,ZERO)
!
!---      Salt mass flow rate from fracture to grid cell, kg/s  ---
!
          TRNSS_FRC(M,NTX) =
     &      XLS_FRC(MN,NTX)*RHOL_FRC(MN,NTX)*MAX(QLX,ZERO) -
     &      XLS(MP,N)*RHOL(MP,N)*MAX(-QLX,ZERO)
!
!---      Total heat transfer rate from fracture to grid cell, W  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            TRNSQ_FRC(M,NTX) = QTCX +
     &        HL_FRC(MN,NTX)*RHOL_FRC(MN,NTX)*MAX(QLX,ZERO) -
     &        HL(MP,N)*RHOL(MP,N)*MAX(-QLX,ZERO) +
     &        HG_FRC(MN,NTX)*RHOG_FRC(MN,NTX)*MAX(QGX,ZERO) -
     &        HG(MP,N)*RHOG(MP,N)*MAX(-QGX,ZERO)
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of TRNS_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_FRC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Update the fracture primary variables.
!
!----------------------Authors-----------------------------------------!
!
!     Written by Mark White, PNNL, 8 September 2022.
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE PROP_FRC
      USE OUTPU
      USE JACOB
      USE JACOB_FRC
      USE HYST
      USE GRID
      USE GEOM_FRC
      USE FILES
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(14) :: VARZ
      REAL*8, DIMENSION(14) :: VARX
      INTEGER, DIMENSION(14) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*64 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      SAVE PH_CND
      DATA PH_CND /'Saturated w/o Entrapped Gas',
     &   'Unsaturated w/ or w/o Entrapped Gas',
     &   'Saturated w/ Trapped Gas',
     &   'Fully Unsaturated',
     &   'Supercritical Water'/
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_FRC_GT'
!
!---  Update primary variables on fracture triangles  ---
!
      IERR = 0
      IERRL = NFT_G + 1
      IERRG = NFT_G + 1
!
!---  Loop over fracture triangles (without ghost triangles)  ---
!
      DO NTX = 1,NFT(ID+1)
        NFX = NF_FRC(NTX)
        IF( IERRL.NE.(NFT_G+1) ) CYCLE
        NMD = (IXP_FRC(NTX)-1)*ISVC
        MPW = NMD + IEQW
        IF( ISLC(37).EQ.0 ) THEN
          MPA = NMD + IEQA
          DPA = BLU(MPA)
        ENDIF
        DPW = BLU(MPW)
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ENDIF
!
!---    Nonisothermal simulations  ---
!
        IF( ISLC(30).EQ.0 ) THEN
          MPT = NMD + IEQT
          DPT = BLU(MPT)
          DPT = SIGN( MIN( 1.D+0,ABS(DPT) ),DPT )
          T_FRC(2,NTX) = T_FRC(2,NTX) + DPT
        ENDIF
!
!---    Saturated system w/o entrapped gas
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - aqueous-air mole fraction
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ_FRC(2,NTX).EQ.1 ) THEN
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
          DPX = 1.D+6
          DPW = SIGN( MIN( ABS(DPW),DPX ),DPW )
          PL_FRC(2,NTX) = PL_FRC(2,NTX) + DPW
!
!---      Zero negative corrections for zero aqueous air  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            PVA_FRC(2,NTX) = MAX( PVA_FRC(2,NTX)+DPA,0.D+0 )
            IF( PVA_FRC(2,NTX).LT.EPSL ) PVA_FRC(2,NTX) = 0.D+0
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Limit salt mass fraction changes to 0.25 of the
!           maximum value if salt mass fraction is less than
!           the maximum   ---
!
            PWX = MAX( PSWX,PL_FRC(2,NTX)+PATM )
            CALL SOL_BRNS( T_FRC(2,NTX),PWX,XLSMX )
            DPX = ABS(2.5D-1*XLSMX)
            IF( YLS_FRC(2,NTX).LT.XLSMX ) THEN
              DPS = SIGN( MIN( DPX,ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero aqueous salt  ---
!
            IF( YLS_FRC(2,NTX)/EPSL.LT.EPSL .AND.
     &        BLU(MPS)/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            IF( YLS_FRC(2,NTX)+DPS.LT.0.D+0 ) DPS = 6.D-1*DPS
            YLS_FRC(2,NTX) = YLS_FRC(2,NTX) + DPS
            IF( YLS_FRC(2,NTX).LT.EPSL ) YLS_FRC(2,NTX) = 0.D+0
            XLS_FRC(2,NTX) = MIN( YLS_FRC(2,NTX),XLSMX )
          ENDIF
!
!---    Unsaturated system
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.2 ) THEN
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PSWX,INDX )
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Limit salt mass fraction changes to 0.25 of the
!           maximum value if salt mass fraction is less than
!           the maximum   ---
!
            CALL SOL_BRNS( T_FRC(2,NTX),PSWX,XLSMX )
            DPX = ABS(2.5D-1*XLSMX)
            IF( YLS_FRC(2,NTX).LT.XLSMX ) THEN
              DPS = SIGN( MIN( DPX,ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero aqueous salt  ---
!
            IF( YLS_FRC(2,NTX)/EPSL.LT.EPSL .AND.
     &        BLU(MPS)/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            IF( YLS_FRC(2,NTX)+DPS.LT.0.D+0 ) DPS = 6.D-1*DPS
            YLS_FRC(2,NTX) = YLS_FRC(2,NTX) + DPS
            IF( YLS_FRC(2,NTX).LT.EPSL ) YLS_FRC(2,NTX) = 0.D+0
            XLS_FRC(2,NTX) = MIN( YLS_FRC(2,NTX),XLSMX )
          ENDIF
!
!---      Assign gas-entry pressure  ---
!
          ENPR = RKSP_FRC(1,NFX)*RHORL*GRAV
!
!---      Limit changes in pressure  ---
!
          DPX = MAX( 1.D+6,2.5D-1*(PG_FRC(2,NTX)-PL_FRC(2,NTX)) )
          DPCX = MAX( 1.D+4,2.5D-1*(PG_FRC(2,NTX)-PL_FRC(2,NTX)) )
          IF( (DPA-DPW).GT.DPCX ) THEN
            DPA = DPA - 5.D-1*DPCX
            DPW = DPW + 5.D-1*DPCX
          ELSE
            DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
            DPA = SIGN( MIN(ABS(DPX),ABS(DPA)),DPA )
          ENDIF
!
!---      Relax pressure updates when transitioning to unsaturated
!         conditions  ---
!
          IF( (PG_FRC(2,NTX)+DPA)-(PL_FRC(2,NTX)+DPW).LT.ENPR ) THEN
            DPA = 6.D-1*DPA
            DPW = 6.D-1*DPW
          ENDIF
          PG_FRC(2,NTX) = PG_FRC(2,NTX) + DPA
          PL_FRC(2,NTX) = PL_FRC(2,NTX) + DPW
          PL_FRC(2,NTX) = MAX( PL_FRC(2,NTX),
     &      (PG_FRC(2,NTX)-RKSP_FRC(5,NFX)*RHORL*GRAV) )
!
!---      Maintain the gas pressure above or at the water vapor
!         pressure  ---
!
          CALL P_IAPWS( T_FRC(2,NTX),PSWX,RHOGWX,RHOLWX,HGWX,
     &      HLWX,UGWX,ULWX )
          CALL DENS_B( XLS_FRC(2,NTX),RHOBX,RHOLWX,T_FRC(2,NTX) )
          CALL SP_B( T_FRC(2,NTX),XLS_FRC(2,NTX),PSBX )
          PGX = PG_FRC(2,NTX) + PATM
          PLX = PL_FRC(2,NTX) + PATM
          PCX = PGX - PLX
          CALL VPL_B( T_FRC(2,NTX),PSBX,PCX,RHOBX,PVBX )
          PG_FRC(2,NTX) = MAX( PG_FRC(2,NTX),(PVBX-PATM) )
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - gas pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ_FRC(2,NTX).EQ.4 ) THEN
!
!---      Limit changes in water vapor partial pressure  ---
!
          INDX = 0
          CALL REGION_4( T_FRC(2,NTX),PWX,INDX )
          PWX = MIN( PWX,PCRW )
          DPX = 2.5D-1*PWX
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          PVW_FRC(2,NTX) = MAX( PVW_FRC(2,NTX)+DPW,1.D-6 )
!
!---      Limit changes in gas pressure  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            DPX = 2.5D-1*MAX(PG_FRC(2,NTX)+PATM,1.D+6)
            DPA = SIGN( MIN(ABS(DPX),ABS(DPA)),DPA )
            PG_FRC(2,NTX) = PG_FRC(2,NTX) + DPA
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Zero negative corrections for salt volumetric conc.  ---
!
            IF( TMS_FRC(2,NTX)/EPSL.LT.EPSL .AND.
     &        BLU(MPS)/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            TMS_FRC(2,NTX) = TMS_FRC(2,NTX) + DPS
            IF( TMS_FRC(2,NTX).LT.1.D-9 ) TMS_FRC(2,NTX) = 0.D+0
          ENDIF
        ENDIF
!
!---    Check for excessive pressure or temperature   ---
!
        PGX = PG_FRC(2,NTX)+PATM
        PLX = PL_FRC(2,NTX)+PATM
        TKX = T_FRC(2,NTX)+TABS
        IF( PGX.GT.100.D+6 .OR. PGX.LT.0.D+0 ) IERR = 1
        IF( PLX.GT.100.D+6 ) IERR = 1
        IF( TKX.GT.1073.15D+0 .OR. TKX.LT.TABS ) IERR = 1
        IF( IERR.EQ.1 ) NSD_FRC(1) = NTX
!
!---    Excess changes in primary variables, skip updates  ---
!
        IF( IERR.EQ.1 .AND. IERRL.EQ.(NFT_G+1) ) THEN
          IERRL = ND_FRC(NTX)
          VARZ(1) = REAL( NTX )
          VARZ(2) = REAL( NPHAZ_FRC(2,NTX) )
          VARZ(3) = DPT
          VARZ(4) = DPW
          VARZ(5) = DPA
          VARZ(6) = DPS
          VARZ(7) = T_FRC(2,NTX)
          VARZ(8) = PL_FRC(2,NTX)+PATM
          VARZ(9) = PG_FRC(2,NTX)+PATM
          VARZ(10) = SG_FRC(2,NTX)
          VARZ(11) = XMLA_FRC(2,NTX)
          VARZ(12) = PVW_FRC(2,NTX)
          VARZ(13) = YLS_FRC(2,NTX)
          VARZ(14) = TMS_FRC(2,NTX)
        ENDIF
      ENDDO
!
!---  Identify minimum global triangle with errors  ---
!
      CALL MPI_ALLREDUCE( IERRL,IERRG,1,MPI_INTEGER,MPI_MIN,
     &  MPI_COMM_WORLD,IERR )
!
!---  Triangle identified with an excessive primary variable change  ---
!
      IF( IERRG.NE.(NFT_G+1) ) THEN
        ICNV = 1
        IDX = 0
!
!---    Identify processor with error  ---
!
        DO MP = 1,NP
          IF( IERRL.EQ.IERRG ) IDX = ID
        ENDDO
!
!---    Send node state to P0  ---
!
        IF( ID.EQ.IDX ) THEN
          CALL MPI_SEND( VARZ,14,MPI_REAL8,0,18,MPI_COMM_WORLD,IERR )
        ENDIF
        IF( ID.EQ.0 ) THEN
          CALL MPI_RECV( VARZ,14,MPI_REAL8,IDX,18,MPI_COMM_WORLD,
     &      STATUS,IERR )
          N = INT(VARZ(1))
          NPHZX = MOD(INT(VARZ(2)),100)
          PRINT *,'---  Excessive Primary Variable Change '
     &    // 'for Fracture Flow  ---'
          PRINT *,'  Fracture Triangle = ',ND_FRC(NTX)
          PRINT *,'  Phase Condition = ',PH_CND(NPHZX)
          IF( ISLC(30).EQ.0 ) THEN
            PRINT *,'  DPT = ',VARZ(3)
          ENDIF
          PRINT *,'  DPW = ',VARZ(4)
          PRINT *,'  DPA = ',VARZ(5)
          IF( ISLC(32).EQ.0 ) THEN
            PRINT *,'  DPS = ',VARZ(6)
          ENDIF
          PRINT *,'  Temperature, C = ',VARZ(7)
          PRINT *,'  Aqueous Pressure, Pa = ',VARZ(8)
          PRINT *,'  Gas Pressure, Pa = ',VARZ(9)
          PRINT *,'  Gas Saturation = ',VARZ(10)
          PRINT *,'  Aqueous-Air Mass Fraction = ',VARZ(11)
          PRINT *,'  Water Vapor Pressure = ',VARZ(12)
          PRINT *,'  Total-Salt Aqu. Mass Fraction = ',VARZ(13)
          PRINT *,'  Salt Volumetric Concentration = ',VARZ(14)
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            PVA(2,N) = PVA(1,N)
            XMLA(2,N) = XMLA(1,N)
            SL(2,N) = SL(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Loop over fracture triangles (without ghost triangles)  ---
!
          DO NTX = 1,NFT(ID+1)
            T_FRC(2,NTX) = T_FRC(1,NTX)
            PL_FRC(2,NTX) = PL_FRC(1,NTX)
            PG_FRC(2,NTX) = PG_FRC(1,NTX)
            PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
            PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
            XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
            SL_FRC(2,NTX) = SL_FRC(1,NTX)
            SG_FRC(2,NTX) = SG_FRC(1,NTX)
            YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
            TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
            NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
          ENDDO
!
!---      Write a excessive primary variable index in the NSTEP location
!         plus write the global triangle numbers and phase condition 
!         indices for the location of maximum residuals for the water, 
!         air, and salt equations to output.bin  ---
!
          NVAR = 3
          IVARX(1) = -4
          IVARX(2) = ND_FRC(IERRG)
          IVARX(3) = NPHZX
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---      Write maximum residuals for the water, air, and salt
!         equations and time step reductions to output.bin  ---
!
          NVAR = 10
          VARX(1) = VARZ(7)
          VARX(2) = VARZ(8)
          VARX(3) = VARZ(9)
          VARX(4) = VARZ(10)
          VARX(5) = VARZ(11)
          VARX(6) = VARZ(12)
          VARX(7) = VARZ(13)
          VARX(8) = VARZ(14)
          VARX(9) = DTX*CNVTM
          VARX(10) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            PVA(2,N) = PVA(1,N)
            XMLA(2,N) = XMLA(1,N)
            SL(2,N) = SL(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Loop over fracture triangles (without ghost triangles)  ---
!
          DO NTX = 1,NFT(ID+1)
            T_FRC(2,NTX) = T_FRC(1,NTX)
            PL_FRC(2,NTX) = PL_FRC(1,NTX)
            PG_FRC(2,NTX) = PG_FRC(1,NTX)
            PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
            PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
            XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
            SL_FRC(2,NTX) = SL_FRC(1,NTX)
            SG_FRC(2,NTX) = SG_FRC(1,NTX)
            YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
            TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
            NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
          ENDDO
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_FRC_GT group ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_FRC_GC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Update the primary variables on ghost triangles
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 08 September 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE TRNS_FRC
      USE SOLTN
      USE OUTPU
      USE JACOB_FRC
      USE HYST
      USE GRID
      USE GEOM_FRC
      USE FDVP_FRC
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_FRC_GC_GT'
      NPVX = 20
!
!---  Loop over processor ranks, sequencing ghost triangle
!     send and receives  ---
!
      DO IDX = 0,NP-1
!
!---    Sending updated fracture triangle primary variables to 
!       ghost triangles on receiving processors
!       NCSGT_FRC(NPRX) - count of fracture triangles going to processor
!         NPRX
!       NDSGT_FRC(NC) - local fracture triangle number sending data
!       NPSGT_FRC(NC) - processor receiving fracture triangle data  ---
!
        IF( NPSGT_FRC(1).GT.0 ) THEN
!
!---      Loop over receiving processors  ---
!
          DO NPRX = 1,NP
!
!---        Load sending buffer for ghost triangles for processors
!           with ghost triangles going to receiving processor, and 
!           send buffer to receiving processor  ---
!
            NCS = 0
            DO M = 1,NCSGT_FRC(ID+1)
              NTX = NDSGT_FRC(M)
              NPX = NPSGT_FRC(M)
              IF( NPRX.EQ.NPX ) THEN
                SBF_FRC(NCS+1) = PG_FRC(2,NTX)
                SBF_FRC(NCS+2) = PL_FRC(2,NTX)
                SBF_FRC(NCS+3) = PVA_FRC(2,NTX)
                SBF_FRC(NCS+4) = PVW_FRC(2,NTX)
                SBF_FRC(NCS+5) = SG_FRC(2,NTX)
                SBF_FRC(NCS+6) = SL_FRC(2,NTX)
                SBF_FRC(NCS+7) = T_FRC(2,NTX)
                SBF_FRC(NCS+8) = TMS_FRC(2,NTX)
                SBF_FRC(NCS+9) = XMLA_FRC(2,NTX)
                SBF_FRC(NCS+10) = XLS_FRC(2,NTX)
                SBF_FRC(NCS+11) = YLS_FRC(2,NTX)
                SBF_FRC(NCS+12) = PL_TN(NTX)
                SBF_FRC(NCS+13) = PG_TN(NTX)
                SBF_FRC(NCS+14) = T_TN(NTX)
                DO K = 1,6
                  SBF_FRC(NCS+14+K) = SIG_GM_TN(K,NTX)
                ENDDO
                NCS = NCS + NPVX
              ENDIF
            ENDDO
            IF( NCS.EQ.0 ) CYCLE
            NSNDX = NCS
            IDRCVX = NPRX - 1
            ITAGX = ITAG(ID+1,NPRX)
            IF( ID.EQ.IDX ) THEN
!            PRINT *,'NSNDX = ',NSNDX,'IDRCVX = ',IDRCVX,
!       &      'ITAGX = ',ITAGX,'ID = ',ID
            CALL MPI_SEND( SBF_FRC,NSNDX,MPI_REAL8,IDRCVX,
     &        ITAGX,MPI_COMM_WORLD,IERR )
!            PRINT *,'Post Send: IERR = ',IERR,
!       &      'ITAGX = ',ITAGX,'ID = ',ID
            ENDIF
          ENDDO
        ENDIF
!
!---    Receiving updated ghost triangle primary variables from 
!       fracture triangles on sending processors
!       NCRGT_FRC(NPRX) - count of fracture triangles coming from 
!         processor NPRX
!       NDRGT_FRC(NC) - local ghost triangle number receiving data
!       NPRGT_FRC(NC) - processor sending ghost triangle data  ---
!
        IF( NPRGT_FRC(1).GT.0 ) THEN
!
!---      Loop over sending processors  ---
!
          DO NPSX = 1,NP
!
!---        Load sending buffer for ghost triangles for processors
!           with ghost triangles going to receiving processor, and 
!           send buffer to receiving processor  ---
!
            NCR = 0
            DO M = 1,NCRGT_FRC(ID+1)
              NTX = NDRGT_FRC(M)
              NPX = NPRGT_FRC(M)
              IF( NPSX.EQ.NPX ) THEN
                NCR = NCR + NPVX
              ENDIF
            ENDDO
            IF( NCR.EQ.0 ) CYCLE
            NRCVX = NCR
            IDSNDX = NPSX - 1
            ITAGX = ITAG(NPSX,ID+1)
            IF( IDSNDX.EQ.IDX ) THEN
!            PRINT *,'NRCVX = ',NRCVX,'IDSNDX = ',IDSNDX,
!       &      'ITAGX = ',ITAGX,'ID = ',ID
            CALL MPI_RECV( RBF_FRC,NRCVX,MPI_REAL8,
     &        IDSNDX,ITAGX,MPI_COMM_WORLD,STATUS,IERR )
!            PRINT *,'Post Recv: IERR = ',IERR,
!       &      'ITAGX = ',ITAGX,'ID = ',ID
            DO M = 1,NCRGT_FRC(ID+1)
              NTX = NDRGT_FRC(M)
              NPX = NPRGT_FRC(M)
              IF( NPSX.EQ.NPX ) THEN
                PG_FRC(2,NTX) = RBF_FRC(NCR+1)
                PL_FRC(2,NTX) = RBF_FRC(NCR+2)
                PVA_FRC(2,NTX) = RBF_FRC(NCR+3)
                PVW_FRC(2,NTX) = RBF_FRC(NCR+4)
                SG_FRC(2,NTX) = RBF_FRC(NCR+5)
                SL_FRC(2,NTX) = RBF_FRC(NCR+6)
                T_FRC(2,NTX) = RBF_FRC(NCR+7)
                TMS_FRC(2,NTX) = RBF_FRC(NCR+8)
                XMLA_FRC(2,NTX) = RBF_FRC(NCR+9)
                XLS_FRC(2,NTX) = RBF_FRC(NCR+10)
                YLS_FRC(2,NTX) = RBF_FRC(NCR+11)
                PL_TN(NTX) = RBF_FRC(NCR+12)
                PG_TN(NTX) = RBF_FRC(NCR+13)
                T_TN(NTX) = RBF_FRC(NCR+14)
                DO K = 1,6
                  SIG_GM_TN(K,NTX) = RBF_FRC(NCR+14+K)
                ENDDO
              ENDIF
            ENDDO
            ENDIF
          ENDDO
        ENDIF
        CALL MPI_BARRIER( MPI_COMM_WORLD,IERR )
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_FRC_GC_GT group
!
      RETURN
      END

