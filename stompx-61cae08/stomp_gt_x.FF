!----------------------Program-----------------------------------------!
!
      PROGRAM STOMP
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------------------------------------------------------!
!
!     STOMPX: Subsurface Transport Over Multiple Phases Extensible
!
!     Geothermal Mode (STOMPX-GT)
!
!     This engineering program numerically simulates the transport
!     of water, salt and air through multifluid subsurface environments
!     under non-isothermal conditions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE PROP
      USE OUTPU
      USE JACOB
      USE FLUX
      USE FILES
      USE FDVP
      USE GRID
      USE GLB_PAR
      USE GEO_MECH
      USE COUP_WELL
      USE BCVP
      USE BCV
#ifdef lis
!
!----------------------Lis Modules-----------------------------------!
!
      USE LIS_STOMP
#endif
#ifdef petsc
!
!----------------------PETSc Modules-----------------------------------!
!
      USE PETSCKSP
      USE PETSC_STOMP
#endif
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
#ifdef lis
#include "lisf.h"
#endif
#ifdef petsc
#include "petsc/finclude/petscmat.h"
#include "petsc/finclude/petscvec.h"
#include "petsc/finclude/petscksp.h"
#endif
!
!----------------------Type Declarations-------------------------------!
!
      LOGICAL HALT,PLOT,RESTART
#ifdef lis
      LIS_INTEGER :: IERR
#endif
#ifdef petsc
      PetscErrorCode :: IERR
#endif
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*132 CHMSGX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = 1
      SUB_LOG(1) = 'STOMPX-GT'
!
!---  Initialize MPI  ---
!
      CALL MPI_INIT( IERR )
!
!---  Get the individual process ID  ---
!
      CALL MPI_COMM_RANK( MPI_COMM_WORLD,ID,IERR )
!
!---  Get the number of processes  ---
!
      CALL MPI_COMM_SIZE ( MPI_COMM_WORLD,NP,IERR )
#ifdef lis
!
!---  Initialize Lis ---
!
      CALL LIS_INITIALIZE( IERR )
!      PRINT *,'LIS_INITIALIZE: IERR = ',IERR,'ID = ',ID
#endif
#ifdef petsc
!
!---  Initialize PETSc ---
!
      CALL PetscInitialize(PETSC_NULL_CHARACTER,IERR )
#endif
!
!---  Print banner to screen ---
!
      IF( ID.EQ.0 ) THEN
      PRINT *,' Welcome to ...'
      PRINT *,' '
      PRINT *,'              Geothermal Mode (STOMPX-GT)'
      PRINT *,'        Subsurface Transport Over Multiple Phases'
      PRINT *,'                 GT Operational Mode'
      PRINT *,'               OpenMPI Extensible Version'
      PRINT *,' '
      PRINT *,' This screen echo was produced by STOMPX, a numerical '
      PRINT *,' simulator developed by the Pacific Northwest National '
      PRINT *,' Laboratory. The simulator additionally produces'
      PRINT *,' binary formatted output files: output.bin, plot_xxx.bin'
      PRINT *,' and surface.bin, which can be converted to text format'
      PRINT *,' with postprocessing utilities.'
      PRINT *,' '
      PRINT *,'                     Disclaimer'
      PRINT *,' This material was prepared as an account of work '
      PRINT *,' sponsored by an agency of the United States Government.'
      PRINT *,' Neither the United States Government nor the United '
      PRINT *,' States Department of Energy, nor Battelle, nor any of '
      PRINT *,' their employees, makes any warranty, express or '
      PRINT *,' implied, or assumes any legal liability or '
      PRINT *,' responsibility for the accuracy, completeness, or '
      PRINT *,' usefulness of any information, apparatus, product, '
      PRINT *,' software or process disclosed, or represents that its '
      PRINT *,' use would not infringe privately owned rights.'
      PRINT *,' '
      PRINT *,'                     Acknowledgement'
      PRINT *,' This software and its documentation were produced with '
      PRINT *,' Government support under Contract Number '
      PRINT *,' DE-AC06-76RLO-1830 awarded by the United Department of '
      PRINT *,' of Energy. The Government retains a paid-up '
      PRINT *,' non-exclusive, irrevocable worldwide license to'
      PRINT *,' implied, or assumes any legal liability or '
      PRINT *,' reproduce, prepare derivative works, perform publicly '
      PRINT *,' and display publicly by or for the Government, '
      PRINT *,' including the right to distribute to other Government '
      PRINT *,' contractors.'
      PRINT *,' '
      PRINT *,' For support:  Tel: 509.372.6070'
      PRINT *,'               E-mail:  mark.white@pnnl.gov'
      PRINT *,' '
      PRINT *,'                     Notice'
      PRINT *,' This screen echo only reports basic time stepping '
      PRINT *,' information to track the simulation progress. Expanded'
      PRINT *,' simulation results are reported in binary formatted '
      PRINT *,' output files: output.bin, plot_xxx.bin and '
      PRINT *,' surface.bin.'
      PRINT *,' '
      ENDIF
!
!---  Read binary files from preprocessor and allocate
!     memory for global arrays  ---
!
      CALL READ_BIN_GT
!      PRINT *,'Post READ_BIN_GT: ID = ',ID
!      ISKIP = 1
!      IF( ISKIP.EQ.0 ) THEN
!
!---  Initialize global arrays  ---
!
      CALL INTLZ_GT
!      PRINT *,'Post INTLZ_GT: ID = ',ID
!
!---  Configure the arrays for compressed sparse row matrix storage  ---
!
      CALL JCBP_GT
!      PRINT *,'Post JCBP_GT: ID = ',ID
!
!---  Compute primary variable increments  ---
!
      CALL INCRM_GT
!      PRINT *,'Post INCRM_GT: ID = ',ID
!
!---  Compute fracture and borehole primary variable increments  ---
!
      IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL INCRM_FRC_GT 
!      PRINT *,'Post INCRM_FRC_GT: ID = ',ID
!      IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL INCRM_BH_GT
!
!---  Hydrologic and thermodynamic properties  ---
!
      CALL PROP_GT
!      PRINT *,'Post PROP_GT: ID = ',ID
      CALL BCP_GT
!      PRINT *,'Post BCP_GT: ID = ',ID
!
!---  Load old time step arrays, values to be used in the initial
!     call to PROP_FRC_GT  ---
!
      CALL LDO_GT
!      PRINT *,'Post LDO_GT: ID = ',ID
!
!---  Initial hydrologic and thermodynamic properties for active
!     fracture triangles and borehole nodes  ---
!
      IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL PROP_FRC_GT
!      PRINT *,'Post PROP_FRC_GT: ID = ',ID
!      IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL PROP_BH_GT
!
!---  Compute initial solute concentrations  ---
!
      CALL CISC_GT
!      PRINT *,'Post CISC_GT: ID = ',ID
!
!---  Compute initial solute concentrations for active
!     fracture triangles and borehole nodes  ---
!
      IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL CISC_FRC_GT
!      PRINT *,'Post CISC_FRC_GT: ID = ',ID
!      IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL CISC_BH_GT
!      PRINT *,'Post CISC_BH_GT: ID = ',ID
!
!---  Reactive transport  ---
!
      IF( ISLC(40).EQ.1 ) THEN
!
!---    Convert initial reactive species concentrations to
!       node volume basis, mol/m^3  ---
!
        CALL FLHSP
!
!---    Temporarily store time stepping  ---
!
        DT_RST = DT
        DTI_RST = DTI
        TM_RST = TM
!
!---    Loop over number of conservation component species  ---
!
        DO NEQ = 1,NEQC
          NSL = NEQ + NSOLU
!
!---      Mobile conservation component fractions   ---
!
          CALL MOBCF( NEQ )
!
!---      Add immobile conservation component fractions   ---
!
          CALL IMOBCF( NEQ )
        ENDDO
!
!---    Loop over number of kinetic component species  ---
!
        DO NEQ = 1,NEQK
          NSL = NEQ + NEQC + NSOLU
!
!---      Mobile kinetic component fractions   ---
!
          CALL MOBKF( NEQ )
!
!---      Add immobile kinetic component fractions   ---
!
          CALL IMOBKF( NEQ )
        ENDDO
!
!---    Equilibrium-conservation-kinetic reaction chemistry   ---
!
        CALL ECKECHEM
!
!---    Reconstitute mineral species concentrations for initial
!       output  ---
!
        CALL RMNSP
!
!---    Reset time stepping  ---
!
        DT = DT_RST
        DTI = DTI_RST
        TM = TM_RST
      ENDIF
!
!---  Compute initial fluxes on non-boundary and boundary surfaces  ---
!
      ISVF = 1
      CALL FLUX_GT
!      PRINT *,'Post FLUX_GT: ID = ',ID
      CALL BCF_GT
!      PRINT *,'Post BCF_GT: ID = ',ID
      ISVF = 2*ISVC + 1
!
!---  Surface flux integrator for zero time step  ---
!
      DTX = DT
      DT = 0.D+0
      CALL SFIN_GT
!      PRINT *,'Post SFIN_GT: ID = ',ID
      DT = DTX
#ifdef lis
!
!---  Create Lis matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
!      PRINT *,'NUKFL(ID+1) = ',NUKFL(ID+1),' ID = ',ID
!      PRINT *,'NUKFO(ID+1) = ',NUKFO(ID+1),' ID = ',ID
!      PRINT *,'NUKFG = ',NUKFG,' ID = ',ID
      CALL STOMP_LIS_CREATE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &  NUKFL(ID+1),INDX )
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!        PRINT *,'NUKTL(ID+1) = ',NUKTL(ID+1),' ID = ',ID
!        PRINT *,'NUKTO(ID+1) = ',NUKTO(ID+1),' ID = ',ID
!        PRINT *,'NUKTG = ',NUKTG,' ID = ',ID
        INDX = 1
        CALL STOMP_LIS_CREATE( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC,
     &    NUKTL(ID+1),INDX )
      ENDIF
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
!        PRINT *,'NUKGL(ID+1) = ',NUKGL(ID+1),' ID = ',ID
!        PRINT *,'NUKGO(ID+1) = ',NUKGO(ID+1),' ID = ',ID
!        PRINT *,'NUKGG = ',NUKGG,' ID = ',ID
        INDX = 2
        CALL STOMP_LIS_CREATE( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC,
     &    NUKGL(ID+1),INDX )
      ENDIF
#endif
#ifdef petsc
!
!---  Create PETSc matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
!      PRINT *,'NUKFL(ID+1) = ',NUKFL(ID+1),' ID = ',ID
!      PRINT *,'NUKFO(ID+1) = ',NUKFO(ID+1),' ID = ',ID
!      PRINT *,'NUKFG = ',NUKFG,' ID = ',ID
      INDX = 0
      CALL STOMP_PETSC_CREATE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &  F_SOL_VEC_S,F_SCATTER,INDX )
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!        PRINT *,'NUKTL(ID+1) = ',NUKTL(ID+1),' ID = ',ID
!        PRINT *,'NUKTO(ID+1) = ',NUKTO(ID+1),' ID = ',ID
!        PRINT *,'NUKTG = ',NUKTG,' ID = ',ID
        INDX = 1
        CALL STOMP_PETSC_CREATE( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC,
     &    T_SOL_VEC_S,T_SCATTER,INDX )
      ENDIF
!
!---    Create Lis matrix, solver, and solution and problem vectors
!       for geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
!        PRINT *,'NUKGL(ID+1) = ',NUKGL(ID+1),' ID = ',ID
!        PRINT *,'NUKGO(ID+1) = ',NUKGO(ID+1),' ID = ',ID
!        PRINT *,'NUKGG = ',NUKGG,' ID = ',ID
        INDX = 2
        CALL STOMP_PETSC_CREATE( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC,
     &    G_SOL_VEC_S,G_SCATTER,INDX )
      ENDIF
#endif
!
!---  Check for fatal execution errors and stop simulation
!     if detected  ---
!
      CALL CHK_ERROR
!      PRINT *,'Post CHK_ERROR: ID = ',ID
!
!---  New Time Step ---
!
      IF( ID.EQ.0 ) ICNO = 10
      TSLOOP: DO
!
!---    Reference node(s) output  ---
!
        IF( MOD( (NSTEP-NRST),IFQO ).EQ.0 ) THEN
          CALL REFNOD_GT
          IF( ID.EQ.0 ) THEN
            IF( ICNO.EQ.10 ) THEN
              ICNO = 0
              NCH = INDEX(UNTM(1:),'  ') - 1
              PRINT *,'       Step         Itr           Time' //
     &          ' [',UNTM(1:NCH),']             Timestep [',
     &          UNTM(1:NCH),']'
            ENDIF
            ICNO = ICNO + 1
            PRINT *,NSTEP,NITER,TM*CNVTM,DT*CNVTM
          ENDIF
        ENDIF
!
!---    Normalize mineral species concentrations after initial
!       output for normal simulations  ---
!
        IF( ISLC(40).EQ.1 .AND. (NSTEP-NRST).EQ.0 ) CALL NMNSP
!
!---    Load old time step arrays  ---
!
        CALL LDO_GT
!        PRINT *,'Post LDO_GT: ID = ',ID
!
!---    Load old time step arrays for active fracture triangles
!       and borehole nodes  ---
!
        IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL LDO_FRC_GT
!        PRINT *,'Post LDO_FRC_GT: ID = ',ID
!        IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL LDO_BH_GT
!
!---    Stop simulation if simulation time exceeds limit  ---
!
        IF( ABS(TMMX-TM).LE.1.D-6 ) THEN
          IF( ID.EQ.0 ) PRINT *,'Simulation Stopped:  ' //
     &      'Simulation Time Limit'
          EXIT TSLOOP
        ENDIF
!
!---    Restart and plot file outputs  ---
!
        IF( ABS(TMPR-TM).LE.1.D-6 ) THEN
          CALL WRPLOT_GT
          IF( ISLC(18).LT.1 ) CALL WRRST_GT
        ENDIF
!
!---    Compute the next time step and increment time step counter  ---
!
        DTSO = DT
        CALL TMSTEP
!       PRINT *,'Post TMSTEP: ID = ',ID
        IF( NSTEP.EQ.0 ) DTSO = DT
        NSTEP = NSTEP + 1
        IF( NSTEP-NRST.GT.MXSTEP ) THEN
          IF( ID.EQ.0 ) PRINT *,'Simulation Stopped:  Time Step Limit'
          NSTEP = NSTEP - 1
          EXIT TSLOOP
        ENDIF
!
!---    New Newton-Raphson iteration ---
!
        NITER = 0
        NRLOOP: DO
          IF( ICNV.EQ.1 ) NITER = 0
          NITER = NITER + 1
!
!---      Compute boundary saturation, relative permeability, and
!         thermodynamic properties  ---
!
          CALL BCP_GT
!         PRINT *,'Post BCP_GT: ID = ',ID
!
!---      Compute source contributions  ---
!
          CALL SORC_GT
!         PRINT *,'Post SORC_GT: ID = ',ID
!
!---      Compute fluxes on non-boundary and boundary surfaces  ---
!
          CALL FLUX_GT
!          PRINT *,'Post FLUX_GT: ID = ',ID
          CALL BCF_GT
!          PRINT *,'Post BCF_GT: ID = ',ID
!
!---      Zero Jacobian matrix  ---
!
          CALL JCBZ_GT
!          PRINT *,'Post JCBZ_GT: ID = ',ID
!
!---      Load Jacobian matrix for the water, air
!         and salt mass equations (zero flux boundary)  ---
!
          CALL JCB_GT
!          PRINT *,'Post JCB_GT: ID = ',ID
!
!---      Modify the Jacobian matrix for boundary conditions  ---
!
          CALL BCJ_GT
!          PRINT *,'Post BCJ_GT: ID = ',ID
!
!---      Set values of the Jacobian matrix  ---
!
          CALL JCB_SV
!          PRINT *,'Post JCB_SV: ID = ',ID
!
!---      Check for fatal execution errors and stop simulation
!         if detected  ---
!
          CALL CHK_ERROR
!          PRINT *,'Post CHK_ERROR: ID = ',ID
!
!---      Solve the linear system A x = b for coupled flow  ---
!
#ifdef lis
          INDX = 0
          CALL STOMP_LIS_SOLVE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &      NUKFO(ID+1),NUKFL(ID+1),INDX )
!          PRINT *,'Post STOMP_LIS_SOLVE:ID = ',ID
          IF( ICNV.EQ.4 ) EXIT TSLOOP
#endif
#ifdef petsc
          INDX = 0
          CALL STOMP_PETSC_SOLVE( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &      F_SOL_VEC_S,F_SCATTER,INDX )
!          PRINT *,'Post STOMP_PETSC_SOLVE:ID = ',ID
          IF( ICNV.EQ.4 ) EXIT TSLOOP
#endif
!          PRINT *,'Post STOMP_LIS_SOLVE: ID = ',ID
!
!---      Check for fatal execution errors and stop simulation
!         if detected  ---
!
          CALL CHK_ERROR
!          PRINT *,'Post CHK_ERROR: ID = ',ID
!
!---      Update primary variables on field nodes w/o ghost cells  ---
!
          CALL UPDT_GT
!          PRINT *,'Post UPDT_GT: ID = ',ID
!
!---      Update fracture primary variables  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL UPDT_FRC_GT
!          PRINT *,'Post UPDT_FRC_GT: ID = ',ID
!
!---      Communicate field node variables to fracture triangles  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL COMM_FRC_GT
!          PRINT *,'Post COMM_FRC_GT: ID = ',ID
#ifdef lis
!
!---      Update primary variables on ghost cells  ---
!
          CALL UPDT_GC_GT
!          PRINT *,'Post UPDT_GC_GT: ID = ',ID
!
!---      Update primary variables on ghost triangles  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL UPDT_FRC_GC_GT
!          PRINT *,'Post UPDT_FRC_GC_GT: ID = ',ID
#endif
!
!---      Compute convergence from maximum relative residuals  ---
!
          CALL RSDL_GT
!          PRINT *,'Post RSDL_GT: ID = ',ID
!
!---      Compute borehole and fracture flow convergence from 
!         maximum relative residuals  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL RSDL_BF_GT
!          PRINT *,'Post RSDL_BF_GT: ID = ',ID
!
!---      Compute primary variable increments, saturation,
!         relative permeability, porosity, tortuosity,
!         thermodynamic properties for interior nodes,
!         except immediately after a new time step  ---
!
          CALL INCRM_GT
!          PRINT *,'Post INCRM_GT: ID = ',ID
          CALL PROP_GT
!          PRINT *,'Post PROP_GT: ID = ',ID
!
!---      Increment fracture primary variables  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL INCRM_FRC_GT
!          PRINT *,'Post INCRM_FRC_GT: ID = ',ID
!
!---      Fracture secondary field variables  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL PROP_FRC_GT
!          PRINT *,'Post PROP_FRC_GT: ID = ',ID
!
!---      Convergence check  ---
!
!         ICNV = 1 - cut time step and restart Newton-Raphson loop
!         ICNV = 2 - next Newton-Raphson loop
!         ICNV = 3 - converged solution next time step
!         ICNV = 4 - total convergence failure stop simulation
!
!          IF( ID.EQ.0 ) THEN
!            PRINT *,'NSTEP = ',NSTEP,' NITER = ',NITER
!            DO M = 1,ISVC
!              PRINT *,'RSD(',M,') = ',RSD(M),
!     &          'NSD(',M,') = ',NSD(M),' ICNV = ',ICNV
!            ENDDO
!          ENDIF
          IF( ICNV.EQ.3 ) EXIT NRLOOP
          IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---    Proceed to new Newton-Raphson iteration  ---
!
        ENDDO NRLOOP
!
!---    Compute current fluxes for transport solutions or flux
!       integrations  ---
!
        ISVF = 1
        CALL FLUX_GT
        CALL BCF_GT
        ISVF = 2*ISVC + 1
!
!---    Compute Local Courant Numbers  ---
!
        IF( ICRNT.EQ.1 ) CALL CRNTNB
        ISVF = 2*ISVC+1
!
!---    Beginning of transport equation solution  ---
!
        IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
!
!---      Loop over number of solutes  ---
!
          DO NSL = 1,NSOLU
!
!---        Courant number limiting  ---
!
            N_CRN(NSL) = 1
            IF( ISLC(17).NE.0 ) CALL CRN_LIM( NSL )
!            PRINT *,'N_CRN(',NSL,') = ',N_CRN(NSL),' ID = ',ID
!
!---        Sub-time step loop  ---
!
            DO NC = 1,N_CRN(NSL)
              IF( ISLC(17).NE.0 ) TM = MIN( TM+DT,TM_CRN )
!
!---          Compute solute mole fractions ---
!
              CALL SPRP_GT( NSL )
!
!---          Solute transport ---
!
              CALL TPORT_GT( NSL )
              IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---        Bottom of sub-time step loop  ---
!
            ENDDO
!
!---        Courant number limiting, reset time stepping  ---
!
            IF( ISLC(17).NE.0 ) THEN
              DT = DT_CRN
              DTI = DTI_CRN
              TM = TM_CRN
            ENDIF
          ENDDO
!
!---      Decay matrix, fracture, and borehole solutes via Bateman
!         chain decay solution  ---
!
          CALL CHAIN_DECAY
!
!---      Reactive transport  ---
!
          IF( ISLC(40).EQ.1 ) THEN
            N_CRN(NSOLU+1) = 1
            IF( ISLC(17).NE.0 ) CALL CRN_LIM( NSOLU+1 )
!
!---        Courant-limiting sub-time step loop  ---
!
            DO NCR = 1,N_CRN(NSOLU+1)
              IF( ISLC(17).NE.0 ) TM = MIN( TM+DT,TM_CRN )
!
!---          Temporarily store time stepping  ---
!
              DT_RST = DT
              DTI_RST = DTI
              TM_RST = TM
              TM = TM - DT
              N_RST = 1
!
!---          Top of ECKEChem time-step reduction loop  ---
!
              TRLOOP: DO
!
!---            Zero linked sources  ---
!
                CALL ZLKSRC
!
!---            Sub-time step reduction limit exceeded  ---
!
                IF( N_RST.GT.16 ) THEN
                  IF( ID.EQ.0 ) PRINT *, '          ---  ECKEChem ' //
     &              'Sub-Time Step Reduction Limit Exceeded  ---'
                  DT = DT_RST
                  DTI = DTI_RST
                  TM = TM_RST
                  NSTEP = NSTEP-1
                  TM = TM-DT
                  DT = DTO
                  CALL BCK_STP
                  EXIT TSLOOP
                ENDIF
!
!---            Sub-time step loop  ---
!
                DO NC = 1,N_RST
                  TM = TM + DT
!
!---              Loop over number of conservation component species ---
!
                  DO NEQ = 1,NEQC
                    NSL = NEQ + NSOLU
!
!---                Skip transport for linked aqueous air   ---
!
                    IF( ISPLK(6).EQ.NSL ) THEN
                      CALL IMOBCF( NEQ )
!
!---                Transport for conservation component species   ---
!
                    ELSE
!
!---                  Mobile conservation component fractions   ---
!
                      CALL MOBCF( NEQ )
!
!---                  Solute transport ---
!
                      CALL TPORT_GT( NSL )
                      IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---                  Add immobile conservation component fractions  ---
!
                      CALL IMOBCF( NEQ )
                    ENDIF
!
!---              End of conservation component species transport  ---
!
                  ENDDO
!
!---              Loop over number of kinetic component species  ---
!
                  DO NEQ = 1,NEQK
                    NSL = NEQ + NEQC + NSOLU
!
!---                Skip transport for linked aqueous air   ---
!
                    IF( ISPLK(6).EQ.NSL ) THEN
                      CALL IMOBKF( NEQ )
!
!---                Transport for mobile kinetic component species   ---
!
                    ELSE
!
!---                  Mobile kinetic component fractions   ---
!
                      CALL MOBKF( NEQ )
!
!---                  Solute transport ---
!
                      CALL TPORT_GT( NSL )
                      IF( ICNV.EQ.4 ) EXIT TSLOOP
!
!---                  Add immobile kinetic component fractions   ---
!
                      CALL IMOBKF( NEQ )
                    ENDIF
!
!---              End of kinetic component species transport  ---
!
                  ENDDO
!
!---              Equilibrium-conservation-kinetic reaction
!                 chemistry  ---
!
                  CALL ECKECHEM
                  IF( ECKE_ER ) CYCLE TRLOOP
!
!---              Load old sub-time-step reactive species concentrations
!                 and component species concentrations  ---
!
                  IF( ISLC(17).NE.0 ) CALL UPDTCHEM
!
!---            Bottom of sub-time step loop  ---
!
                ENDDO
!
!---             Exit time-step reduction loop  ---
!
                 EXIT TRLOOP
!
!---          Bottom of ECKEChem time-step reduction loop  ---
!
              ENDDO TRLOOP
!
!---          Reset time stepping  ---
!
              IF( N_RST.GT.1 ) THEN
                DT = DT_RST
                DTI = DTI_RST
                TM = TM_RST
              ENDIF
            ENDDO
!
!---        Courant number limiting, reset time stepping  ---
!
            IF( ISLC(17).NE.0 ) THEN
              DT = DT_CRN
              DTI = DTI_CRN
              TM = TM_CRN
            ENDIF
          ENDIF
        ENDIF
!
!---    Surface flux integrator  ---
!
        CALL SFIN_GT
!
!---  Proceed to new time step  ---
!
      ENDDO TSLOOP
#ifdef lis
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for coupled flow  ---
!
      CALL STOMP_LIS_DESTROY( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC )
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
        CALL STOMP_LIS_DESTROY( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC )
      ENDIF
!
!---  Destroy Lis matrix, solver, and solution and problem vectors
!     for geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
        CALL STOMP_LIS_DESTROY( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC )
      ENDIF
!
!---  Finalize Lis execution  ---
!
      CALL LIS_FINALIZE( IERR )
#endif
#ifdef petsc
!
!---  Destroy solution vector, problem vector, matrix, solver, and
!     solution-vector scatter scheme for the PETSc solver for coupled
!     flow and heat transport  ---
!
      INDX = 0
      CALL STOMP_PETSC_DESTROY( F_KSP,F_MAT,F_RHS_VEC,F_SOL_VEC,
     &  F_SOL_VEC_S,F_SCATTER,INDX )
!
!---  Destroy solution vector, problem vector, matrix, solver, and
!     solution-vector scatter scheme for the PETSc solver for 
!     solute transport  ---
!
      IF( IEQC.NE.0 .OR. ISLC(40).NE.0 ) THEN
        INDX = 1
        CALL STOMP_PETSC_DESTROY( T_KSP,T_MAT,T_RHS_VEC,T_SOL_VEC,
     &   T_SOL_VEC_S,T_SCATTER,INDX )
      ENDIF
!
!---  Destroy solution vector, problem vector, matrix, solver, and
!     solution-vector scatter scheme for the PETSc solver for 
!     geomechanics  ---
!
      IF( ISLC(50).NE.0 ) THEN
        INDX = 2
        CALL STOMP_PETSC_DESTROY( G_KSP,G_MAT,G_RHS_VEC,G_SOL_VEC,
     &   G_SOL_VEC_S,G_SCATTER,INDX )
      ENDIF
!
!---  Finalize PETSc execution  ---
!
      CALL PetscFinalize( IERR )
#endif
!
!---  Write plot_xxx.bin file  ---
!
      CALL WRPLOT_GT
!
!---  Write restart_xxx.bin file  ---
!
      CALL WRRST_GT
!
!---  Close output.bin file, putting a closing -9 at the end
!     of the file  ---
!
      NVAR = 1
      IVARX = -9
      OFFSET = IOFFSET_REF
      IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &   MPI_INTEGER,STATUS,IERR)
      CALL MPI_FILE_CLOSE( IWR,IERR )
!
!---  Close surface.bin file(s), putting a closing -9.D+20 at the end
!     of the file  ---
!
      NSTART = 1
      IF( ISFGP(1).EQ.0 ) NSTART = 2
      DO NSG = NSTART,NSFGP
        NVAR = 1
        VARX = -9.D+20
        OFFSET = IOFFSET_SF(NSG)
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( ISF(NSG),OFFSET,VARX,
     &     NVAR,MPI_REAL8,STATUS,IERR)
        CALL MPI_FILE_CLOSE( ISF(NSG),IERR )
      ENDDO
!      ENDIF
      PRINT *,'Fini STOMPX-GT: ID = ',ID
      CALL MPI_FINALIZE(IERR)
!
!---  End of STOMP program  ---
!
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCF_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute boundary surface fluxes.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 BCX(LBCV)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCF_GT'
!      PRINT *,'BCF_GT: NBC(ID+1) = ',NBC(ID+1),'LBCV = ',LBCV,'ID = ',ID
!      PRINT *,'BCF_GT: ND(IBCN(1481)) = ',ND(IBCN(1481)),'ID = ',ID
      DO NB = 1,NBC(ID+1)
        N = IBCN(NB)
        IF( IBCD(NB).EQ.-3 ) THEN
          DO M = 1,ISVF
            WL(M,1,N) = 0.D+0
            WG(M,1,N) = 0.D+0
            WLA(M,1,N) = 0.D+0
            WLW(M,1,N) = 0.D+0
            WGA(M,1,N) = 0.D+0
            WGW(M,1,N) = 0.D+0
            WDLA(M,1,N) = 0.D+0
            WDGW(M,1,N) = 0.D+0
            WS(M,1,N) = 0.D+0
            WDS(M,1,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
          DO M = 1,ISVF
            VL(M,1,N) = 0.D+0
            VG(M,1,N) = 0.D+0
            VLA(M,1,N) = 0.D+0
            VLW(M,1,N) = 0.D+0
            VGA(M,1,N) = 0.D+0
            VGW(M,1,N) = 0.D+0
            VDLA(M,1,N) = 0.D+0
            VDGW(M,1,N) = 0.D+0
            VS(M,1,N) = 0.D+0
            VDS(M,1,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
          DO M = 1,ISVF
            UL(M,1,N) = 0.D+0
            UG(M,1,N) = 0.D+0
            ULA(M,1,N) = 0.D+0
            ULW(M,1,N) = 0.D+0
            UGA(M,1,N) = 0.D+0
            UGW(M,1,N) = 0.D+0
            UDLA(M,1,N) = 0.D+0
            UDGW(M,1,N) = 0.D+0
            US(M,1,N) = 0.D+0
            UDS(M,1,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.1 ) THEN
          DO M = 1,ISVF
            UL(M,2,N) = 0.D+0
            UG(M,2,N) = 0.D+0
            ULA(M,2,N) = 0.D+0
            ULW(M,2,N) = 0.D+0
            UGA(M,2,N) = 0.D+0
            UGW(M,2,N) = 0.D+0
            UDLA(M,2,N) = 0.D+0
            UDGW(M,2,N) = 0.D+0
            US(M,2,N) = 0.D+0
            UDS(M,2,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.2 ) THEN
          DO M = 1,ISVF
            VL(M,2,N) = 0.D+0
            VG(M,2,N) = 0.D+0
            VLA(M,2,N) = 0.D+0
            VLW(M,2,N) = 0.D+0
            VGA(M,2,N) = 0.D+0
            VGW(M,2,N) = 0.D+0
            VDLA(M,2,N) = 0.D+0
            VDGW(M,2,N) = 0.D+0
            VS(M,2,N) = 0.D+0
            VDS(M,2,N) = 0.D+0
          ENDDO
        ELSEIF( IBCD(NB).EQ.3 ) THEN
          DO M = 1,ISVF
            WL(M,2,N) = 0.D+0
            WG(M,2,N) = 0.D+0
            WLA(M,2,N) = 0.D+0
            WLW(M,2,N) = 0.D+0
            WGA(M,2,N) = 0.D+0
            WGW(M,2,N) = 0.D+0
            WDLA(M,2,N) = 0.D+0
            WDGW(M,2,N) = 0.D+0
            WS(M,2,N) = 0.D+0
            WDS(M,2,N) = 0.D+0
          ENDDO
        ENDIF
      ENDDO
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
!
!---  Assign local boundary condition variables  ---
!
        IF( IBCM(NB).EQ.1 ) THEN
          DO N = 1,LBCV
            BCX(N) = BC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,IBCM(NB)
            IF( TMZ.LE.BC(1,M,MB) ) THEN
             TDBC = (BC(1,M,MB)-BC(1,M-1,MB))
             DTBC = MIN( BC(1,M,MB)-TMZ,DT )
             TFBC = (TMZ-BC(1,M-1,MB))/TDBC
             DO N = 1,LBCV
               BCX(N) = BC(N,M-1,MB) + TFBC*(BC(N,M,MB)-BC(N,M-1,MB))
             ENDDO
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
        N = IBCN(NB)
        N_DB = -NB
        ITFX = MOD(IBCT(2,NB),100)
!
!---    Bottom boundary  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
!
!---      Fluid flow Neumann  ---
!
          IF( ITFX.EQ.2 ) THEN
!
!---        Aqueous saturated (BC1)  ---
!
            IF( IBCT(2,NB)/100.EQ.1 ) THEN
              WLX = BCX(3)
              WGX = 0.D+0
!
!---        Aqueous partially saturated (BC2)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.2 ) THEN
              WLX = BCX(3)*BCX(4)
              WGX = BCX(3)*(1.D+0-BCX(4))
!
!---        Aqueous unsaturated (BC3)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.3 ) THEN
              WLX = 0.D+0
              WGX = BCX(3)
            ENDIF
            DO M = 1,ISVF
              WL(M,1,N) = WLX
              WG(M,1,N) = WGX
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWB_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSB_GT( N,NB )
!
!---      Fluid flow aqueous Neumann  ---
!
          ELSEIF( ITFX.EQ.12 ) THEN
            DO M = 1,ISVF
              WL(M,1,N) = BCX(3)
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWB_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSB_GT( N,NB )
!
!---      Fluid flow Seepage Face  ---
!
          ELSEIF( ITFX.EQ.13 ) THEN
            CALL DRCVLB_GT( N,NB )
!
!---      Fluid flow evaporative  ---
!
          ELSEIF( ITFX.EQ.25 ) THEN
            CALL DRCVGB_GT( N,NB )
            CALL DFFGAWB_GT( N,NB )
!
!---      Fluid flow Dirichlet, Saturated, or Unit Gradient  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL DRCVLB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFLAWB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWB_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSB_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                WQ(M,1,N) = BCX(2)
              ENDDO
!
!---        Energy outflow  ---
!
            ELSEIF( IBCT(1,NB).EQ.6 ) THEN
              CALL THALB_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGB_GT( N,NB )
!
!---        Energy not zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDB_GT( N,NB )
              CALL THALB_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGB_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THDGB_GT( N,NB )
            ENDIF
          ENDIF
!
!---    South boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
!
!---      Flow flow Neumann  ---
!
          IF( ITFX.EQ.2 ) THEN
!
!---        Aqueous saturated (BC1)  ---
!
            IF( IBCT(2,NB)/100.EQ.1 ) THEN
              VLX = BCX(3)
              VGX = 0.D+0
!
!---        Aqueous partially saturated (BC2)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.2 ) THEN
              VLX = BCX(3)*BCX(4)
              VGX = BCX(3)*(1.D+0-BCX(4))
!
!---        Aqueous unsaturated (BC3)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.3 ) THEN
              VLX = 0.D+0
              VGX = BCX(3)
            ENDIF
            DO M = 1,ISVF
              VL(M,1,N) = VLX
              VG(M,1,N) = VGX
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWS_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSS_GT( N,NB )
!
!---      Fluid flow Aqueous Neumann  ---
!
          ELSEIF( ITFX.EQ.12 ) THEN
            DO M = 1,ISVF
              VL(M,1,N) = BCX(3)
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWS_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSS_GT( N,NB )
!
!---      Fluid flow Seepage Face  ---
!
          ELSEIF( ITFX.EQ.13 ) THEN
            CALL DRCVLS_GT( N,NB )
!
!---      Fluid flow evaporative  ---
!
          ELSEIF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL DRCVGS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWS_GT( N,NB )
!
!---      Fluid flow Dirichlet, Saturated, or Unit Gradient  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL DRCVLS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFLAWS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWS_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSS_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                VQ(M,1,N) = BCX(2)
              ENDDO
!
!---        Energy outflow  ---
!
            ELSEIF( IBCT(1,NB).EQ.6 ) THEN
              CALL THALS_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGS_GT( N,NB )
!
!---        Energy not zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDS_GT( N,NB )
              CALL THALS_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGS_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THDGS_GT( N,NB )
            ENDIF
          ENDIF
!
!---    West boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
!
!---      Fluid flow Neumann  ---
!
          IF( ITFX.EQ.2 ) THEN
!
!---        Aqueous saturated (BC1)  ---
!
            IF( IBCT(2,NB)/100.EQ.1 ) THEN
              ULX = BCX(3)
              UGX = 0.D+0
!
!---        Aqueous partially saturated (BC2)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.2 ) THEN
              ULX = BCX(3)*BCX(4)
              UGX = BCX(3)*(1.D+0-BCX(4))
!
!---        Aqueous unsaturated (BC3)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.3 ) THEN
              ULX = 0.D+0
              UGX = BCX(3)
            ENDIF
            DO M = 1,ISVF
              UL(M,1,N) = ULX
              UG(M,1,N) = UGX
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWW_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSW_GT( N,NB )
!
!---      Fluid flow Aqueous Neumann  ---
!
          ELSEIF( ITFX.EQ.12 ) THEN
            DO M = 1,ISVF
              UL(M,1,N) = BCX(3)
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWW_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSW_GT( N,NB )
!
!---      Fluid flow Seepage Face  ---
!
          ELSEIF( ITFX.EQ.13 ) THEN
            CALL DRCVLW_GT( N,NB )
!
!---      Fluid flow evaporative  ---
!
          ELSEIF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL DRCVGW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWW_GT( N,NB )
!
!---      Fluid flow Dirichlet, Saturated, or Unit Gradient  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL DRCVLW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFLAWW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWW_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSW_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                UQ(M,1,N) = BCX(2)
              ENDDO
!
!---        Energy outflow  ---
!
            ELSEIF( IBCT(1,NB).EQ.6 ) THEN
              CALL THALW_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGW_GT( N,NB )
!
!---        Energy not zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDW_GT( N,NB )
              CALL THALW_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGW_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THDGW_GT( N,NB )
            ENDIF
          ENDIF
!
!---    East boundary  ---
!
        ELSEIF( IBCD(NB).EQ.1 ) THEN
!
!---      Fluid flow Neumann  ---
!
          IF( ITFX.EQ.2 ) THEN
!
!---        Aqueous saturated (BC1)  ---
!
            IF( IBCT(2,NB)/100.EQ.1 ) THEN
              ULX = BCX(3)
              UGX = 0.D+0
!
!---        Aqueous partially saturated (BC2)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.2 ) THEN
              ULX = BCX(3)*BCX(4)
              UGX = BCX(3)*(1.D+0-BCX(4))
!
!---        Aqueous unsaturated (BC3)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.3 ) THEN
              ULX = 0.D+0
              UGX = BCX(3)
            ENDIF
            DO M = 1,ISVF
              UL(M,2,N) = ULX
              UG(M,2,N) = UGX
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWE_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSE_GT( N,NB )
!
!---      Fluid flow Aqueous Neumann  ---
!
          ELSEIF( ITFX.EQ.12 ) THEN
            DO M = 1,ISVF
              UL(M,2,N) = BCX(3)
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWE_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSE_GT( N,NB )
!
!---      Fluid flow Seepage Face  ---
!
          ELSEIF( ITFX.EQ.13 ) THEN
            CALL DRCVLE_GT( N,NB )
!
!---      Fluid flow evaporative  ---
!
          ELSEIF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL DRCVGE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWE_GT( N,NB )
!
!---      Fluid flow Dirichlet, Saturated, or Unit Gradient  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL DRCVLE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFLAWE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWE_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSE_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                UQ(M,2,N) = BCX(2)
              ENDDO
!
!---        Energy outflow  ---
!
            ELSEIF( IBCT(1,NB).EQ.6 ) THEN
              CALL THALE_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGE_GT( N,NB )
!
!---        Energy not zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDE_GT( N,NB )
              CALL THALE_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGE_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THDGE_GT( N,NB )
            ENDIF
          ENDIF
!
!---    North boundary  ---
!
        ELSEIF( IBCD(NB).EQ.2 ) THEN
!
!---      Fluid flow Neumann  ---
!
          IF( ITFX.EQ.2 ) THEN
!
!---        Aqueous saturated (BC1)  ---
!
            IF( IBCT(2,NB)/100.EQ.1 ) THEN
              VLX = BCX(3)
              VGX = 0.D+0
!
!---        Aqueous partially saturated (BC2)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.2 ) THEN
              VLX = BCX(3)*BCX(4)
              VGX = BCX(3)*(1.D+0-BCX(4))
!
!---        Aqueous unsaturated (BC3)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.3 ) THEN
              VLX = 0.D+0
              VGX = BCX(3)
            ENDIF
            DO M = 1,ISVF
              VL(M,2,N) = VLX
              VG(M,2,N) = VGX
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWN_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSN_GT( N,NB )
!
!---      Fluid flow Aqueous Neumann  ---
!
          ELSEIF( ITFX.EQ.12 ) THEN
            DO M = 1,ISVF
              VL(M,2,N) = BCX(3)
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWN_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSN_GT( N,NB )
!
!---      Fluid flow Seepage Face  ---
!
          ELSEIF( ITFX.EQ.13 ) THEN
            CALL DRCVLN_GT( N,NB )
!
!---      Fluid flow evaporative  ---
!
          ELSEIF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL DRCVGN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWN_GT( N,NB )
!
!---      Fluid flow Dirichlet, Saturated, or Unit Gradient  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL DRCVLN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFLAWN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWN_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLSN_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                VQ(M,2,N) = BCX(2)
              ENDDO
!
!---        Energy outflow  ---
!
            ELSEIF( IBCT(1,NB).EQ.6 ) THEN
              CALL THALN_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGN_GT( N,NB )
!
!---        Energy not zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDN_GT( N,NB )
              CALL THALN_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGN_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THDGN_GT( N,NB )
            ENDIF
          ENDIF
!
!---    Top boundary  ---
!
        ELSEIF( IBCD(NB).EQ.3 ) THEN
!
!---      Fluid flow Neumann  ---
!
          IF( ITFX.EQ.2 ) THEN
!
!---        Aqueous saturated (BC1)  ---
!
            IF( IBCT(2,NB)/100.EQ.1 ) THEN
              WLX = BCX(3)
              WGX = 0.D+0
!
!---        Aqueous partially saturated (BC2)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.2 ) THEN
              WLX = BCX(3)*BCX(4)
              WGX = BCX(3)*(1.D+0-BCX(4))
!
!---        Aqueous unsaturated (BC3)  ---
!
            ELSEIF( IBCT(2,NB)/100.EQ.3 ) THEN
              WLX = 0.D+0
              WGX = BCX(3)
            ENDIF
            DO M = 1,ISVF
              WL(M,2,N) = WLX
              WG(M,2,N) = WGX
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWT_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLST_GT( N,NB )
!
!---      Fluid flow Aqueous Neumann  ---
!
          ELSEIF( ITFX.EQ.12 ) THEN
            DO M = 1,ISVF
              WL(M,2,N) = BCX(3)
            ENDDO
            IF( ISLC(37).EQ.0 ) CALL DFFLAWT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWT_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLST_GT( N,NB )
!
!---      Fluid flow Seepage Face  ---
!
          ELSEIF( ITFX.EQ.13 ) THEN
            CALL DRCVLT_GT( N,NB )
!
!---      Fluid flow evaporative  ---
!
          ELSEIF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL DRCVGT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWT_GT( N,NB )
!
!---      Fluid flow Dirichlet, Saturated, or Unit Gradient  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL DRCVLT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFLAWT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DRCVGT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL DFFGAWT_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL DFFLST_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy Neumann  ---
!
            IF( IBCT(1,NB).EQ.2 ) THEN
              DO M = 1,ISVF
                WQ(M,2,N) = BCX(2)
              ENDDO
!
!---        Energy outflow  ---
!
            ELSEIF( IBCT(1,NB).EQ.6 ) THEN
              CALL THALT_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGT_GT( N,NB )
!
!---        Energy not zero flux  ---
!
            ELSEIF( IBCT(1,NB).NE.3 ) THEN
              CALL THDT_GT( N,NB )
              CALL THALT_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THAGT_GT( N,NB )
              IF( ISLC(37).EQ.0 ) CALL THDGT_GT( N,NB )
            ENDIF
          ENDIF
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCF_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCJ_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Modify the Jacobian matrix for boundary conditions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCJ_GT'
!      PRINT *,'BCJ_GT: NBC(ID+1) = ',NBC(ID+1),'LBCV = ',LBCV,'ID = ',ID
!      PRINT *,'BCJ_GT1: ND(IBCN(1481)) = ',ND(IBCN(1481)),'ID = ',ID
!
!---  Loop over boundary conditions  ---
!
      DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
        IF( IBCM(NB).GT.1 .AND. TMZ.GT.BC(1,IBCM(NB),MB) ) CYCLE
        N = IBCN(NB)
        N_DB = -NB
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
        ITFX = MOD(IBCT(2,NB),100)
!
!---    Bottom boundary  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
!
!---      Fluid flow evaporative  ---
!
          IF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL JCBGWB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAB_GT( N,NB )
!
!---      Fluid flow and salt transport  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL JCBLWB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBLAB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGWB_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAB_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL JCBSB_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy  ---
!
            IF( IBCT(1,NB).NE.3 ) THEN
              CALL JCBTB_GT( N,NB )
            ENDIF
          ENDIF
!
!---    South boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
!
!---      Fluid flow evaporative  ---
!
          IF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL JCBGWS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAS_GT( N,NB )
!
!---      Fluid flow and salt transport  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL JCBLWS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBLAS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGWS_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAS_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL JCBSS_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy  ---
!
            IF( IBCT(1,NB).NE.3 ) THEN
              CALL JCBTS_GT( N,NB )
            ENDIF
          ENDIF
!
!---    West boundary  ---
!
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
!
!---      Fluid flow evaporative  ---
!
          IF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL JCBGWW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAW_GT( N,NB )
!
!---      Fluid flow and salt transport  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL JCBLWW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBLAW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGWW_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAW_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL JCBSW_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy  ---
!
            IF( IBCT(1,NB).NE.3 ) THEN
              CALL JCBTW_GT( N,NB )
            ENDIF
          ENDIF
!
!---    East boundary  ---
!
        ELSEIF( IBCD(NB).EQ.1 ) THEN
!
!---      Fluid flow evaporative  ---
!
          IF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL JCBGWE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAE_GT( N,NB )
!
!---      Fluid flow and salt transport  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL JCBLWE_GT( N,NB,NQX )
            IF( ISLC(37).EQ.0 ) CALL JCBLAE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGWE_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAE_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL JCBSE_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy  ---
!
            IF( IBCT(1,NB).NE.3 ) THEN
              CALL JCBTE_GT( N,NB )
            ENDIF
          ENDIF
!
!---    North boundary
!
        ELSEIF( IBCD(NB).EQ.2 ) THEN
!
!---      Fluid flow evaporative  ---
!
          IF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL JCBGWN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAN_GT( N,NB )
!
!---      Fluid flow and salt transport  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL JCBLWN_GT( N,NB,NQY )
            IF( ISLC(37).EQ.0 ) CALL JCBLAN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGWN_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAN_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL JCBSN_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy  ---
!
            IF( IBCT(1,NB).NE.3 ) THEN
              CALL JCBTN_GT( N,NB )
            ENDIF
          ENDIF
!
!---    Top boundary  ---
!
        ELSEIF( IBCD(NB).EQ.3 ) THEN
!
!---      Fluid flow evaporative  ---
!
          IF( ITFX.EQ.25 ) THEN
            IF( ISLC(37).EQ.0 ) CALL JCBGWT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAT_GT( N,NB )
!
!---      Fluid flow and salt transport  ---
!
          ELSEIF( ITFX.NE.3 ) THEN
            CALL JCBLWT_GT( N,NB,NQZ )
            IF( ISLC(37).EQ.0 ) CALL JCBLAT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGWT_GT( N,NB )
            IF( ISLC(37).EQ.0 ) CALL JCBGAT_GT( N,NB )
            IF( ISLC(32).EQ.0 ) CALL JCBST_GT( N,NB )
          ENDIF
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 )  THEN
!
!---        Energy  ---
!
            IF( IBCT(1,NB).NE.3 ) THEN
              CALL JCBTT_GT( N,NB )
            ENDIF
          ENDIF
        ENDIF
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCJ_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE BCP_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute saturation, relative permeability and thermodynamic
!     properties for boundary surfaces.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE PROP
      USE HYST
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 BCX(LBCV),YLSX(3)
      REAL*8 GX(3),RX(2),RPX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/BCP_GT'
!      PRINT *,'BCP_GT: NBC(ID+1) = ',NBC(ID+1),'ID = ',ID
!
!---  Loop over boundary conditions  ---
!
      L1 : DO NB = 1,NBC(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = IBCIN(NB)
        IF( IBCC(NB).EQ.1 ) TMZ = MOD( TM,BC(1,IBCM(NB),MB) )
        IF( TMZ.LE.BC(1,1,MB) ) CYCLE
        ITFX = MOD(IBCT(2,NB),100)
!
!---    Assign local boundary condition variables  ---
!
        IF( IBCM(NB).EQ.1 ) THEN
          DO N = 1,LBCV
            BCX(N) = BC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,IBCM(NB)
            IF( TMZ.LE.BC(1,M,MB) ) THEN
             TDBC = (BC(1,M,MB)-BC(1,M-1,MB))
             DTBC = MIN( BC(1,M,MB)-TMZ,DT )
             TFBC = (TMZ-BC(1,M-1,MB))/TDBC
             DO N = 1,LBCV
               BCX(N) = BC(N,M-1,MB) + TFBC*(BC(N,M,MB)-BC(N,M-1,MB))
             ENDDO
!
!---         Energy boundary condition  ---
!
             IF( IBCT(1,NB).EQ.2 ) THEN
              BCX(2) = BCX(2)-5.D-1*DTBC*(BC(2,M,MB)-BC(2,M-1,MB))/TDBC
             ENDIF
!
!---         Fluid flow boundary condition  ---
!
             IF( ITFX.EQ.2 ) THEN
               BCX(3) = BCX(3)-5.D-1*DTBC*(BC(3,M,MB)-BC(3,M-1,MB))/TDBC
               BCX(4) = BCX(4)-5.D-1*DTBC*(BC(4,M,MB)-BC(4,M-1,MB))/TDBC
               BCX(5) = BCX(5)-5.D-1*DTBC*(BC(6,M,MB)-BC(6,M-1,MB))/TDBC
             ENDIF
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
!
!---    Initial condition boundary condition  ---
!
        IF( IBCT(1,NB).EQ.4 ) THEN
          BCX(2) = TB(1,NB)
        ENDIF
        IF( ITFX.EQ.4 ) THEN
          IF( IBCT(2,NB).EQ.104 ) THEN
            BCX(3) = PLB(1,NB)
            BCX(4) = XLAB(1,NB)
            BCX(5) = YLSB(1,NB)
          ELSEIF( IBCT(2,NB).EQ.204 ) THEN
            BCX(3) = PGB(1,NB)
            BCX(4) = SLB(1,NB)
          ELSEIF( IBCT(2,NB).EQ.304 ) THEN
            BCX(3) = PGB(1,NB)
            BCX(4) = XGWB(1,NB)
          ENDIF
        ENDIF
        N = IBCN(NB)
        IBD = ABS(IBCD(NB))
        N_DB = -NB
!
!---    ECKEChem  ---
!
        POR0(1,N) = POR0(1,N)
        POR0(2,N) = POR0(2,N)
!
!---    Assign gas-entry pressure for non Brooks-Corey;
!       Brooks-Corey; Brooks-Corey, Dual Porosity; and
!       Brooks-Corey, Entrapment  ---
!
        IF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &      ISCHR(N).EQ.202 ) THEN
          ENPR = SCHR(1,N)*RHORL*GRAV
        ELSEIF( ISCHR(N).EQ.4 ) THEN
          ENPR = MIN( SCHR(1,N),SCHR(5,N) )*RHORL*GRAV
        ELSE
          ENPR = 0.D+0
        ENDIF
!
!---    Initial trapped gas saturation for the van Genuchten or
!       Brooks/Corey entrapment model  ---
!
        IF( ISCHR(N).EQ.101 .OR. ISCHR(N).EQ.102 .OR.
     &      ISCHR(N).EQ.201 .OR. ISCHR(N).EQ.202 ) THEN
!
!---      w/ Webb extension  ---
!
          IF( ISM(N).EQ.2 ) THEN
            ESGTMX = SCHR(15,N)
!
!---      w/o Webb extension  ---
!
          ELSE
            ESGTMX = SCHR(15,N)/(1.D+0-SCHR(4,N))
          ENDIF
        ELSE
          ESGTMX = 0.D+0
        ENDIF
!
!---    Boundary Direction  ---
!
        IF( IBCD(NB).EQ.-3 ) THEN
          DB = 0.5D+0*DZGF(N)
          GB = GRVZ(1,N)*DB
          GBX = GRVZ(1,N)
          AFBX = AFZ(1,N)
        ELSEIF( IBCD(NB).EQ.-2 ) THEN
          DB = 0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(1,N)*DB
          GBX = GRVY(1,N)
          AFBX = AFY(1,N)
        ELSEIF( IBCD(NB).EQ.-1 ) THEN
          DB = 0.5D+0*DXGF(N)
          GB = GRVX(1,N)*DB
          GBX = GRVX(1,N)
          AFBX = AFX(1,N)
        ELSEIF( IBCD(NB).EQ.1 ) THEN
          DB = -0.5D+0*DXGF(N)
          GB = GRVX(2,N)*DB
          GBX = GRVX(2,N)
          AFBX = AFX(2,N)
        ELSEIF( IBCD(NB).EQ.2 ) THEN
          DB = -0.5D+0*DYGF(N)*RP(N)
          GB = GRVY(2,N)*DB
          GBX = GRVY(2,N)
          AFBX = AFY(2,N)
        ELSEIF( IBCD(NB).EQ.3 ) THEN
          DB = -0.5D+0*DZGF(N)
          GB = GRVZ(2,N)*DB
          GBX = GRVZ(2,N)
          AFBX = AFZ(2,N)
        ENDIF
        LBCX = MAX( NBC(ID+1),1 )
!
!---    Loop over secondary variable indices  ---
!
        L2: DO M = 2,ISVC+2
          TX = T(M,N)
          PLX = PL(M,N) + PATM
          PGX = PG(M,N) + PATM
          ISKIP1 = 0
          ISKIP2 = 0
!
!---      Energy Dirichlet or initial conditions  ---
!
          IF( IBCT(1,NB).EQ.1 .OR. IBCT(1,NB).EQ.4 ) THEN
            TX = BCX(2)
!
!---      Energy Neumann  ---
!
          ELSEIF( IBCT(1,NB).EQ.2 ) THEN
            INDX = ABS( IBCD(NB) )
            TKP = THKE_L( N,SL(M,N),THKL(M,N),PORD(M,N),
     &        PORT(M,N),INDX )
            TX = TX + BCX(2)*DB/TKP
!
!---      Geothermal gradient  ---
!
          ELSEIF( IBCT(1,NB).EQ.8 ) THEN
            TX = BCX(2) + BCX(7)*(ZPBC(NB)-BCX(6))
!
!---      Barometric formula  ---
!
          ELSEIF( IBCT(1,NB).EQ.12 ) THEN
!
!---        Temperature lapse rate, K/m  ---
!
            TLRX = BCX(7)
            TBX = BCX(2)
            TKBX = BCX(2) + TABS
            PGBX = BCX(4) + PATM
            TX = TBX + TLRX*(ZPBC(NB)-BCX(6))
!
!---        Non-zero lapse rate  ---
!
            IF( ABS(TLRX).GT.EPSL ) THEN
              PGX = PGBX*(TKBX/(TKBX + TLRX*(ZPBC(NB)-BCX(6))))**
     &          (GBX*WTMA/(RCU*TLRX))
!
!---        Zero lapse rate  ---
!
            ELSE
              PGX = PGBX*EXP(-GBX*WTMA*(ZPBC(NB)-BCX(6))/(RCU*TBX))
            ENDIF
!
!---      Energy Convective  ---
!
          ELSEIF( IBCT(1,NB).EQ.18 ) THEN
            INDX = ABS( IBCD(NB) )
            TKP = THKE_L( N,SL(M,N),THKL(M,N),PORD(M,N),
     &        PORT(M,N),INDX )
            TX = (TX*TKP/ABS(DB) + BCX(2)*BCX(6))
     &        /(TKP/ABS(DB) + BCX(6))
!
!---      Energy Convective-Radiative  ---
!
          ELSEIF( IBCT(1,NB).EQ.28 ) THEN
            INDX = ABS( IBCD(NB) )
            TKP = THKE_L( N,SL(M,N),THKL(M,N),PORD(M,N),
     &        PORT(M,N),INDX )
            TSX = TX
            DO
              TKS = TSX+TABS
              TKR = BCX(LBCU)+TABS
              TKC = BCX(2)+TABS
              TKX = TX+TABS
              HCX = 1.259D+0*(MAX( TKS-TKC,0.D+0 ))**(3.3333D-1)
              HRX = 5.6699D-8*(TKS**3+(TKS**2)*TKR+TKS*(TKR**2)+TKR**3)
              UX = (TKX*TKP/ABS(DB) + TKC*HCX + TKR*HRX)
              VX = (TKP/ABS(DB) + HCX + HRX)
              UXX = HCX*3.3333D-1/(TKS-TKC)
              VXX = 5.6699D-8*(3.D+0*(TKS**2)+2.D+0*TKS*TKR+(TKR**2))
              DUX = TKC*UXX + TKR*VXX
              DVX = UXX + VXX
              DF = 1.D+0 - DUX/VX + UX*DVX/(VX**2)
              F = TKS - UX/VX
              DTSX = -F/DF
              TSX = TSX + DTSX
              IF( ABS(DTSX)/TKS.LE.1.D-8 ) EXIT
            ENDDO
            TX = TSX
!
!---      Energy Convective  ---
!
          ELSEIF( IBCT(1,NB).EQ.29 ) THEN
            INDX = ABS( IBCD(NB) )
            TKP = THKE_L( N,SL(M,N),THKL(M,N),PORD(M,N),
     &        PORT(M,N),INDX )
            TX = (TX*TKP/ABS(DB) + BCX(2)*BCX(LBCU))
     &        /(TKP/ABS(DB) + BCX(LBCU))
          ENDIF
!
!---      Boundary condition state #1  ---
!
!         SL = 1.0
!         SG = 0.0
!
!         Declared variables:
!
!         BCX(4) - aqueous air relative saturation, or
!                  aqueous air mass fraction
!         BCX(5) - aqueous salt relative saturation, or
!                  aqueous salt mass fraction
!
          IF( IBCT(2,NB)/100.EQ.1 ) THEN
            SGB(M,NB) = 0.D+0
            SLB(M,NB) = 1.D+0
            SGTX = 0.D+0
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PLX = BCX(3) + PATM
              PGX = PLX
            ELSE
              PLX = MAX( PLX,PGX )
              PGX = MAX( PLX,PGX )
            ENDIF
            PX = MAX( PLX,PGX )
            PVAB(M,NB) = BCX(4)
            TMSX = BCX(5)
!
!---        Input aqueous pressure and aqueous saturation  ---
!
            ICSX = 2
            CALL FLH_IC1( BTGLB(M,NB),PGX,PLX,PVAB(M,NB),
     &        SGTX,SLB(M,NB),TX,TMSX,XMLAB(M,NB),YLSB(M,NB),
     &        IBCT(4,NB),IBCT(3,NB),ICSX,N )
            PGB(M,NB) = PGX - PATM
            PLB(M,NB) = PLX - PATM
            CALL SOL_BRNS( TX,PX,XLSMX )
            XLSB(M,NB) = MIN( YLSB(M,NB),XLSMX )
            CALL SP_B( TX,XLSB(M,NB),PSBX )
            PWX = PLX
            CALL P_IAPWS( TX,PWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL DENS_B( XLSB(M,NB),RHOBX,RHOLWX,TX )
            PVBX = PSBX
            PVAB(M,NB) = XMLAB(M,NB)*HCAW
            PVWB(M,NB) = PVBX
            XMGAB(M,NB) = PVAB(M,NB)/(PVAB(M,NB)+PVWB(M,NB))
            CALL EQUIL( XGAB(M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &        XLWB(M,NB),XMGAB(M,NB),XMGWB(M,NB),XMLAB(M,NB),
     &        XMLSB(M,NB),XMLWB(M,NB) )
!
!---      Boundary condition state #2  ---
!
!         SL < 1.0
!         SG > 0.0
!
!         Declared variables:
!
!         BCX(4) - aqueous saturation
!         BCX(5) - aqueous salt relative saturation, or
!                  aqueous salt mass fraction
!
          ELSEIF( IBCT(2,NB)/100.EQ.2 ) THEN
            SLB(M,NB) = BCX(4)
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PGX = BCX(3) + PATM
!
!---        Fluid Flow: Aqueous Neumann  ---
!
            ELSEIF( ITFX.EQ.12 ) THEN
              RKLX = ABS(BCX(3))*1.0391029D-7/PERM(IBD,N)
              IF( RKLX.GT.1.D+0 ) THEN
                M_ERR(1) = 'Aqueous Flux > Hydraulic Conductivity '
     &            // '(Aqueous Flux/Hydraulic Conductivity) = '
                M_ERR(2) = ' at Boundary Surface: '
                CALL PATH
                R_ERR = RKLX
                I_ERR(1) = NB
                I_ERR(2) = 1
                I_ERR(3) = 2
                I_ERR(4) = ID
              ENDIF
              ESLX = SQRT(RKLX)
              SLRX = SCHR(4,N)
              SLB(2,NB) = ESLX*(1.D+0-SLRX) + SLRX
!
!---        Fluid Flow: Aqueous Seepage Face  ---
!
            ELSEIF( ITFX.EQ.13 ) THEN
              ZX = BCX(8)
              KC = MAX( 1,INT(ABS(ZX-ZPBC(NB))) )
              DISTZ = (ZX-ZPBC(NB))/REAL(KC)
              PLX = BCX(3) + PATM
              DO K = 1,KC
                ZX = ZX - 5.D-1*DISTZ
                TLRX = BCX(7)
                TBX = BCX(2)
                TKBX = BCX(2) + TABS
                PGBX = BCX(4) + PATM
                TX = TBX + TLRX*(ZPBC(NB)-BCX(6))
                PGX = PGBX*(TKBX/(TKBX + TLRX*(ZPBC(NB)-BCX(6))))**
     &            (GBX*WTMA/(RCU*TLRX))
                CALL REGION_4( TX,PSWX,INDX )
                PWX = MAX( PSWX,PLX )
                CALL P_IAPWS( TX,PWX,RHOX,RHOLWX,HX,HLWX,UX,ULWX )
                CALL SOL_BRNS( TX,PSWX,XLSMX )
                IF( IBCT(4,NB).EQ.2 ) THEN
                  XLSX = BCX(5)*XLSMX
                ELSE
                  XLSX = MIN( XLSMX,BCX(5) )
                ENDIF
                CALL DENS_B( XLSX,RHOBX,RHOLWX,TX )
                PLX = PLX + RHOBX*GRAVZ*DISTZ
                PGX = MAX( PGX,PLX )
              ENDDO
              INDX = 0
              CALL REGION_4( TX,PSWX,INDX )
              CALL SCF_GL( BTGLX,PSWX )
              SGTX = 0.D+0
              INDX = 1
              CALL SP_GT( ASLFX,ASLMX,ASLX,ASLMINX,ESLX,ESGTX,
     &          ESGTMX,PGX,PLX,BTGLX,SGX,SGTX,SLB(2,NB),SLFX,
     &          SLMX,SLRX,INDX,N )
            ENDIF
            PX = PGX
            TMSX = BCX(5)
!
!---        Input gas pressure and aqueous saturation  ---
!
            ICSX = 1
            CALL FLH_IC2( BTGLB(M,NB),PGX,PLX,SGTX,SLB(2,NB),
     &        TX,TMSX,XMLAB(M,NB),YLSB(M,NB),IBCT(4,NB),ICSX,N )
            PGB(M,NB) = PGX - PATM
            PLB(M,NB) = PLX - PATM
            INDX = 0
            CALL REGION_4( TX,PSWX,INDX )
            CALL P_IAPWS( TX,PSWX,RHOX,RHOLWX,HX,HLWX,UX,ULWX )
            PCX = PGB(M,NB)-PLB(M,NB)
            CALL VPL_B( TX,PSWX,PCX,RHOLWX,PVWX )
            CALL SCF_GL( BTGLB(M,NB),PVWX )
            CALL SOL_BRNS( TX,PSWX,XLSMX )
            XLSB(M,NB) = MIN( YLSB(M,NB),XLSMX )
            CALL DENS_B( XLSB(M,NB),RHOBX,RHOLWX,TX )
            CALL SP_B( TX,XLSB(M,NB),PSBX )
            CALL VPL_B( TX,PSBX,PCX,RHOBX,PVBX )
            CALL P_IAPWS( TX,PVBX,RHOGWX,RHOX,HGWX,HX,UGWX,UX )
            PVAB(M,NB) = PGX-PVBX
            IF( PVAB(M,NB).LT.1.D-6 ) PVAB(M,NB) = 0.D+0
            PVWB(M,NB) = PVBX
            XMLAB(M,NB) = PVAB(M,NB)/HCAW
            XMGAB(M,NB) = PVAB(M,NB)/PGX
            CALL EQUIL( XGAB(M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &        XLWB(M,NB),XMGAB(M,NB),XMGWB(M,NB),XMLAB(M,NB),
     &        XMLSB(M,NB),XMLWB(M,NB) )
!
!---      Boundary condition state #3  ---
!
!         SL = 0.0
!         SG = 1.0
!
!         Declared variables:
!
!         BCX(4) - water-vapor relative saturation
!
          ELSEIF( IBCT(2,NB)/100.EQ.3 ) THEN
!
!---        Fluid Flow: Dirichlet, initial condition, Dirichlet-inflow,
!           Dirichlet-outflow, or hydraulic gradient  ---
!
            IF( ITFX.EQ.1 .OR. ITFX.EQ.4 .OR. ITFX.EQ.5 .OR.
     &        ITFX.EQ.6 .OR. ITFX.EQ.8 ) THEN
              PGX = BCX(3) + PATM
            ENDIF
            PVWB(M,NB) = MIN( MAX(BCX(4),0.D+0),1.D+0 )
            PX = PGX
            SLB(M,NB) = 0.D+0
            YLSB(M,NB) = 0.D+0
            TMSX = 0.D+0
!
!---        Input gas pressure and aqueous saturation  ---
!
            ICSX = 1
            CALL FLH_IC4( BTGLB(M,NB),PGX,PLX,PVAB(M,NB),PVWB(M,NB),
     &        SGTX,SLB(M,NB),TX,TMSX,XMGAB(M,NB),YLSB(M,NB),
     &        IBCT(3,NB),ICSX,N )
            PGB(M,NB) = PGX - PATM
            PLB(M,NB) = PLX - PATM
            INDX = 0
            CALL REGION_4( TX,PSWX,INDX )
            CALL SOL_BRNS( TX,PSWX,XLSMX )
            XLSB(M,NB) = 0.D+0
            CALL SCF_GL( BTGLB(M,NB),PVWB(M,NB) )
            SLB(M,NB) = 0.D+0
            SGTX = 0.D+0
            ASLMINX = -1.D+0
            CALL CAP_GT( ASLMINX,BTGLB(M,NB),PCX,SLB(M,NB),SGTX,N )
            PLB(M,NB) = PGB(M,NB) - PCX
            CALL P_IAPWS( TX,PVWB(M,NB),RHOGWX,RHOLWX,HGWX,HLWX,
     &        UGWX,ULWX )
            CALL DENS_B( XLSB(M,NB),RHOBX,RHOLWX,TX )
            XMLAB(M,NB) = PVAB(M,NB)/HCAW
            XMGAB(M,NB) = PVAB(M,NB)/PGX
            CALL EQUIL( XGAB(M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &        XLWB(M,NB),XMGAB(M,NB),XMGWB(M,NB),XMLAB(M,NB),
     &        XMLSB(M,NB),XMLWB(M,NB) )
!
!---      Hydrostatic boundary condition  ---
!
          ELSEIF( IBCT(2,NB).EQ.11 ) THEN
            IF( IBCM(NB).EQ.1 .AND. (NSTEP-NRST).GT.1 ) CYCLE L1
            IF( M.EQ.2 ) THEN
              N_DB = -NB
              CALL HYDST_BC_GT( BCX,PGX,PLX,TX,XLAB(M,NB),XLSB(M,NB),
     &          YLSB(M,NB),ZP(N) )
            ELSE
              TX = TB(2,NB)
              PLX = PLB(2,NB)
              PGX = PGB(2,NB)
              XLSB(M,NB) = XLSB(2,NB)
              YLSB(M,NB) = YLSB(2,NB)
            ENDIF
            PGB(M,NB) = PGX - PATM
            PLB(M,NB) = PLX - PATM
            CALL SP_B( TX,XLSB(M,NB),PSBX )
            PWX = PLX
            CALL P_IAPWS( TX,PWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL DENS_B( XLSB(M,NB),RHOBX,RHOLWX,TX )
            PVBX = PSBX
            XMLAB(M,NB) = 0.D+0
            PVAB(M,NB) = XMLAB(M,NB)*HCAW
            PVWB(M,NB) = PVBX
            CALL SCF_GL( BTGLB(M,NB),PVWB(M,NB) )
            XMGAB(M,NB) = PVAB(M,NB)/(PVAB(M,NB)+PVWB(M,NB))
            CALL EQUIL( XGAB(M,NB),XGWB(M,NB),XLAB(M,NB),XLSB(M,NB),
     &        XLWB(M,NB),XMGAB(M,NB),XMGWB(M,NB),XMLAB(M,NB),
     &        XMLSB(M,NB),XMLWB(M,NB) )
!
!---      Evaporative boundary condition  ---
!
!         Set aqueous and gas saturation equal to the nodal value
!         compute evporation rate and apply rate as a water sink, and
!         compute associated cooling rate and apply rate as an
!         energy sink.
!
          ELSEIF( IBCT(2,NB).EQ.25 ) THEN
            PGX = BCX(3) + PATM
            PX = PGX
            PGB(M,NB) = PGX - PATM
            PORDB(M,NB) = PORD(M,N)
            PORTB(M,NB) = PORT(M,N)
            RKLB(M,NB) = RKL(M,N)
            RKGB(M,NB) = RKG(M,N)
            BTGLB(M,NB) = BTGL(M,N)
            SGB(M,NB) = SG(M,N)
            SLB(M,NB) = SL(M,N)
            XLAB(M,NB) = XLA(M,N)
            XLSB(M,NB) = XLS(M,N)
            XLWB(M,NB) = XLW(M,N)
            YLSB(M,NB) = YLS(M,N)
            XMLAB(M,NB) = XMLA(M,N)
            XMLSB(M,NB) = XMLS(M,N)
            XMLWB(M,NB) = XMLW(M,N)
            SGTX = SGT(M,N)
            ASLMINX = ASLMIN(2,N)
            CALL CAP_GT( ASLMINX,BTGLB(M,NB),PCX,SLB(M,NB),SGTX,N )
            PLB(M,NB) = PGB(M,NB) - PCX
!
!---        Air relative humidity  ---
!
            RHX = BCX(5)
!
!---        Air specific humidity at air temperature and relative
!           humidity, kg water/kg moist air  ---
!
            INDX = 0
            TGX = BCX(2)
            CALL REGION_4( TGX,PSWX,INDX )
            PVWB(M,NB) = RHX*PSWX
            PVAB(M,NB) = PGX - PVWB(M,NB)
            IF( PVWB(M,NB).LT.1.D-6 ) PVWB(M,NB) = 0.D+0
            XMGAB(M,NB) = PVAB(M,NB)/PGX
            XMGWB(M,NB) = MAX( 1.D+0-XMGAB(M,NB),0.D+0 )
            WTMGX = XMGWB(M,NB)*WTMW + XMGAB(M,NB)*WTMA
            XGWB(M,NB) = XMGWB(M,NB)*WTMW/WTMGX
            XGAB(M,NB) = XMGAB(M,NB)*WTMA/WTMGX
            CALL P_IAPWS( TX,PVWB(M,NB),RHOGWX,RHOLWX,HGWX,HLWX,
     &        UGWX,ULWX )
            CALL DENS_B( XLSB(M,NB),RHOBX,RHOLWX,TX )
            ISKIP1 = 1
!
!---      Boundary variables equal those at the node  ---
!
          ELSE
            SGB(M,NB) = SG(M,N)
            SLB(M,NB) = SL(M,N)
            PVAB(M,NB) = PVA(M,N)
            BTGLB(M,NB) = BTGL(M,N)
            YLSB(M,NB) = YLS(M,N)
            PGB(M,NB) = PG(M,N)
            PLB(M,NB) = PL(M,N)
            XLSB(M,NB) = XLS(M,N)
            PVWB(M,NB) = PVW(M,N)
            XMGAB(M,NB) = XMGA(M,N)
            XGAB(M,NB) = XGA(M,N)
            XGWB(M,NB) = XGW(M,N)
            XLAB(M,NB) = XLA(M,N)
            XLSB(M,NB) = XLS(M,N)
            XLWB(M,NB) = XLW(M,N)
            XMGAB(M,NB) = XMGA(M,N)
            XMGWB(M,NB) = XMGW(M,N)
            XMLAB(M,NB) = XMLA(M,N)
            XMLSB(M,NB) = XMLS(M,N)
            XMLWB(M,NB) = XMLW(M,N)
            PORDB(M,NB) = PORD(M,N)
            PORTB(M,NB) = PORT(M,N)
            RKLB(M,NB) = RKL(M,N)
            RKGB(M,NB) = RKG(M,N)
            RHOGB(M,NB) = RHOG(M,N)
            RHOMGB(M,NB) = RHOMG(M,N)
            VISGB(M,NB) = VISG(M,N)
            RHOLB(M,NB) = RHOL(M,N)
            RHOMLB(M,NB) = RHOML(M,N)
            VISLB(M,NB) = VISL(M,N)
            DFGWB(M,NB) = DFGW(M,N)
            DFLAB(M,NB) = DFLA(M,N)
            DFLSB(M,NB) = DFLS(M,N)
            TORLB(M,NB) = TORL(M,N)
            TORGB(M,NB) = TORG(M,N)
            HGAB(M,NB) = HGA(M,N)
            HGWB(M,NB) = HGW(M,N)
            HGB(M,NB) = HG(M,N)
            THKGB(M,NB) = THKG(M,N)
            HLB(M,NB) = HL(M,N)
            THKLB(M,NB) = THKL(M,N)
            ISKIP2 = 1
          ENDIF
!
!---      Porous-media porosity  ---
!
          IF( ISKIP2.EQ.0 ) THEN
          IF( ISKIP1.EQ.0 ) THEN
          CALL PORSTY_GT( N,PX,PCMP(N),PORDB(M,NB),PORTB(M,NB) )
          PORDB(M,NB) = MAX( PORDB(M,NB),EPSL )
          PORTB(M,NB) = MAX( PORTB(M,NB),PORDB(M,NB) )
!
!---      Saturation, relative permeability  ---
!
          INDX = 0
          CALL KSP_GT( N,PGB(M,NB),PLB(M,NB),BTGLB(M,NB),SGB(M,NB),SGTX,
     &      SLB(M,NB),SDPF(N),SDPM(N),RKLB(M,NB),RKGB(M,NB),ASLX,
     &      ASLMINX,ESGTX,ESGTMX,SLRX,INDX )
          ENDIF
!
!---      Gas density and component fractions  ---
!
          CALL AIRGSD( TX,PVAB(M,NB),RHOGAX )
          RHOGB(M,NB) = XGAB(M,NB)*RHOGAX + XGWB(M,NB)*RHOGWX
          WTMGX = XMGAB(M,NB)*WTMA + XMGWB(M,NB)*WTMW
          RHOMGB(M,NB) = RHOGB(M,NB)/WTMGX
!
!---      Gas viscosity  ---
!
          CALL AIRGSV( TX,VISGAX )
          CALL VISC_W( TX,PVBX,RHOGWX,VISGWX )
          CALL VISC_G( VISGAX,VISGWX,XMGAB(M,NB),XMGWB(M,NB),
     &      VISGB(M,NB) )
!
!---      Aqueous density and molar density  ---
!
          RHOLB(M,NB) = RHOBX
          WTMLX = XMLAB(M,NB)*WTMA + XMLSB(M,NB)*WTMS + XMLWB(M,NB)*WTMW
          RHOMLB(M,NB) = RHOLB(M,NB)/WTMLX
!
!---      Aqueous viscosity  ---
!
          CALL VISC_W( TX,PX,RHOLWX,VISLWX )
          CALL VISC_B( TX,XLSB(M,NB),VISLWX,VISBX )
          CALL VISC_L( XMLAB(M,NB),VISBX,VISGAX,VISLB(M,NB) )
!
!---      Gas-water diffusion coefficients  ---
!
          IF( ISLC(2).EQ.1 ) THEN
            DFGWB(M,NB) = DFGWC
          ELSEIF( ISLC(2).EQ.2 ) THEN
            CALL BNDFAW( TX,PGX,DFGWB(M,NB) )
          ELSEIF( ISLC(2).EQ.3 ) THEN
            CALL BNDFAW( TX,PGX,DFGWB(M,NB) )
            CMFF = 1.D+0 + 2.6D+0/(DFGWC**0.5)
            AMC = PORDB(M,NB)*SLB(M,NB)
            ENHF = 9.5D+0 + 6.D+0*(AMC) -
     &        8.5D+0/EXP((CMFF*AMC)**4)
            DFGWB(M,NB) = ENHF*DFGWB(M,NB)
          ELSEIF( ISLC(2).EQ.4 ) THEN
            CALL BNDFAW( TX,PGX,DFGWB(M,NB) )
            ENHF = DFEF(1,N)+DFEF(2,N)*SLB(M,NB)-
     &        (DFEF(1,N)-DFEF(4,N))
     &        *EXP(-((DFEF(3,N)*SLB(M,NB))**DFEF(5,N)))
            DFGWB(M,NB) = ENHF*DFGWB(M,NB)
          ENDIF
!
!---      Aqueous-air diffusion coefficients  ---
!
          IF( ISLC(4).EQ.1 ) THEN
            DFLAB(M,NB) = DFLAC
          ELSEIF( ISLC(4).EQ.2 ) THEN
            CALL AIRDFL( TX,VISLB(M,NB),DFLAB(M,NB) )
          ENDIF
!
!---      Aqueous-salt diffusion coefficient  ---
!
          IF( ISLC(4).EQ.1 ) THEN
            DFLSB(M,NB) = DFLSC
          ELSEIF( ISLC(4).EQ.2 ) THEN
            CALL DIFC_LS( TX,XLSB(M,NB),VISLB(M,NB),DFLSB(M,NB) )
          ENDIF
!
!---      Aqueous and gas tortuosity  ---
!
          IF( ISLC(3).EQ.1 ) CALL TORTU( N,SLB(M,NB),SGB(M,NB),
     &      PORDB(M,NB),TORLB(M,NB),TORGB(M,NB) )
!
!---      Nonisothermal simulation  ---
!
          IF( ISLC(30).EQ.0 ) THEN
!
!---        Gas enthalpy and internal energy  ---
!
            CALL AIRGSH( TX,PVAB(M,NB),HGAB(M,NB),UEGAX )
            HGWB(M,NB) = HGWX
            HGB(M,NB) = XGAB(M,NB)*HGAB(M,NB) + XGWB(M,NB)*HGWB(M,NB)
!
!---        Gas thermal conductivity  ---
!
            CALL AIRGSK( TX,THKGAX )
            CALL THK_W( TX,PGX,RHOGWX,THKGWX )
            CALL THK_G( TX,THKGAX,THKGWX,XMGAB(M,NB),
     &        XMGWB(M,NB),THKGB(M,NB) )
!
!---        Aqueous enthalpy and internal energy  ---
!
            CALL ENTH_B( TX,XLSB(M,NB),HLWX,HBX )
            HLB(M,NB) = MAX(1.D+0-XLAB(M,NB),0.D+0)*HBX +
     &        XLAB(M,NB)*HGAB(M,NB)
!
!---        Aqueous thermal conductivity  ---
!
            CALL THK_W( TX,PX,RHOLWX,THKLWX )
            CALL THK_B( TX,XLSB(M,NB),THKLWX,THKLB(M,NB) )
          ENDIF
!
!---      Evaporative boundary condition  ---
!
!         Set aqueous and gas saturation equal to the nodal value
!         compute evporation rate and apply rate as a water sink, and
!         compute associated cooling rate and apply rate as an
!         energy sink.  ---
!
          IF( IBCT(2,NB).EQ.25 ) THEN
!
!---        Surface wet function from T.J. Lee and R.A. Pielke
!           1991. "Estimating the soil surface specific heat."
!           Journal of Applied Meteorology, 31:480-484.  ---
!
            SLRX = SCHR(4,N)
            IF( SLB(M,NB).LT.SLRX ) THEN
              BETAX = 2.5D-1*((1.D+0-COS(SLB(M,NB)*GPI/SLRX))**2)
            ELSE
              BETAX = 1.D+0
            ENDIF
!
!---        Exchange coefficient for mositure from J. Kondo, N. Saigusa,
!           and T. Sato. 1990. "A parameterization of evaporation
!           from bare soil surfaces."
!           Journal of Applied Meteorology, 29:385-389.  ---
!
            CEX = 2.5D-2
!
!---        Air speed (m/s)  ---
!
            UGX = BCX(4)
!
!---        Air relative humidity  ---
!
            RHX = BCX(5)
!
!---        Air specific humidity at air temperature and relative
!           humidity, kg water/kg moist air  ---
!
            INDX = 0
            TGX = BCX(2)
            CALL REGION_4( TGX,PSWX,INDX )
            PVWX = RHX*PSWX
            PVAX = PGX - PVWX
            IF( PVAX.LT.1.D-6 ) PVAX = 0.D+0
            XMGAX = PVAX/PGX
            XMGWX = MAX( 1.D+0-XMGAX,0.D+0 )
            WTMGX = XMGWX*WTMW + XMGAX*WTMA
            XGWX = XMGWX*WTMW/WTMGX
            XGAX = XMGAX*WTMA/WTMGX
!
!---        Air density at air temperature and relative
!           humidity, kg/m^3  ---
!
            CALL P_IAPWS( TGX,PVWX,RHOGWX,RHOX,HGWX,HX,UGWX,UX )
            CALL AIRGSD( TGX,PVAX,RHOGAX )
            RHOGX = XGAX*RHOGAX + XGWX*RHOGWX
!
!---        Saturated specific humidity at surface temperature,
!           kg water/kg moist air  ---
!
            CALL REGION_4( TX,PSWX,INDX )
            PSAX = PGX - PSWX
            IF( PSAX.LT.1.D-6 ) PSAX = 0.D+0
            XMSAX = PSAX/PGX
            XMSWX = MAX( 1.D+0-XMSAX,0.D+0 )
            WTMSX = XMSWX*WTMW + XMSAX*WTMA
            XSWX = XMSWX*WTMW/WTMSX
!
!---        Evaporation rate, kg/s m^2  ---
!
            EVAPX = RHOGX*CEX*UGX*BETAX*(XSWX-XGWX)
            SRCW(M,N) = SRCW(M,N) - EVAPX*AFBX
!
!---        Cooling rate, W  ---
!
            SRCT(M,N) = SRCT(M,N) + EVAPX*(HLWX-HGWX)*AFBX
          ENDIF
          ENDIF
!
!---      Assign boundary primary variables  ---
!
          TB(M,NB) = TX
          PLB(M,NB) = PLX - PATM
          PGB(M,NB) = PGX - PATM
        ENDDO L2
      ENDDO L1
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of BCP_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE CAP_GT( ASLMINX,BTGLX,CPGL,SLX,SGTX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the gas/aqueous capillary pressure from the aqueous
!     saturation.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 GX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/CAP_GT'
      IF( SLX.LT.EPSL ) THEN
        CPGL = SCHR(12,N)*RHORL*GRAV/BTGLX
!
!---    Reset subroutine string sequence  ---
!
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  van Genuchten saturation function w/o gas entrapment,
!     w/ or w/o Webb extension  ---
!
      IF( ISCHR(N).EQ.1 ) THEN
!
!---    van Genuchten saturation function w/o gas entrapment,
!       w/ Webb extension ASL = SL  ---
!
        SLRX = SCHR(4,N)
        IF( ISM(N).EQ.2 ) THEN
          ESLX = (SLX-SLRX)/(1.D+0-SLRX)
          CN = MAX( SCHR(3,N),SMALL )
          IF( SCHR(14,N).LE.ZERO ) THEN
            IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
              CM = 1.D+0 - 2.D+0/CN
            ELSE
              CM = 1.D+0 - 1.D+0/CN
            ENDIF
          ELSE
            CM = SCHR(14,N)
          ENDIF
          SMPX = SCHR(8,N)
!
!---      Aqueous saturation below the matching point,
!         use Webb extension  ---
!
          IF( SLX.LT.SMPX ) THEN
            HMPX = SCHR(9,N)
            DMPX = -(LOG10(SCHR(12,N))-LOG10(HMPX))/SMPX
            HDGL = 1.D+1**(DMPX*(SLX-SMPX) + LOG10(HMPX))
!
!---      Aqueous saturation at or above the matching point,
!         use van Genuchten function
!
          ELSE
            HDGL = (((1.D+0/ESLX)**(1.D+0/CM)-1.D+0)**(1.D+0/CN))/
     &        SCHR(1,N)
          ENDIF
!
!---    van Genuchten saturation function w/o gas entrapment,
!       w/o Webb extension ASL = ESL  ------
!
        ELSE
          ESLX = (SLX-SLRX)/(1.D+0-SLRX)
          CN = MAX( SCHR(3,N),SMALL )
          IF( SCHR(14,N).LE.ZERO ) THEN
            IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
              CM = 1.D+0 - 2.D+0/CN
            ELSE
              CM = 1.D+0 - 1.D+0/CN
            ENDIF
          ELSE
            CM = SCHR(14,N)
          ENDIF
          IF( SLX.GT.SCHR(4,N) ) THEN
            HDGL = (((1.D+0/ESLX)**(1.D+0/CM)-1.D+0)**(1.D+0/CN))/
     &        SCHR(1,N)
          ELSE
            HDGL = SCHR(12,N)
            SLX = SLRX + 1.D-6
          ENDIF
        ENDIF
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Brooks and Corey saturation function w/o gas entrapment,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.2 ) THEN
!
!---    Brooks and Corey saturation function w/o gas entrapment,
!       w/ Webb extension ASL = SL  ---
!
        SLRX = SCHR(4,N)
        IF( ISM(N).EQ.2 ) THEN
          ESLX = (SLX-SLRX)/(1.D+0-SLRX)
          CL = MAX( SCHR(3,N),SMALL )
          SMPX = SCHR(8,N)
!
!---      Aqueous saturation below the matching point,
!         use Webb extension  ---
!
          IF( SLX.LT.SMPX ) THEN
            HMPX = SCHR(9,N)
            DMPX = -(LOG10(SCHR(12,N))-LOG10(HMPX))/SMPX
            HDGL = 1.D+1**(DMPX*(SLX-SMPX) + LOG10(HMPX))
!
!---      Aqueous saturation at or above the matching point,
!         use Brooks and Corey function
!
          ELSE
            HDGL = SCHR(1,N)*(1.D+0/ESLX)**(1.D+0/CL)
          ENDIF
!
!---    Brooks and Corey saturation function w/o gas entrapment,
!       w/o Webb extension ASL = ESL  ---
!
        ELSE
          ISKIP = 0
          ESLX = (SLX-SLRX)/(1.D+0-SLRX)
          IF( (1.D+0-SLX)/EPSL.LT.EPSL ) THEN
            HDGL = SCHR(1,N)
            ISKIP = 1
          ENDIF
          IF( ISKIP.EQ.0 ) THEN
            CL = MAX( SCHR(3,N),SMALL )
            IF( SLX.GT.SCHR(4,N) ) THEN
              HDGL = SCHR(1,N)*(1.D+0/ESLX)**(1.D+0/CL)
            ELSE
              HDGL = SCHR(12,N)
              SLX = SLRX + 1.D-9
            ENDIF
          ENDIF
        ENDIF
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Dual porosity van Genuchten saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.3 ) THEN
        CNM = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CMM = 1.D+0 - 2.D+0/CNM
          ELSE
            CMM = 1.D+0 - 1.D+0/CNM
          ENDIF
        ELSE
          CMM = SCHR(14,N)
        ENDIF
        CNF = MAX( SCHR(6,N),SMALL )
        IF( SCHR(15,N).LE.EPSL ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CMF = 1.D+0 - 2.D+0/CNF
          ELSE
            CMF = 1.D+0 - 1.D+0/CNF
          ENDIF
        ELSE
          CMF = SCHR(15,N)
        ENDIF
        PORD_MX = (1.D+0-POR(4,N))*POR0(2,N)/
     &    ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
        PORD_FX = POR(4,N)/
     &    ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
!
!---    Use matrix properties to generate a guess for
!       capillary head  ---
!
        IF( SLX.GT.SCHR(4,N) ) THEN
          ASLX = (SLX-SCHR(4,N))/(1.D+0-SCHR(4,N))
          HDGL = (((1.D+0/ASLX)**(1.D+0/CMM)-1.D+0)**(1.D+0/CNM))/
     &      SCHR(1,N)
        ELSE
          HDGL = SCHR(12,N)
          SLX = SCHR(4,N) + 1.D-6
        ENDIF
!
!---    Start Newton-Raphson solution  ---
!
        NC = 0
        DO
          NC = NC + 1
          REALX = REAL(ISM(N))
          HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
!
!---      Matrix saturation and partial derivative  ---
!
          SLRX = MAX( (1.D+0-HSCL)*SCHR(4,N),ZERO )
          DSLRX = -SCHR(4,N)/(HDGL*LOG(SCHR(12,N)))*REALX
          ASLX = 1.D+0/((1.D+0 + (SCHR(1,N)*HDGL)**CNM)**CMM)
          DASLX = -CMM*SCHR(1,N)*CNM*((SCHR(1,N)*HDGL)**(CNM-1.D+0))
     &    /((1.D+0 + (SCHR(1,N)*HDGL)**CNM)**(CMM+1.D+0))
          SLMZ = ASLX*(1.D+0-SLRX) + SLRX
          DSLMZ = DASLX*(1.D+0-SLRX) + DSLRX*(1.D+0-ASLX)
!
!---      Fracture saturation and partial derivative  ---
!
          SLRX = MAX( (1.D+0-HSCL)*SCHR(7,N),ZERO )
          DSLRX = -SCHR(7,N)/(HDGL*LOG(SCHR(12,N)))*REALX
          ASLX = 1.D+0/((1.D+0 + (SCHR(5,N)*HDGL)**CNF)**CMF)
          DASLX = -CMF*SCHR(5,N)*CNF*((SCHR(5,N)*HDGL)**(CNF-1.D+0))
     &    /((1.D+0 + (SCHR(5,N)*HDGL)**CNF)**(CMF+1.D+0))
          SLFZ = ASLX*(1.D+0-SLRX) + SLRX
          DSLFZ = DASLX*(1.D+0-SLRX) + DSLRX*(1.D+0-ASLX)
          F = SLX - SLMZ*PORD_MX - SLFZ*PORD_FX
          DF = -DSLMZ*PORD_MX -DSLFZ*PORD_FX
          DH = -F/(DF+SMALL)
          HDGL = HDGL + DH
!
!---      No convergence on dual porosity van Genuchten
!         capillary pressure  ---
!
          IF( NC.GT.32 ) THEN
            M_ERR(1) = 'Dual Porosity van Genuchten: '
     &        // 'No Convergence on Capillary Pressure: ' //
     &        'Aqueous Saturation = '
            M_ERR(2) = ' at Node: '
            CALL PATH
            R_ERR = SLX
            I_ERR(1) = ND(N)
            I_ERR(2) = 1
            I_ERR(3) = 2
            I_ERR(4) = ID
!
!---        Use matrix properties to generate a guess for
!          capillary head  ---
!
            IF( SLX.GT.SCHR(4,N) ) THEN
              ASLX = (SLX-SCHR(4,N))/(1.D+0-SCHR(4,N))
              HDGL = (((1.D+0/ASLX)**(1.D+0/CMM)-1.D+0)**(1.D+0/CNM))/
     &          SCHR(1,N)
            ELSE
              HDGL = SCHR(12,N)
              SLX = SCHR(4,N) + 1.D-6
            ENDIF
            DH = 0.D+0
          ENDIF
          IF( ABS(DH).LE.1.D-7 ) EXIT
        ENDDO
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Dual porosity Brooks and Corey saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.4 ) THEN
        ISKIP = 0
        IF( (1.D+0-SLX)/EPSL.LT.EPSL ) THEN
          HDGL = SCHR(1,N)
          ISKIP = 1
        ENDIF
        IF( ISKIP.EQ.0 ) THEN
          CLM = MAX( SCHR(3,N),SMALL )
          CLF = MAX( SCHR(6,N),SMALL )
          PORD_MX = (1.D+0-POR(4,N))*POR0(2,N)/
     &      ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
          PORD_FX = POR(4,N)/
     &      ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
!
!---      Use matrix properties to generate a guess for
!         capillary head  ---
!
          IF( SLX.GT.SCHR(4,N) ) THEN
            ASLX = (SLX-SCHR(4,N))/(1.D+0-SCHR(4,N))
            HDGL = SCHR(1,N)*(1.D+0/ASLX)**(1.D+0/CLM)
          ELSE
            HDGL = SCHR(12,N)
            SLX = SCHR(4,N) + 1.D-9
          ENDIF
!
!---      Start Newton-Raphson solution  ---
!
          NC = 0
          DO
            NC = NC + 1
            REALX = REAL(ISM(N))
            HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
!
!---        Matrix saturation and partial derivative  ---
!
            SLRX = MAX( (1.D+0-HSCL)*SCHR(4,N),ZERO )
            DSLRX = -SCHR(4,N)*REALX/(HDGL*LOG(SCHR(12,N)))
            HDGLX = MAX( SCHR(1,N),HDGL )
            ASLX = (SCHR(1,N)/HDGLX)**CLM
            DASLX = -CLM*(SCHR(1,N)/(HDGLX**2))
     &        *(SCHR(1,N)/HDGLX)**(CLM-1.D+0)
            SLMZ = ASLX*(1.D+0-SLRX) + SLRX
            DSLMZ = DASLX*(1.D+0-SLRX) + DSLRX*(1.D+0-ASLX)
!
!---        Fracture saturation and partial derivative  ---
!
            SLRX = MAX( (1.D+0-HSCL)*SCHR(7,N),ZERO )
            DSLRX = -SCHR(7,N)*REALX/(HDGL*LOG(SCHR(12,N)))
            HDGLX = MAX( SCHR(5,N),HDGL )
            ASLX = (SCHR(5,N)/HDGLX)**CLF
            DASLX = -CLF*(SCHR(5,N)/(HDGLX**2))
     &        *(SCHR(5,N)/HDGLX)**(CLF-1.D+0)
            SLFZ = ASLX*(1.D+0-SLRX) + SLRX
            DSLFZ = DASLX*(1.D+0-SLRX) + DSLRX*(1.D+0-ASLX)
            F = SLX - SLMZ*PORD_MX - SLFZ*PORD_FX
            DF = -DSLMZ*PORD_MX -DSLFZ*PORD_FX
            DH = -F/(DF+SMALL)
            HDGL = HDGL + DH
!
!---        No convergence Brooks-Corey capillary pressure  ---
!
            IF( NC.GT.32 ) THEN
              M_ERR(1) = 'Dual Porosity Brooks and Corey: '
     &          // 'No Convergence on Capillary Pressure: ' //
     &          'Aqueous Saturation = '
              M_ERR(2) = ' at Node: '
              CALL PATH
              R_ERR = SLX
              I_ERR(1) = ND(N)
              I_ERR(2) = 1
              I_ERR(3) = 2
              I_ERR(4) = ID
!
!---          Use matrix properties to generate a guess for
!             capillary head  ---
!
              IF( SLX.GT.SCHR(4,N) ) THEN
                ASLX = (SLX-SCHR(4,N))/(1.D+0-SCHR(4,N))
                HDGL = SCHR(1,N)*(1.D+0/ASLX)**(1.D+0/CLM)
              ELSE
                HDGL = SCHR(12,N)
                SLX = SCHR(4,N) + 1.D-9
              ENDIF
              DH = 0.D+0
            ENDIF
            IF( ABS(DH).LE.1.D-7 ) EXIT
          ENDDO
        ENDIF
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Haverkamp saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.5 ) THEN
        IF( SLX.GT.SCHR(4,N) ) THEN
          ASLX = (SLX-SCHR(4,N))/(1.D+0-SCHR(4,N))
          HDGL = SCHR(1,N) + SCHR(5,N)*
     &      ((SCHR(2,N)/ASLX)-SCHR(2,N))**(1.D+0/SCHR(3,N))
        ELSE
          HDGL = SCHR(12,N)
          SLX = SCHR(4,N) + 1.D-9
        ENDIF
!
!---    Start Newton-Raphson solution  ---
!
        NC = 0
        DO
          NC = NC + 1
          REALX = REAL(ISM(N))
          HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
          SLRX = MAX( (1.D+0-HSCL)*SCHR(4,N),ZERO )
          DSLRX = -SCHR(4,N)*REALX/(HDGL*LOG(SCHR(12,N)))
          ASLX = SCHR(2,N)/(SCHR(2,N)+((HDGL-SCHR(1,N))/
     &      SCHR(5,N))**SCHR(3,N))
          DASLX = -(SCHR(2,N)*SCHR(3,N)*
     &      (((HDGL-SCHR(1,N))/SCHR(5,N))**(SCHR(3,N)-1.D+0))
     &      /SCHR(5,N))/((SCHR(2,N)+((HDGL-SCHR(1,N))/SCHR(5,N))
     &      **SCHR(3,N))**2)
          SLZ = ASLX*(1.D+0-SLRX) + SLRX
          DSLZ = DASLX*(1.D+0-SLRX) + DSLRX*(1.D+0-ASLX)
          F = SLX - SLZ
          DF = -DSLZ
          DH = -F/(DF+SMALL)
          HDGL = HDGL + DH
!
!---      No convergence Haverkamp capillary pressure  ---
!
          IF( NC.GT.32 ) THEN
            M_ERR(1) = 'Haverkamp: '
     &        // 'No Convergence on Capillary Pressure: ' //
     &        'Aqueous Saturation = '
            M_ERR(2) = ' at Node: '
            CALL PATH
            R_ERR = SLX
            I_ERR(1) = ND(N)
            I_ERR(2) = 1
            I_ERR(3) = 2
            I_ERR(4) = ID
!
!---        Use matrix properties to generate a guess for
!           capillary head  ---
!
            IF( SLX.GT.SCHR(4,N) ) THEN
              ASLX = (SLX-SCHR(4,N))/(1.D+0-SCHR(4,N))
              HDGL = SCHR(1,N) + SCHR(5,N)*
     &          ((SCHR(2,N)/ASLX)-SCHR(2,N))**(1.D+0/SCHR(3,N))
            ELSE
              HDGL = SCHR(12,N)
              SLX = SCHR(4,N) + 1.D-9
            ENDIF
            DH = 0.D+0
          ENDIF
          IF( ABS(DH).LE.1.D-7 ) EXIT
        ENDDO
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Linear interpolation function  ---
!
      ELSEIF( ISCHR(N).EQ.10 ) THEN
        ITBX = 0
        HDGL = FNTBLX( SLX,ISLTBL(1,N),ISLTBL(2,N),ITBX )
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Log-linear interpolation function  ---
!
      ELSEIF( ISCHR(N).EQ.11 ) THEN
        ITBX = 0
        HDGL = FNTBLX( SLX,ISLTBL(1,N),ISLTBL(2,N),ITBX )
        HDGL = EXP(HDGL)
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Hysteretic linear interpolation function, using the drainage
!     curve as an initial guess  ---
!
      ELSEIF( ISCHR(N).EQ.12 ) THEN
        SLDX = MAX( SLX-SGTX,0.D+0 )
        ITBX = 0
        HDGL = FNTBLX( SLDX,ISLTBL(1,N),ISLTBL(2,N),ITBX )
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Hysteretic log-linear interpolation function, using the drainage
!     curve  ---
!
      ELSEIF( ISCHR(N).EQ.13 ) THEN
        SLDX = MAX( SLX-SGTX,0.D+0 )
        ITBX = 0
        HDGL = FNTBLX( SLDX,ISLTBL(1,N),ISLTBL(2,N),ITBX )
        HDGL = EXP(HDGL)
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  van Genuchten saturation function w/ gas entrapment,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.101 ) THEN
!
!---    van Genuchten saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        SLRX = SCHR(4,N)
        IF( ISM(N).EQ.2 ) THEN
          ESGTMX = SCHR(15,N)
          SGFX = MAX( 1.D+0-SLX-SGTX,0.D+0 )
          SGFX = SGFX + MAX( SGTX-ESGTMX,0.D+0 )
          SGTX = MIN( SGTX,ESGTMX )
          SLX = 1.D+0 - SGFX - SGTX
          ESGTX = SGTX
          ASLX = SLX + SGTX
          ESLX = (ASLX-SLRX)/(1.D+0-SLRX)
!
!---    van Genuchten saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          ESGTMX = SCHR(15,N)/(1.D+0-SLRX)
          ESLX = (SLX-SLRX)/(1.D+0-SLRX)
          ESGTX = SGTX/(1.D+0-SLRX)
          ESGFX = MAX( 1.D+0-ESLX-ESGTX,0.D+0 )
          ESGFX = ESGFX + MAX( ESGTX-ESGTMX,0.D+0 )
          ESGTX = MIN( ESGTX,ESGTMX )
          ESLX = 1.D+0 - ESGFX - ESGTX
          ASLX = ESLX + ESGTX
          ESLX = ASLX
        ENDIF
!
!---    Minimum apparent aqueous saturation  ---
!
        R = 1.D+0/ESGTMX - 1.D+0
        IF( ASLMINX.LT.0.D+0 ) THEN
          ASLMINX = (ESGTX*R*ASLX + ESGTX*(R**2)*ASLX + ASLX - ESGTX -
     &      2.D+0*ESGTX*R - ESGTX*(R**2))/
     &      (1.D+0 + ESGTX*(R**2)*ASLX - ESGTX*R - ESGTX*(R**2) )
          ASLMINX = MIN( MAX( ASLMINX,0.D+0 ),1.D+0 )
        ENDIF
!
!---    Capillary head  ---
!
        CN = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CM = 1.D+0 - 2.D+0/CN
          ELSE
            CM = 1.D+0 - 1.D+0/CN
          ENDIF
        ELSE
          CM = SCHR(14,N)
        ENDIF
        SMPX = SCHR(8,N)
!
!---    van Genuchten saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        IF( ISM(N).EQ.2 ) THEN
!
!---      Aqueous saturation below the matching point,
!         use Webb extension  ---
!
          IF( SLX.LT.SMPX ) THEN
            HMPX = SCHR(9,N)
            DMPX = -(LOG10(SCHR(12,N))-LOG10(HMPX))/SMPX
            HDGL = 1.D+1**(DMPX*(SLX-SMPX) + LOG10(HMPX))
!
!---      Aqueous saturation at or above the matching point,
!         use van Genuchten function
!
          ELSE
            HDGL = (((1.D+0/ESLX)**(1.D+0/CM)-1.D+0)**(1.D+0/CN))/
     &        SCHR(1,N)
          ENDIF
!
!---    van Genuchten saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          HDGL = (((1.D+0/ASLX)**(1.D+0/CM)-1.D+0)**(1.D+0/CN))/
     &      SCHR(1,N)
        ENDIF
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Brooks and Corey saturation function w/ gas entrapment,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.102 ) THEN
!
!---    Brooks and Corey saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        SLRX = SCHR(4,N)
        IF( ISM(N).EQ.2 ) THEN
          ESGTMX = SCHR(15,N)
          SGFX = MAX( 1.D+0-SLX-SGTX,0.D+0 )
          SGFX = SGFX + MAX( SGTX-ESGTMX,0.D+0 )
          SGTX = MIN( SGTX,ESGTMX )
          SLX = 1.D+0 - SGFX - SGTX
          ESGTX = SGTX
          ASLX = SLX + SGTX
          ESLX = (ASLX-SLRX)/(1.D+0-SLRX)
!
!---    Brooks and Corey saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          ESGTMX = SCHR(15,N)/(1.D+0-SLRX)
          ESLX = (SLX-SLRX)/(1.D+0-SLRX)
          ESGTX = SGTX/(1.D+0-SLRX)
          ESGFX = MAX( 1.D+0-ESLX-ESGTX,0.D+0 )
          ESGFX = ESGFX + MAX( ESGTX-ESGTMX,0.D+0 )
          ESGTX = MIN( ESGTX,ESGTMX )
          ESLX = 1.D+0 - ESGFX - ESGTX
          ASLX = ESLX + ESGTX
          ESLX = ASLX
        ENDIF
!
!---    Minimum apparent aqueous saturation  ---
!
        R = 1.D+0/ESGTMX - 1.D+0
        IF( ASLMINX.LT.0.D+0 ) THEN
          ASLMINX = (ESGTX*R*ASLX + ESGTX*(R**2)*ASLX + ASLX - ESGTX -
     &      2.D+0*ESGTX*R - ESGTX*(R**2))/
     &      (1.D+0 + ESGTX*(R**2)*ASLX - ESGTX*R - ESGTX*(R**2) )
          ASLMINX = MIN( MAX( ASLMINX,0.D+0 ),1.D+0 )
        ENDIF
!
!---    Capillary head  ---
!
        CL = MAX( SCHR(3,N),SMALL )
        SMPX = SCHR(8,N)
!
!---    Brooks and Corey saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        IF( ISM(N).EQ.2 ) THEN
!
!---      Aqueous saturation below the matching point,
!         use Webb extension  ---
!
          IF( SLX.LT.SMPX ) THEN
            HMPX = SCHR(9,N)
            DMPX = -(LOG10(SCHR(12,N))-LOG10(HMPX))/SMPX
            HDGL = 1.D+1**(DMPX*(SLX-SMPX) + LOG10(HMPX))
!
!---      Aqueous saturation at or above the matching point,
!         use Brooks and Corey function
!
          ELSE
            HDGL = SCHR(1,N)*(1.D+0/ESLX)**(1.D+0/CL)
          ENDIF
!
!---    Brooks and Corey saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          HDGL = SCHR(1,N)*(1.D+0/ASLX)**(1.D+0/CL)
        ENDIF
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  van Genuchten drainage-imbibition saturation function,
!     w/ or w/o extensions---
!
      ELSEIF( ISCHR(N).EQ.201 ) THEN
!
!---    van Genuchten drainage-imbibition saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        SLRX = SCHR(4,N)
        IF( ISM(N).EQ.2 ) THEN
          ESGTX = SGTX
          ASLX = SLX + SGTX
          ESLX = (ASLX-SLRX)/(1.D+0-SLRX)
          ESGTMX = SCHR(15,N)
!
!---    van Genuchten drainage-imbibition saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          ESGTX = SGTX/(1.D+0-SLRX)
          ASLX = (SLX+SGTX-SLRX)/(1.D+0-SLRX)
          ESLX = ASLX
          ESGTMX = SCHR(15,N)/(1.D+0-SLRX)
        ENDIF
!
!---    Minimum apparent aqueous saturation  ---
!
        R = 1.D+0/ESGTMX - 1.D+0
        IF( ASLMINX.LT.0.D+0 ) THEN
          ASLMINX = (ESGTX*R*ASLX + ESGTX*(R**2)*ASLX + ASLX - ESGTX -
     &      2.D+0*ESGTX*R - ESGTX*(R**2))/
     &      (1.D+0 + ESGTX*(R**2)*ASLX - ESGTX*R - ESGTX*(R**2) )
          ASLMINX = MIN( MAX( ASLMINX,0.D+0 ),1.D+0 )
        ENDIF
!
!---    Drainage capillary head  ---
!
        CND = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CMD = 1.D+0 - 2.D+0/CND
          ELSE
            CMD = 1.D+0 - 1.D+0/CND
          ENDIF
        ELSE
          CMD = SCHR(14,N)
        ENDIF
        SMPDX = SCHR(8,N)
!
!---    Aqueous saturation below the matching point,
!       use Webb extension  ---
!
        IF( SLX.LT.SMPDX ) THEN
          HMPDX = SCHR(9,N)
          DMPDX = -(LOG10(SCHR(12,N))-LOG10(HMPDX))/SMPDX
          HDGLD = 1.D+1**(DMPDX*(ASLX-SMPDX) + LOG10(HMPDX))
!
!---    Aqueous saturation at or above the matching point,
!       use van Genuchten function
!
        ELSE
          HDGLD = (((1.D+0/ESLX)**(1.D+0/CMD)-1.D+0)**(1.D+0/CND))/
     &      SCHR(1,N)
        ENDIF
        CNI = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CMI = 1.D+0 - 2.D+0/CNI
          ELSE
            CMI = 1.D+0 - 1.D+0/CNI
          ENDIF
        ELSE
          CMI = SCHR(14,N)
        ENDIF
        SMPIX = SCHR(8,N)
!
!---    Aqueous saturation below the matching point,
!       use Webb extension  ---
!
        IF( ASLX.LT.SMPIX ) THEN
          HMPIX = SCHR(11,N)
          DMPIX = -(LOG10(SCHR(12,N))-LOG10(HMPIX))/SMPIX
          HDGLI = 1.D+1**(DMPIX*(ASLX-SMPIX) + LOG10(HMPIX))
!
!---    Aqueous saturation at or above the matching point,
!       use van Genuchten function
!
        ELSE
          HDGLI = (((1.D+0/ESLX)**(1.D+0/CMI)-1.D+0)**(1.D+0/CNI))/
     &      SCHR(2,N)
        ENDIF
!
!---    Guess capillary head  ---
!
        HDGL = (ASLMINX/ASLX)*HDGLD + (1.D+0-(ASLMINX/ASLX))*HDGLI
        HDGLMN = MIN( HDGLD,HDGLI )
        HDGLMX = MAX( HDGLD,HDGLI )
!
!---    Start Newton-Raphson solution  ---
!
        NC = 0
        DO
          NC = NC + 1
!
!---      No convergence on van Genuchten drainage-imbibition
!         saturation function  ---
!
          IF( NC.GT.32 ) THEN
            M_ERR(1) = 'van Genuchten Drainage-Imbibition: '
     &        // 'No Convergence on Capillary Pressure: ' //
     &        'Aqueous Saturation = '
            M_ERR(2) = ' at Node: '
            CALL PATH
            R_ERR = SLX
            I_ERR(1) = ND(N)
            I_ERR(2) = 1
            I_ERR(3) = 2
            I_ERR(4) = ID
            HDGL = (ASLMINX/ASLX)*HDGLD + (1.D+0-(ASLMINX/ASLX))*HDGLI
            EXIT
          ENDIF
          DO M = 1,2
            HDGLZ = HDGL
            DHDGLZ = SIGN( MAX( 1.D-6*HDGL,1.D-6 ),
     &        (5.D-1*SCHR(12,N) - HDGL) )
            IF( M.EQ.2 ) HDGLZ = HDGL + DHDGLZ
            HMPDZ = SCHR(9,N)
            HMPIZ = SCHR(11,N)
            SLRZ = SCHR(4,N)
!
!---        van Genuchten drainage-imbibition saturation function,
!           w/ Webb extension ASL = SL + SGT  ---
!
            IF( ISM(N).EQ.2 ) THEN
!
!---          Capillary head above the drainage matching point head,
!             use Webb extension  ---
!
              IF( HDGLZ.GT.HMPDZ ) THEN
                SMPDZ = SCHR(8,N)
                HDGLZ = MIN( HDGLZ,SCHR(12,N) )
                DMPDZ = SMPDZ/(LOG10(SCHR(12,N))-LOG10(HMPDZ))
                SLDZ = -(LOG10(HDGLZ)-LOG10(SCHR(12,N)))*DMPDZ
                ASLDZ = SLDZ
                ASLMZ = MAX( MIN( ASLDZ,ASLMINX ),0.D+0 )
!
!---            Capillary head above the imbibition matching point head,
!               use Webb extension  ---
!
                IF( HDGLZ.GT.HMPIZ ) THEN
                  SMPIZ = SCHR(10,N)
                  DMPIZ = SMPIZ/(LOG10(SCHR(12,N))-LOG10(HMPIZ))
                  SLIZ = -(LOG10(HDGLZ)-LOG10(SCHR(12,N)))*DMPIZ
                  ASLIZ = SLIZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
!
!---            Capillary head at or below the imbibition matching
!               point head, use van Genuchten function
!
                ELSE
                  CNI = MAX( SCHR(5,N),SMALL )
                  IF( SCHR(13,N).LE.ZERO ) THEN
                    IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                      CMI = 1.D+0 - 2.D+0/CNI
                    ELSE
                       CMI = 1.D+0 - 1.D+0/CNI
                    ENDIF
                  ELSE
                    CMI = SCHR(13,N)
                  ENDIF
                  ASLIZ = (1.D+0/(1.D+0 + (SCHR(2,N)*HDGLZ)**CNI))**CMI
                  ASLIZ = ASLIZ*(1.D+0-SLRZ) + SLRZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
                ENDIF
!
!---          Capillary head at or below the drainage matching point head,
!             use van Genuchten function
!
              ELSE
                CND = MAX( SCHR(3,N),SMALL )
                IF( SCHR(14,N).LE.ZERO ) THEN
                  IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                    CMD = 1.D+0 - 2.D+0/CND
                  ELSE
                    CMD = 1.D+0 - 1.D+0/CND
                  ENDIF
                ELSE
                  CMD = SCHR(14,N)
                ENDIF
                ASLDZ = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGLZ)**CND))**CMD
                ASLDZ = ASLDZ*(1.D+0-SLRZ) + SLRZ
                ASLMZ = MAX( MIN( ASLDZ,ASLMINX ),0.D+0 )
!
!---            Capillary head above the imbibition matching point head,
!               use Webb extension  ---
!
                IF( HDGLZ.GT.HMPIZ ) THEN
                  SMPIZ = SCHR(10,N)
                  DMPIZ = SMPIZ/(LOG10(SCHR(12,N))-LOG10(HMPIZ))
                  SLIZ = -(LOG10(HDGLZ)-LOG10(SCHR(12,N)))*DMPIZ
                  ASLIZ = SLIZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
!
!---            Capillary head at or below the imbibition matching
!               point head, use van Genuchten function
!
                ELSE
                  CNI = MAX( SCHR(5,N),SMALL )
                  IF( SCHR(13,N).LE.ZERO ) THEN
                    IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                      CMI = 1.D+0 - 2.D+0/CNI
                    ELSE
                      CMI = 1.D+0 - 1.D+0/CNI
                    ENDIF
                  ELSE
                    CMI = SCHR(13,N)
                  ENDIF
                  ASLIZ = (1.D+0/(1.D+0 + (SCHR(2,N)*HDGLZ)**CNI))**CMI
                  ASLIZ = ASLIZ*(1.D+0-SLRZ) + SLRZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
                ENDIF
              ENDIF
!
!---          Compute trapped gas saturation, using the minimum
!             apparent aqueous saturation  ---
!
              ASLM = MAX( MIN( ASLZ,ASLMINX ),0.D+0 )
              IF( ESGTMX.GT.EPSL .AND. ASLZ.GT.ASLM ) THEN
                SGTMZ = ESGTMX
                R = 1.D+0/SGTMZ - 1.D+0
                ESGTZ = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &            (1.D+0-ASLZ)/(1.D+0 + R*(1.D+0-ASLZ))
                IF( ESGTZ.LT.EPSL ) ESGTZ = 0.D+0
              ELSE
                ESGTZ = 0.D+0
              ENDIF
              SLZ = ASLZ - ESGTZ
              SGTZ = ESGTZ
              SGZ = 1.D+0-SLZ
              IF( SGZ.LT.EPSL ) SGZ = 0.D+0
!
!---        van Genuchten drainage-imbibition saturation function,
!           w/o Webb extension ASL = ESL + ESGT  ---
!
            ELSE
              CND = MAX( SCHR(3,N),SMALL )
              IF( SCHR(14,N).LE.ZERO ) THEN
                IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                  CMD = 1.D+0 - 2.D+0/CND
                ELSE
                  CMD = 1.D+0 - 1.D+0/CND
                ENDIF
              ELSE
                CMD = SCHR(14,N)
              ENDIF
              ASLDZ = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGLZ)**CND))**CMD
              CNI = MAX( SCHR(5,N),SMALL )
              IF( SCHR(13,N).LE.ZERO ) THEN
                IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                  CMI = 1.D+0 - 2.D+0/CNI
                ELSE
                  CMI = 1.D+0 - 1.D+0/CNI
                ENDIF
              ELSE
                CMI = SCHR(13,N)
              ENDIF
              ASLIZ = (1.D+0/(1.D+0 + (SCHR(2,N)*HDGLZ)**CNI))**CMI
              ASLMZ = MAX( MIN( ASLDZ,ASLMINX ),0.D+0 )
              IF( ASLDZ.GE.ASLIZ ) THEN
                ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &             + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
              ELSE
                ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
              ENDIF
!
!---          Compute trapped gas saturation, using the minimum
!             apparent aqueous saturation  ---
!
              ASLM = MAX( MIN( ASLZ,ASLMINX ),0.D+0 )
              IF( ESGTMX.GT.EPSL .AND. ASLZ.GT.ASLM ) THEN
                R = 1.D+0/ESGTMX - 1.D+0
                ESGTZ = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &            (1.D+0-ASLZ)/(1.D+0 + R*(1.D+0-ASLZ))
                IF( ESGTZ.LT.EPSL ) ESGTZ = 0.D+0
              ELSE
                ESGTZ = 0.D+0
              ENDIF
              ESLZ = ASLZ - ESGTZ
              SLZ = ESLZ*(1.D+0-SLRZ) + SLRZ
              SGTZ = ESGTZ*(1.D+0-SLRZ)
              SGZ = 1.D+0-SLZ
              IF( SGZ.LT.EPSL ) SGZ = 0.D+0
            ENDIF
            GX(M) = SLX - SLZ
          ENDDO
!
!---      Convergence check  ---
!
          IF( ABS(GX(1)).LT.1.D-9 ) EXIT
!
!---      Solve linear system  ---
!
          FX = GX(1)
          DFX = (GX(2)-GX(1))/DHDGLZ
          DHDGL = -FX/DFX
!
!---      Update primary unknowns  ---
!
          DHX = MAX( 1.D-3,2.D-1*HDGL )
          DHDGL = SIGN( MIN( DHX,ABS(DHDGL) ),DHDGL )
          HDGL = HDGL + DHDGL
          IF( (HDGL-HDGLMN).LT.EPSL .AND. NC.GE.3 ) EXIT
          IF( (HDGLMX-HDGL).LT.EPSL .AND. NC.GE.3 ) EXIT
          HDGL = MIN( HDGL,HDGLMX )
          HDGL = MAX( HDGL,HDGLMN )
        ENDDO
!
!---    Converged solution return capillary pressure  ---
!
        CPGL = HDGL*RHORL*GRAV/BTGLX
!
!---  Brooks and Corey drainage-imbibition saturation function,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.202 ) THEN
!
!---    Brooks and Corey drainage-imbibition saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        SLRX = SCHR(4,N)
        IF( ISM(N).EQ.2 ) THEN
          ESGTX = SGTX
          ASLX = SLX + SGTX
          ESGTMX = SCHR(15,N)
!
!---    Brooks and Corey drainage-imbibition saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          ESGTX = SGTX/(1.D+0-SLRX)
          ASLX = (SLX+SGTX-SLRX)/(1.D+0-SLRX)
          ESGTMX = SCHR(15,N)/(1.D+0-SLRX)
        ENDIF
!
!---    Minimum apparent aqueous saturation  ---
!
        R = 1.D+0/ESGTMX - 1.D+0
        IF( ASLMINX.LT.0.D+0 ) THEN
          ASLMINX = (ESGTX*R*ASLX + ESGTX*(R**2)*ASLX + ASLX - ESGTX -
     &      2.D+0*ESGTX*R - ESGTX*(R**2))/
     &      (1.D+0 + ESGTX*(R**2)*ASLX - ESGTX*R - ESGTX*(R**2) )
          ASLMINX = MIN( MAX( ASLMINX,0.D+0 ),1.D+0 )
        ENDIF
!
!---    Drainage capillary head  ---
!
        CLD = MAX( SCHR(3,N),SMALL )
        SMPDX = SCHR(8,N)
!
!---    Aqueous saturation below the matching point,
!       use Webb extension  ---
!
        IF( ASLX.LT.SMPDX ) THEN
          HMPDX = SCHR(9,N)
          DMPDX = -(LOG10(SCHR(12,N))-LOG10(HMPDX))/SMPDX
          HDGLD = 1.D+1**(DMPDX*(ASLX-SMPDX) + LOG10(HMPDX))
!
!---    Aqueous saturation at or above the matching point,
!       use Brooks and Corey function
!
        ELSE
!
!---      w/ Webb extension  ---
!
          IF( ISM(N).EQ.2 ) THEN
            ASLZ = (ASLX-SLRX)/(1.D+0-SLRX)
            HDGLD = SCHR(1,N)*(1.D+0/ASLZ)**(1.D+0/CLD)
!
!---      w/o Webb extension  ---
!
          ELSE
            HDGLD = SCHR(1,N)*(1.D+0/ASLX)**(1.D+0/CLD)
          ENDIF
        ENDIF
!
!---    Imbibition capillary head  ---
!
        CLI = MAX( SCHR(6,N),SMALL )
        SMPIX = SCHR(10,N)
!
!---    Aqueous saturation below the matching point,
!       use Webb extension  ---
!
        IF( ASLX.LT.SMPIX ) THEN
          HMPIX = SCHR(11,N)
          DMPIX = -(LOG10(SCHR(12,N))-LOG10(HMPIX))/SMPIX
          HDGLI = 1.D+1**(DMPIX*(ASLX-SMPIX) + LOG10(HMPIX))
!
!---    Aqueous saturation at or above the matching point,
!       use Brooks and Corey function
!
        ELSE
!
!---      w/ Webb extension  ---
!
          IF( ISM(N).EQ.2 ) THEN
            ASLZ = (ASLX-SLRX)/(1.D+0-SLRX)
            HDGLI = SCHR(5,N)*(1.D+0/ASLZ)**(1.D+0/CLI)
!
!---      w/o Webb extension  ---
!
          ELSE
            HDGLI = SCHR(5,N)*(1.D+0/ASLX)**(1.D+0/CLI)
          ENDIF
        ENDIF
!
!---    Guess capillary head  ---
!
        HDGL = (ASLMINX/ASLX)*HDGLD + (1.D+0-(ASLMINX/ASLX))*HDGLI
        HDGLMN = MIN( HDGLD,HDGLI )
        HDGLMX = MAX( HDGLD,HDGLI )
!
!---    Start Newton-Raphson solution  ---
!
        NC = 0
        DO
          NC = NC + 1
!
!---      No convergence on Brooks and Corey drainage-imbibition
!         saturation function  ---
!
          IF( NC.GT.32 ) THEN
            M_ERR(1) = 'Brooks and Corey Drainage-Imbibition: '
     &        // 'No Convergence on Capillary Pressure: ' //
     &        'Aqueous Saturation = '
            M_ERR(2) = ' at Node: '
            CALL PATH
            R_ERR = SLX
            I_ERR(1) = ND(N)
            I_ERR(2) = 1
            I_ERR(3) = 2
            I_ERR(4) = ID
            HDGL = (ASLMINX/ASLX)*HDGLD + (1.D+0-(ASLMINX/ASLX))*HDGLI
            EXIT
          ENDIF
          DO M = 1,2
            HDGLZ = HDGL
            DHDGLZ = SIGN( MAX( 1.D-6*HDGL,1.D-6 ),
     &        (5.D-1*SCHR(12,N) - HDGL) )
            IF( M.EQ.2 ) HDGLZ = HDGL + DHDGLZ
            HMPDZ = SCHR(9,N)
            HMPIZ = SCHR(11,N)
            SLRZ = SCHR(4,N)
!
!---        Brooks and Corey drainage-imbibition saturation function,
!           w/ Webb extension ASL = SL + SGT  ---
!
            IF( ISM(N).EQ.2 ) THEN
!
!---          Capillary head above the drainage matching point head,
!             use Webb extension  ---
!
              IF( HDGLZ.GT.HMPDZ ) THEN
                SMPDZ = SCHR(8,N)
                HDGLZ = MIN( HDGLZ,SCHR(12,N) )
                DMPDZ = SMPDZ/(LOG10(SCHR(12,N))-LOG10(HMPDZ))
                SLDZ = -(LOG10(HDGLZ)-LOG10(SCHR(12,N)))*DMPDZ
                ASLDZ = SLDZ
                ASLMZ = MAX( MIN( ASLDZ,ASLMINX ),0.D+0 )
!
!---            Capillary head above the imbibition matching point head,
!               use Webb extension  ---
!
                IF( HDGLZ.GT.HMPIZ ) THEN
                  SMPIZ = SCHR(10,N)
                  DMPIZ = SMPIZ/(LOG10(SCHR(12,N))-LOG10(HMPIZ))
                  SLIZ = -(LOG10(HDGLZ)-LOG10(SCHR(12,N)))*DMPIZ
                  ASLIZ = SLIZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
!
!---            Capillary head at or below the imbibition matching
!               point head, use Brooks and Corey function
!
                ELSE
                  CLI = MAX( SCHR(6,N),SMALL )
                  IF( HDGLZ.LE.SCHR(5,N) ) THEN
                    ASLIZ = 1.D+0
                  ELSE
                    ASLIZ = (SCHR(5,N)/HDGLZ)**CLI
                  ENDIF
                  ASLIZ = ASLIZ*(1.D+0-SLRZ) + SLRZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
                ENDIF
!
!---          Capillary head at or below the drainage matching point head,
!             use Brooks and Corey function
!
              ELSE
                CLD = MAX( SCHR(3,N),SMALL )
                IF( HDGLZ.LE.SCHR(1,N) ) THEN
                  ASLDZ = 1.D+0
                ELSE
                  ASLDZ = (SCHR(1,N)/HDGLZ)**CLD
                ENDIF
                ASLDZ = ASLDZ*(1.D+0-SLRZ) + SLRZ
                ASLMZ = MAX( MIN( ASLDZ,ASLMINX ),0.D+0 )
!
!---            Capillary head above the imbibition matching point head,
!               use Webb extension  ---
!
                IF( HDGLZ.GT.HMPIZ ) THEN
                  SMPIZ = SCHR(10,N)
                  DMPIZ = SMPIZ/(LOG10(SCHR(12,N))-LOG10(HMPIZ))
                  SLIZ = -(LOG10(HDGLZ)-LOG10(SCHR(12,N)))*DMPIZ
                  ASLIZ = SLIZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
!
!---            Capillary head at or below the imbibition matching
!               point head, use Brooks and Corey function
!
                ELSE
                  CLI = MAX( SCHR(6,N),SMALL )
                  IF( HDGLZ.LE.SCHR(5,N) ) THEN
                    ASLIZ = 1.D+0
                  ELSE
                    ASLIZ = (SCHR(5,N)/HDGLZ)**CLI
                  ENDIF
                  ASLIZ = ASLIZ*(1.D+0-SLRZ) + SLRZ
                  IF( ASLDZ.GE.ASLIZ ) THEN
                    ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ELSE
                    ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
                  ENDIF
                ENDIF
              ENDIF
!
!---          Compute trapped gas saturation, using the minimum
!             apparent aqueous saturation  ---
!
              ASLM = MAX( MIN( ASLZ,ASLMINX ),0.D+0 )
              IF( ESGTMX.GT.EPSL .AND. ASLZ.GT.ASLM ) THEN
                SGTMZ = ESGTMX
                R = 1.D+0/SGTMZ - 1.D+0
                ESGTZ = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &            (1.D+0-ASLZ)/(1.D+0 + R*(1.D+0-ASLZ))
                IF( ESGTZ.LT.EPSL ) ESGTZ = 0.D+0
              ELSE
                ESGTZ = 0.D+0
              ENDIF
              SLZ = ASLZ - ESGTZ
              SGTZ = ESGTZ
              SGZ = 1.D+0-SLZ
              IF( SGZ.LT.EPSL ) SGZ = 0.D+0
!
!---        Brooks and Corey drainage-imbibition saturation function,
!           w/o Webb extension ASL = ESL + ESGT  ---
!
            ELSE
              CLD = MAX( SCHR(3,N),SMALL )
              IF( HDGLZ.LE.SCHR(1,N) ) THEN
                ASLDZ = 1.D+0
              ELSE
                ASLDZ = (SCHR(1,N)/HDGLZ)**CLD
              ENDIF
              CLI = MAX( SCHR(6,N),SMALL )
              IF( HDGLZ.LE.SCHR(5,N) ) THEN
                ASLIZ = 1.D+0
              ELSE
                ASLIZ = (SCHR(5,N)/HDGLZ)**CLI
              ENDIF
              ASLMZ = MAX( MIN( ASLDZ,ASLMINX ),0.D+0 )
              IF( ASLDZ.GE.ASLIZ ) THEN
                ASLZ = 5.D-1*(ASLIZ + SQRT((ASLIZ**2)
     &             + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
              ELSE
                ASLZ = 5.D-1*(ASLIZ - SQRT((ASLIZ**2)
     &                 + 4.D+0*ASLMZ*ASLDZ - 4.D+0*ASLIZ*ASLMZ))
              ENDIF
!
!---          Compute trapped gas saturation, using the minimum
!             apparent aqueous saturation  ---
!
              ASLM = MAX( MIN( ASLZ,ASLMINX ),0.D+0 )
              IF( ESGTMX.GT.EPSL .AND. ASLZ.GT.ASLM ) THEN
                R = 1.D+0/ESGTMX - 1.D+0
                ESGTZ = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &            (1.D+0-ASLZ)/(1.D+0 + R*(1.D+0-ASLZ))
                IF( ESGTZ.LT.EPSL ) ESGTZ = 0.D+0
              ELSE
                ESGTZ = 0.D+0
              ENDIF
              ESLZ = ASLZ - ESGTZ
              SLZ = ESLZ*(1.D+0-SLRZ) + SLRZ
              SGTZ = ESGTZ*(1.D+0-SLRZ)
              SGZ = 1.D+0-SLZ
              IF( SGZ.LT.EPSL ) SGZ = 0.D+0
            ENDIF
            GX(M) = SLX - SLZ
          ENDDO
!
!---      Convergence check  ---
!
          IF( ABS(GX(1)).LT.1.D-9 ) EXIT
!
!---      Solve linear system  ---
!
          FX = GX(1)
          DFX = (GX(2)-GX(1))/DHDGLZ
          DHDGL = -FX/DFX
!
!---      Update primary unknowns  ---
!
          DHX = MAX( 1.D-3,2.D-1*HDGL )
          DHDGL = SIGN( MIN( DHX,ABS(DHDGL) ),DHDGL )
          IF( (HDGL-HDGLMN).LT.EPSL .AND. NC.GE.3 ) EXIT
          IF( (HDGLMX-HDGL).LT.EPSL .AND. NC.GE.3 ) EXIT
          HDGL = HDGL + DHDGL
          HDGL = MIN( HDGL,HDGLMX )
          HDGL = MAX( HDGL,HDGLMN )
        ENDDO
!
!---    Converged solution return capillary pressure  ---
!
        CPGL = HDGL*RHORL*GRAV/BTGLX
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of CAP_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE FLUX_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute fluxes on internal and boundary surfaces.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE HYST
      USE GLB_PAR
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/FLUX_GT'
!
!---  Gas volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVG_GT
!      PRINT *,'Post DRCVG_GT: ID = ',ID
!
!---  Aqueous volumetric flux (non-boundary surfaces)  ---
!
      CALL DRCVL_GT
!      PRINT *,'Post DRCVL_GT: ID = ',ID
!
!---  Salt diffusive flux through aqueous (non-boundary surfaces)
!     inactive for iso-brine option  ---
!
      IF( ISLC(32).EQ.0 ) CALL DFFLS_GT
!      PRINT *,'Post DFFLS_GT: ID = ',ID
!
!---  air and water diffusive flux through gas
!     (non-boundary surfaces)  ---
!
      CALL DFFGAW_GT
!      PRINT *,'Post DFFGAW_GT: ID = ',ID
!
!---  air and water diffusive flux through aqueous
!     (non-boundary surfaces)  ---
!
      CALL DFFLAW_GT
!      PRINT *,'Post DFFLAW_GT: ID = ',ID
!
!---  Nonisothermal simulations  ---
!
      IF( ISLC(30).EQ.0 )  THEN
!
!---    Compute diffusive thermal flux (interior surfaces)  ---
!
        CALL THD_GT
!        PRINT *,'Post THD_GT: ID = ',ID
!
!---    Compute aqueous-phase advective thermal flux
!       (interior surfaces)  ---
!
        CALL THAL_GT
!        PRINT *,'Post THAL_GT: ID = ',ID
!
!---    Compute gas-phase advective thermal flux
!       (interior surfaces)  ---
!
        IF( ISLC(37).EQ.0 ) CALL THAG_GT
!        PRINT *,'Post THAG_GT: ID = ',ID
!
!---    Compute vapor diffusive thermal flux
!       (interior surfaces)  ---
!
        IF( ISLC(37).EQ.0 ) CALL THDG_GT
!        PRINT *,'Post THDG_GT: ID = ',ID
      ENDIF
!
!---  Fracture flow and transport solution  ---
!
      IF( ISLC(74).NE.0 ) THEN
!!
!!---    Compute advective fluxes from borehole node to 
!!       fracture triangle  ---
!!
!        IF( ISLC(74).EQ.3 ) CALL DRCV_BTF_GT
!!
!!---    Compute diffusive fluxes from borehole node to 
!!       fracture triangle  ---
!!
!        IF( ISLC(74).EQ.3 .AND. ISLC(37).EQ.0 ) CALL DFFX_BTF_GT
!
!---    Compute borehole and fracture aqueous-phase volumetric flux  ---
!
        CALL DRCVL_BF_GT
!        PRINT *,'Post DRCVL_BF_GT: ID = ',ID
!
!---    Compute borehole and frature gas-phase volumetric flux  ---
!
        IF( ISLC(37).EQ.0 ) CALL DRCVG_BF_GT
!        PRINT *,'Post DRCVG_BF_GT: ID = ',ID
!
!---    Compute borehole and fracture water-vapor flux  ---
!
        IF( ISLC(37).EQ.0 ) CALL DFFGW_BF_GT
!
!---    Compute borehole and fracture dissolved-air flux  ---
!
        IF( ISLC(37).EQ.0 ) CALL DFFLA_BF_GT
!
!---    Isobrine option ---
!
        IF( ISLC(32).EQ.0 ) THEN
!
!---      Compute borehole and fracture advective and diffusive
!         salt flux  ---
!
          CALL DFFLS_BF_GT
!!
!!---      Compute borehole to fracture salt flux  ---
!!
!          IF( ISLC(74).EQ.3 ) CALL DFFLS_BTF_GT
        ENDIF
!
!---    Isothermal option  ---
!
        IF( ISLC(30).EQ.0 )  THEN
!!
!!---      Compute thermal fluxes from borehole node to 
!!         fracture triangle  ---
!!
!          IF( ISLC(74).EQ.3 ) CALL THFX_BTF_GT
!
!---      Compute borehole and fracture thermal diffusive flux  ---
!
          CALL THD_BF_GT
!          PRINT *,'Post THD_BF_GT: ID = ',ID
!
!---      Compute borehole and fracture thermal advective flux  ---
!
          CALL THA_BF_GT
!          PRINT *,'Post THA_BF_GT: ID = ',ID
!
!---      Compute borehole and fracture thermal gas component 
!         diffusive flux  ---
!
          IF( ISLC(37).EQ.0 ) CALL THDG_BF_GT
!          PRINT *,'Post THDG_BF_GT: ID = ',ID
        ENDIF
!
!---    Fracture to matrix transfer functions  ---
!
        IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL TRNS_FRC_GT
!        PRINT *,'Post TRNS_FRC_GT: ID = ',ID
!!
!!---    Borehole to matrix transfer functions  ---
!!
!        IF( ISLC(74).EQ.2 .OR. ISLC(74).EQ.3 ) CALL TRNS_BH_GT
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of FLUX_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE HYDST_BC_GT( BCX,PGX,PLX,TX,XLAX,XLSX,YLSX,ZPX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Establish hydrostatic boundary conditions.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      CHARACTER*132 CHMSGX(2)
      REAL*8 BCX(*)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/HYDST_BC_GT'
!
!---  Hydrostatic boundary conditions, establish aqueous pressure,
!     temperature, and salt mass fraction at boundary surface  ---
!
      ZX = BCX(3)
      KC = MAX( 1,INT(ABS(ZX-ZPX)) )
      DISTZ = (ZX-ZPX)/REAL(KC)
      PLX = BCX(2) + PATM
      PGX = PLX
      PX = MAX( PLX,PGX )
      DO K = 1,KC
        ZX = ZX - 5.D-1*DISTZ
        TX = BCX(4) + (ZX-BCX(5))*BCX(6)
        YLSX = BCX(7) + (ZX-BCX(8))*BCX(9)
        XLAX = BCX(10) + (ZX-BCX(11))*BCX(12)
        ZX = ZX - 5.D-1*DISTZ
!
!---    Check for out-of-range salt mass fraction  ---
!
        CALL SOL_BRNS( TX,PX,XLSMX )
        IF( YLSX.LT.0.D+0 ) THEN
          M_ERR(1) = 'Hydrostatic Boundary Condition: Salt ' //
     &      'Mass Fraction < 0.0 : XLS = '
          M_ERR(2) = ' at Node: '
          CALL PATH
          R_ERR = YLSX
          I_ERR(1) = ABS(N_DB)
          I_ERR(2) = 1
          I_ERR(3) = 2
          I_ERR(4) = ID
          YLSX = 0.D+0
          RETURN
        ELSEIF( YLSX.GT.XLSMX ) THEN
          M_ERR(1) = 'Hydrostatic Boundary Condition: Salt ' //
     &      'Mass Fraction > Solubility Limit : XLS = '
          M_ERR(2) = ' at Node: '
          CALL PATH
          R_ERR = YLSX
          I_ERR(1) = ABS(N_DB)
          I_ERR(2) = 1
          I_ERR(3) = 2
          I_ERR(4) = ID
          YLSX = XLSMX
          RETURN
        ENDIF
        PX = MAX( PGX,PLX )
        CHMSGX(1) = 'Unconverged Hydrostatic Boundary Conditions: ' //
     &    'Air Aqu. Mass Frac., Salt Aqu. Mass Frac. = '
        CHMSGX(2) = 'Hydrostatic Boundary Condition Transition: ' //
     &    'Vapor Pressure > Gas Pressure: PVB + PVA = '
        CALL P_IAPWS( TX,PLX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
        XLSX = YLSX
        CALL DENS_B( XLSX,RHOBX,RHOLWX,TX )
        RHOLX = RHOBX
        PLX = PLX + RHOLX*GRAVZ*DISTZ
        PGX = PLX
      ENDDO
      PGX = PLX
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of HYDST_BC_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE INCRM_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute primary variable increments.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE MPI
      USE PROP
      USE HYST
      USE GLB_PAR
      USE GRID
      USE FLUX
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/INCRM_GT'
      EPSLX = 1.D-4
      DO N = 1,NFCGC(ID+1)
        IF( IXP(N).EQ.0 ) CYCLE
        N_DB = ND(N)
!
!---    Minimum apparent aqueous saturation  ---
!
        ASLMINX = ASLMIN(2,N)
!
!---    Assign gas entry pressure and minimum gas saturation
!       for transition to unsaturated conditions---
!
        SGMNX = 1.D-3
        ENPR = 0.D+0
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.101 ) THEN
          SGMNX = 1.D+1**(-3.D+0+LOG10(1.D+0/SCHR(1,N)))
          SGMNX = MIN( MAX( SGMNX,1.D-4 ),1.D-3 )
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 ) THEN
          ENPR = SCHR(1,N)*RHORL*GRAV
          SGMNX = 1.D+1**(-3.D+0+LOG10(SCHR(1,N)))
          SGMNX = MIN( MAX( SGMNX,1.D-4 ),1.D-3 )
        ELSEIF( ISCHR(N).EQ.3 ) THEN
          SCHRX = MAX( SCHR(1,N),SCHR(5,N) )
          SGMNX = 1.D+1**(-3.D+0+LOG10(1.D+0/SCHRX))
          SGMNX = MIN( MAX( SGMNX,1.D-4 ),1.D-3 )
        ELSEIF( ISCHR(N).EQ.4 ) THEN
          ENPR = MIN( SCHR(1,N),SCHR(5,N) )*RHORL*GRAV
          SCHRX = MIN( SCHR(1,N),SCHR(5,N) )
          SGMNX = 1.D+1**(-3.D+0+LOG10(SCHRX))
          SGMNX = MIN( MAX( SGMNX,1.D-4 ),1.D-3 )
        ENDIF
!
!---    Maximum effective trapped gas saturation  ---
!
        IF( ISCHR(N).EQ.101 .OR. ISCHR(N).EQ.102 ) THEN
!
!---      w/ Webb extension  ---
!
          IF( ISM(N).EQ.2 ) THEN
            ESGTMX = SCHR(15,N)
!
!---      w/o Webb extension  ---
!
          ELSE
            ESGTMX = SCHR(15,N)/(1.D+0-SCHR(4,N))
          ENDIF
!
!---    Zero maximum trapped gas saturation  ---
!
        ELSE
          ESGTMX = 0.D+0
        ENDIF
!
!---    Absolute temperature  ---
!
        TKX = T(2,N) + TABS
!
!---    Saturated system w/o entrapped gas
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - aqueous-air mole fraction
!       Air mass - gas air partial pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ(2,N).EQ.1 ) THEN
          PG(2,N) = PL(2,N) + ENPR
          PLX = PL(2,N) + PATM
          INDX = 0
          CALL REGION_4( T(2,N),PSWX,INDX )
          PWX = MAX( PSWX,PLX )
          CALL SCF_GL( BTGLX,PWX )
          CALL SOL_BRNS( T(2,N),PWX,XLSMX )
          XLSX = MIN( YLS(2,N),XLSMX )
          XLS(2,N) = XLSX
          CALL SP_B( T(2,N),XLSX,PSBX )
          PVBX = PSBX
          PLX = PL(2,N) + PATM
!          PGAX = XMLA(2,N)*HCAW
          PGAX = PVA(2,N)
!
!---      Isoair option no transition from aqueous
!         saturated conditions  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            PGX = PVBX + PGAX
          ELSE
            PGX = PLX
          ENDIF
          PX = MAX( PGX,PLX )
          INDX = 0
          CALL KSP_GT( N,PGX,PLX,BTGLX,SGX,SGTX,SLX,SLFX,SLMX,
     &      RKLX,RKGX,ASLX,ASLMINX,ESGTX,ESGTMX,
     &      SLRX,INDX )
!
!---      Transition from aqueous saturated conditions to
!         aqueous unsaturated conditions: PC1 -> PC2  ---
!
          IF( SGX.GT.1.D-3 ) THEN
            SGX = 1.D-3
            SLX = 1.D+0 - SGX
            CALL CAP_GT( ASLMINX,BTGLX,CPGL,SLX,SGTX,N )
            PCX = CPGL
            CALL P_IAPWS( T(2,N),PSWX,RHOX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL VPL_B( T(2,N),PSWX,PCX,RHOLWX,PVW(2,N) )
            CALL SCF_GL( BTGLX,PVW(2,N) )
            CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            XLS(2,N) = XLSX
            CALL DENS_B( XLSX,RHOBX,RHOLWX,T(2,N) )
            CALL SP_B( T(2,N),XLSX,PSBX )
            CALL VPL_B( T(2,N),PSBX,PCX,RHOBX,PVBX )
            PGX = PVBX + PGAX
            PG(2,N) = PGX - PATM
            PL(2,N) = PG(2,N) - CPGL
            NPHAZ(2,N) = 2
!
!---      No transition from aqueous saturated conditions  ---
!
          ELSE
            NPHAZ(2,N) = 1
          ENDIF
!
!---    Unsaturated system w/ or w/o entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.2 ) THEN
          PLX = PL(2,N) + PATM
          PGX = PG(2,N) + PATM
          PX = MAX( PGX,PLX )
          INDX = 0
          CALL REGION_4( T(2,N),PSWX,INDX )
          CALL P_IAPWS( T(2,N),PSWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
          PCX = PGX - PLX
          CALL VPL_B( T(2,N),PSWX,PCX,RHOLWX,PVW(2,N) )
          CALL SCF_GL( BTGLX,PVW(2,N) )
          CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
          XLSX = MIN( YLS(2,N),XLSMX )
          XLS(2,N) = XLSX
          CALL DENS_B( XLSX,RHOBX,RHOLWX,T(2,N) )
          CALL SP_B( T(2,N),XLSX,PSBX )
          CALL VPL_B( T(2,N),PSBX,PCX,RHOBX,PVW(2,N) )
          PGAX = PGX - PVW(2,N)
          INDX = 0
          CALL KSP_GT( N,PGX,PLX,BTGLX,SGX,SGTX,SLX,SLFX,SLMX,
     &      RKLX,RKGX,ASLX,ASLMINX,ESGTX,ESGTMX,
     &      SLRX,INDX )
!
!---      Apparent aqueous saturation (i.e., aqueous saturation +
!         trapped gas saturation = 1.0), transition to saturation
!         conditions  ---
!
          IF( ABS(1.D+0-ASLX).LT.EPSL ) THEN
!
!---        Trapped gas exists transition to saturated condition
!           w/ entrapped gas: PC2 -> PC3  ---
!
            IF( ESGTMX.GT.EPSL .AND. SGTX.GT.EPSL ) THEN
              CALL CAP_GT( ASLMIN(2,N),BTGLX,PCX,SLX,SGTX,N )
              PG(2,N) = PL(2,N) + PCX
              SG(2,N) = SGX
              SGT(2,N) = SGX
              NPHAZ(2,N) = 3
!
!---        No trapped gas transition to saturated condition
!           w/o entrapped gas: PC2 -> PC1  ---
!
            ELSE
              PX = PL(2,N)+PATM
              CALL SP_B( T(2,N),XLSX,PSBX )
              PVBX = PSBX
              PG(2,N) = PL(2,N) + ENPR - EPSLX
              NPHAZ(2,N) = 1
            ENDIF
!
!---      No aqueous phase, transition
!         to fully unsaturated condition: PC2 -> PC4  ---
!
          ELSEIF( ( SLX.LT.EPSL .AND. (1.D+0-SL(1,N)).GT.EPSL ) .OR.
     &      TKX.GT.(TCRW+2.5D+0) ) THEN
            PGX = PG(2,N) + PATM
            INDX = 0
            CALL REGION_4( T(2,N),PSWX,INDX )
            CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
            IF( TMS(2,N).GT.EPSL ) THEN
              XLSX = XLSMX
            ELSE
              XLSX = 0.D+0
            ENDIF
            XLS(2,N) = XLSX
            SL(2,N) = 0.D+0
            SGT(2,N) = 0.D+0
            CALL CAP_GT( ASLMIN(2,N),BTGLX,PCX,SL(2,N),SGT(2,N),N )
            PL(2,N) = PG(2,N) - PCX
            PLX = PGX - PCX
            CALL SP_B( T(2,N),XLSX,PSBX )
            PX = MAX( PGX,PSBX )
            CALL P_IAPWS( T(2,N),PX,RHOX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL DENS_B( XLSX,RHOBX,RHOLWX,T(2,N) )
            PCX = PGX - PLX
            CALL VPL_B( T(2,N),PSBX,PCX,RHOBX,PVW(2,N) )
            PVA(2,N) = PGX - PVW(2,N)
            NPHAZ(2,N) = 4
!
!---      Gas pressure remains above gas-entry pressure, remain
!         as unsaturated condition  ---
!
          ELSE
            NPHAZ(2,N) = 2
          ENDIF
!
!---    Saturated system w/ entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - trapped gas saturation
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.3 ) THEN
          SLRX = SCHR(4,N)
!
!---      w/ Webb extension  ---
!
          IF( ISM(N).EQ.2 ) THEN
            ESGTX = SGT(2,N)
            ESGTOX = SGT(1,N)
!
!---      w/o Webb extension  ---
!
          ELSE
            ESGTX = SGT(2,N)/(1.D+0-SLRX)
            ESGTOX = SGT(1,N)/(1.D+0-SLRX)
          ENDIF
!
!---      Test against previous effective trapped gas saturation when
!         previous phase condition is saturated w/ entrapped gas  ---
!
          IF( NPHAZ(1,N).EQ.3 ) THEN
            ESGTPX = ESGTOX
          ELSE
            ESGTPX = ESGTX
          ENDIF
!
!---      Reversal point floats with trapped gas saturation  ---
!
          IF( (ESGTMX-ESGTX).GT.EPSL ) THEN
            ASLMIN(2,N) = (ESGTMX-ESGTX)/(ESGTMX + ESGTMX*ESGTX - ESGTX)
          ELSE
            ASLMIN(2,N) = 0.D+0
          ENDIF
          PX = PL(2,N)+PATM
          XLS(2,N) = XLSX
          CALL SP_B( T(2,N),XLSX,PSBX )
          PVBX = PSBX
!
!---      Trapped gas saturation disappears, transition to
!         saturated condition w/o entrapped gas: PC3 -> PC1  ---
!
          IF( SG(2,N).LT.EPSL ) THEN
            SGT(2,N) = 0.D+0
            SG(2,N) = 0.D+0
            PG(2,N) = PL(2,N) + ENPR - EPSLX
            ASLMIN(2,N) = 1.D+0
            NPHAZ(2,N) = 1
!
!---      Trapped gas saturation exceeds previous trapped gas
!         saturation or maximum trapped gas saturation, transition
!         to free gas w/ trapped gas phase condition: PC3 -> PC2  ---
!
          ELSEIF( ((ESGTX-ESGTPX).GT.EPSL) .OR.
     &      ((ESGTX-ESGTMX).GT.EPSL) ) THEN
!
!---        w/ Webb extension  ---
!
            IF( ISM(N).EQ.2 ) THEN
              ASLX = 1.D+0 - ESGTX + ESGTOX
              ASLMIN(2,N) = MIN( ASLMINX,ASLX )
              SGT(2,N) = ESGTOX
              SLX = ASLX - ESGTOX
!
!---        w/o Webb extension  ---
!
            ELSE
              ASLX = 1.D+0 - ESGTX + ESGTOX
              ASLMIN(2,N) = MIN( ASLMINX,ASLX )
              SGT(2,N) = ESGTOX*(1.D+0-SLRX)
              SLX = (ASLX-ESGTOX)*(1.D+0-SLRX) + SLRX
            ENDIF
            CALL CAP_GT( ASLMIN(2,N),BTGLX,PCX,SLX,SGT(2,N),N )
            PCX = CPGL
            CALL P_IAPWS( T(2,N),PSWX,RHOX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL VPL_B( T(2,N),PSWX,PCX,RHOLWX,PVW(2,N) )
            CALL SCF_GL( BTGLX,PVW(2,N) )
            CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
            XLSX = MIN( YLS(2,N),XLSMX )
            XLS(2,N) = XLSX
            CALL DENS_B( XLSX,RHOBX,RHOLWX,T(2,N) )
            CALL SP_B( T(2,N),XLSX,PSBX )
            CALL VPL_B( T(2,N),PSBX,PCX,RHOBX,PVBX )
            PGX = PVBX + PGAX
            PG(2,N) = PGX - PATM
            PL(2,N) = PG(2,N) - CPGL
            NPHAZ(2,N) = 2
!
!---      Trapped gas saturation neither disappears nor
!         exceeds previous trapped gas saturation,
!         remain as saturated w/ entrapped gas condition  ---
!
          ELSE
            IF( ISCHR(N).EQ.202 ) THEN
              PG(2,N) = PL(2,N) + SCHR(5,N) - EPSLX
            ELSE
              PG(2,N) = PL(2,N) + ENPR - EPSLX
            ENDIF
            NPHAZ(2,N) = 3
          ENDIF
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - air gas partial pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ(2,N).EQ.4 ) THEN
          PGX = PVA(2,N) + PVW(2,N)
          PG(2,N) = PGX - PATM
!
!---      Maximum salt solubility if aqueous phase existed  ---
!
          INDX = 0
          CALL REGION_4( T(2,N),PSWX,INDX )
          CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
          IF( TMS(2,N).GT.EPSL ) THEN
            XLSX = XLSMX
          ELSE
            XLSX = 0.D+0
          ENDIF
          XLS(2,N) = XLSX
          CALL SCF_GL( BTGLX,PVW(2,N) )
          SL(2,N) = 0.D+0
          SGT(2,N) = 0.D+0
          CALL CAP_GT( ASLMIN(2,N),BTGLX,PCX,SL(2,N),SGT(2,N),N )
          PL(2,N) = PG(2,N) - PCX
          PLX = PGX - PCX
          CALL P_IAPWS( T(2,N),PVW(2,N),RHOGWX,RHOLWX,HGWX,HLWX,
     &      UGWX,ULWX )
!
!---      Saturated water vapor pressure given temperature and
!         capillary pressure  ---
!
          CALL SP_B( T(2,N),XLSX,PSBX )
          CALL DENS_B( XLSX,RHOBX,RHOLWX,T(2,N) )
          PCX = PGX - PLX
          CALL VPL_B( T(2,N),PSBX,PCX,RHOBX,PVBX )
!
!---      Aqueous phase appears, transition to
!         unsaturated conditions: PC4 -> PC2  ---
!
          IF( PVW(2,N).GT.PSBX .AND. TKX.LE.(TCRW-2.5D+0) ) THEN
            SLX = MIN( MAX( 1.D-4,(1.D+1*(PVW(2,N)-PSBX)/PSBX) ),1.D-1 )
            SGTX = 0.D+0
            CALL CAP_GT( ASLMIN(2,N),BTGLX,CPGL,SLX,SGTX,N )
            PCX = CPGL
            CALL P_IAPWS( T(2,N),PSWX,RHOX,RHOLWX,HX,HLWX,UX,ULWX )
            CALL VPL_B( T(2,N),PSWX,PCX,RHOLWX,PVWX )
            CALL SCF_GL( BTGLX,PVWX )
            CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
            YLS(2,N) = TMS(2,N)/(RHOLWX*SLX*PORD(2,N)+TMS(2,N))
            XLSX = MIN( YLS(2,N),XLSMX )
            XLS(2,N) = XLSX
            CALL DENS_B( XLSX,RHOBX,RHOLWX,T(2,N) )
            CALL SP_B( T(2,N),XLSX,PSBX )
            CALL VPL_B( T(2,N),PSBX,PCX,RHOBX,PVBX )
            PGX = PVBX + PVA(2,N)
            PG(2,N) = PGX - PATM
            PL(2,N) = PG(2,N) - CPGL
            NPHAZ(2,N) = 2
!
!---      No aqueous phase, no transition from
!         fully unsaturated condition  ---
!
          ELSE
            NPHAZ(2,N) = 4
          ENDIF
        ENDIF
!
!---    Compute increments  ---
!
!
!---    Saturated system w/o entrapped gas
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - aqueous-air mole fraction
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ(2,N).EQ.1 ) THEN
!
!---      Energy - temperature
!
          DNR(IEQT,N) = -1.D-7
!
!---      Water mass - aqueous pressure
!
          PLX = PL(2,N) + PATM
          DNR(IEQW,N) = MAX( 1.D-4,1.D-7*PLX )
!
!---      Air mass - aqueous-air mole fraction
!---      Air mass - gas air partial pressure
!
          IF( ISLC(37).EQ.0 ) THEN
!            XMLAX = MAX( PL(2,N)+PATM,PATM )/HCAW
!            IF( XMLA(2,N).GT.(1.D-2*XMLAX) ) THEN
!              DNR(IEQA,N) = SIGN( 1.D-4*XMLAX,5.D-1*XMLAX-XMLA(2,N) )
!            ELSE
!              DNR(IEQA,N) = SIGN( 1.D-3*XMLAX,5.D-1*XMLAX-XMLA(2,N) )
!            ENDIF
            DNR(IEQA,N) = 1.D-1
          ENDIF
!
!---      NaCl mass - total NaCl brine mass fraction
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_BRNS( T(2,N),PLX,XLSMX )
            DNR(IEQS,N) = 1.D-5*XLSMX
          ENDIF
!
!---    Unsaturated system w/ or w/o entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.2 ) THEN
!
!---      Energy - temperature
!
          DNR(IEQT,N) = -1.D-7
!
!---      Water mass - aqueous pressure
!
          DNRX = MAX( 1.D-1,1.D-7*ABS(PG(2,N)-PL(2,N)) )
          DNR(IEQW,N) = -DNRX
!
!---      Air mass - gas pressure
!
          IF( ISLC(37).EQ.0 ) THEN
            DNRX = MAX( 1.D-3,1.D-7*(PG(2,N)+PATM) )
            DNR(IEQA,N) = DNRX
          ENDIF
!
!---      NaCl mass - total NaCl brine mass fraction
!
          IF( ISLC(32).EQ.0 ) THEN
            INDX = 0
            CALL REGION_4( T(2,N),PSWX,INDX )
            CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
            DNR(IEQS,N) = 1.D-5*XLSMX
          ENDIF
!
!---    Saturated system w/ entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - trapped gas saturation
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.3 ) THEN
!
!---      Energy - temperature
!
          DNR(IEQT,N) = -1.D-7
!
!---      Water mass - aqueous pressure
!
          PLX = PL(2,N)+PATM
          DNR(IEQW,N) = MAX( 1.D-1,1.D-6*PLX )
!
!---      Initial trapped gas saturation for the van Genuchten or
!         Brooks/Corey entrapment model  ---
!
          IF( ISCHR(N).EQ.101 .OR. ISCHR(N).EQ.102 .OR.
     &      ISCHR(N).EQ.201 .OR. ISCHR(N).EQ.202 ) THEN
!
!---        w/ Webb extension  ---
!
            IF( ISM(N).EQ.2 ) THEN
              ESGTMX = SCHR(15,N)
!
!---        w/o Webb extension  ---
!
            ELSE
              ESGTMX = SCHR(15,N)/(1.D+0-SCHR(4,N))
            ENDIF
          ELSE
            ESGTMX = 0.D+0
          ENDIF
!
!---      w/ Webb extension  ---
!
          IF( ISM(N).EQ.2 ) THEN
            SGTMX = ESGTMX
!
!---      w/o Webb extension  ---
!
          ELSE
            SGTMX = ESGTMX*(1.D+0-SCHR(4,N))
          ENDIF
!
!---      Air mass - trapped gas saturation
!
          IF( ISLC(37).EQ.0 ) THEN
            DNR(IEQA,N) = SIGN( 1.D-7,5.D-1*SGTMX-SG(2,N) )
          ENDIF
!
!---      NaCl mass - total NaCl brine mass fraction
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL SOL_BRNS( T(2,N),PLX,XLSMX )
            DNR(IEQS,N) = 1.D-5*XLSMX
          ENDIF
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - gas pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ(2,N).EQ.4 ) THEN
!
!---      Energy - temperature  ---
!
          DNR(IEQT,N) = -1.D-7
!
!---      Water mass - water vapor partial pressure  ---
!
          DPX = SIGN( MAX( 1.D-4,1.D-6*PVW(2,N) ),1.D+0-PVW(2,N) )
          DNR(IEQW,N) = DPX
!
!---      Air mass - air gas partial pressure  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            DPX = MAX( 1.D-4,1.D-6*PVA(2,N) )
            DNR(IEQA,N) = DPX
          ENDIF
!
!---      NaCl mass - salt mass  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            DNR(IEQS,N) = 1.D-6
          ENDIF
        ENDIF
!
!---    Assign gas-entry pressure for non Brooks-Corey;
!       Brooks-Corey; Brooks-Corey, Dual Porosity; and
!       Brooks-Corey, Entrapment  ---
!
        IF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &      ISCHR(N).EQ.202 ) THEN
          ENPR = SCHR(1,N)*RHORL*GRAV
        ELSEIF( ISCHR(N).EQ.4 ) THEN
          ENPR = MIN( SCHR(1,N),SCHR(5,N) )*RHORL*GRAV
        ELSE
          ENPR = 0.D+0
        ENDIF
!
!--- Increment the primary variables  ---
!
        DO M = 3,ISVC+2
          T(M,N) = T(2,N)
          PL(M,N) = PL(2,N)
          PG(M,N) = PG(2,N)
          PVW(M,N) = PVW(2,N)
          PVA(M,N) = PVA(2,N)
          XMLA(M,N) = XMLA(2,N)
          SG(M,N) = SG(2,N)
          SL(M,N) = SL(2,N)
          YLS(M,N) = YLS(2,N)
          TMS(M,N) = TMS(2,N)
!
!---      Saturated system w/o entrapped gas
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - aqueous-air mole fraction
!         NaCl mass - total NaCl brine mass fraction  ---
!
          IF( NPHAZ(2,N).EQ.1 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PL(M,N) = PL(M,N) + DNR(IEQW,N)
              PG(M,N) = PL(M,N) + ENPR - EPSLX
            ELSEIF( M.EQ.IEQA+2 .AND. ISLC(37).EQ.0 ) THEN
!              XMLA(M,N) = XMLA(M,N) + DNR(IEQA,N)
              PVA(M,N) = PVA(M,N) + DNR(IEQA,N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Unsaturated system w/ or w/o entrapped gas
!
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - gas pressure
!         NaCl mass - total NaCl brine mass fraction  ---
!
          ELSEIF( NPHAZ(2,N).EQ.2 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PL(M,N) = PL(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQA+2 .AND. ISLC(37).EQ.0 ) THEN
              PG(M,N) = PG(M,N) + DNR(IEQA,N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Saturated system w/ entrapped gas
!
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - trapped gas saturation
!         NaCl mass - total NaCl brine mass fraction  ---
!
          ELSEIF( NPHAZ(2,N).EQ.3 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PL(M,N) = PL(M,N) + DNR(IEQW,N)
              IF( ISCHR(N).EQ.202 ) THEN
                PG(M,N) = PL(M,N) + SCHR(5,N) - EPSLX
              ELSE
                PG(M,N) = PL(M,N) + ENPR - EPSLX
              ENDIF
            ELSEIF( M.EQ.IEQA+2 .AND. ISLC(37).EQ.0 ) THEN
              SG(M,N) = SG(M,N) + DNR(IEQA,N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              YLS(M,N) = YLS(M,N) + DNR(IEQS,N)
            ENDIF
!
!---      Fully unsaturated conditions
!
!         Energy - temperature
!         Water mass - water vapor partial pressure
!         Air mass - gas pressure
!         NaCl mass - salt mass  ---
!
          ELSEIF( NPHAZ(2,N).EQ.4 ) THEN
            IF( M.EQ.IEQT+2 ) THEN
              T(M,N) = T(M,N) + DNR(IEQT,N)
            ELSEIF( M.EQ.IEQW+2 ) THEN
              PVW(M,N) = PVW(M,N) + DNR(IEQW,N)
            ELSEIF( M.EQ.IEQA+2 .AND. ISLC(37).EQ.0 ) THEN
              PVA(M,N) = PVA(M,N) + DNR(IEQA,N)
            ELSEIF( M.EQ.IEQS+2 .AND. ISLC(32).EQ.0 ) THEN
              TMS(M,N) = TMS(M,N) + DNR(IEQS,N)
            ENDIF
         ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of INCRM_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE KSP_GT( N,PGX,PLX,BTGLX,SGX,SGTX,SLX,SLFX,SLMX,
     &  RKLX,RKGX,ASLX,ASLMINX,ESGTX,ESGTMX,SLRX,INDX )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Aqueous saturation, gas saturation, aqueous relative permeability,
!     and gas relative permeability.
!
!     INDX = 0 : Trapped-gas saturation computed.
!     INDX = 1 : Trapped-gas saturation given.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE FDVP
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/KSP_GT'
!
!---  Aqueous and gas saturation  ---
!
      IF( NPHAZ(2,N).EQ.4 ) THEN
        ASL_F = 0.D+0
        ASL_M = 0.D+0
        ASLX = 0.D+0
        ASLMINX = 0.D+0
        ESLX = 0.D+0
        ESGTX = 0.D+0
        SGTX = 0.D+0
        SLX = 0.D+0
        SGX = 1.D+0
      ELSE
        CALL SP_GT( ASL_F,ASL_M,ASLX,ASLMINX,ESLX,ESGTX,ESGTMX,
     &    PGX,PLX,BTGLX,SGX,SGTX,SLX,SLFX,SLMX,SLRX,INDX,N )
      ENDIF
!
!---  Aqueous relative permeability  ---
!
      CALL RKLS_GT( ASL_F,ASL_M,BTGLX,ESLX,PGX,PLX,RKLX,SLX,N )
!
!---  Gas relative permeability  ---
!
      CALL RKGS_GT( ASL_F,ASL_M,ASLX,ASLMINX,BTGLX,ESGTX,PGX,PLX,RKGX,
     &  SGX,SGTX,SLX,N )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of KSP_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE LDO_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Load the current time step values into the old time step
!     variables.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE GLB_PAR
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE HYST
      USE GRID
      USE FDVP
      USE BCVP
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/LDO_GT'
!
!---  Assign old time step values  ---
!
      DO N = 1,NFCGC(ID+1)
!
!---    Saturated system w/o trapped gas
!       Water mass - aqueous pressure
!       Air mass - aqueous-air mass fraction
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ(2,N).EQ.1 ) THEN
          ASLMIN(1,N) = 1.D+0
          ASLMIN(2,N) = 1.D+0
!
!---    Unsaturated system w/ or w/o entrapped gas
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.2 .OR. NPHAZ(2,N).EQ.4
     &    .OR. NPHAZ(2,N).EQ.6 ) THEN
          ASLMIN(1,N) = MIN( ASL(N),ASLMIN(1,N),ASLMIN(2,N) )
          ASLMIN(1,N) = MAX( ASLMIN(1,N),0.D+0 )
          ASLMIN(2,N) = ASLMIN(1,N)
!
!---    Saturated system w/ entrapped gas
!       Water mass - aqueous pressure
!       Air mass - trapped gas saturation
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.3 .OR. NPHAZ(2,N).EQ.5
     &    .OR. NPHAZ(2,N).EQ.7 ) THEN
          ASLMIN(1,N) = ASLMIN(2,N)
!
!---    Fully unsaturated system w/ or w/o entrapped gas
!       Water mass - aqueous saturation
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.8 .OR. NPHAZ(2,N).EQ.9
     &    .OR. NPHAZ(2,N).EQ.10 ) THEN
          ASLMIN(1,N) = 0.D+0
          ASLMIN(2,N) = 0.D+0
        ENDIF
        T(1,N) = T(2,N)
        PL(1,N) = PL(2,N)
        PG(1,N) = PG(2,N)
        PORD(1,N) = PORD(2,N)
        PORT(1,N) = PORT(2,N)
        BTGL(1,N) = BTGL(2,N)
        SL(1,N) = SL(2,N)
        SG(1,N) = SG(2,N)
        SI(1,N) = SI(2,N)
        PVA(1,N) = PVA(2,N)
        PVW(1,N) = PVW(2,N)
        XGA(1,N) = XGA(2,N)
        XGW(1,N) = XGW(2,N)
        XMGA(1,N) = XMGA(2,N)
        XMGW(1,N) = XMGW(2,N)
        XLA(1,N) = XLA(2,N)
        XLW(1,N) = XLW(2,N)
        XMLA(1,N) = XMLA(2,N)
        XMLW(1,N) = XMLW(2,N)
        RHOL(1,N) = RHOL(2,N)
        RHOG(1,N) = RHOG(2,N)
        RHOSP(1,N) = RHOSP(2,N)
        RHOI(1,N) = RHOI(2,N)
        VISL(1,N) = VISL(2,N)
        VISG(1,N) = VISG(2,N)
        TORL(1,N) = TORL(2,N)
        TORG(1,N) = TORG(2,N)
        RKL(1,N) = RKL(2,N)
        RKG(1,N) = RKG(2,N)
        DFGW(1,N) = DFGW(2,N)
        DFLA(1,N) = DFLA(2,N)
        THKG(1,N) = THKG(2,N)
        THKL(1,N) = THKL(2,N)
        HI(1,N) = HI(2,N)
        HL(1,N) = HL(2,N)
        HGW(1,N) = HGW(2,N)
        HGA(1,N) = HGA(2,N)
        HG(1,N) = HG(2,N)
        UEG(1,N) = UEG(2,N)
        HSP(1,N) = HSP(2,N)
        NPHAZ(1,N) = NPHAZ(2,N)
        SS(1,N) = SS(2,N)
        TMS(1,N) = TMS(2,N)
        XLS(1,N) = XLS(2,N)
        YLS(1,N) = YLS(2,N)
        DO NSL = 1,NSOLU
          CO(N,NSL) = C(N,NSL)
        ENDDO
        DO NEQ = 1,NEQC+NEQK
          NSL = NEQ + NSOLU
          CO(N,NSL) = C(N,NSL)
        ENDDO
        DO NSP = 1,NSPR
          SP_CO(N,NSP) = SP_C(N,NSP)
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of LDO_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE PROP_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute hydrologic, thermodynamic and physical properties.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE JACOB
      USE HYST
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/PROP_GT'
!
!---  Loop over all nodes, skipping inactive nodes  ---
!
      L1: DO N = 1,NFCGC(ID+1)
        IF( IXP(N).EQ.0 ) CYCLE
        N_DB = ND(N)
!
!---    Initial trapped gas saturation for the van Genuchten or
!       Brooks/Corey entrapment model  ---
!
        IF( ISCHR(N).EQ.101 .OR. ISCHR(N).EQ.102 .OR.
     &      ISCHR(N).EQ.201 .OR. ISCHR(N).EQ.202 ) THEN
!
!---      w/ Webb extension  ---
!
          IF( ISM(N).EQ.2 ) THEN
            ESGTMX = SCHR(15,N)
!
!---      w/o Webb extension  ---
!
          ELSE
            ESGTMX = SCHR(15,N)/(1.D+0-SCHR(4,N))
          ENDIF
        ELSE
          ESGTMX = 0.D+0
        ENDIF
!
!---    Minimum apparent aqueous saturation  ---
!
        ASLMINX = ASLMIN(2,N)
!
!---    Loop over increment indices  ---
!
        L2: DO M = 2,ISVC+2
          PLX = PL(M,N)+PATM
          PGX = PG(M,N)+PATM
          INDX = 0
          CALL REGION_4( T(M,N),PSW(M,N),INDX )
!
!---      Saturated system w/o entrapped gas
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - gas air partial pressure
!         NaCl mass - total NaCl brine mass fraction  ---
!
          IF( NPHAZ(2,N).EQ.1 ) THEN
            PX = PLX
            PWX = PLX
            PCX = 0.D+0
            SL(M,N) = 1.D+0
            CALL SCF_GL( BTGL(M,N),PWX )
            CALL SOL_BRNS( T(M,N),PWX,XLSMX )
            XLS(M,N) = MIN(YLS(M,N),XLSMX)
            CALL SP_B( T(M,N),XLS(M,N),PSBX )
            CALL P_IAPWS( T(M,N),PWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL DENS_B( XLS(M,N),RHOBX,RHOLWX,T(M,N) )
            PVBX = PSBX
!            PVA(M,N) = XMLA(M,N)*HCAW
            XMLA(M,N) = PVA(M,N)/HCAW
            PVW(M,N) = PVBX
            XMGA(M,N) = PVA(M,N)/(PVA(M,N)+PVW(M,N))
            CALL EQUIL( XGA(M,N),XGW(M,N),XLA(M,N),XLS(M,N),XLW(M,N),
     &        XMGA(M,N),XMGW(M,N),XMLA(M,N),XMLS(M,N),XMLW(M,N) )
!
!---      Unsaturated system w/ or w/o entrapped gas
!
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - gas pressure
!         NaCl mass - total NaCl brine mass fraction  ---
!
          ELSEIF( NPHAZ(2,N).EQ.2 ) THEN
            PX = PG(2,N) + PATM
            CALL P_IAPWS( T(M,N),PSW(M,N),RHOX,RHOLWX,HX,HLWX,UX,ULWX )
            PCX = PG(M,N)-PL(M,N)
            CALL VPL_B( T(M,N),PSW(M,N),PCX,RHOLWX,PVWX )
            CALL SCF_GL( BTGL(M,N),PVWX )
            CALL SOL_BRNS( T(M,N),PSW(M,N),XLSMX )
            XLS(M,N) = MIN(YLS(M,N),XLSMX)
            CALL DENS_B( XLS(M,N),RHOBX,RHOLWX,T(M,N) )
            CALL SP_B( T(M,N),XLS(M,N),PSBX )
            CALL VPL_B( T(M,N),PSBX,PCX,RHOBX,PVBX )
            CALL P_IAPWS( T(M,N),PVBX,RHOGWX,RHOX,HGWX,HX,UGWX,UX )
            PVA(M,N) = PGX-PVBX
            IF( PVA(M,N).LT.1.D-6 ) PVA(M,N) = 0.D+0
            PVW(M,N) = PVBX
            XMLA(M,N) = PVA(M,N)/HCAW
            XMGA(M,N) = PVA(M,N)/PGX
            CALL EQUIL( XGA(M,N),XGW(M,N),XLA(M,N),XLS(M,N),XLW(M,N),
     &        XMGA(M,N),XMGW(M,N),XMLA(M,N),XMLS(M,N),XMLW(M,N) )
!
!---      Saturated system w/ entrapped gas
!
!         Energy - temperature
!         Water mass - aqueous pressure
!         Air mass - trapped gas saturation
!         NaCl mass - total NaCl brine mass fraction  ---
!
          ELSEIF( NPHAZ(2,N).EQ.3 ) THEN
            PCX = 0.D+0
            PWX = PSW(M,N)
            CALL SCF_GL( BTGL(M,N),PWX )
            CALL P_IAPWS( T(M,N),PWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL SOL_BRNS( T(M,N),PWX,XLSMX )
            XLS(M,N) = MIN(YLS(M,N),XLSMX)
            CALL SP_B( T(M,N),XLS(M,N),PSBX )
            PX = MAX( PLX,PSBX )
            CALL DENS_B( XLS(M,N),RHOBX,RHOLWX,T(M,N) )
            CALL VPL_B( T(M,N),PSBX,PCX,RHOBX,PVBX )
            PVA(M,N) = PX-PVBX
            IF( PVA(M,N).LT.1.D-6 ) PVA(M,N) = 0.D+0
            PVW(M,N) = PVBX
            XMLA(M,N) = PVA(M,N)/HCAW
            XMGA(M,N) = PVA(M,N)/(PVA(M,N)+PVW(M,N))
            CALL EQUIL( XGA(M,N),XGW(M,N),XLA(M,N),XLS(M,N),XLW(M,N),
     &        XMGA(M,N),XMGW(M,N),XMLA(M,N),XMLS(M,N),XMLW(M,N) )
!
!---      Fully unsaturated conditions
!
!         Energy - temperature
!         Water mass - water vapor partial pressure
!         Air mass - air gas partial pressure
!         NaCl mass - salt mass  ---
!
          ELSEIF( NPHAZ(2,N).EQ.4 ) THEN
            PGX = PVA(M,N) + PVW(M,N)
            PG(M,N) = PGX - PATM
            PX = PGX
            INDX = 0
            CALL REGION_4( T(M,N),PSW(M,N),INDX )
            CALL SOL_BRNS( T(M,N),PSW(M,N),XLSMX )
            IF( TMS(M,N).GT.EPSL ) THEN
              XLS(M,N) = XLSMX
            ELSE
              XLS(M,N) = 0.D+0
            ENDIF
            CALL SCF_GL( BTGL(M,N),PVW(M,N) )
            SL(M,N) = 0.D+0
            SGT(M,N) = 0.D+0
            CALL CAP_GT( ASLMIN(2,N),BTGL(M,N),PCX,SL(M,N),SGT(M,N),N)
            PL(M,N) = PG(M,N) - PCX
            PLX = PGX - PCX
            CALL P_IAPWS( T(M,N),PVW(M,N),RHOGWX,RHOLWX,HGWX,HLWX,
     &        UGWX,ULWX )
            CALL DENS_B( XLS(M,N),RHOBX,RHOLWX,T(M,N) )
            XMLA(M,N) = PVA(M,N)/HCAW
            XMGA(M,N) = PVA(M,N)/PGX
            CALL EQUIL( XGA(M,N),XGW(M,N),XLA(M,N),XLS(M,N),XLW(M,N),
     &        XMGA(M,N),XMGW(M,N),XMLA(M,N),XMLS(M,N),XMLW(M,N) )
          ENDIF
!
!---      Porous-media porosity  ---
!
          CALL PORSTY_GT( N,PX,PCMP(N),PORD(M,N),PORT(M,N) )
          PORD(M,N) = MAX( PORD(M,N),EPSL )
          PORT(M,N) = MAX( PORT(M,N),PORD(M,N) )
!
!---      Saturation, relative permeability  ---
!
          INDX = 0
          IF( NPHAZ(2,N).EQ.3 ) THEN
            SGT(M,N) = SG(M,N)
            INDX = 1
          ENDIF
          CALL KSP_GT( N,PG(M,N),PL(M,N),BTGL(M,N),SG(M,N),SGT(M,N),
     &      SL(M,N),SDPF(N),SDPM(N),RKL(M,N),RKG(M,N),ASLX,ASLMINX,
     &      ESGTX,ESGTMX,SLRX,INDX )
          IF( M.EQ.2 ) THEN
            ASL(N) = ASLX
            ASGT(N) = ESGTX
          ENDIF
!
!---      Gas density and component fractions  ---
!
          CALL AIRGSD( T(M,N),PVA(M,N),RHOGAX )
          RHOG(M,N) = XGA(M,N)*RHOGAX + XGW(M,N)*RHOGWX
          WTMGX = XMGA(M,N)*WTMA + XMGW(M,N)*WTMW
          RHOMG(M,N) = RHOG(M,N)/WTMGX
!
!---      Gas viscosity  ---
!
          CALL AIRGSV( T(M,N),VISGAX )
          CALL VISC_W( T(M,N),PVBX,RHOGWX,VISGWX )
          CALL VISC_G( VISGAX,VISGWX,XMGA(M,N),XMGW(M,N),VISG(M,N) )
!
!---      Aqueous density and molar density  ---
!
          RHOL(M,N) = RHOBX
          WTMLX = XMLA(M,N)*WTMA + XMLS(M,N)*WTMS + XMLW(M,N)*WTMW
          RHOML(M,N) = RHOL(M,N)/WTMLX
!
!---      Aqueous viscosity  ---
!
          CALL VISC_W( T(M,N),PX,RHOLWX,VISLWX )
          CALL VISC_B( T(M,N),XLS(M,N),VISLWX,VISBX )
          CALL VISC_L( XMLA(M,N),VISBX,VISGAX,VISL(M,N) )
!
!---      Gas-water diffusion coefficients  ---
!
          IF( ISLC(2).EQ.1 ) THEN
            DFGW(M,N) = DFGWC
          ELSEIF( ISLC(2).EQ.2 ) THEN
            CALL BNDFAW( T(M,N),PGX,DFGW(M,N) )
          ELSEIF( ISLC(2).EQ.3 ) THEN
            CALL BNDFAW( T(M,N),PGX,DFGW(M,N) )
            CMFF = 1.D+0 + 2.6D+0/(DFGWC**0.5)
            AMC = PORD(M,N)*SL(M,N)
            ENHF = 9.5D+0 + 6.D+0*(AMC) -
     &        8.5D+0/EXP(MIN(((CMFF*AMC)**4),1.D+2))
            DFGW(M,N) = ENHF*DFGW(M,N)
          ELSEIF( ISLC(2).EQ.4 ) THEN
            CALL BNDFAW( T(M,N),PGX,DFGW(M,N) )
            ENHF = DFEF(1,N)+DFEF(2,N)*SL(M,N)-
     &        (DFEF(1,N)-DFEF(4,N))
     &        *EXP(-((DFEF(3,N)*SL(M,N))**DFEF(5,N)))
            DFGW(M,N) = ENHF*DFGW(M,N)
          ENDIF
!
!---      Aqueous-air diffusion coefficients  ---
!
          IF( ISLC(4).EQ.1 ) THEN
            DFLA(M,N) = DFLAC
          ELSEIF( ISLC(4).EQ.2 ) THEN
            CALL AIRDFL( T(M,N),VISL(M,N),DFLA(M,N) )
          ENDIF
!
!---      Aqueous-salt diffusion coefficient  ---
!
          IF( ISLC(4).EQ.1 ) THEN
            DFLS(M,N) = DFLSC
          ELSEIF( ISLC(4).EQ.2 ) THEN
            CALL DIFC_LS( T(M,N),XLS(M,N),VISL(M,N),DFLS(M,N) )
          ENDIF
!
!---      Precipitated NaCl density and saturation  ---
!
          CALL DENS_S( T(M,N),PX,RHOSP(M,N) )
!
!---      Fully unsaturated system w/ or w/o entrapped gas
!         Water mass - aqueous saturation
!         air mass - gas pressure
!         NaCl mass - total NaCl brine mass fraction  ---
!
          IF( NPHAZ(2,N).EQ.4 ) THEN
            SS(M,N) = TMS(M,N)/(RHOSP(M,N)*PORD(M,N))
            SLX = EPSL
            YLS(M,N) = TMS(M,N)*RHOBX*SLX*PORD(M,N)
          ELSE
!
!---        Precipitated salt saturation  ---
!
            SS(M,N) = MAX(YLS(M,N)-XLSMX,0.D+0)*RHOBX*SL(M,N)/
     &        RHOSP(M,N)
!
!---        NaCl volumetric concentration  ---
!
            TMS(M,N) = YLS(M,N)*RHOBX*SL(M,N)*PORD(M,N)
          ENDIF
!
!---      Permeability reduction factor with simplified Verma and
!         Preuss model  ---
!
          IF( IPRF(N)/10.EQ.4 ) THEN
!
!---        Porosity with salt precipitation  ---
!
            PORD(M,N) = MAX( PORD(M,N)*(1.D+0-SS(M,N)),
     &        PORD(M,N)*PERM(5,N),1.D-12 )
!
!---        Permeability reduction factor with salt precipitation
!           and mineral precipitation or dissolution  ---
!
            PERMRF(M,N) = ((PORD(M,N)-PERM(5,N))/
     &        (PERM(4,N)-PERM(5,N)))**PERM(6,N)
!
!---      Permeability reduction factor with Verma and Preuss model  ---
!
          ELSEIF( IPRF(N).EQ.1 ) THEN
            CALL PERM_R( SS(M,N),PERMRF(M,N),PORD(M,N),N )
          ENDIF
!
!---      Aqueous and gas tortuosity  ---
!
          IF( ISLC(3).EQ.1 ) CALL TORTU( N,SL(M,N),SG(M,N),
     &      PORD(M,N),TORL(M,N),TORG(M,N) )
!
!---      Nonisothermal simulation  ---
!
          IF( ISLC(30).EQ.0 ) THEN
!
!---        Gas enthalpy and internal energy  ---
!
            CALL AIRGSH( T(M,N),PVA(M,N),HGA(M,N),UEGAX )
            UEG(M,N) = XGA(M,N)*UEGAX + XGW(M,N)*UGWX
            HGW(M,N) = HGWX
            HG(M,N) = XGA(M,N)*HGA(M,N) + XGW(M,N)*HGW(M,N)
!
!---        Gas thermal conductivity  ---
!
            CALL AIRGSK( T(M,N),THKGAX )
            CALL THK_W( T(M,N),PGX,RHOGWX,THKGWX )
            CALL THK_G( T(M,N),THKGAX,THKGWX,XMGA(M,N),
     &        XMGW(M,N),THKG(M,N) )
!
!---        Aqueous enthalpy and internal energy  ---
!
            CALL ENTH_B( T(M,N),XLS(M,N),HLWX,HBX )
            HL(M,N) = MAX(1.D+0-XLA(M,N),0.D+0)*HBX + XLA(M,N)*HGA(M,N)
!
!---        Aqueous thermal conductivity  ---
!
            CALL THK_W( T(M,N),PX,RHOLWX,THKLWX )
            CALL THK_B( T(M,N),XLS(M,N),THKLWX,THKL(M,N) )
!
!---        Precipitated NaCl enthalpy  ---
!
            CALL ENTH_S( T(M,N),HSP(M,N) )
          ENDIF
        ENDDO L2
      ENDDO L1
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of PROP_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_BIN_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary files from processor.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE REACT
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_BIN_GT'
!
!---  Read input.bin for solution control and output data  ---
!
      CALL READ_SOLU_GT
!      PRINT *,'Post READ_SOLU_GT: ID = ',ID
!
!---  Read input.bin for grid data  ---
!
      CALL READ_GRID_GT
!      PRINT *,'Post READ_GRID_GT: ID = ',ID
!
!---  Read input.bin for property data  ---
!
      CALL READ_PROP_GT
!      PRINT *,'Post READ_PROP_GT: ID = ',ID
!
!---  Read input.bin for state condition data  ---
!
      CALL READ_STATE_GT
!      PRINT *,'Post READ_STATE_GT: ID = ',ID
!
!---  Read input.bin for boundary condition data  ---
!
      CALL READ_BOCO_GT
!      PRINT *,'Post READ_BOCO_GT: ID = ',ID
!
!---  Read input.bin for source data  ---
!
      CALL READ_SORC_GT
!      PRINT *,'Post READ_SORC_GT: ID = ',ID
!
!---  Read input.bin for solute/species transport data  ---
!
      IF( IEQC.NE.0 ) CALL READ_TPORT_GT
!      PRINT *,'Post READ_TPORT_GT: ID = ',ID
!
!---  Read geomechanial binary files  ---
!
      IF( ISLC(50).NE.0 ) CALL READ_BIN_GM
!      PRINT *,'Post READ_BIN_GM: ID = ',ID
!
!---  Read ecke.bin for ECKEChem (i.e., reactive transport data)  ---
!
      IF( ISLC(40).EQ.1 ) THEN
        CALL READ_REACT_GT
      ELSE
        ALLOCATE( ISPLK(1:2*LNGC+LSPR+14),STAT=ISTAT )
        CHMSG = 'ISPLK'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        DO L = 1,2*LNGC+LSPR+14
          ISPLK(L) = 0
        ENDDO
      ENDIF
!      PRINT *,'Post READ_REACT_GT: ID = ',ID
!
!---  Read ptzrcoef.bin  ---
!
      IF( IACTV.EQ.2 ) CALL READ_PTZRCOEF
!      PRINT *,'Post READ_PTZR_CO2: IACTV = ',IACTV,'ID = ',ID
!
!---  Read fracture.bin for simulations with fractures  ---
!
      IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) CALL READ_FBIN_GT
!      PRINT *,'Post READ_FBIN_GT: ID = ',ID
!
!---  Read restart.bin for restart simulations  ---
!
      IF( IEO.EQ.2 ) CALL RDRST_GT
!      PRINT *,'Post RDRST_GT: IEO = ',IEO,'ID = ',ID
!
!---  Check for fatal execution errors and stop simulation
!     if detected  ---
!
      CALL CHK_ERROR
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_BIN_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_BOCO_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for boundary condition data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE PROP
      USE MPI
      USE GRID
      USE GLB_PAR
      USE FILES
      USE BCVP
      USE BCV
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_BOCO_GT'
!
!---  Open boco.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'boco.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate memory for NBC  ---
!
      ALLOCATE( NBC(1:NP),STAT=ISTAT )
      CHMSG = 'NBC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of boundary condition surfaces on each
!     processor  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NBC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate memory for boundary condition arrays  ---
!
      CALL ALLOC_BCV
      CALL ALLOC_BCVP
!
!---  Initialize boundary condition variables  ---
!
      CALL INTLZ_BCV
      CALL INTLZ_BCVP
!
!---  Read boundary condition variables
!     (duplicated across processors)  ---
!
      NVAR = LBCV*LBTM*LBCIN
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,BC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read array of boundary condition nodes  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NBC(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NBC(N)
      ENDDO
!
!---  Index array of boundary condition field nodes  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCN: ID = ',ID
!
!---  Index array of boundary condition directions  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCD,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCD: ID = ',ID
!
!---  Index array of boundary condition number of time points  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCM: ID = ',ID
!
!---  Index array of boundary condition input links  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCIN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCIN: ID = ',ID
!
!---  Index array of boundary condition cycling options  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCC,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCC: ID = ',ID
!
!---  Index array of boundary condition types  ---
!
      LX = LUK+LSOLU*LC
      NVAR = NBC(ID+1)*LX
      OFFSET = IOFFSET + NC*LX*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*LX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'Post IBCT: ID = ',ID
!
!---  Index array of boundary condition reactive species  ---
!
      NVAR = NBC(ID+1)*(LSPBC+1)
      OFFSET = IOFFSET + NC*(LSPBC+1)*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*(LSPBC+1)*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCSP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      PRINT *,'IBCSP = ',((IBCSP(K,L),K=1,(LSPBC+1)),L=1,NBC(ID+1)),
!     &  ' ID = ',ID
!
!---  Array of x-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post XPBC: ID = ',ID
!
!---  Array of y-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      PRINT *,'Post YPBC: ID = ',ID
!
!---  Array of z-coordinate of boundary surface centroid  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZPBC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!      DO NB = 1,NBC(ID+1)
!        PRINT *,'XPBC(',NB,') = ',XPBC(NB),' ID = ',ID
!        PRINT *,'YPBC(',NB,') = ',YPBC(NB),' ID = ',ID
!        PRINT *,'ZPBC(',NB,') = ',ZPBC(NB),' ID = ',ID
!      ENDDO
!
!---  Allocate local temporary real initial condition boundary
!     condition array memory  ---
!
      ALLOCATE( VARX(1:NBC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Array of initial condition boundary condition temperature  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO NB = 1,NBC(ID+1)
        TB(1,NB) = VARX(NB)
        VARX(NB) = 0.D+0
      ENDDO
!      PRINT *,'TB(1,NBC(ID+1)) = ',TB(1,NBC(ID+1)),'ID = ',ID
!
!---  Array of initial condition boundary condition aqueous 
!     pressure  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        PLB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!      PRINT *,'PLB(1,NBC(ID+1)) = ',PLB(1,NBC(ID+1)),'ID = ',ID
!
!---  Array of initial condition boundary condition gas 
!     pressure  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        PGB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!      PRINT *,'PGB(1,NBC(ID+1)) = ',PGB(1,NBC(ID+1)),'ID = ',ID
!
!---  Array of initial condition boundary condition aqueous air 
!     mass fraction  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        XLAB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!      PRINT *,'XLAB(1,NBC(ID+1)) = ',XLAB(1,NBC(ID+1)),'ID = ',ID
!
!---  Array of initial condition boundary condition gas water 
!     mass fraction  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        XGWB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!      PRINT *,'XGWB(1,NBC(ID+1)) = ',XGWB(1,NBC(ID+1)),'ID = ',ID
!
!---  Array of initial condition boundary condition aqueous salt 
!     mass fraction  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        YLSB(1,N) = VARX(N)
        VARX(N) = 0.D+0
      ENDDO
!      PRINT *,'YLSB(1,NBC(ID+1)) = ',YLSB(1,NBC(ID+1)),'ID = ',ID
!
!---  Array of initial condition boundary condition aqueous 
!     saturation  ---
!
      NVAR = NBC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NBC(ID+1)
        SLB(1,N) = VARX(N)
      ENDDO
!      PRINT *,'SLB(1,NBC(ID+1)) = ',SLB(1,NBC(ID+1)),'ID = ',ID
!      DO N = 1,NBC(ID+1)
!        SLB(1,N) = VARX(N)
!        PRINT *,'SLB(1,',N,') = ',SLB(1,N),' ID = ',ID
!        VARX(N) = 0.D+0
!      ENDDO
!
!---  Deallocate local temporary real initial condition boundary
!     condition array memory  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Close the boco.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_BOCO_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_GRID_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for grid data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE JACOB
      USE GRID
      USE GLB_PAR
      USE FILES
      USE CONST
#ifdef lis
!
!----------------------Lis Modules-----------------------------------!
!
      USE LIS_STOMP
#endif
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER IVARX(10)
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_GRID_GT'
!
!---  Allocate memory for NFCGC, number of field cells and ghost
!     cells on each processor  ---
!
      ALLOCATE( NFCGC(1:NP),STAT=ISTAT )
      CHMSG = 'NFCGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NFC, number of field cells on each
!     processor  ---
!
      ALLOCATE( NFC(1:NP),STAT=ISTAT )
      CHMSG = 'NFC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for IDP  ---
!
      ALLOCATE( IDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'IDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for JDP  ---
!
      ALLOCATE( JDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'JDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for KDP  ---
!
      ALLOCATE( KDP(1:2,1:NP),STAT=ISTAT )
      CHMSG = 'KDP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKFL ---
!
      ALLOCATE( NUKFL(1:NP),STAT=ISTAT )
      CHMSG = 'NUKFL'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKFO ---
!
      ALLOCATE( NUKFO(1:NP),STAT=ISTAT )
      CHMSG = 'NUKFO'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKFP ---
!
      ALLOCATE( NUKFP(1:NP),STAT=ISTAT )
      CHMSG = 'NUKFP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKTL ---
!
      ALLOCATE( NUKTL(1:NP),STAT=ISTAT )
      CHMSG = 'NUKTL'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKTO ---
!
      ALLOCATE( NUKTO(1:NP),STAT=ISTAT )
      CHMSG = 'NUKTO'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for NUKTP ---
!
      ALLOCATE( NUKTP(1:NP),STAT=ISTAT )
      CHMSG = 'NUKTP'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Open grid1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read NFCGC array (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET =  IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NFCGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NFCGC_G = 0
      DO N = 1,NP
        NFCGC_G = NFCGC_G + NFCGC(N)
      ENDDO
!
!---  Allocate memory for geometry arrays (including ghost cells)  ---
!
      CALL ALLOC_GRID
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Read IDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read JDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,JDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read KDP array (duplicated across processors)  ---
!
      NVAR = 2*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,KDP,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read local copies of XE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XE,NVAR,MPI_REAL8,STATUS,IERR )
!
!---  Close the grid1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of YE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YE,NVAR,MPI_REAL8,STATUS,IERR )
!
!---  Close the grid2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid3.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid3.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ZE array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*8
      OFFSET = IOFFSET + NBYTB + NC*8*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*8*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZE,NVAR,MPI_REAL8,STATUS,IERR )
!
!---  Close the grid3.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid4.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid4.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of XP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,XP,NVAR,MPI_REAL8,STATUS,IERR )
!
!---  Read local copies of YP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,YP,NVAR,MPI_REAL8,STATUS,IERR )
!
!---  Read local copies of ZP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ZP,NVAR,MPI_REAL8,STATUS,IERR )
!
!---  Read local copies of RP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RP,NVAR,MPI_REAL8,STATUS,IERR )
!
!---  Close the grid4.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid5.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid5.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of DXGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DXGF,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of DYGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DYGF,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of DZGF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DZGF,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Close the grid5.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid6.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid6.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of DXGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DXGP,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of DYGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DYGP,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of DZGP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DZGP,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Close the grid6.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid7.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid7.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of AFX array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFX,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of AFY array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFY,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of AFZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,AFZ,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Close the grid7.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid8.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid8.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of VOL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VOL,NVAR,MPI_REAL8,STATUS,
     &  IERR )
!
!---  Read local copies of GRVX array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVX,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of GRVY array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVY,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read local copies of GRVZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*2
      OFFSET = IOFFSET + NBYTB + NC*2*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*2*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,GRVZ,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Close the grid8.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open grid9.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'grid9.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of IXP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IXP,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read local copies of INBS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,INBS,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read local copies of ND array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ND,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read NUKFL (local flow equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFL,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read NUKFO (local flow equation offsets)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFO,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read NUKFG (global flow equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKFG,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read NUKTL (local transport equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTL,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read NUKTO (local transport equation offsets)
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTO,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read NUKTG  (global transport equation unknowns)
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NUKTG,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read IFLD, JFLD, KFLD, NFLD (global field limits)
!     IPFLD, JPFLD, KPFLD, NPFLD (processor field limits)
!     (duplicated across processors)  ---
!
      NVAR = 10
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      IFLD = IVARX(1)
      JFLD = IVARX(2)
      KFLD = IVARX(3)
      NFLD = IVARX(4)
      NXP = IVARX(5)
      ICS = IVARX(6)
      IPFLD = IVARX(7)
      JPFLD = IVARX(8)
      KPFLD = IVARX(9)
      NPFLD = IVARX(10)
      IF( NP.NE.NPFLD ) THEN
        IF( ID.EQ.0 ) PRINT *,'Processor Count Error: Number of ' //
     &    'Processors Requested ≠ Input File Processor Count'
        CALL MPI_FINALIZE( IERR )
        STOP
      ENDIF
!
!---  Allocate memory for NGHC ---
!
      ALLOCATE( NGHC(1:NP),STAT=ISTAT )
      CHMSG = 'NGHC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NGHC array total number of ghost cells on a processor,
!     (duplicated across processors)  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NGHC,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Allocate memory for NCGC ---
!
      ALLOCATE( NCGC(1:6,1:NP),STAT=ISTAT )
      CHMSG = 'NCGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NCGC array, number of ghost cells to be sent in the
!     stencil directions, (duplicated across processors)  ---
!
      NVAR = 6*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NCGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Allocate memory for NPGC ---
!
      ALLOCATE( NPGC(1:6,1:NP),STAT=ISTAT )
      CHMSG = 'NPGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read NPGC array, receiving processors in the
!     stencil directions, (duplicated across processors)  ---
!
      NVAR = 6*NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NPGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Allocate memory for NLSGC ---
!
      ALLOCATE( NLSGC(1:NGHC(ID+1)),STAT=ISTAT )
      CHMSG = 'NLSGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      NCX = 0
      DO I = 1,ID
        NCX = NCX + NGHC(I)
      ENDDO
      NCSX = 0
      DO I = 1,NP
        NCSX = NCSX + NGHC(I)
      ENDDO
!
!---  Read local copies of NLSGC array  ---
!
      NVAR = NGHC(ID+1)
      OFFSET = IOFFSET + NBYTB + NCX*NBYTI
      IOFFSET = IOFFSET + NCSX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NLSGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Allocate memory for NLRGC ---
!
      ALLOCATE( NLRGC(1:NGHC(ID+1)),STAT=ISTAT )
      CHMSG = 'NLRGC'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local copies of NLRGC array  ---
!
      NVAR = NGHC(ID+1)
      OFFSET = IOFFSET + NBYTB + NCX*NBYTI
      IOFFSET = IOFFSET + NCSX*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NLRGC,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Close the grid9.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Load ITAG, sending/receiving tags
!     (duplicated across processors)  ---
!
      NC = 0
      DO NPRX = 1,NP
        DO NPSX = 1,NP
          NC = NC + 1
          ITAG(NPSX,NPRX) = NC
        ENDDO
      ENDDO
!
!---  Number of ghost-cell primary variables for STOMP-CO2  ---
!
      NPVX = 12
!
!---  Allocate memory for ghost-cell send buffers in the six
!     stencil directions  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        PRINT *,'SBFB(',NPVX*NCGC(1,ID+1),' ID = ',ID
        ALLOCATE( SBFB(1:NPVX*NCGC(1,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFB on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(1,ID+1)
          SBFB(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        PRINT *,'SBFS(',NPVX*NCGC(2,ID+1),' ID = ',ID
        ALLOCATE( SBFS(1:NPVX*NCGC(2,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFS on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(2,ID+1)
          SBFS(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        PRINT *,'SBFW(',NPVX*NCGC(3,ID+1),' ID = ',ID
        ALLOCATE( SBFW(1:NPVX*NCGC(3,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFW on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(3,ID+1)
          SBFW(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        PRINT *,'SBFE(',NPVX*NCGC(4,ID+1),' ID = ',ID
        ALLOCATE( SBFE(1:NPVX*NCGC(4,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFE on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(4,ID+1)
          SBFE(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        PRINT *,'SBFN(',NPVX*NCGC(5,ID+1),' ID = ',ID
        ALLOCATE( SBFN(1:NPVX*NCGC(5,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFN on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(5,ID+1)
          SBFN(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        PRINT *,'SBFT(',NPVX*NCGC(6,ID+1),' ID = ',ID
        ALLOCATE( SBFT(1:NPVX*NCGC(6,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for SBFT on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(6,ID+1)
          SBFT(M) = 0.D+0
        ENDDO
      ENDIF
!
!---  Allocate memory for ghost-cell receive buffers in the six
!     stencil directions  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        PRINT *,'RBFB(',NPVX*NCGC(6,ID+1),' ID = ',ID
        ALLOCATE( RBFB(1:NPVX*NCGC(6,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFB on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(6,ID+1)
          RBFB(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        PRINT *,'RBFS(',NPVX*NCGC(5,ID+1),' ID = ',ID
        ALLOCATE( RBFS(1:NPVX*NCGC(5,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFS on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(5,ID+1)
          RBFS(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        PRINT *,'RBFW(',NPVX*NCGC(4,ID+1),' ID = ',ID
        ALLOCATE( RBFW(1:NPVX*NCGC(4,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFW on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(4,ID+1)
          RBFW(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        PRINT *,'RBFE(',NPVX*NCGC(3,ID+1),' ID = ',ID
        ALLOCATE( RBFE(1:NPVX*NCGC(3,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFE on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(3,ID+1)
          RBFE(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        PRINT *,'RBFN(',NPVX*NCGC(2,ID+1),' ID = ',ID
        ALLOCATE( RBFN(1:NPVX*NCGC(2,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFN on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(2,ID+1)
          RBFN(M) = 0.D+0
        ENDDO
      ENDIF
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        PRINT *,'RBFT(',NPVX*NCGC(1,ID+1),' ID = ',ID
        ALLOCATE( RBFT(1:NPVX*NCGC(1,ID+1)),STAT=ISTAT )
        IF( ISTAT.NE.0 ) THEN
          PRINT *,'Allocation Error for RBFT on ID = ',ID
        ENDIF
        DO M = 1,NPVX*NCGC(1,ID+1)
          RBFT(M) = 0.D+0
        ENDDO
      ENDIF
!
!---  Initialize ghost cell map  ---
!
      DO L = 1,NFCGC(ID+1)
        IGHC(L) = 0
      ENDDO
!
!---  Create a local node connection map and identify ghost cells  ---
!
      KFLD_L = KDP(2,ID+1)-KDP(1,ID+1)+1
      JFLD_L = JDP(2,ID+1)-JDP(1,ID+1)+1
      IFLD_L = IDP(2,ID+1)-IDP(1,ID+1)+1
      DO K = KDP(1,ID+1),KDP(2,ID+1)
        DO J = JDP(1,ID+1),JDP(2,ID+1)
          DO I = IDP(1,ID+1),IDP(2,ID+1)
            KX = K - KDP(1,ID+1) + 1
            JX = J - JDP(1,ID+1) + 1
            IX = I - IDP(1,ID+1) + 1
            N = (KX-1)*IFLD_L*JFLD_L + (JX-1)*IFLD_L + IX
!
!---        Bottom connection  ---
!
            ICM(1,N) = 0
            IF( KX.GT.1 ) THEN
              NB = N-IFLD_L*JFLD_L
              IF( IXP(NB).GT.0 .AND. INBS(1,N).EQ.0 ) ICM(1,N) = NB
            ENDIF
!
!---        Bottom ghost cells  ---
!
            IF( KX.EQ.1 .AND. K.GT.1 ) IGHC(N) = 1
!
!---        South connection  ---
!
            ICM(2,N) = 0
            IF( JX.GT.1 ) THEN
              NS = N-IFLD_L
              IF( IXP(NS).GT.0 .AND. INBS(2,N).EQ.0 ) ICM(2,N) = NS
            ENDIF
!
!---        South ghost cells  ---
!
            IF( JX.EQ.1 .AND. J.GT.1 ) IGHC(N) = 1
!
!---        West connection  ---
!
            ICM(3,N) = 0
            IF( IX.GT.1 ) THEN
              NW = N-1
              IF( IXP(NW).GT.0 .AND. INBS(3,N).EQ.0 ) ICM(3,N) = NW
            ENDIF
!
!---        West ghost cells  ---
!
            IF( IX.EQ.1 .AND. I.GT.1 ) IGHC(N) = 1
!
!---        East connection  ---
!
            ICM(4,N) = 0
            IF( IX.LT.IFLD_L ) THEN
              NE = N+1
              IF( IXP(NE).GT.0 .AND. INBS(4,N).EQ.0 ) ICM(4,N) = NE
            ENDIF
!
!---        East ghost cells  ---
!
            IF( IX.EQ.IFLD_L .AND. I.LT.IDP(2,NP) ) IGHC(N) = 1
!
!---        North connection  ---
!
            ICM(5,N) = 0
            IF( JX.LT.JFLD_L ) THEN
              NN = N+IFLD_L
              IF( IXP(NN).GT.0 .AND. INBS(5,N).EQ.0 ) ICM(5,N) = NN
            ENDIF
!
!---        North ghost cells  ---
!
            IF( JX.EQ.JFLD_L .AND. J.LT.JDP(2,NP) ) IGHC(N) = 1
!
!---        Top connection  ---
!
            ICM(6,N) = 0
            IF( KX.LT.KFLD_L ) THEN
              NT = N+IFLD_L*JFLD_L
              IF( IXP(NT).GT.0 .AND. INBS(6,N).EQ.0 ) ICM(6,N) = NT
            ENDIF
!
!---        Top ghost cells  ---
!
            IF( KX.EQ.KFLD_L .AND. K.LT.KDP(2,NP) ) IGHC(N) = 1
          ENDDO
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_GRID_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_PROP_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for property data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE TABL
      USE SOLTN
      USE PROP
      USE MPI
      USE GRID
      USE GLB_PAR
      USE GEO_MECH
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_PROP_GT'
!
!---  Allocate local memory for property arrays ---
!
      CALL ALLOC_PROP
!
!---  Allocate local memory for lookup table arrays ---
!
      CALL ALLOC_TABL
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Open mech.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'mech.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of IZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IZ,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RHOS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RHOS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of CPS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CPS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of CMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*4
      OFFSET = IOFFSET + NBYTB + NC*4*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*4*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of POR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,POR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TOR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*6
      OFFSET = IOFFSET + NBYTB + NC*6*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*6*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TOR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of ITOR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ITOR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the mech.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open hydr.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'hydr.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of PERM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*9
      OFFSET = IOFFSET + NBYTB + NC*9*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*9*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PERM,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of IPRF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IPRF,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the hydr.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open satu1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'satu1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of SCHR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LSCHR
      OFFSET = IOFFSET + NBYTB + NC*LSCHR*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LSCHR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,SCHR,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the satu1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open satu2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'satu2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ISCHR array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISCHR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of ISM array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of ISLTBL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*4
      OFFSET = IOFFSET + NBYTB + NC*4*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*4*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISLTBL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of IRGTBL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*4
      OFFSET = IOFFSET + NBYTB + NC*4*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*4*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRGTBL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of IRLTBL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*4
      OFFSET = IOFFSET + NBYTB + NC*4*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*4*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRLTBL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the satu2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open rel_perm.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'perm.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of ISKP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISKP,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RPGC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPGC
      OFFSET = IOFFSET + NBYTB + NC*LRPGC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPGC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPGC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of IRPG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPG,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of RPLC array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*LRPLC
      OFFSET = IOFFSET + NBYTB + NC*LRPLC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*LRPLC*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RPLC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of IRPL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IRPL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Close the rel_perm.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open comp.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'comp.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of PCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PCMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TCMP array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TCMP,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the comp.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open tabl.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'tabl.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of NTBL, duplicated over all processors  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NTBL,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of TBLX array, duplicated over all 
!     processors  ---
!
      NVAR = LTBL
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TBLX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TBLY array, duplicated over all 
!     processors  ---
!
      NVAR = LTBL
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TBLY,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TBLDDX array, duplicated over all 
!     processors  ---
!
      NVAR = LTBL
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TBLDDX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of TBLDDY arra, duplicated over all 
!     processors  ---
!
      NVAR = LTBL
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TBLDDY,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the tabl.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open ther.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'ther.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of THKS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*9
      OFFSET = IOFFSET + NBYTB + NC*9*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*9*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,THKS,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read local copies of ITHK array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ITHK,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read local copies of DFEF array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)*5
      OFFSET = IOFFSET + NBYTB + NC*5*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*5*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,DFEF,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Close the ther.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_PROP_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_REACT_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for ECKEChem (reactive transport) data
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE REACT
      USE PROP
      USE HYST
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
      USE BCV
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX,VARZ
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX,IVARZ
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_REACT_GT'
!
!---  Open ecke.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'ecke.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate and initialize memory, global and local, for
!     reactive species arrays  ---
!
      CALL ALLOC_REACT
      CALL INTLZ_REACT
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Allocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of reactive species integers
!     (duplicated across processors)  ---
!
      NVAR = 19
      ALLOCATE( IVARZ(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARZ'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARZ,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      IACTEX = IVARZ(1)
      IACTV = IVARZ(2)
      ISP_IEDL = IVARZ(3)
      NEQE = IVARZ(4)
      NEQC = IVARZ(5)
      NEQK = IVARZ(6)
      NESITE = IVARZ(7)
      NRCE = IVARZ(8)
      NRCK = IVARZ(9)
      NRTSI = IVARZ(10)
      NSPC = IVARZ(11)
      NSPE = IVARZ(12)
      NSPG = IVARZ(13)
      NSPK = IVARZ(14)
      NSPL = IVARZ(15)
      NSPLK = IVARZ(16)
      NSPN = IVARZ(17)
      NSPR = IVARZ(18)
      NSPS = IVARZ(19)
!      PRINT *,'IVARZ = ',(IVARZ(M),M=1,NVAR),' ID = ',ID
      DEALLOCATE( IVARZ,STAT=ISTAT )
      CHMSG = 'IVARZ'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read reactive transport parameters, indices, and variables
!     if reactive species are modeled  ---
!
      IF( NEQE+NEQC+NEQK.GT.0 ) THEN
!
!---    Read index for equilibrium equations
!       (duplicated across processors)  ---
!
        NVAR = (LSEE+2)*LEQE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_E,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_E = ',((IEQ_E(L,M),L=1,LSEE+2),M=1,LEQE),
!     &    ' ID = ',ID
!
!---    Read index for conservation equations
!       (duplicated across processors)  ---
!
        NVAR = (LSEC+1)*LEQC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_C,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_C = ',((IEQ_C(L,M),L=1,LSEC+1),M=1,LEQC),
!     &    ' ID = ',ID
!
!---    Read index for kinetic equations
!       (duplicated across processors)  ---
!
        NVAR = (LSEK+LREK+2)*LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_K,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_K = ',((IEQ_K(L,M),L=1,LSEK+LREK+2),M=1,LEQK),
!     &    ' ID = ',ID
!
!---    Read index for reactive equation sequencing
!       (duplicated across processors)  ---
!
        NVAR = LSPR
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEQ_S,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEQ_S = ',(IEQ_S(L),L=1,LSPR),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISP_E,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISP_E = ',(ISP_E(L),L=1,LSPE),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IEL_LK,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IEL_LK = ',(IEL_LK(L),L=1,LSPE),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPR
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISP_MN,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISP_MN = ',(ISP_MN(L),L=1,LSPR),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LEQE+LEQC+LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISP_S,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISP_S = ',(ISP_S(L),L=1,LEQE+LEQC+LEQK),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSOLU+LSPT
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IMMB,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IMMB = ',(IMMB(L),L=1,LSOLU+LSPT),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = (LSPK+3)*LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IRC_K,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IRC_K = ',((IRC_K(L,M),L=1,LSPK+3),M=1,LRCK),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPK+11
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IRCKN,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IRCKN = ',(IRCKN(L),L=1,LSPK+11),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IRCKT,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IRCKT = ',(IRCKT(L),L=1,LRCK),
!     &    ' ID = ',ID
!
!---    Read index for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 2*LNGC+LSPR+14
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ISPLK,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ISPLK = ',(ISPLK(L),L=1,2*LNGC+LSPR+14),
!     &    ' ID = ',ID
!
!---    Read index for reactive species  ---
!
        DO J = 1,LSPS
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTI + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            ISP_OW(J,N) = IVARX(N)
          ENDDO
!          PRINT *,'ISP_OW(',J,',1) = ',ISP_OW(J,1),
!     &      'ISP_OW(',J,',',ND(NVAR),') = ',ISP_OW(J,NVAR),' ID = ',ID
        ENDDO
!
!---    Read index for reactive species  ---
!
        DO M = 1,LSPR
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTI + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            IC_SP(N,M) = IVARX(N)
          ENDDO
!          PRINT *,'IC_SP(1,',M,') = ',IC_SP(1,M),
!     &      'IC_SP(',ND(NVAR),',',M,') = ',IC_SP(NVAR,M),' ID = ',ID
        ENDDO
!
!---    Read parameters for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 4
        ALLOCATE( VARZ(1:NVAR),STAT=ISTAT )
        CHMSG = 'VARZ'
        CALL ALLOC_ERROR( CHMSG,ISTAT )
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,VARZ,NVAR,MPI_REAL8,
     &    STATUS,IERR)
        ACTVC = VARZ(1)
        CMIN = VARZ(2)
        SP_MDG = VARZ(3)
        SP_MDL = VARZ(4)
        DEALLOCATE( VARZ,STAT=ISTAT )
        CHMSG = 'VARZ'
        CALL DEALLOC_ERROR( CHMSG,ISTAT )
!        PRINT *,'ACTVC = ',ACTVC,' CMIN = ',CMIN,
!     &    ' SP_MDG = ',SP_MDG,' SP_MDL = ',SP_MDL,' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 3
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SP_SDCL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SP_SDCL = ',(SP_SDCL(L),L=1,3),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LMC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CFMX,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'LMC = ',LMC,' CFMX = ',(CFMX(L),L=1,LMC),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSPR
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CHARG,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'LSPR = ',LSPR,' CHARG = ',(CHARG(L),L=1,LSPR),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSEC*LEQC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,EQ_C,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'EQ_C = ',((EQ_C(L,M),L=1,LSEC),M=1,LEQC),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = LSEE*LEQE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,EQ_E,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'EQ_E = ',((EQ_E(L,M),L=1,LSEE),M=1,LEQE),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = (LSEK+LREK)*LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,EQ_K,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'EQ_K = ',((EQ_K(L,M),L=1,LSEK+LREK),M=1,LEQK),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 5*LRCE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RC_E,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'RC_E = ',((RC_E(L,M),L=1,5),M=1,LRCE),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = (LSPK+11)*LCKN*LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RC_K,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'RC_K = ',(RC_K(K,1,1),K=1,LSPK+11),' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 3*LSPL
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SP_L,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SP_L = ',((SP_L(L,M),L=1,3),M=1,LSPL),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 2*LSPS
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SP_S,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SP_S = ',((SP_S(L,M),L=1,2),M=1,LSPS),
!     &    ' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO I = 1,3
          DO J = 1,LSPS
            NVAR = NFCGC(ID+1)
            OFFSET = IOFFSET + NC*NBYTR + NBYTB
            IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
            CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &        STATUS,IERR)
            DO N = 1,NFCGC(ID+1)
              RS_S(I,J,N) = VARX(N)
            ENDDO
          ENDDO
        ENDDO
!        PRINT *,'RS_S = ',((RS_S(I,J,1),I=1,3),J=1,LSPS),' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO M = 1,LEQC+LEQK
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            YSPG(N,M) = VARX(N)
          ENDDO
        ENDDO
!        PRINT *,'YSPG = ',(YSPG(1,M),M=1,LEQC+LEQK),' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO M = 1,LEQC+LEQK
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            YSPL(N,M) = VARX(N)
          ENDDO
        ENDDO
!        PRINT *,'YSPL = ',(YSPL(1,M),M=1,LEQC+LEQK),' ID = ',ID
!
!---    Read parameter for reactive species  ---
!
        DO M = 1,LSPR
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            SP_C(N,M) = VARX(N)
          ENDDO
        ENDDO
!        PRINT *,'SP_C = ',(SP_C(1,M),M=1,LSPR),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LRCE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RCNME,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'RCNME = ',(RCNME(L),L=1,LRCE),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LRCK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,RCNMK,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'RCNMK = ',(RCNMK(L),L=1,LRCK),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LEQC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMC,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMC = ',(SPNMC(L),L=1,LEQC),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LEQK
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMK,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMK = ',(SPNMK(L),L=1,LEQK),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPG
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMG,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMG = ',(SPNMG(L),L=1,LSPG),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPL
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNML,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNML = ',(SPNML(L),L=1,LSPL),' ID = ',ID
!
!---    Read character string for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPS
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNMS,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNMS = ',(SPNMS(L),L=1,LSPS),' ID = ',ID
!
!---    Read parameter for reactive species
!       (duplicated across processors)  ---
!
        NVAR = 64*LSPE
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SPNME,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SPNME = ',(SPNME(L),L=1,LSPE),' ID = ',ID
      ENDIF
!
!---  Deallocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Close the ecke.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_REACT_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_SOLU_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for solution control and output data
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE SOLTN
      USE OUTPU
      USE GRID
      USE GLB_PAR
      USE FDVP
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
      CHARACTER(64), DIMENSION(2) :: FNSFX
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_SOLU_GT'
!
!---  Open solu.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'solu.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Initialize rror messaging variables  ---
!
      DO M = 1,4
        I_ERR(M) = 0
        M_ERR(M) = ''
      ENDDO
      I_ERR(4) = NP + 1
      R_ERR = 0.D+0
!
!---  Initialize cummulative offset  ---
!
      IOFFSET = 0
!
!---  Read parameter variables (duplicated across processors)  ---
!
      NVAR = 341
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      L_BH = IVARX(1)
      L_CW = IVARX(2)
      L_DP = IVARX(3)
      L_EC = IVARX(4)
      L_FRC = IVARX(5)
      L_LV = IVARX(6)
      L_LW = IVARX(7)
      L_SFC = IVARX(8)
      LAD = IVARX(9)
      LALC = IVARX(10)
      LAN = IVARX(11)
      LANI = IVARX(12)
      LANW = IVARX(13)
      LATM = IVARX(14)
      LBAL = IVARX(15)
      LBC = IVARX(16)
      LBC_BH = IVARX(17)
      LBC_EC = IVARX(18)
      LBC_FRC = IVARX(19)
      LBC_GM = IVARX(20)
      LBCA = IVARX(21)
      LBCC = IVARX(22)
      LBCG = IVARX(23)
      LBCGC = IVARX(24)
      LBCH = IVARX(25)
      LBCI = IVARX(26)
      LBCIN = IVARX(27)
      LBCIN_GM = IVARX(28)
      LBCL = IVARX(29)
      LBCN = IVARX(30)
      LBCN2 = IVARX(31)
      LBCS = IVARX(32)
      LBCT = IVARX(33)
      LBCU = IVARX(34)
      LBCV = IVARX(35)
      LBCV_GM = IVARX(36)
      LBD = IVARX(37)
      LBN_BH = IVARX(38)
      LBN_BHC = IVARX(39)
      LBR = IVARX(40)
      LBTM = IVARX(41)
      LBTM_GM = IVARX(42)
      LC = IVARX(43)
      LCAT = IVARX(44)
      LCDC = IVARX(45)
      LCDP = IVARX(46)
      LCDS = IVARX(47)
      LCH_HT = IVARX(48)
      LCHEM = IVARX(49)
      LCKN = IVARX(50)
      LCMP = IVARX(51)
      LCN = IVARX(52)
      LCN_HT = IVARX(53)
      LCOAX_BH = IVARX(54)
      LCP_HT = IVARX(55)
      LD = IVARX(56)
      LDCO2 = IVARX(57)
      LEPD = IVARX(58)
      LEQC = IVARX(59)
      LEQE = IVARX(60)
      LEQK = IVARX(61)
      LESITE = IVARX(62)
      LF_FRC = IVARX(63)
      LF_FRCC = IVARX(64)
      LFC_BH = IVARX(65)
      LFC_FRC = IVARX(66)
      LFD = IVARX(67)
      LFD_DP = IVARX(68)
      LFD_EC = IVARX(69)
      LFDA = IVARX(70)
      LFDC = IVARX(71)
      LFDCR = IVARX(72)
      LFDD = IVARX(73)
      LFDG = IVARX(74)
      LFDGC = IVARX(75)
      LFDH = IVARX(76)
      LFDI = IVARX(77)
      LFDL = IVARX(78)
      LFDM = IVARX(79)
      LFDN = IVARX(80)
      LFDN2 = IVARX(81)
      LFDNH = IVARX(82)
      LFDR = IVARX(83)
      LFDRG = IVARX(84)
      LFDRL = IVARX(85)
      LFDRN = IVARX(86)
      LFDS = IVARX(87)
      LFDT = IVARX(88)
      LFEN = IVARX(89)
      LFILES = IVARX(90)
      LFW = IVARX(91)
      LFX = IVARX(92)
      LFX_MPI = IVARX(93)
      LFXY = IVARX(94)
      LFY = IVARX(95)
      LFY_MPI = IVARX(96)
      LFYZ = IVARX(97)
      LFZ = IVARX(98)
      LFZ_MPI = IVARX(99)
      LFZX = IVARX(100)
      LG = IVARX(101)
      LGC = IVARX(102)
      LHBW = IVARX(103)
      LHE_HT = IVARX(104)
      LHF_HT = IVARX(105)
      LHYD = IVARX(106)
      LI_BH = IVARX(107)
      LINC = IVARX(108)
      LINH = IVARX(109)
      LIS = IVARX(110)
      LJA = IVARX(111)
      LJB = IVARX(112)
      LJC = IVARX(113)
      LJC_BH = IVARX(114)
      LJC_GM = IVARX(115)
      LJD = IVARX(116)
      LJE = IVARX(117)
      LJF = IVARX(118)
      LJG = IVARX(119)
      LJG_BCF = IVARX(120)
      LJG_BCM = IVARX(121)
      LJG_BH = IVARX(122)
      LJG_FCB = IVARX(123)
      LJG_FCM = IVARX(124)
      LJG_FRC = IVARX(125)
      LJG_GM = IVARX(126)
      LJG_MCB = IVARX(127)
      LJG_MCF = IVARX(128)
      LJH = IVARX(129)
      LJH_BCF = IVARX(130)
      LJH_BCM = IVARX(131)
      LJH_BH = IVARX(132)
      LJH_FCB = IVARX(133)
      LJH_FCM = IVARX(134)
      LJH_FRC = IVARX(135)
      LJH_GM = IVARX(136)
      LJH_MCB = IVARX(137)
      LJH_MCF = IVARX(138)
      LJI = IVARX(139)
      LJJ = IVARX(140)
      LJK = IVARX(141)
      LJK_BCF = IVARX(142)
      LJK_BCM = IVARX(143)
      LJK_BH = IVARX(144)
      LJK_FCB = IVARX(145)
      LJK_FCM = IVARX(146)
      LJK_FRC = IVARX(147)
      LJK_MCB = IVARX(148)
      LJK_MCF = IVARX(149)
      LJL = IVARX(150)
      LJL_BCF = IVARX(151)
      LJL_BCM = IVARX(152)
      LJL_BH = IVARX(153)
      LJL_FCB = IVARX(154)
      LJL_FCM = IVARX(155)
      LJL_FRC = IVARX(156)
      LJL_MCB = IVARX(157)
      LJL_MCF = IVARX(158)
      LJM = IVARX(159)
      LJN = IVARX(160)
      LJN_BH = IVARX(161)
      LJO = IVARX(162)
      LJO_GM = IVARX(163)
      LL = IVARX(164)
      LM = IVARX(165)
      LMC = IVARX(166)
      LMCG = IVARX(167)
      LMNP = IVARX(168)
      LMPH = IVARX(169)
      LN = IVARX(170)
      LN_BH = IVARX(171)
      LN_BHC = IVARX(172)
      LN_CW = IVARX(173)
      LN_LW = IVARX(174)
      LN2 = IVARX(175)
      LNAF = IVARX(176)
      LNC_FRC = IVARX(177)
      LNCF = IVARX(178)
      LNEU = IVARX(179)
      LNGC = IVARX(180)
      LNHC = IVARX(181)
      LNNF = IVARX(182)
      LNNGC = IVARX(183)
      LNOTES = IVARX(184)
      LNW = IVARX(185)
      LNWN = IVARX(186)
      LNWS = IVARX(187)
      LNWT = IVARX(188)
      LNWV = IVARX(189)
      LO_PH = IVARX(190)
      LO_TH = IVARX(191)
      LOBDS = IVARX(192)
      LOBDT = IVARX(193)
      LOUPV = IVARX(194)
      LP_MPI = IVARX(195)
      LP_TA = IVARX(196)
      LPC = IVARX(197)
      LPCF = IVARX(198)
      LPE_HT = IVARX(199)
      LPF_EOR = IVARX(200)
      LPH = IVARX(201)
      LPLANT = IVARX(202)
      LPOLYC = IVARX(203)
      LPOLYN = IVARX(204)
      LPP_HT = IVARX(205)
      LPT = IVARX(206)
      LPTA = IVARX(207)
      LPTM = IVARX(208)
      LPX_MPI = IVARX(209)
      LPY_MPI = IVARX(210)
      LPZ_MPI = IVARX(211)
      LR = IVARX(212)
      LRC = IVARX(213)
      LRCE = IVARX(214)
      LRCG = IVARX(215)
      LRCK = IVARX(216)
      LRCL = IVARX(217)
      LRCN = IVARX(218)
      LRCS = IVARX(219)
      LRCT = IVARX(220)
      LREF = IVARX(221)
      LREK = IVARX(222)
      LREL = IVARX(223)
      LREM = IVARX(224)
      LRFN = IVARX(225)
      LRK = IVARX(226)
      LRPGC = IVARX(227)
      LRPL = IVARX(228)
      LRPLC = IVARX(229)
      LRPNC = IVARX(230)
      LS = IVARX(231)
      LSALC = IVARX(232)
      LSCHR = IVARX(233)
      LSEC = IVARX(234)
      LSEE = IVARX(235)
      LSEK = IVARX(236)
      LSF = IVARX(237)
      LSFCA = IVARX(238)
      LSFCC = IVARX(239)
      LSFCN = IVARX(240)
      LSFCP = IVARX(241)
      LSFCT = IVARX(242)
      LSFDOM = IVARX(243)
      LSFV = IVARX(244)
      LSFVGC = IVARX(245)
      LSOLSR = IVARX(246)
      LSOLU = IVARX(247)
      LSOLU_BH = IVARX(248)
      LSOLU_CW = IVARX(249)
      LSP = IVARX(250)
      LSPBC = IVARX(251)
      LSPC_CW = IVARX(252)
      LSPE = IVARX(253)
      LSPG = IVARX(254)
      LSPILL = IVARX(255)
      LSPK = IVARX(256)
      LSPL = IVARX(257)
      LSPLK = IVARX(258)
      LSPN = IVARX(259)
      LSPR = IVARX(260)
      LSPS = IVARX(261)
      LSPT = IVARX(262)
      LSR = IVARX(263)
      LSR_BH = IVARX(264)
      LSR_FRC = IVARX(265)
      LSRX = IVARX(266)
      LSRY = IVARX(267)
      LSRZ = IVARX(268)
      LSTC = IVARX(269)
      LSTM = IVARX(270)
      LSTM_BH = IVARX(271)
      LSTM_FRC = IVARX(272)
      LSU = IVARX(273)
      LSV = IVARX(274)
      LSW = IVARX(275)
      LSX = IVARX(276)
      LSXC = IVARX(277)
      LSXG = IVARX(278)
      LSXGC = IVARX(279)
      LSXL = IVARX(280)
      LSXLC = IVARX(281)
      LSXN = IVARX(282)
      LSXN2 = IVARX(283)
      LSXNC = IVARX(284)
      LSXS = IVARX(285)
      LSXT = IVARX(286)
      LSY = IVARX(287)
      LSYC = IVARX(288)
      LSYG = IVARX(289)
      LSYGC = IVARX(290)
      LSYL = IVARX(291)
      LSYLC = IVARX(292)
      LSYN = IVARX(293)
      LSYN2 = IVARX(294)
      LSYNC = IVARX(295)
      LSYS = IVARX(296)
      LSYT = IVARX(297)
      LSZ = IVARX(298)
      LSZC = IVARX(299)
      LSZG = IVARX(300)
      LSZGC = IVARX(301)
      LSZL = IVARX(302)
      LSZLC = IVARX(303)
      LSZN = IVARX(304)
      LSZN2 = IVARX(305)
      LSZNC = IVARX(306)
      LSZS = IVARX(307)
      LSZT = IVARX(308)
      LSZW = IVARX(309)
      LT = IVARX(310)
      LT_BH = IVARX(311)
      LT_FRC = IVARX(312)
      LT_FRCC = IVARX(313)
      LT_PH = IVARX(314)
      LT_TA = IVARX(315)
      LT_TH = IVARX(316)
      LTBL = IVARX(317)
      LTC_FRC = IVARX(318)
      LTP_HT = IVARX(319)
      LUGR = IVARX(320)
      LUK = IVARX(321)
      LUK_BH = IVARX(322)
      LUK_CW = IVARX(323)
      LUK_SFC = IVARX(324)
      LUKW = IVARX(325)
      LVIC_FRC = IVARX(326)
      LVPLOT = IVARX(327)
      LVREF = IVARX(328)
      LWELL = IVARX(329)
      LWF_CW = IVARX(330)
      LWF_LW = IVARX(331)
      LWI_CW = IVARX(332)
      LWI_LW = IVARX(333)
      LWN_CW = IVARX(334)
      LWN_LW = IVARX(335)
      LWSI = IVARX(336)
      LWT_CW = IVARX(337)
      LWTI = IVARX(338)
      LWTP_CW = IVARX(339)
      LXP_FRC = IVARX(340)
      LXYZG = IVARX(341)
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read time variables (duplicated across processors)  ---
!
      NVAR = 18
      ALLOCATE( VARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      TM = VARX(1)
      TMMX = VARX(2)
      TMPR = VARX(3)
      DT = VARX(4)
      DTI = VARX(5)
      DTMX = VARX(6)
      DTMN = VARX(7)
      DTAF = VARX(8)
      DTCF = VARX(9)
      DTO = VARX(10)
      DTSO = VARX(11)
      RSDMX = VARX(12)
      RLXF = VARX(13)
      CRNTMXC = VARX(14)
      RTOL_PETSC = VARX(15)
      ATOL_PETSC = VARX(16)
      DTOL_PETSC = VARX(17)
      MAXITS_PETSC = INT(VARX(18))
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for solution control variables  ---
!
      CALL ALLOC_SOLTN
!
!---  Initialize solution control variables  ---
!
      CALL INTLZ_SOLTN
!
!---  Read time stepping variables (duplicated across processors)  ---
!
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPS,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPE,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPD,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPX,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPN,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPA,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,TMPC,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LEPD
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RSDM,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LUK*(1+LWELL+LSPILL)
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,RSD,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = 20
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,WFMN,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read solution control integers (duplicated across processors)  ---
!
      NVAR = 39
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      IVRSN = IVARX(1)
      ISIC = IVARX(2)
      ICNV = IVARX(3)
      IEO = IVARX(4)
      ILES = IVARX(5)
      IOM = IVARX(6)
      ICODE = IVARX(7)
      IEQT = IVARX(8)
      IEQW = IVARX(9)
      IEQA = IVARX(10)
      IEQN = IVARX(11)
      IEQO = IVARX(12)
      IEQC = IVARX(13)
      IEQS = IVARX(14)
      IEQD = IVARX(15)
      IEQDO = IVARX(16)
      IEQHA = IVARX(17)
      IEQHN = IVARX(18)
      IEQHO = IVARX(19)
      IEQDA = IVARX(20)
      IAQU = IVARX(21)
      IGAS = IVARX(22)
      INAPL = IVARX(23)
      NEPD = IVARX(24)
      MEPD = IVARX(25)
      IEPD = IVARX(26)
      NRIMX = IVARX(27)
      NSTEP = IVARX(28)
      NRST = IVARX(29)
      NITER = IVARX(30)
      NTSR = IVARX(31)
      NGC = IVARX(32)
      MXSTEP = IVARX(33)
      IUNM = IVARX(34)
      IUNKG = IVARX(35)
      IUNS = IVARX(36)
      IUNK = IVARX(37)
      IUNMOL = IVARX(38)
      ISVC = IVARX(39)
      ISVF = 2*ISVC + 1
      DO M = 1,4
        M_ERR(M) = ''
      ENDDO
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read solution control integers (duplicated across processors)  ---
!
      NVAR = 100
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISLC,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      IEDLS = 1
      IF( ISLC(4).EQ.1 ) IEDLS = 3
!
!---  Read interfacial averaging indices
!     (duplicated across processors)  ---
!
      NVAR = 20
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IDMN,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Allocate memory for output control variables  ---
!
      CALL ALLOC_OUTPU
!
!---  Read output unit conversions
!     (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVTM,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVLN,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVPLOT,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVREF,NVAR,MPI_REAL8,
     &  STATUS,IERR )
      NVAR = 2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CNVSF,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read output units
!     (duplicated across processors)  ---
!
      NVAR = 64
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNTM,NVAR,MPI_CHAR,
     &  STATUS,IERR )
      NVAR = 64
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNLN,NVAR,MPI_CHAR,
     &  STATUS,IERR )
      NVAR = 64*LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNPLOT,NVAR,MPI_CHAR,
     &  STATUS,IERR )
      NVAR = 64*LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNREF,NVAR,MPI_CHAR,
     &  STATUS,IERR )
      NVAR = 64*2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,UNSF,NVAR,MPI_CHAR,
     &  STATUS,IERR )
!
!---  Read output control variables
!     (duplicated across processors)  ---
!
      NVAR = LPTM
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,PRTM,NVAR,MPI_REAL8,
     &  STATUS,IERR )
!
!---  Read output control integer arrays
!     (duplicated across processors)  ---
!
      NVAR = LVPLOT
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IPLOT,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NVAR = LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IREF,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NVAR = LREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NDREF,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFT,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFF,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFD,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NVAR = LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFGP,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!
!---  Read output control integers (duplicated across processors)  ---
!
      NVAR = 14
      ALLOCATE( IVARX(1:NVAR),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
      NPRTM = IVARX(1)
      NVPLOT = IVARX(2)
      NREF = IVARX(3)
      NVREF = IVARX(4)
      ICNO = IVARX(5)
      ICNS = IVARX(6)
      NSF = IVARX(7)
      NSFGP = IVARX(8)
      IHSF = IVARX(9)
      IHSF = 0
      IFQS = IVARX(10)
      IFQO = IVARX(11)
      ISGNS = IVARX(12)
      ISGNO = IVARX(13)
      ISGNP = IVARX(14)
!      PRINT *,'NSF = ',NSF,' ID = ',ID
!
!---  Read output character strings, duplicated over all processors  ---
!
      NVAR = 64*LVREF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CHREF,NVAR,MPI_CHAR,
     &  STATUS,IERR )
!
!---  Read surface flux file names, duplicated over all processors  ---
!
      NVAR = 64*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,FNSF,NVAR,MPI_CHAR,
     &  STATUS,IERR )
!      PRINT *,'FNSF = ',(FNSF(M),M=1,NSF),' ID = ',ID
!
!---  Read surface flux header character strings,
!     duplicated over all processors  ---
!
      NVAR = 64*2*LSF
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,CHSF,NVAR,MPI_CHAR,
     &  STATUS,IERR )
!      PRINT *,'CHSF = ',((CHSF(L,M),L=1,2),M=1,NSF),' ID = ',ID
!
!---  Allocate memory for NSFN  ---
!
      ALLOCATE( NSFN(1:NP),STAT=ISTAT )
      CHMSG = 'NSFN'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local number of surface flux nodes on each processor,
!     duplicated over all processors  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSFN,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!      DO M = 1,NP
!        PRINT *,'NSFN(',M,') = ',NSFN(M),' ID = ',ID
!      ENDDO
!
!---  Determine offsets for reading ISFN and ISFS  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NSFN(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NSFN(N)
      ENDDO
!      PRINT *,'NC = ',NC,' NCP = ',NCP,' ID = ',ID
!
!---  Allocate memory for ISFN  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFN(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFN'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for ISFS  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFS(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFS'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Allocate memory for ISFB  ---
!
      NSFNX = MAX( NSFN(ID+1),1 )
      ALLOCATE( ISFB(1:NSFNX),STAT=ISTAT )
      CHMSG = 'ISFB'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read local surface-flux node number  ---
!
      NVAR = NSFN(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFN,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!      PRINT *,'ISFN = ',(ISFN(M),M=1,NSFN(ID+1)),' ID = ',ID
!
!---  Read local surface-flux number  ---
!
      NVAR = NSFN(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISFS,NVAR,MPI_INTEGER,
     &  STATUS,IERR )
!      PRINT *,'ISFS = ',(ISFS(M),M=1,NSFN(ID+1)),' ID = ',ID
!
!---  Close the solu.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_SOLU_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_SORC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for source data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOURC
      USE SOLTN
      USE PROP
      USE OUTPU
      USE MPI
      USE GRID
      USE GLB_PAR
      USE FILES
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_SORC_GT'
!
!---  Open sorc.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'sorc.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate memory for NSR  ---
!
      ALLOCATE( NSR(1:NP),STAT=ISTAT )
      CHMSG = 'NSR'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of source nodes on each processor  ---
!
      NVAR = NP
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSR,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Allocate local source arrays  ---
!
      CALL ALLOC_SOURC
!
!---  Initialize source variables  ---
!
      CALL INTLZ_SOURC
!
!---  Read source variables (duplicated across processors)  ---
!
      LX = 8+LSOLU+LSPT+LNGC
      NVAR = LX*LSTM*LSR
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,SRC,NVAR,MPI_REAL8,
     &  STATUS,IERR)
!
!---  Read array of source nodes  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NSR(I)
      ENDDO
      NCP = 0
      DO N = 1,NP
        NCP = NCP + NSR(N)
      ENDDO
!
!---  Index array of source field nodes  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source number of time points  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRM,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source inputs  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRIN,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Index array of source types  ---
!
      NVAR = NSR(ID+1)
      OFFSET = IOFFSET + NC*NBYTI + NBYTB
      IOFFSET = IOFFSET + NCP*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,ISRT,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!      DO N = 1,NSR(ID+1)
!        PRINT *,'ISRT(',N,') = ',ISRT(N),' ID = ',ID
!      ENDDO
!
!---  Close the sorc.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_SORC_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_STATE_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for state condition data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE SOLTN
      USE PROP
      USE MPI
      USE HYST
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_STATE_GT'
!
!---  Open state1.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state1.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate local memory state condition arrays
!     (including ghost cells)  ---
!
      CALL ALLOC_FDVP
!
!---  Initialize global array memory for general field variables  ---
!
      CALL INTLZ_FDVP
!
!---  Allocate array memory for hysteretic k-s-P function
!     variables  ---
!
      CALL ALLOC_HYST
!
!---  Initialize global array memory for Hysteretic k-s-P function
!     variables  ---
!
      CALL INTLZ_HYST
!
!---  Allocate local temporary state condition arrays
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Read local copies of T array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NC*NBYTR + NBYTB
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        T(2,N) = VARX(N)
      ENDDO
!      PRINT *,'T(2,',ND(11),') = ',T(2,11),' ID = ',ID
!
!---  Read local copies of PL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PL(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PL(2,',ND(11),') = ',PL(2,11),' ID = ',ID
!
!---  Read local copies of PG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PG(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PG(2,',ND(11),') = ',PG(2,11),' ID = ',ID
!
!---  Read local copies of SG array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SG(2,N) = VARX(N)
      ENDDO
!      PRINT *,'SG(2,',ND(11),') = ',SG(2,11),' ID = ',ID
!
!---  Read local copies of SL array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SL(2,N) = VARX(N)
      ENDDO
!      PRINT *,'SL(2,',ND(11),') = ',SL(2,11),' ID = ',ID
!
!---  Read local copies of SGT array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        SGT(2,N) = VARX(N)
      ENDDO
!      PRINT *,'SGT(2,',ND(11),') = ',SGT(2,11),' ID = ',ID
!
!---  Read local copies of ASLMIN array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        ASLMIN(2,N) = VARX(N)
      ENDDO
!      PRINT *,'ASLMIN(2,',ND(11),') = ',ASLMIN(2,11),' ID = ',ID
!
!---  Read local copies of TMS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        TMS(2,N) = VARX(N)
      ENDDO
!      PRINT *,'TMS(2,',ND(11),') = ',TMS(2,11),' ID = ',ID
!
!---  Close the state1.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Open state2.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'state2.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Read local copies of YLS array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        YLS(2,N) = VARX(N)
      ENDDO
!      PRINT *,'YLS(2,',ND(11),') = ',YLS(2,11),' ID = ',ID
!
!---  Read local copies of PVA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PVA(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PVA(2,',ND(11),') = ',PVA(2,11),' ID = ',ID
!
!---  Read local copies of PVW array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PVW(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PVW(2,',ND(11),') = ',PVW(2,11),' ID = ',ID
!
!---  Read local copies of XMLA array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        XMLA(2,N) = VARX(N)
      ENDDO
!      PRINT *,'XMLA(2,',ND(11),') = ',XMLA(2,11),' ID = ',ID
!
!---  Read local copies of PORD array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PORD(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PORD(2,',ND(11),') = ',PORD(2,11),' ID = ',ID
!
!---  Read local copies of PORT array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTR
      IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        PORT(2,N) = VARX(N)
      ENDDO
!      PRINT *,'PORT(2,',ND(11),') = ',PORT(2,11),' ID = ',ID
!
!---  Read local copies of NPHAZ array (including ghost cells)  ---
!
      NVAR = NFCGC(ID+1)
      OFFSET = IOFFSET + NBYTB + NC*NBYTI
      IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
      DO N = 1,NFCGC(ID+1)
        NPHAZ(2,N) = IVARX(N)
      ENDDO
!
!---  Deallocate local temporary state condition arrays
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Close the state2.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_STATE_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE READ_TPORT_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Read binary input.bin file for solute transport data.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE TRNSPT
      USE SOLTN
      USE PROP
      USE HYST
      USE GRID
      USE GLB_PAR
      USE FILES
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(:), ALLOCATABLE :: VARX
      INTEGER, DIMENSION(:), ALLOCATABLE :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER(32) :: CHMSG
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/READ_TPORT_GT'
!
!---  Open tpor.bin file  ---
!
      CALL MPI_FILE_OPEN( MPI_COMM_WORLD,'tpor.bin',
     &  MPI_MODE_RDONLY,MPI_INFO_NULL,IRD,IERR )
      IOFFSET = 0
!
!---  Allocate and initialize memory, global and local, for
!     solute transport arrays  ---
!
      CALL ALLOC_TRNSPT
      CALL INTLZ_TRNSPT
!
!---  Set local starting point for local copies of nodal variables  ---
!
      NC = 0
      DO I = 1,ID
        NC = NC + NFCGC(I)
      ENDDO
!
!---  Allocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      ALLOCATE( VARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'VARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
      ALLOCATE( IVARX(1:NFCGC(ID+1)),STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL ALLOC_ERROR( CHMSG,ISTAT )
!
!---  Read number of solutes (duplicated across processors)  ---
!
      NVAR = 1
      OFFSET = IOFFSET + NBYTB
      IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
      CALL MPI_FILE_READ_AT( IRD,OFFSET,NSOLU,NVAR,MPI_INTEGER,
     &  STATUS,IERR)
!
!---  Read solute parameters, indices, and variables
!     if solutes are modeled  ---
!
      IF( NSOLU.GT.0 ) THEN
!
!---    Read solute names (duplicated across processors)  ---
!
        NVAR = 64*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SOLUT,NVAR,MPI_CHAR,
     &    STATUS,IERR)
!        PRINT *,'SOLUT = ',(SOLUT(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Loop over the number of solutes  ---
!
        DO NSL = 1,NSOLU
!
!---      Read local copies of C array (including ghost cells)  ---
!
          NVAR = NFCGC(ID+1)
          OFFSET = IOFFSET + NC*NBYTR + NBYTB
          IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
          CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &      STATUS,IERR)
          DO N = 1,NFCGC(ID+1)
            C(N,NSL) = VARX(N)
          ENDDO
!          PRINT *,'C(2,',NSL,') = ',C(2,NSL),'C(3,',NSL,') = ',C(3,NSL),
!     &      'C(4,',NSL,') = ',C(4,NSL),' ID = ',ID
        ENDDO
!
!---    Read solute aqueous diffusion coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SMDL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SMDL = ',(SMDL(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute gas diffusion coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,SMDG,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'SMDG = ',(SMDG(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read index for solute gas-aqueous partition coefficient
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IPCGL,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IPCGL = ',(IPCGL(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute gas-aqueous partition coefficient parameters
!       (duplicated across processors)  ---
!
        NVAR = 5*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,PCGL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!
!---    Read solute half-life, s
!       (duplicated across processors)  ---
!
        NVAR = NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,HLF,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'HLF = ',(HLF(NSL),NSL=1,NSOLU),' ID = ',ID
!
!---    Read solute chain-decay fraction
!       (duplicated across processors)  ---
!
        NVAR = NSOLU*NSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CHDF,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'CHDF = ',((CHDF(MSL,NSL),MSL=1,NSOLU),NSL=1,NSOLU),
!     &    ' ID = ',ID
!
!---    Read number of Bateman chain decay series
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,NBCDS,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'NBCDS = ',NBCDS,' ID = ',ID
!
!---    Read Bateman chain decay series index
!       (duplicated across processors)  ---
!
        NVAR = LCDC+LSOLU
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCDS,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IBCDS = ',(IBCDS(M),M=1,LCDC+LSOLU),' ID = ',ID
!
!---    Read Bateman number of solutes in chain decay path
!       (duplicated across processors)  ---
!
        NVAR = LCDC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,NBCDP,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'NBCDP = ',(NBCDP(M),M=1,LCDC),' ID = ',ID
!
!---    Read Bateman chain decay path indices
!       (duplicated across processors)  ---
!
        NVAR = LCDS*LCDP*LCDC
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IBCDP,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'IBCDP = ',
!     &    (((IBCDP(K,L,M),K=1,LCDS),L=1,LCDP),M=1,LCDC),' ID = ',ID
!
!---    Read Courant number calculation index
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,ICRNT,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
!        PRINT *,'ICRNT = ',ICRNT,' ID = ',ID
!        PRINT *,'IBCDS = ',(IBCDS(M),M=1,NSOLU+NBCDS),' ID = ',ID
!
!---    Read maximum Courant number
!       (duplicated across processors)  ---
!
        NVAR = 1
        OFFSET = IOFFSET + NBYTB
        IOFFSET = IOFFSET + NVAR*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,CRNTMXT,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'CRNTMXT = ',CRNTMXT,' ID = ',ID
!
!---    Loop over the number of solutes  ---
!
        DO NSL = 1,NSOLU
!
!---      Loop over the number of solid-aqueous partition
!         coefficient indices  ---
!
          DO M = 1,5
!
!---        Read local copies of solute solid-aqueous partition
!           coefficient (including ghost cells)  ---
!
            NVAR = NFCGC(ID+1)
            OFFSET = IOFFSET + NC*NBYTR + NBYTB
            IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
            CALL MPI_FILE_READ_AT( IRD,OFFSET,VARX,NVAR,MPI_REAL8,
     &        STATUS,IERR)
            DO N = 1,NFCGC(ID+1)
              PCSL(M,N,NSL) = VARX(N)
            ENDDO
!            PRINT *,'PCSL(',M,',',ND(11),',',NSL,') = ',
!     &        PCSL(M,11,NSL),' ID = ',ID
          ENDDO
        ENDDO
!
!---    Read local copies of longitudinal dispersivity
!       (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTR + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,DISPL,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'DISPL(1) = ',DISPL(1),' ID = ',ID
!
!---    Read local copies of transverse dispersivity
!       (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTR + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTR + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,DISPT,NVAR,MPI_REAL8,
     &    STATUS,IERR)
!        PRINT *,'DISPT(1) = ',DISPT(1),' ID = ',ID
      ENDIF
!
!---  Loop over the number of solutes and reactive species  ---
!
      DO M = 1,LSOLU+LSPT
!
!---    Read local copies of solute or reactive species initial
!       condition indices (including ghost cells)  ---
!
        NVAR = NFCGC(ID+1)
        OFFSET = IOFFSET + NC*NBYTI + NBYTB
        IOFFSET = IOFFSET + NFCGC_G*NBYTI + 2*NBYTB
        CALL MPI_FILE_READ_AT( IRD,OFFSET,IVARX,NVAR,MPI_INTEGER,
     &    STATUS,IERR)
        DO N = 1,NFCGC(ID+1)
          ICT(N,M) = IVARX(N)
        ENDDO
!        PRINT *,'ICT(',ND(11),',',M,') = ',ICT(11,M),' ID = ',ID
      ENDDO
!
!---  Deallocate local temporary real and integer nodal arrays
!     (including ghost cells)  ---
!
      DEALLOCATE( VARX,STAT=ISTAT )
      CHMSG = 'VARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
      DEALLOCATE( IVARX,STAT=ISTAT )
      CHMSG = 'IVARX'
      CALL DEALLOC_ERROR( CHMSG,ISTAT )
!
!---  Close the tpor.bin file  ---
!
      CALL MPI_FILE_CLOSE( IRD,IERR )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of READ_TPORT_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKGS_GT( ASL_F,ASL_M,ASLX,ASLMINX,BTGLX,ESGTX,PGX,PLX,
     &  RKGX,SGX,SGTX,SLX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Gas relative permeability.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RKGS_GT'
      ASLZ = MAX( ASLX,0.D+0 )
!
!---  Gas relative permeability function  ---
!
      IF( IRPG(N).EQ.0 ) THEN
        RKGX = RPGC(3,N)
!
!---  Mualem porosity distribution function  ---
!
      ELSEIF( IRPG(N).EQ.1 ) THEN
!
!---    van Genuchten saturation function  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.101 ) THEN
          ASLZ = MIN( ASLZ+ESGTX,1.D+0 )
          SGP = 1.D+0 - ASLZ
          RKGX = SQRT(SGP)*((1.D+0-ASLZ**(1.D+0/RPGC(3,N)))
     &      **RPGC(3,N))**2
!
!---    Brooks and Corey saturation function  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &    ISCHR(N).EQ.202 ) THEN
          ASLZ = MIN( ASLZ+ESGTX,1.D+0 )
          SGP = 1.D+0 - ASLZ
          RKGX = SQRT(SGP)*(1.D+0-ASLZ**(1.D+0+1.D+0/RPGC(3,N)))**2
!
!---    Single-pressure dual-porosity van Genuchten  ---
!
        ELSEIF( ISCHR(N).EQ.3 ) THEN
          SGPM = 1.D+0-ASL_M
          RKGM = SQRT(SGPM)*((1.D+0-ASL_M**(1.D+0/RPGC(3,N)))
     &      **RPGC(3,N))**2
          SGPF = 1.D+0-ASL_F
          RKGF = SQRT(SGPF)*((1.D+0-ASL_F**(1.D+0/RPGC(1,N)))
     &      **RPGC(1,N))**2
          RKGX = ( PERM(4,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKGF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
          RKGY = ( PERM(5,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(8,N)*RKGF*POR(4,N) )/
     &      ( PERM(5,N)*(1.D+0-POR(4,N)) + PERM(8,N)*POR(4,N)
     &      + SMALL )
          RKGZ = ( PERM(6,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(9,N)*RKGF*POR(4,N) )/
     &      ( PERM(6,N)*(1.D+0-POR(4,N)) + PERM(9,N)*POR(4,N)
     &      + SMALL )
          RKGX = MAX( RKGX,RKGY,RKGZ )
!
!---    Single-pressure dual-porosity Brooks and Corey  ---
!
        ELSEIF( ISCHR(N).EQ.4 ) THEN
          SGPM = 1.D+0-ASL_M
          RKGM = SGPM**(2.5D+0 + 2.0D+0/RPGC(3,N))
          SGPF = 1.D+0-ASL_F
          RKGF = SGPF**(2.5D+0 + 2.0D+0/RPGC(1,N))
          RKGX = ( PERM(4,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKGF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
          RKGY = ( PERM(5,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(8,N)*RKGF*POR(4,N) )/
     &      ( PERM(5,N)*(1.D+0-POR(4,N)) + PERM(8,N)*POR(4,N)
     &      + SMALL )
          RKGZ = ( PERM(6,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(9,N)*RKGF*POR(4,N) )/
     &      ( PERM(6,N)*(1.D+0-POR(4,N)) + PERM(9,N)*POR(4,N)
     &      + SMALL )
          RKGX = MAX( RKGX,RKGY,RKGZ )
        ENDIF
!
!---  Burdine porosity distribution function  ---
!
      ELSEIF( IRPG(N).EQ.2 ) THEN
!
!---    van Genuchten saturation function  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.101 ) THEN
          ASLZ = MIN( ASLZ+ESGTX,1.D+0 )
          SGP = 1.D+0 - ASLZ
          RKGX = (SGP**2)*((1.D+0-ASLZ**(1.D+0/RPGC(3,N)))
     &      **RPGC(3,N))
!
!---    Brooks and Corey saturation function  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &    ISCHR(N).EQ.202 ) THEN
          ASLZ = MIN( ASLZ+ESGTX,1.D+0 )
          SGP = 1.D+0 - ASLZ
          RKGX = (SGP**2)*(1.D+0-ASLZ**(1.D+0 + 2.D+0/RPGC(3,N)))
!
!---    Single-pressure dual-porosity van Genuchten  ---
!
        ELSEIF( ISCHR(N).EQ.3 ) THEN
          SGPM = 1.D+0-ASL_M
          RKGM = (SGPM**2)*((1.D+0-ASL_M**(1.D+0/RPGC(3,N)))
     &      **RPGC(3,N))
          SGPF = 1.D+0-ASL_F
          RKGF = (SGPF**2)*((1.D+0-ASL_F**(1.D+0/RPGC(1,N)))
     &      **RPGC(1,N))
          RKGX = ( PERM(4,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKGF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
          RKGY = ( PERM(5,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(8,N)*RKGF*POR(4,N) )/
     &      ( PERM(5,N)*(1.D+0-POR(4,N)) + PERM(8,N)*POR(4,N)
     &      + SMALL )
          RKGZ = ( PERM(6,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(9,N)*RKGF*POR(4,N) )/
     &      ( PERM(6,N)*(1.D+0-POR(4,N)) + PERM(9,N)*POR(4,N)
     &      + SMALL )
          RKGX = MAX( RKGX,RKGY,RKGZ )
!
!---    Single-pressure dual-porosity Brooks and Corey  ---
!
        ELSEIF( ISCHR(N).EQ.4 ) THEN
          SGPM = 1.D+0-ASL_M
          RKGM = SGPM**(3.0D+0 + 2.0D+0/RPGC(3,N))
          SGPF = 1.D+0-ASL_F
          RKGF = SGPF**(3.0D+0 + 2.0D+0/RPGC(1,N))
          RKGX = ( PERM(4,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKGF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
          RKGY = ( PERM(5,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(8,N)*RKGF*POR(4,N) )/
     &      ( PERM(5,N)*(1.D+0-POR(4,N)) + PERM(8,N)*POR(4,N)
     &      + SMALL )
          RKGZ = ( PERM(6,N)*RKGM*(1.D+0-POR(4,N)) +
     &      PERM(9,N)*RKGF*POR(4,N) )/
     &      ( PERM(6,N)*(1.D+0-POR(4,N)) + PERM(9,N)*POR(4,N)
     &      + SMALL )
          RKGX = MAX( RKGX,RKGY,RKGZ )
        ENDIF
!
!---  Modified-Corey relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.3 ) THEN
        SLRX = RPGC(1,N)
        SGRX = RPGC(3,N)
        SLPX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SGRX),0.D+0 ),1.D+0 )
        ASLPX = SLPX + ESGTX
        RKGX = RPGC(2,N)*((1.D+0-ASLPX)**2)*(1.D+0-ASLPX**2)
!
!---  Fatt and Klikoff relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.4 ) THEN
        ASLZ = MIN( ASLZ+ESGTX,1.D+0 )
        RKGX = (1.D+0-ASLZ)**3
!
!---  Free-Corey relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.7 ) THEN
        SLRX = RPGC(3,N)
        SGRX = RPGC(4,N)
        SLPX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SGRX),0.D+0 ),1.D+0 )
        ASLPX = SLPX + ESGTX
        SGPX = 1.D+0 - ASLPX
        RKGX = RPGC(1,N)*(SGPX**(RPGC(2,N)))
!
!---  Classical-Corey relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.17 ) THEN
        SLRX = RPGC(3,N)
        SGRX = RPGC(4,N)
        SLPX = (SLX-SLRX)/(1.D+0-SLRX-SGRX)
        SLPX = MIN( MAX( SLPX,0.D+0 ),1.D+0 )
        ASLPX = SLPX + ESGTX
        RKGX = RPGC(1,N)*(1.D+0-(ASLPX**(RPGC(2,N)/2.D+0)))*
     &    ((1.D+0-ASLPX)**(RPGC(2,N)/2.D+0))
!
!---  van Genuchten gas relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.9 ) THEN
        SLRX = RPGC(1,N)
        SGRX = RPGC(3,N)
        ASLZ = MIN( ASLZ+ESGTX,1.D+0 )
        SGZ = (1.D+0-ASLZ)*(1.D+0-SLRX)
        SGPX = MIN( MAX( (SGZ-SGRX)/(1.D+0-SGRX),0.D+0 ),1.D+0 )
        RKGX = SQRT(SGPX)*((1.D+0-((1.D+0-SGPX)**(1.D+0/RPGC(2,N)))
     &      **RPGC(2,N))**2)
!
!---  Tabular gas relative permeability versus gas saturation
!     w/ linear interpolation and table truncation beyond limits  ---
!
      ELSEIF( IRPG(N).EQ.10 ) THEN
        SGZ = MAX( SGX-SGTX,0.D+0 )
        ITBX = 0
        RKGX = FNTBLY( SGZ,IRGTBL(1,N),IRGTBL(2,N),ITBX )
!
!---  Tabular gas relative permeability versus gas saturation
!     w/ cubic spline interpolation  ---
!
      ELSEIF( IRPG(N).EQ.11 ) THEN
        SGZ = MAX( SGX-SGTX,0.D+0 )
        RKGX = FSPLNY( SGZ,IRGTBL(1,N),IRGTBL(2,N) )
!
!---  Tabular gas relative permeability versus ln(capillary head)
!     w/ linear interpolation and table truncation beyond limits  ---
!
      ELSEIF( IRPG(N).EQ.12 ) THEN
        ITBX = 0
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        HDGLX = LOG(HDGL)
        RKGX = FNTBLY( HDGLX,IRGTBL(1,N),IRGTBL(2,N),ITBX )
!
!---  Tabular gas relative permeability versus ln(capillary head)
!     w/ cubic spline interpolation  ---
!
      ELSEIF( IRPG(N).EQ.13 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        HDGLX = LOG(HDGL)
        RKGX = FSPLNY( HDGLX,IRGTBL(1,N),IRGTBL(2,N) )
!
!---  Tabular gas relative permeability versus capillary head
!     w/ linear interpolation and table truncation beyond limits  ---
!
      ELSEIF( IRPG(N).EQ.14 ) THEN
        ITBX = 0
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        RKGX = FNTBLY( HDGL,IRGTBL(1,N),IRGTBL(2,N),ITBX )
!
!---  Tabular gas relative permeability versus capillary head
!     w/ cubic spline interpolation  ---
!
      ELSEIF( IRPG(N).EQ.15 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        RKGX = FSPLNY( HDGL,IRGTBL(1,N),IRGTBL(2,N) )
!
!---  Doughty gas relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.18 ) THEN
        RKGMX = RPGC(1,N)
        GAMMAX = RPGC(2,N)
        SLRX = RPGC(3,N)
        CMX = RPGC(4,N)
        ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        ASLPX = MIN( MAX( (ESLX+ESGTX),0.D+0 ),1.D+0 )
        RKGX = RKGMX*((1.D+0-ASLPX)**GAMMAX)*
     &    (((1.D+0-ASLPX)**(1.D+0/CMX))**(2.D+0*CMX))
!
!---  Doughty drainage-imbibition gas relative permeability
!     function  ---
!
      ELSEIF( IRPG(N).EQ.19 ) THEN
        RKGMX = RPGC(1,N)
        GAMMAX = RPGC(2,N)
        SLRDX = RPGC(3,N)
        CMX = RPGC(4,N)
        SLRIX = RPGC(5,N)
        SGTMX = RPGC(6,N)
        SLDX = MIN( SLX+SGTX,1.D+0 )
        SLIX = MIN( SLX+SGTMX,1.D+0 )
        ESLDX = MIN( MAX( (SLDX-SLRDX)/(1.D+0-SLRDX),0.D+0 ),1.D+0 )
        ESLIX = MIN( MAX( (SLIX-SLRIX)/(1.D+0-SLRIX),0.D+0 ),1.D+0 )
        RKGDX = RKGMX*((1.D+0-ESLDX)**GAMMAX)*
     &    (((1.D+0-ESLDX)**(1.D+0/CMX))**(2.D+0*CMX))
        RKGIX = RKGMX*((1.D+0-ESLIX)**GAMMAX)*
     &    (((1.D+0-ESLIX)**(1.D+0/CMX))**(2.D+0*CMX))
        RSLX = MIN( MAX( ASLMINX/ASLX,0.D+0 ),1.D+0 )
        RKGX = RSLX*RKGDX + (1.D+0-RSLX)*RKGIX
!
!---  Variable-Corey relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.20 ) THEN
        SLRX = RPGC(1,N)
        SGRX = RPGC(3,N)
        SLPX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SGRX),0.D+0 ),1.D+0 )
        ASLPX = SLPX + ESGTX
        IF( SLRX.GT.EPSL ) THEN
          BX = (1.D+0-RPGC(1,N))/SLRX
          AX = 1.D+0 - BX
          DSLX = 5.D-2
          RKG1X = AX + BX*(1.D+0-SLX)
          RKG2X = RPGC(2,N)*((1.D+0-ASLPX)**2)*
     &      (1.D+0-ASLPX**RPGC(4,N))
          RKG1X = MIN( MAX( RKG1X,0.D+0 ),1.D+0 )
          RKG2X = MIN( MAX( RKG2X,0.D+0 ),1.D+0 )
          SIGMAX = 1.D+0/(1.D+0 + EXP((SLRX-SLX)/DSLX))
          RKGX = (1.D+0-SIGMAX)*RKG1X + SIGMAX*RKG2X
        ELSE
          RKGX = RPGC(2,N)*((1.D+0-ASLPX)**2)*
     &      (1.D+0-ASLPX**RPGC(4,N))
        ENDIF

!
!---  Extended power law relative permeability function  ---
!
      ELSEIF( IRPG(N).EQ.21 ) THEN
        SLRX = RPGC(3,N)
        SGRX = RPGC(4,N)
        SLPX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SGRX),0.D+0 ),1.D+0 )
        ASLPX = SLPX + ESGTX
        SGPX = 1.D+0 - ASLPX
        IF( SLRX.GT.EPSL ) THEN
          BX = (1.D+0-RPGC(1,N))/SLRX
          AX = 1.D+0 - BX
          DSLX = 5.D-2
          RKG1X = AX + BX*(1.D+0-SLX)
          RKG2X = RPGC(1,N)*(SGPX**(RPGC(2,N)))
          RKG1X = MIN( MAX( RKG1X,0.D+0 ),1.D+0 )
          RKG2X = MIN( MAX( RKG2X,0.D+0 ),1.D+0 )
          SIGMAX = 1.D+0/(1.D+0 + EXP((SLRX-SLX)/DSLX))
          RKGX = (1.D+0-SIGMAX)*RKG1X + SIGMAX*RKG2X
        ELSE
          RKGX = RPGC(1,N)*(SGPX**(RPGC(2,N)))
        ENDIF
      ENDIF
      RKGX = MIN( MAX( RKGX,0.D+0 ),1.D+0 )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKGS_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RKLS_GT( ASL_F,ASL_M,BTGLX,ESLX,PGX,PLX,RKLX,SLX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Aqueous relative permeability.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RKLS_GT'
      ESLZ = MAX( ESLX,0.D+0 )
!
!---  Constant relative permeability function  ---
!
      IF( MOD( IRPL(N),100 ).EQ.0 ) THEN
        RKLX = RPLC(2,N)
!
!---    Single-pressure dual-porosity saturation functions  ---
!
        IF( ISCHR(N).EQ.3 .OR. ISCHR(N).EQ.4 ) THEN
          RKLM = RPLC(2,N)
          RKLF = RPLC(1,N)
          RKLX = ( PERM(4,N)*RKLM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKLF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
        ENDIF
!
!---  Mualem-irreducible porosity distribution function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.21 ) THEN
        SLRX = RPLC(1,N)
        SLPX = MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 )
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.101  ) THEN
          RKLX = SQRT(SLPX)*((1.D+0-(1.D+0-SLPX**(1.D+0/RPLC(2,N)))
     &      **RPLC(2,N))**2)
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &    ISCHR(N).EQ.202 ) THEN
          RKLX = SLPX**(2.5D+0 + 2.0D+0/RPLC(2,N))
        ENDIF
!
!---  Mualem porosity distribution function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.1 ) THEN
!
!---    van Genuchten saturation function  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.101 ) THEN
          RKLX = SQRT(ESLZ)*((1.D+0-(1.D+0-ESLZ**(1.D+0/RPLC(2,N)))
     &      **RPLC(2,N))**2)
!
!---    Brooks and Corey saturation function  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &    ISCHR(N).EQ.202 ) THEN
          RKLX = ESLZ**(2.5D+0 + 2.0D+0/RPLC(2,N))
!
!---    Single-pressure dual-porosity van Genuchten  ---
!
          ELSEIF( ISCHR(N).EQ.3  ) THEN
            RKLM = (1.D+0-(ASL_M**(1.D+0/RPLC(2,N))))
            RKLM = SQRT(ASL_M)*((1.D+0-RKLM**RPLC(2,N))**2)
            RKLF = (1.D+0-(ASL_F**(1.D+0/RPLC(1,N))))
            RKLF = SQRT(ASL_F)*((1.D+0-RKLF**RPLC(1,N))**2)
            RKLX = ( PERM(4,N)*RKLM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKLF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
!
!---    Single-pressure dual-porosity Brooks and Corey  ---
!
          ELSEIF( ISCHR(N).EQ.4  ) THEN
            RKLM = ASL_M**(2.5D+0 + 2.0D+0/RPLC(2,N))
            RKLF = ASL_F**(2.5D+0 + 2.0D+0/RPLC(1,N))
            RKLX = ( PERM(4,N)*RKLM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKLF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
        ENDIF
!
!---  Burdine porosity distribution function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.2 ) THEN
!
!---    van Genuchten saturation function  ---
!
        IF( ISCHR(N).EQ.1 .OR. ISCHR(N).EQ.101 ) THEN
          RKLX = (ESLZ**2)*(1.D+0-(1.D+0-ESLZ**(1.D+0/RPLC(2,N)))
     &      **RPLC(2,N))
!
!---    Brooks and Corey saturation function  ---
!
        ELSEIF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &    ISCHR(N).EQ.202 ) THEN
          RKLX = ESLZ**(3.0D+0 + 2.0D+0/RPLC(2,N))
!
!---    Single-pressure dual-porosity van Genuchten  ---
!
        ELSEIF( ISCHR(N).EQ.3 ) THEN
          RKLM = (ASL_M**2)*(1.D+0-(1.D+0-ASL_M**(1.D+0/RPLC(2,N)))
     &      **RPLC(2,N))
          RKLF = (ASL_F**2)*(1.D+0-(1.D+0-ASL_F**(1.D+0/RPLC(1,N)))
     &      **RPLC(1,N))
          RKLX = ( PERM(4,N)*RKLM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKLF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
!
!---  Dual porosity Brooks and Corey  ---
!
        ELSEIF( ISCHR(N).EQ.4 ) THEN
          RKLM = ASL_M**(3.0D+0 + 2.0D+0/RPLC(2,N))
          RKLF = ASL_F**(3.0D+0 + 2.0D+0/RPLC(1,N))
          RKLX = ( PERM(4,N)*RKLM*(1.D+0-POR(4,N)) +
     &      PERM(7,N)*RKLF*POR(4,N) )/
     &      ( PERM(4,N)*(1.D+0-POR(4,N)) + PERM(7,N)*POR(4,N)
     &      + SMALL )
        ENDIF
!
!---  Corey relative permeability function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.3 ) THEN
        RKLX = ESLZ**4
!
!---  Fatt and Klikoff relative permeability function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.4 ) THEN
        RKLX = ESLZ**3
!
!---  Haverkamp relative permeability function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.5 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        IF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &    ISCHR(N).EQ.202 .OR. ISCHR(N).EQ.5 ) THEN
          HDEN = SCHR(1,N)
        ELSE
          HDEN = ZERO
        ENDIF
        IF( HDGL.LE.HDEN ) THEN
          RKLX = 1.D+0
        ELSE
          RKLX = RPLC(1,N)/
     &      (RPLC(1,N) + (((HDGL-HDEN)/SCHR(5,N))**RPLC(2,N)))
        ENDIF
!
!---  Touma and Vauclin relative permeability function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.6 ) THEN
        RKLX = RPLC(1,N)*(ESLZ**RPLC(2,N))
!
!---  Free Corey relative permeability function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.7 ) THEN
        SLRX = RPLC(3,N)
        SGRX = RPLC(4,N)
        SLPX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX-SGRX),0.D+0 ),1.D+0 )
        RKLX = RPLC(1,N)*(SLPX**(RPLC(2,N)))
!
!---  Rijtema-Gardner modified exponential function  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.9 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        RKLX = EXP( RPLC(1,N)*HDGL + RPLC(2,N) )
!
!---  Tabular aqueous relative permeability versus gas saturation
!     w/ linear interpolation and table truncation beyond limits  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.10 ) THEN
        ITBX = 0
        RKLX = FNTBLY( SLX,IRLTBL(1,N),IRLTBL(2,N),ITBX )
!
!---  Tabular aqueous relative permeability versus gas saturation
!     w/ cubic spline interpolation  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.11 ) THEN
        RKLX = FSPLNY( SLX,IRLTBL(1,N),IRLTBL(2,N) )
!
!---  Tabular aqueous relative permeability versus ln(capillary head)
!     w/ linear interpolation and table truncation beyond limits  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.12 ) THEN
        ITBX = 0
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        HDGLX = LOG(HDGL)
        RKLX = FNTBLY( HDGLX,IRLTBL(1,N),IRLTBL(2,N),ITBX )
!
!---  Tabular aqueous relative permeability versus ln(capillary head)
!     w/ cubic spline interpolation  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.13 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        HDGLX = LOG(HDGL)
        RKLX = FSPLNY( HDGLX,IRLTBL(1,N),IRLTBL(2,N) )
!
!---  Tabular aqueous relative permeability versus capillary head
!     w/ linear interpolation and table truncation beyond limits  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.14 ) THEN
        ITBX = 0
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        RKLX = FNTBLY( HDGL,IRLTBL(1,N),IRLTBL(2,N),ITBX )
!
!---  Tabular aqueous relative permeability versus capillary head
!     w/ cubic spline interpolation  ---
!
      ELSEIF( MOD( IRPL(N),100 ).EQ.15 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        RKLX = FSPLNY( HDGL,IRLTBL(1,N),IRLTBL(2,N) )
      ENDIF
!
!---  Polmann anisotropy permeability function  ---
!
      IF( IRPL(N).GE.100 .AND. IRPL(N).LT.200 ) THEN
        PSI = HDGL*1.D+2
        SKLX = RPLC(5,N) - RPLC(10,N)*PSI -
     &    RPLC(6,N)*RPLC(9,N)*( RPLC(7,N) -
     &    (RPLC(7,N)**2)*PSI - (RPLC(8,N)**2)*PSI)/
     &    (1.D+0 + RPLC(10,N)*RPLC(9,N))
        SIGMA = RPLC(6,N)*(((1.D+0 - RPLC(7,N)*PSI)**2) +
     &    (RPLC(8,N)**2)*(PSI**2))/
     &    (1.D+0 + RPLC(10,N)*RPLC(9,N))
        SKHX = EXP( SKLX + 5.D-1*SIGMA )
        SKVX = EXP( SKLX - 5.D-1*SIGMA )
        ANISOX = MIN( MAX( SKHX/SKVX,0.D+0 ),RPLC(11,N) )
        ANISOX = MAX( ANISOX,RPLC(12,N) )
        RKLX = RKLX*ANISOX
!
!---  Pruess anisotropy permeability function  ---
!
      ELSEIF( IRPL(N).GE.200 .AND. IRPL(N).LT.300 ) THEN
        HDGL_CM = HDGL*1.D+2
        ANISOX = RPLC(5,N)*(RPLC(6,N)**(RPLC(7,N)**HDGL_CM))
        ANISOX = MAX( ANISOX,1.D+0 )
        ANISOX = MIN( ANISOX,RPLC(5,N) )
        RKLX = RKLX*ANISOX
      ENDIF
      RKLX = MIN( MAX( RKLX,1.D-24 ),1.D+0 )
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RKLS_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE RSDL_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute the maximum relative residuals
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE OUTPU
      USE JACOB
      USE HYST
      USE GRID
      USE GEOM_FRC
      USE FILES
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(LUK*(1+LWELL+LSPILL)) :: RSDLX	
      REAL*8, DIMENSION(6) :: VARX	
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: NSDLX,NPHLX,NPHX
      INTEGER, DIMENSION(LUK*(1+LWELL+LSPILL)) :: IDLX,IDX
      INTEGER, DIMENSION(NFCGC(ID+1)) :: IRSDX
      INTEGER, DIMENSION(9) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*64 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      SAVE PH_CND
      DATA PH_CND /'Saturated w/o Entrapped Gas',
     &   'Unsaturated w/ or w/o Entrapped Gas',
     &   'Saturated w/ Trapped Gas',
     &   'Fully Unsaturated',
     &   'Supercritical Water'/
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/RSDL_GT'
!
!---  Zero local and global maximum residuals  ---
!
      DO M = 1,ISVC
        RSD(M) = 0.D+0
        RSDLX(M) = 0.D+0
        NSD(M) = 0
        NSDLX(M) = 0
        NPHLX(M) = 0
      ENDDO
!
!---  Loop over local nodes  ---
!
      NMD = 0
      DO N = 1,NFCGC(ID+1)
#ifdef lis
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
        N_DB = ND(N)
!
!---    Nonisothermal simulations  ---
!
        IF( ISLC(30).EQ.0 ) MPT = NMD + IEQT
        MPW = NMD + IEQW
        IF( ISLC(37).EQ.0 ) MPA = NMD + IEQA
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) MPS = NMD + IEQS
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
#ifdef petsc
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Skip selected nodes in the residual calculation
!       (not implemented)  ---
!
        IF( ISKP(N).EQ.1 ) CYCLE
!
!---    Nonisothermal simulations  ---
!
        IF( ISLC(30).EQ.0 ) THEN
!
!---      Energy equation  ---
!
          ACP = ((1.D+0-PORT(2,N))*RHOS(N)*CPS(N)*T(2,N) +
     &      (PORT(2,N)-PORD(2,N))*RHOL(2,N)*HL(2,N) +
     &      PORD(2,N)*(SL(2,N)*RHOL(2,N)*HL(2,N) +
     &      (YLS(2,N)-XLS(2,N))*SL(2,N)*RHOL(2,N)*HSP(2,N) +
     &      SG(2,N)*RHOG(2,N)*UEG(2,N)))*DTI*VOL(N)
          RSDX = MIN( ABS(BLU(MPT))/TABS,
     &      ABS(RSDL(IEQT,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQT) ) THEN
            RSDLX(IEQT) = RSDX
            NSDLX(IEQT) = N
            NPHLX(IEQT) = NPHAZ(2,N)
          ENDIF
        ENDIF
!
!---    Saturated system w/o trapped gas
!       Water mass - aqueous pressure
!       Air mass - aqueous-air mass fraction
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ(2,N).EQ.1 ) THEN
!
!---      Water mass equation  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(BLU(MPW))/(ABS(PL(2,N))+PATM),
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Air mass equation, ignore residual for small aqueous-air  ---
!
          INDX = 0
          CALL REGION_4( T(2,N),PSWX,INDX )
          PWX = MAX( PSWX,PL(2,N)+PATM )
          CALL SOL_BRNS( T(2,N),PWX,XLSMX )
          XLSX = MIN( YLS(2,N),XLSMX )
          XLS(2,N) = XLSX
          CALL SP_B( T(2,N),XLS(2,N),PSBX )
          IF( ISLC(37).EQ.0 ) THEN
            PVAX = MAX( PWX-PSBX,0.D+0 )
            XMLAX = PVAX/HCAW
            XMLA(2,N) = PVA(2,N)/HCAW
            IF( XMLA(2,N).GT.(1.D-6*XMLAX) ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLA(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(BLU(MPA))/MAX( XMLAX,PATM/HCAW ),
     &          ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX(IEQA) ) THEN
                RSDLX(IEQA) = RSDX
                NSDLX(IEQA) = N
                NPHLX(IEQA) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Salt mass equation, isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            RSDX = MIN( (ABS(BLU(MPS))/XLSMX),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Unsaturated system w/ or w/o entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.2 ) THEN
!
!---      Water mass equation  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(BLU(MPW))/(ABS(PL(2,N))+PATM),
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Air mass equation  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            IF( SG(2,N).GT.1.D-3 ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLA(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(BLU(MPA))/(ABS(PG(2,N))+PATM),
     &          ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX(IEQA) ) THEN
                RSDLX(IEQA) = RSDX
                NSDLX(IEQA) = N
                NPHLX(IEQA) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Salt mass equation, isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            INDX = 0
            CALL REGION_4( T(2,N),PWX,INDX )
            CALL SOL_BRNS( T(2,N),PWX,XLSMX )
            RSDX = MIN( (ABS(BLU(MPS))/XLSMX),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Saturated system w/ entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - trapped gas saturation
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.3 ) THEN
!
!---      Water mass equation  ---
!
          ACP = PORD(2,N)*(RHOL(2,N)*SL(2,N)*XLW(2,N) +
     &      RHOG(2,N)*SG(2,N)*XGW(2,N))*DTI*VOL(N)
          RSDX = MIN( ABS(BLU(MPW))/(ABS(PL(2,N))+PATM),
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Air mass equation  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            IF( SG(2,N).GT.1.D-5 ) THEN
              ACP = PORD(2,N)*(RHOG(2,N)*SG(2,N)*XGA(2,N) +
     &          RHOL(2,N)*SL(2,N)*XLA(2,N))*DTI*VOL(N)
              RSDX = MIN( ABS(BLU(MPA)/1.D+1),
     &          ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
              IF( RSDX.GT.RSDLX(IEQA) ) THEN
                RSDLX(IEQA) = RSDX
                NSDLX(IEQA) = N
                NPHLX(IEQA) = NPHAZ(2,N)
              ENDIF
              IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
            ENDIF
          ENDIF
!
!---      Salt mass equation, isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            ACP = TMS(2,N)*DTI*VOL(N)
            INDX = 0
            CALL REGION_4( T(2,N),PWX,INDX )
            CALL P_IAPWS( T(2,N),PWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL SOL_BRNS( T(2,N),PWX,XLSMX )
            RSDX = MIN( (ABS(BLU(MPS))/XLSMX),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            RSDX = RSDX*1.D-1
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - gas pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ(2,N).EQ.4 ) THEN
!
!---      Water mass equation  ---
!
          INDX = 0
          CALL REGION_4( T(2,N),PWX,INDX )
          PWX = MIN( PWX,PCRW )
          ACP = PORD(2,N)*RHOG(2,N)*SG(2,N)*XGW(2,N)*DTI*VOL(N)
          RSDX = MIN( ABS(BLU(MPW))/PWX,
     &      ABS(RSDL(IEQW,N)/(ACP+SMALL)) )
          IF( RSDX.GT.RSDLX(IEQW) ) THEN
            RSDLX(IEQW) = RSDX
            NSDLX(IEQW) = N
            NPHLX(IEQW) = NPHAZ(2,N)
          ENDIF
          IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
!
!---      Air mass equation  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            PGX = PG(2,N) + PATM
            ACP = PORD(2,N)*RHOG(2,N)*SG(2,N)*XGA(2,N)*DTI*VOL(N)
            RSDX = MIN( ABS(BLU(MPA))/ABS(PGX),
     &        ABS(RSDL(IEQA,N)/(ACP+SMALL)) )
            IF( RSDX.GT.RSDLX(IEQA) ) THEN
              RSDLX(IEQA) = RSDX
              NSDLX(IEQA) = N
              NPHLX(IEQA) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
!
!---      Salt mass equation, isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            CALL DENS_S( T(2,N),PGX,RHOSPX )
            ACP = TMS(2,N)*DTI*VOL(N)
            RSDX = MIN( (ABS(BLU(MPS))/RHOSPX),
     &        ABS(RSDL(IEQS,N)/(ACP+SMALL)) )
            IF( RSDX.GT.RSDLX(IEQS) ) THEN
              RSDLX(IEQS) = RSDX
              NSDLX(IEQS) = N
              NPHLX(IEQS) = NPHAZ(2,N)
            ENDIF
            IF( RSDX.GT.RSDMX ) IRSDX(N) = 1
          ENDIF
        ENDIF
      ENDDO
!
!---  Maximum global residuals  ---
!
      CALL MPI_ALLREDUCE( RSDLX,RSD,ISVC,MPI_REAL8,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
!
!---  Identify processor with maximum residual  ---
!
      DO M = 1,ISVC
        IDLX(M) = -1
        IF( ABS((RSDLX(M)-RSD(M))/EPSL).LT.EPSL ) IDLX(M) = ID
        IF( ID.EQ.IDLX(M) .AND. NSDLX(M).GT.0 ) THEN
          NSD(M) = ND( NSDLX(M) )
          NPHX(M) = NPHLX(M)
        ELSE
          NSD(M) = 0
          NPHX(M) = 0
        ENDIF
      ENDDO
      CALL MPI_ALLREDUCE( IDLX,IDX,ISVC,MPI_INTEGER,MPI_MAX,
     &  MPI_COMM_WORLD,IERR )
      DO M = 1,ISVC
        CALL MPI_BCAST( NSD(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
        CALL MPI_BCAST( NPHX(M),1,MPI_INTEGER,IDX(M),MPI_COMM_WORLD,
     &    IERR )
      ENDDO
!
!---  Assign a convergence index  ---
!
      RSDX = 1.D-20
      DO M = 1,ISVC
        IF( RSD(M).GT.RSDMX ) ICNV = 2
        RSDX = MAX( RSD(M),RSDX )
      ENDDO
      IF( ICNV.EQ.2 .AND. NITER.GE.NRIMX ) ICNV = 1
!
!---  Unconverged solution and Newton-Raphson iteration
!     limit exceeded  ---
!
      IF( ICNV.EQ.1 ) THEN
        OFFSET = IOFFSET_REF
        IF( ID.EQ.0 ) THEN
          IF( RSDX.GE.1.D+2 ) THEN
            PRINT *,'           ---  Excessive Residual  ---'
            IVARX(1) = -5
          ENDIF
        ENDIF
!
!---    Debug printing to the screen  ---
!
        IF( ID.EQ.0 ) THEN
!
!---      Nonisothermal simulations  ---
!
          IF( ISLC(30).EQ.0 ) THEN
            NX = NSD(IEQW)
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQT)
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'  Energy Equation Maximum Residual = ',
     &          RSD(IEQT),': Node = ',NX,': Phase Condition = ',
     &          PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
!
!---      Water mass equation  ---
!
          NX = NSD(IEQW)
          IF( NX.GT.0 ) THEN
            NPX = NPHX(IEQW)
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'  Water Mass Equation Maximum Residual = ',
     &        RSD(IEQW),': Node = ',NX,': Phase Condition = ',
     &        PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Air mass equation  ---
!
          NX = NSD(IEQA)
          IF( NX.GT.0 ) THEN
            NPX = NPHX(IEQA)
            NCHX = INDEX( PH_CND(NPX),'  ') - 1
            PRINT *,'  Air Mass Equation Maximum Residual = ',
     &        RSD(IEQA),': Node = ',NX,': Phase Condition = ',
     &        PH_CND(NPX)(1:NCHX)
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
            NX = NSD(IEQS)
            IF( NX.GT.0 ) THEN
              NPX = NPHX(IEQS)
              NCHX = INDEX( PH_CND(NPX),'  ') - 1
              PRINT *,'  Salt Equation Maximum Residual = ',
     &          RSD(IEQS),': Node = ',NX,': Phase Condition = ',
     &          PH_CND(NPX)(1:NCHX)
            ENDIF
          ENDIF
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            XMLA(2,N) = XMLA(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Fracture flow and transport solution  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) THEN
!
!---        Loop over fracture triangles (without ghost triangles)  ---
!
            DO NTX = 1,NFT(ID+1)
              T_FRC(2,NTX) = T_FRC(1,NTX)
              PL_FRC(2,NTX) = PL_FRC(1,NTX)
              PG_FRC(2,NTX) = PG_FRC(1,NTX)
              PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
              PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
              XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
              SL_FRC(2,NTX) = SL_FRC(1,NTX)
              SG_FRC(2,NTX) = SG_FRC(1,NTX)
              YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
              TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
              NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
            ENDDO
          ENDIF
          IVARX(1) = -1
          VARX(5) = DTX*CNVTM
          VARX(6) = DT*CNVTM
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          RETURN
        ENDIF
!
!---    Write a convergence failure index in the NSTEP location
!       plus write the global node numbers and phase condition indices
!       for the location of maximum residuals for the water, air,
!       and salt equations to output.bin  ---
!
        NVAR = 9
        IF( ISLC(30).EQ.0 ) THEN
          IVARX(2) = NSD(IEQT)
          IVARX(3) = NPHX(IEQT)
        ELSE
          IVARX(2) = 0
          IVARX(3) = 0
        ENDIF
        IVARX(4) = NSD(IEQW)
        IVARX(5) = NPHX(IEQW)
        IVARX(6) = NSD(IEQA)
        IVARX(7) = NPHX(IEQA)
        IF( ISLC(32).EQ.0 ) THEN
          IVARX(8) = NSD(IEQS)
          IVARX(9) = NPHX(IEQS)
        ELSE
          IVARX(8) = 0
          IVARX(9) = 0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &    MPI_INTEGER,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTI
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---    Write maximum residuals for the water, air, and salt
!       equations and time step reductions to output.bin  ---
!
        NVAR = 6
        IF( ISLC(32).EQ.0 ) THEN
          VARX(1) = RSD(IEQT)
        ELSE
          VARX(1) = 0.D+0
        ENDIF
        VARX(2) = RSD(IEQW)
        VARX(3) = RSD(IEQA)
        IF( ISLC(32).EQ.0 ) THEN
          VARX(4) = RSD(IEQS)
        ELSE
          VARX(4) = 0.D+0
        ENDIF
        IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &    MPI_REAL8,STATUS,IERR)
        OFFSET = OFFSET + NVAR*NBYTR
        IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of RSDL_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SORC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Compute source terms.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOURC
      USE SOLTN
      USE PROP
      USE OUTPU
      USE HYST
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8 SRX(8+LSOLU)
      CHARACTER*132 CHMSGX(2)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/SORC_GT'
!
!---    Zero source terms  ---
!
      DO NS = 1,NSR(ID+1)
        N = ISRN(NS)
        DO M = 1,ISVF
          SRCT(M,N) = 0.D+0
          SRCS(M,N) = 0.D+0
          SRCA(M,N) = 0.D+0
          SRCW(M,N) = 0.D+0
        ENDDO
      ENDDO
!
!---  Loop over sources  ---
!
      DO NS = 1,NSR(ID+1)
        TMZ = TM
        IF( NSTEP-NRST.EQ.0 ) TMZ = TMZ*(1.D+0+EPSL)+EPSL
        MB = ISRIN(NS)
        IF( TMZ.LE.SRC(1,1,MB) ) CYCLE
        IF( ISRM(NS).EQ.1 ) THEN
          DO N = 1,8+NSOLU
            SRX(N) = SRC(N,1,MB)
          ENDDO
        ELSE
          IFIND = 0
          DO M = 2,ISRM(NS)
            IF( TMZ.LE.SRC(1,M,MB) ) THEN
             DTSR = MIN( SRC(1,M,MB)-TMZ,DT )
             TFSR = (TMZ-0.5D+0*DTSR-SRC(1,M-1,MB))/
     &         (SRC(1,M,MB)-SRC(1,M-1,MB))
             DO N = 1,8+NSOLU
               SRX(N) = SRC(N,M-1,MB) + TFSR*(SRC(N,M,MB)-SRC(N,M-1,MB))
             ENDDO
             IFIND = 1
             EXIT
            ENDIF
          ENDDO
          IF( IFIND.EQ.0 ) CYCLE
        ENDIF
!
!---    Local node associated with processor-dependent source  ---
!
        N = ISRN(NS)
        N_DB = ND(N)
!
!---    Loop over increment indices  ---
!
        DO M = 2,ISVC+2
          PGX = PG(M,N) + PATM
          PLX = PL(M,N) + PATM
!
!---      Specified Power  ---
!
          IF( ISRT(NS).EQ.1 ) THEN
            SRCT(M,N) = SRCT(M,N) + SRX(4)
!
!---      Power Density  ---
!
          ELSEIF( ISRT(NS).EQ.2 ) THEN
            SRCT(M,N) = SRCT(M,N) + SRX(4)*VOL(N)
!
!---      Setting of Portland Cement  ---
!
          ELSEIF( ISRT(NS).EQ.11 ) THEN
!
!---        Temperature dependent Sigmoid function parameters
!           for Portland cement  ---
!
!            XHALFX = 3.9653D+3 + 9.7147D+4*EXP(-4.7852D-2*T(M,N))
!            RATEX = 8.2143D+2 + 3.0896D+5*EXP(-1.227D-1*T(M,N))
!
!---        Temperature dependent Sigmoid function parameters
!           for Portland cement, with 2x rate and xhalf
!           shifted later by 2000 s  ---
!
!            XHALFX = 5.9653D+3 + 9.7147D+4*EXP(-4.7852D-2*T(M,N))
!            RATEX = 16.429D+2 + 6.1792D+5*EXP(-1.227D-1*T(M,N))
            XHALFX = SRX(2) + SRX(3)*EXP(-SRX(5)*T(M,N))
            RATEX = SRX(6) + SRX(7)*EXP(-SRX(8)*T(M,N))
            BASEX = 0.D+0
            MAXX = SRX(4)
            VARX = EXP((TM-XHALFX)/RATEX)
!
!---        Heat evolution rate, W/kg  ---
!
            HERX = MAXX*VARX/(((1.D+0 + VARX)**2)*RATEX)
            SRCT(M,N) = SRCT(M,N) + HERX*VOL(N)*RHOS(N)
!
!---      Aqueous Volumetric Rate w/
!         Dissolved-Air Relative Saturation ---
!
          ELSEIF( ISRT(NS).EQ.3 ) THEN
            IF( SRX(4).GE.0.D+0 ) THEN
              TX = SRX(2)
              PX = SRX(3)
              WLAX = SRX(5)
              XLSX = SRX(6)
              IF( ISLC(32).EQ.0 ) XLSX = XLS(2,N)
              CALL SOL_BRNS( TX,PX,XLSMX )
              XLSX = XLSX*XLSMX
              INDX = 0
              CALL REGION_4( TX,PSWX,INDX )
              PX = MAX( PGX,PLX,PX,PSWX )
              PWX = PX
              CALL P_IAPWS( TX,PWX,RHOX,RHOLWX,HX,HLWX,UX,ULWX )
              PVAX = WLAX*MAX( PX-PSWX,0.D+0 )
              XMLAX = PVAX/HCAW
              XMLWX = MAX( 1.D+0-XMLAX,0.D+0 )
              WTMX = XMLWX*WTMW + XMLAX*WTMA
              XLAX = (XMLAX*WTMA)/WTMX
              XLWX = (XMLWX*WTMW)/WTMX
              CALL DENS_B( XLSX,RHOLX,RHOLWX,TX )
              CALL AIRGSH( TX,PVAX,HGAX,UEGAX )
              HLX = MAX(1.D+0-XLAX,0.D+0)*HLWX + XLAX*HGAX
              SRCS(M,N) = SRCS(M,N) + SRX(4)*RHOLX*XLSX
              SRCA(M,N) = SRCA(M,N) + SRX(4)*RHOLX*XLAX
              SRCW(M,N) = SRCW(M,N) + SRX(4)*RHOLX*XLWX
              SRCT(M,N) = SRCT(M,N) + SRX(4)*RHOLX*HLX
            ELSE
              SRCT(M,N) = SRCT(M,N) + SRX(4)*RHOL(M,N)*HL(M,N)
              SRCS(M,N) = SRCS(M,N) + SRX(4)*RHOL(M,N)*XLS(M,N)
              SRCA(M,N) = SRCA(M,N) + SRX(4)*RHOL(M,N)*XLA(M,N)
              SRCW(M,N) = SRCW(M,N) + SRX(4)*RHOL(M,N)*XLW(M,N)
            ENDIF
!
!---      Gas Volumetric Rate w/ Component Relative Humidity ---
!
          ELSEIF( ISRT(NS).EQ.4 ) THEN
            IF( SRX(4).GE.0.D+0 ) THEN
              PX = MAX( PGX,PLX,SRX(3) )
              INDX = 0
              CALL REGION_4( SRX(2),PSWX,INDX )
              PVWX = PSWX*SRX(5)
              PVAX = MAX( PX-PVWX,0.D+0 )
              INDX = 0
              CALL WATGSD( SRX(2),PVWX,RHOW,INDX )
              CALL AIRGSD( SRX(2),PVAX,RHOA )
              CALL WATGSH( SRX(2),PSWX,RHOW,HGWX,UGWX )
              CALL AIRGSH( SRX(2),PVAX,HGAX,UGAX )
              SRCT(M,N) = SRCT(M,N) + SRX(4)*(RHOW*HGWX+RHOA*HGAX)
              SRCA(M,N) = SRCA(M,N) + SRX(4)*RHOA
              SRCW(M,N) = SRCW(M,N) + SRX(4)*RHOW
            ELSE
              HGX = XGW(M,N)*HGW(M,N) + XGA(M,N)*HGA(M,N)
              SRCT(M,N) = SRCT(M,N) + SRX(4)*RHOG(M,N)*HGX
              SRCA(M,N) = SRCA(M,N) + SRX(4)*RHOG(M,N)*XGA(M,N)
              SRCW(M,N) = SRCW(M,N) + SRX(4)*RHOG(M,N)*XGW(M,N)
            ENDIF
!
!---      Gas Volumetric Rate w/ Component Mass Fractions ---
!
          ELSEIF( ISRT(NS).EQ.5 ) THEN
            IF( SRX(4).GE.0.D+0 ) THEN
              PX = MAX( PGX,PLX,SRX(3) )
              XGWX = SRX(5)
              XGAX = MAX( 1.D+0-XGWX,0.D+0 )
              XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
              INDX = 0
              CALL REGION_4( SRX(2),PSWX,INDX )
              PVWX = MIN( PX*XMGWX,PSWX )
              PVAX = MAX( PX-PVWX,0.D+0 )
              INDX = 0
              CALL WATGSD( SRX(2),PVWX,RHOW,INDX )
              CALL AIRGSD( SRX(2),PVAX,RHOA )
              CALL WATGSH( SRX(2),PSWX,RHOW,HGWX,UGWX )
              CALL AIRGSH( SRX(2),PVAX,HGAX,UGAX )
              SRCT(M,N) = SRCT(M,N) + SRX(4)*(RHOW*HGWX+RHOA*HGAX)
              SRCA(M,N) = SRCA(M,N) + SRX(4)*RHOA
              SRCW(M,N) = SRCW(M,N) + SRX(4)*RHOW
            ELSE
              HGX = XGW(M,N)*HGW(M,N) + XGA(M,N)*HGA(M,N)
              SRCT(M,N) = SRCT(M,N) + SRX(4)*RHOG(M,N)*HGX
              SRCA(M,N) = SRCA(M,N) + SRX(4)*RHOG(M,N)*XGA(M,N)
              SRCW(M,N) = SRCW(M,N) + SRX(4)*RHOG(M,N)*XGW(M,N)
            ENDIF
!
!---      Undocumented Condensate Source ---
!
          ELSEIF( ISRT(NS).EQ.6 ) THEN
            NSFG = 0
            DO NSU = 1,NSF
              IF( ISFT(NSU).EQ.-6 ) NSFG = NSFG + 1
              IF( NSFG.EQ.INT(SRX(4)) ) THEN
                CMSX = MAX(SF(1,NSU),0.D+0)*VOL(N)/SRX(6)
                EXIT
              ENDIF
            ENDDO
            CMSX = CMSX*MAX( 1.D+0-SRX(7),0.D+0 )
            PX = MAX( PGX,PLX,SRX(3) )
            CALL WATLQH( SRX(2),PX,HLX )
            INDX = 0
            CALL REGION_4( SRX(2),PSWX,INDX )
            PVAX = MAX( PX-PSWX,0.D+0 )*SRX(5)
            XMLAX = PVAX/HCAW
            XMLWX = MAX( 1.D+0-XMLAX,0.D+0 )
            XLAX = (XMLAX*WTMA)/(XMLAX*WTMA+XMLWX*WTMW)
            SRCT(M,N) = SRCT(M,N) + CMSX*HLX
            SRCA(M,N) = SRCA(M,N) + CMSX*XLAX
!
!---      Aqueous Mass Rate w/ Dissolved-Air Relative Saturation  ---
!
          ELSEIF( ISRT(NS).EQ.7 ) THEN
            IF( SRX(4).GE.0.D+0 ) THEN
              TX = SRX(2)
              PX = SRX(3)
              WLAX = SRX(5)
              INDX = 0
              CALL REGION_4( TX,PSWX,INDX )
              PX = MAX( PGX,PLX,PX,PSWX )
              PWX = PX
              CALL P_IAPWS( TX,PWX,RHOX,RHOLWX,HX,HLWX,UX,ULWX )
              PVAX = WLAX*MAX( PX-PSWX,0.D+0 )
              XMLAX = PVAX/HCAW
              XMLWX = MAX( 1.D+0-XMLAX,0.D+0 )
              WTMX = XMLWX*WTMW + XMLAX*WTMA
              XLAX = (XMLAX*WTMA)/WTMX
              XLWX = (XMLWX*WTMW)/WTMX
              CALL AIRGSH( TX,PVAX,HGAX,UEGAX )
              HLX = MAX(1.D+0-XLAX,0.D+0)*HLWX + XLAX*HGAX
              SRCA(M,N) = SRCA(M,N) + SRX(4)*XLAX
              SRCS(M,N) = SRCS(M,N) + SRX(4)*XLSX
              SRCW(M,N) = SRCW(M,N) + SRX(4)*XLWX
              SRCT(M,N) = SRCT(M,N) + SRX(4)*HLX
            ELSE
              SRCT(M,N) = SRCT(M,N) + SRX(4)*HL(M,N)
              SRCS(M,N) = SRCS(M,N) + SRX(4)*XLS(M,N)
              SRCA(M,N) = SRCA(M,N) + SRX(4)*XLA(M,N)
              SRCW(M,N) = SRCW(M,N) + SRX(4)*XLW(M,N)
            ENDIF
!
!---      Gas Mass Rate w/ Component Relative Humidity ---
!
          ELSEIF( ISRT(NS).EQ.8 ) THEN
            IF( SRX(4).GE.0.D+0 ) THEN
              PX = MAX( PGX,PLX,SRX(3) )
              INDX = 0
              CALL REGION_4( SRX(2),PSWX,INDX )
              PVWX = PSWX*SRX(5)
              PVAX = MAX( PGX-PVWX,0.D+0 )
              INDX = 0
              CALL WATGSD( SRX(2),PVWX,RHOW,INDX )
              CALL AIRGSD( SRX(2),PVAX,RHOA )
              CALL WATGSH( SRX(2),PSWX,RHOW,HGWX,UGWX )
              CALL AIRGSH( SRX(2),PVAX,HGAX,UGAX )
              XGWX = RHOW/(RHOW+RHOA)
              XGAX = RHOA/(RHOW+RHOA)
              SRCT(M,N) = SRCT(M,N) + SRX(4)*(XGWX*HGWX+XGAX*HGAX)
              SRCA(M,N) = SRCA(M,N) + SRX(4)*XGAX
              SRCW(M,N) = SRCW(M,N) + SRX(4)*XGWX
            ELSE
              HGX = XGW(M,N)*HGW(M,N) + XGA(M,N)*HGA(M,N)
              SRCT(M,N) = SRCT(M,N) + SRX(4)*HGX
              SRCA(M,N) = SRCA(M,N) + SRX(4)*XGA(M,N)
              SRCW(M,N) = SRCW(M,N) + SRX(4)*XGW(M,N)
            ENDIF
!
!---      Gas Mass Rate w/ Component Mass Fractions ---
!
          ELSEIF( ISRT(NS).EQ.9 ) THEN
            IF( SRX(4).GE.0.D+0 ) THEN
              PX = MAX( PLX,PGX,SRX(3) )
              XGWX = SRX(5)
              XGAX = MAX( 1.D+0-XGWX,0.D+0 )
              XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
              INDX = 0
              CALL REGION_4( SRX(2),PSWX,INDX )
              PVWX = MIN( PX*XMGWX,PSWX )
              PVAX = MAX( PX-PVWX,0.D+0 )
              INDX = 0
              CALL WATGSD( SRX(2),PVWX,RHOW,INDX )
              CALL AIRGSD( SRX(2),PVAX,RHOA )
              CALL WATGSH( SRX(2),PSWX,RHOW,HGWX,UGWX )
              CALL AIRGSH( SRX(2),PVAX,HGAX,UGAX )
              XGWX = RHOW/(RHOW+RHOA)
              XGAX = RHOA/(RHOW+RHOA)
              SRCT(M,N) = SRCT(M,N) + SRX(4)*(XGWX*HGWX+XGAX*HGAX)
              SRCA(M,N) = SRCA(M,N) + SRX(4)*XGAX
              SRCW(M,N) = SRCW(M,N) + SRX(4)*XGWX
            ELSE
              HGX = XGW(M,N)*HGW(M,N) + XGA(M,N)*HGA(M,N)
              SRCT(M,N) = SRCT(M,N) + SRX(4)*HGX
              SRCA(M,N) = SRCA(M,N) + SRX(4)*XGA(M,N)
              SRCW(M,N) = SRCW(M,N) + SRX(4)*XGW(M,N)
            ENDIF
!
!---      Mass Sink ---
!
          ELSEIF( ISRT(NS).EQ.10 ) THEN
            RMLX = (RKL(M,N)*RHOL(M,N)/VISL(M,N))
            RMGX = (RKG(M,N)*RHOG(M,N)/VISG(M,N))
            RMLX = RMLX/(RMLX+RMGX)
            RMGX = 1.D+0-RMLX
            SRCT(M,N) = SRCT(M,N) + SRX(4)*(RMLX*HL(M,N) +
     &        RMGX*HG(M,N))
            SRCA(M,N) = SRCA(M,N) + SRX(4)*(RMLX*XLA(M,N) +
     &        RMGX*XGA(M,N))
            SRCW(M,N) = SRCW(M,N) + SRX(4)*(RMLX*XLW(M,N) +
     &        RMGX*XGW(M,N))
!!
!!---      Z-direction vertical injection well  ---
!!
!          ELSEIF( ISRT(NS).GE.13 .AND. ISRT(NS).LE.15  ) THEN
!!
!!---        Geometric factors  ---
!!
!            RDW = SRX(3)
!            RDE = SQRT( AFZ(1,N)/GPI/SRX(4) )
!            DRD2 = (RDE**2-RDW**2)
!!
!!---        Well pressure  ---
!!
!            IF( M.EQ.2 ) THEN
!              IF( K.EQ.ISRDM(5,NS) ) THEN
!                PGWX = SRX(2)
!                PX = PGWX+PATM
!                IF( ISRT(NS).EQ.14 ) THEN
!                  XGWX = SRX(5)
!                  XGAX = MAX( 1.D+0-XGWX,0.D+0 )
!                  XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
!                ENDIF
!                INDX = 0
!                CALL REGION_4( SRX(7),PSWX,INDX )
!                IF( ISRT(NS).EQ.14 ) THEN
!                  PVWX = MIN( PX*XMGWX,PSWX )
!                ELSE
!                  PVWX = PSWX*SRX(5)
!                ENDIF
!                PVAX = MAX( PX-PVWX,0.D+0 )
!                INDX = 0
!                CALL WATGSD( SRX(7),PVWX,RHOGWX,INDX )
!                CALL AIRGSD( SRX(7),PVAX,RHOGAX )
!                CALL WATGSH( SRX(7),PSWX,RHOGWX,HGWX,UGWX )
!                CALL AIRGSH( SRX(7),PVAX,HGAX,UGAX )
!              ELSE
!                PX = PGWX+PATM
!                IF( ISRT(NS).EQ.14 ) THEN
!                  XGWX = SRX(5)
!                  XGAX = MAX( 1.D+0-XGWX,0.D+0 )
!                  XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
!                ENDIF
!                INDX = 0
!                CALL REGION_4( SRX(7),PSWX,INDX )
!                IF( ISRT(NS).EQ.14 ) THEN
!                  PVWX = MIN( PX*XMGWX,PSWX )
!                ELSE
!                  PVWX = PSWX*SRX(5)
!                ENDIF
!                PVAX = MAX( PX-PVWX,0.D+0 )
!                INDX = 0
!                CALL WATGSD( SRX(7),PVWX,RHOGWX,INDX )
!                CALL AIRGSD( SRX(7),PVAX,RHOGAX )
!                CALL WATGSH( SRX(7),PSWX,RHOGWX,HGWX,UGWX )
!                CALL AIRGSH( SRX(7),PVAX,HGAX,UGAX )
!                NX = ICM(1,N)
!                GB = (ZP(N)-ZP(NX))*GRAVZ
!                RHOGX = RHOGWX+RHOGAX
!                PGWX = PGWX - RHOGX*GB
!              ENDIF
!            ENDIF
!            IF( (PERM(1,N)/EPSL).GT.EPSL ) THEN
!              IF( (PERM(2,N)/EPSL).GT.EPSL ) THEN
!                PERMX = SQRT( PERM(1,N)*PERM(2,N) )
!              ELSE
!                PERMX = PERM(1,N)
!              ENDIF
!            ELSE
!              PERMX = PERM(2,N)
!            ENDIF
!!
!!---        If permeability is too low, skip
!!
!            IF ( PERMX.GT.SRX(6) ) THEN
!!
!!---          Injection  ---
!!
!              IF( PGWX-PG(M,N).GT.EPSL ) THEN
!                XGAX = RHOGAX/(RHOGAX+RHOGWX)
!                XGWX = RHOGWX/(RHOGAX+RHOGWX)
!                WTMGX = 1.D+0/(XGAX/WTMA + XGWX/WTMW)
!                XMGAX = XGAX*WTMGX/WTMA
!                XMGWX = XGWX*WTMGX/WTMW
!                CALL WATGSV( SRX(7),VISGWX )
!                CALL AIRGSV( SRX(7),VISGAX )
!                CALL GASVIS( XMGWX,ZERO,XMGAX,VISGWX,SMALL,VISGAX,
!     &            VISGX )
!                HCGX = 2.D+0*GPI*PERMX*DRD2*DZGF(N)/
!     &            (VISGX*((RDE**2)*LOG(RDE/RDW)-5.D-1*DRD2))
!                QGX = SRX(4)*(PGWX-PG(M,N))*HCGX
!                SRCT(M,N) = SRCT(M,N) + QGX*(RHOGWX*HGWX+RHOGAX
!     &            *HGAX)
!                SRCW(M,N) = SRCW(M,N) + QGX*RHOGWX
!                SRCA(M,N) = SRCA(M,N) + QGX*RHOGAX
!!
!!---          Withdrawl  ---
!!
!              ELSE
!                HCGX = 2.D+0*GPI*PERMX*DRD2*DZGF(N)/
!     &            (VISG(M,N)*((RDE**2)*LOG(RDE/RDW)-5.D-1*DRD2))
!                QGX = SRX(4)*(PGWX-PG(M,N))*RKG(M,N)*HCGX
!                HGX = XGW(M,N)*HGW(M,N) + XGA(M,N)*HGA(M,N)
!                SRCT(M,N) = SRCT(M,N) + QGX*RHOG(M,N)*HGX
!                SRCW(M,N) = SRCW(M,N) + QGX*RHOG(M,N)*XGW(M,N)
!                SRCA(M,N) = SRCA(M,N) + QGX*RHOG(M,N)*XGA(M,N)
!              ENDIF
!            ENDIF
!!
!!---      X-direction horizontal injection well  ---
!!
!          ELSEIF( ISRT(NS).GE.16 .AND. ISRT(NS).LE.18  ) THEN
!!
!!---        Geometric factors  ---
!!
!            RDW = SRX(3)
!            RDE = SQRT( AFX(1,N)/GPI/SRX(4) )
!            DRD2 = (RDE**2-RDW**2)
!!
!!---        Well pressure  ---
!!
!            IF( M.EQ.2 ) THEN
!              IF( I.EQ.ISRDM(1,NS) ) THEN
!                PGWX = SRX(2)
!                PX = PGWX+PATM
!                IF( ISRT(NS).EQ.14 ) THEN
!                  XGWX = SRX(5)
!                  XGAX = MAX( 1.D+0-XGWX,0.D+0 )
!                  XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
!                ENDIF
!                INDX = 0
!                CALL REGION_4( SRX(7),PSWX,INDX )
!                IF( ISRT(NS).EQ.14 ) THEN
!                  PVWX = MIN( PX*XMGWX,PSWX )
!                ELSE
!                  PVWX = PSWX*SRX(5)
!                ENDIF
!                PVAX = MAX( PX-PVWX,0.D+0 )
!                INDX = 0
!                CALL WATGSD( SRX(7),PVWX,RHOGWX,INDX )
!                CALL AIRGSD( SRX(7),PVAX,RHOGAX )
!                CALL WATGSH( SRX(7),PSWX,RHOGWX,HGWX,UGWX )
!                CALL AIRGSH( SRX(7),PVAX,HGAX,UGAX )
!              ELSE
!                PX = PGWX+PATM
!                IF( ISRT(NS).EQ.14 ) THEN
!                  XGWX = SRX(5)
!                  XGAX = MAX( 1.D+0-XGWX,0.D+0 )
!                  XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
!                ENDIF
!                INDX = 0
!                CALL REGION_4( SRX(7),PSWX,INDX )
!                IF( ISRT(NS).EQ.14 ) THEN
!                  PVWX = MIN( PX*XMGWX,PSWX )
!                ELSE
!                  PVWX = PSWX*SRX(5)
!                ENDIF
!                PVAX = MAX( PX-PVWX,0.D+0 )
!                INDX = 0
!                CALL WATGSD( SRX(7),PVWX,RHOGWX,INDX )
!                CALL AIRGSD( SRX(7),PVAX,RHOGAX )
!                CALL WATGSH( SRX(7),PSWX,RHOGWX,HGWX,UGWX )
!                CALL AIRGSH( SRX(7),PVAX,HGAX,UGAX )
!                NX = ICM(3,N)
!                GB = (XP(N)-XP(NX))*GRAVX
!                RHOGX = RHOGWX+RHOGAX
!                PGWX = PGWX - RHOGX*GB
!              ENDIF
!            ENDIF
!            IF( (PERM(2,N)/EPSL).GT.EPSL ) THEN
!              IF( (PERM(3,N)/EPSL).GT.EPSL ) THEN
!                PERMX = SQRT( PERM(2,N)*PERM(3,N) )
!              ELSE
!                PERMX = PERM(2,N)
!              ENDIF
!            ELSE
!              PERMX = PERM(3,N)
!            ENDIF
!!
!!---        If permeability is too low, skip
!!
!            IF ( PERMX.GT.SRX(6) ) THEN
!!
!!---          Injection  ---
!!
!              IF( PGWX-PG(M,N).GT.EPSL ) THEN
!                XGAX = RHOGAX/(RHOGAX+RHOGWX)
!                XGWX = RHOGWX/(RHOGAX+RHOGWX)
!                WTMGX = 1.D+0/(XGAX/WTMA + XGWX/WTMW)
!                XMGAX = XGAX*WTMGX/WTMA
!                XMGWX = XGWX*WTMGX/WTMW
!                CALL WATGSV( SRX(7),VISGWX )
!                CALL AIRGSV( SRX(7),VISGAX )
!                CALL GASVIS( XMGWX,ZERO,XMGAX,VISGWX,SMALL,VISGAX,
!     &            VISGX )
!                HCGX = 2.D+0*GPI*PERMX*DRD2*DXGF(N)/
!     &            (VISGX*((RDE**2)*LOG(RDE/RDW)-5.D-1*DRD2))
!                QGX = SRX(4)*(PGWX-PG(M,N))*HCGX
!                SRCT(M,N) = SRCT(M,N) + QGX*(RHOGWX*HGWX+RHOGAX
!     &            *HGAX)
!                SRCW(M,N) = SRCW(M,N) + QGX*RHOGWX
!                SRCA(M,N) = SRCA(M,N) + QGX*RHOGAX
!!
!!---          Withdrawl  ---
!!
!              ELSE
!                HCGX = 2.D+0*GPI*PERMX*DRD2*DXGF(N)/
!     &            (VISG(M,N)*((RDE**2)*LOG(RDE/RDW)-5.D-1*DRD2))
!                QGX = SRX(4)*(PGWX-PG(M,N))*RKG(M,N)*HCGX
!                HGX = XGW(M,N)*HGW(M,N) + XGA(M,N)*HGA(M,N)
!                SRCT(M,N) = SRCT(M,N) + QGX*RHOG(M,N)*HGX
!                SRCW(M,N) = SRCW(M,N) + QGX*RHOG(M,N)*XGW(M,N)
!                SRCA(M,N) = SRCA(M,N) + QGX*RHOG(M,N)*XGA(M,N)
!              ENDIF
!            ENDIF
!!
!!---      Y-direction horizontal injection well  ---
!!
!          ELSEIF( ISRT(NS).GE.19 .AND. ISRT(NS).LE.21  ) THEN
!!
!!---        Geometric factors  ---
!!
!            RDW = SRX(3)
!            RDE = SQRT( AFY(1,N)/GPI/SRX(4) )
!            DRD2 = (RDE**2-RDW**2)
!!
!!---        Well pressure  ---
!!
!            IF( M.EQ.2 ) THEN
!              IF( J.EQ.ISRDM(3,NS) ) THEN
!                PGWX = SRX(2)
!                PX = PGWX+PATM
!                IF( ISRT(NS).EQ.14 ) THEN
!                  XGWX = SRX(5)
!                  XGAX = MAX( 1.D+0-XGWX,0.D+0 )
!                  XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
!                ENDIF
!                INDX = 0
!                CALL REGION_4( SRX(7),PSWX,INDX )
!                IF( ISRT(NS).EQ.14 ) THEN
!                  PVWX = MIN( PX*XMGWX,PSWX )
!                ELSE
!                  PVWX = PSWX*SRX(5)
!                ENDIF
!                PVAX = MAX( PX-PVWX,0.D+0 )
!                INDX = 0
!                CALL WATGSD( SRX(7),PVWX,RHOGWX,INDX )
!                CALL AIRGSD( SRX(7),PVAX,RHOGAX )
!                CALL WATGSH( SRX(7),PSWX,RHOGWX,HGWX,UGWX )
!                CALL AIRGSH( SRX(7),PVAX,HGAX,UGAX )
!              ELSE
!                PX = PGWX+PATM
!                IF( ISRT(NS).EQ.14 ) THEN
!                  XGWX = SRX(5)
!                  XGAX = MAX( 1.D+0-XGWX,0.D+0 )
!                  XMGWX = (XGWX/WTMW)/((XGAX/WTMA)+(XGWX/WTMW))
!                ENDIF
!                INDX = 0
!                CALL REGION_4( SRX(7),PSWX,INDX )
!                IF( ISRT(NS).EQ.14 ) THEN
!                  PVWX = MIN( PX*XMGWX,PSWX )
!                ELSE
!                  PVWX = PSWX*SRX(5)
!                ENDIF
!                PVAX = MAX( PX-PVWX,0.D+0 )
!                INDX = 0
!                CALL WATGSD( SRX(7),PVWX,RHOGWX,INDX )
!                CALL AIRGSD( SRX(7),PVAX,RHOGAX )
!                CALL WATGSH( SRX(7),PSWX,RHOGWX,HGWX,UGWX )
!                CALL AIRGSH( SRX(7),PVAX,HGAX,UGAX )
!                NX = ICM(2,N)
!                GB = (YP(N)-YP(NX))*RP(I)*GRAVY
!                RHOGX = RHOGWX+RHOGAX
!                PGWX = PGWX - RHOGX*GB
!              ENDIF
!            ENDIF
!            IF( (PERM(1,N)/EPSL).GT.EPSL ) THEN
!              IF( (PERM(3,N)/EPSL).GT.EPSL ) THEN
!                PERMX = SQRT( PERM(1,N)*PERM(3,N) )
!              ELSE
!                PERMX = PERM(1,N)
!              ENDIF
!            ELSE
!              PERMX = PERM(3,N)
!            ENDIF
!!
!!---        If permeability is too low, skip
!!
!            IF ( PERMX.GT.SRX(6) ) THEN
!!
!!---          Injection  ---
!!
!              IF( PGWX-PG(M,N).GT.EPSL ) THEN
!                XGAX = RHOGAX/(RHOGAX+RHOGWX)
!                XGWX = RHOGWX/(RHOGAX+RHOGWX)
!                WTMGX = 1.D+0/(XGAX/WTMA + XGWX/WTMW)
!                XMGAX = XGAX*WTMGX/WTMA
!                XMGWX = XGWX*WTMGX/WTMW
!                CALL WATGSV( SRX(7),VISGWX )
!                CALL AIRGSV( SRX(7),VISGAX )
!                CALL GASVIS( XMGWX,ZERO,XMGAX,VISGWX,SMALL,VISGAX,
!     &            VISGX )
!                HCGX = 2.D+0*GPI*PERMX*DRD2*DYGF(N)/
!     &            (VISGX*((RDE**2)*LOG(RDE/RDW)-5.D-1*DRD2))
!                QGX = SRX(4)*(PGWX-PG(M,N))*HCGX
!                SRCT(M,N) = SRCT(M,N) + QGX*(RHOGWX*HGWX+RHOGAX
!     &            *HGAX)
!                SRCW(M,N) = SRCW(M,N) + QGX*RHOGWX
!                SRCA(M,N) = SRCA(M,N) + QGX*RHOGAX
!!
!!---          Withdrawl  ---
!!
!              ELSE
!                HCGX = 2.D+0*GPI*PERMX*DRD2*DYGF(N)/
!     &            (VISG(M,N)*((RDE**2)*LOG(RDE/RDW)-5.D-1*DRD2))
!                QGX = SRX(4)*(PGWX-PG(M,N))*RKG(M,N)*HCGX
!                HGX = XGW(M,N)*HGW(M,N) + XGA(M,N)*HGA(M,N)
!                SRCT(M,N) = SRCT(M,N) + QGX*RHOG(M,N)*HGX
!                SRCW(M,N) = SRCW(M,N) + QGX*RHOG(M,N)*XGW(M,N)
!                SRCA(M,N) = SRCA(M,N) + QGX*RHOG(M,N)*XGA(M,N)
!              ENDIF
!            ENDIF
          ENDIF
        ENDDO
      ENDDO
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of SORC_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE SP_GT( ASL_F,ASL_M,ASLX,ASLMINX,ESLX,ESGTX,ESGTMX,
     &  PGX,PLX,BTGLX,SGX,SGTX,SLX,SLFX,SLMX,SLRX,INDX,N )
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Aqueous and gas saturations.
!
!     INDX = 0 : Trapped-gas saturation computed.
!     INDX = 1 : Trapped-gas saturation given.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 2 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE GRID
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/SP_GT'
!
!---  van Genuchten saturation function w/o gas entrapment,
!     w/ or w/o Webb extension  ---
!
      IF( ISCHR(N).EQ.1 ) THEN
!
!---    van Genuchten saturation function w/o gas entrapment,
!       w/ Webb extension ASL = SL  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          HMPX = SCHR(9,N)
          SLRX = SCHR(4,N)
!
!---      Capillary head above the matching point head,
!         use Webb extension  ---
!
          IF( HDGL.GT.HMPX ) THEN
            SMPX = SCHR(8,N)
            HDGL = MIN( HDGL,SCHR(12,N) )
            DMPX = SMPX/(LOG10(SCHR(12,N))-LOG10(HMPX))
            SLX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPX
            ASLX = SLX
!
!---      Capillary head at or below the matching point head,
!         use van Genuchten function
!
          ELSE
            CN = MAX( SCHR(3,N),SMALL )
            IF( SCHR(14,N).LE.ZERO ) THEN
              IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                CM = 1.D+0 - 2.D+0/CN
              ELSE
                CM = 1.D+0 - 1.D+0/CN
              ENDIF
            ELSE
              CM = SCHR(14,N)
            ENDIF
            ASLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGL)**CN))**CM
            SLX = ASLX*(1.D+0-SLRX) + SLRX
            ASLX = SLX
          ENDIF
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          ESGTX = 0.D+0
          SGTX = 0.D+0
!
!---    van Genuchten saturation function w/o gas entrapment,
!       w/o Webb extension ASL = ESL  ------
!
        ELSE
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          CN = MAX( SCHR(3,N),SMALL )
          IF( SCHR(14,N).LE.ZERO ) THEN
            IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
              CM = 1.D+0 - 2.D+0/CN
            ELSE
              CM = 1.D+0 - 1.D+0/CN
            ENDIF
          ELSE
            CM = SCHR(14,N)
          ENDIF
          ASLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGL)**CN))**CM
          SLRX = SCHR(4,N)
          SLX = ASLX*(1.D+0-SLRX) + SLRX
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          ESGTX = 0.D+0
          SGTX = 0.D+0
        ENDIF
!
!---  Brooks and Corey saturation function w/o gas entrapment,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.2 ) THEN
!
!---    Brooks and Corey saturation function w/o gas entrapment,
!       w/ Webb extension ASL = SL + SGT  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          HMPX = SCHR(9,N)
          SLRX = SCHR(4,N)
!
!---      Capillary head above the matching point head,
!         use Webb extension  ---
!
          IF( HDGL.GT.HMPX ) THEN
            SMPX = SCHR(8,N)
            HDGL = MIN( HDGL,SCHR(12,N) )
            DMPX = SMPX/(LOG10(SCHR(12,N))-LOG10(HMPX))
            SLX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPX
            ASLX = SLX
!
!---      Capillary head at or below the matching point head,
!         use Brooks-Corey function
!
          ELSE
            CL = MAX( SCHR(3,N),SMALL )
            IF( HDGL.LE.SCHR(1,N) ) THEN
              ASLX = 1.D+0
            ELSE
              ASLX = (SCHR(1,N)/HDGL)**CL
            ENDIF
            SLRX = SCHR(4,N)
            SLX = ASLX*(1.D+0-SLRX) + SLRX
            ASLX = SLX
          ENDIF
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          ESGTX = 0.D+0
          SGTX = 0.D+0
!
!---    Brooks and Corey saturation function w/o gas entrapment,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          CL = MAX( SCHR(3,N),SMALL )
          IF( HDGL.LE.SCHR(1,N) ) THEN
            ASLX = 1.D+0
          ELSE
            ASLX = (SCHR(1,N)/HDGL)**CL
          ENDIF
          SLRX = SCHR(4,N)
          SGRX = SCHR(15,N)
          SLX = ASLX*(1.D+0-SLRX-SGRX) + SLRX
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          ESGTX = 0.D+0
          SGTX = 0.D+0
        ENDIF
!
!---  Dual porosity van Genuchten saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.3 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        CN = MAX( SCHR(3,N),SMALL )
        IF( SCHR(14,N).LE.ZERO ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CM = 1.D+0 - 2.D+0/CN
          ELSE
            CM = 1.D+0 - 1.D+0/CN
          ENDIF
        ELSE
          CM = SCHR(14,N)
        ENDIF
        ASL_M = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGL)**CN))**CM
        REALX = REAL(ISM(N))
        HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
        SLR_M = MAX( (1.D+0-HSCL)*SCHR(4,N),ZERO )
        SLMX = ASL_M*(1.D+0-SLR_M) + SLR_M
        CN = MAX( SCHR(6,N),SMALL )
        IF( SCHR(15,N).LE.EPSL ) THEN
          IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
            CM = 1.D+0 - 2.D+0/CN
          ELSE
            CM = 1.D+0 - 1.D+0/CN
          ENDIF
        ELSE
          CM = SCHR(15,N)
        ENDIF
        ASL_F = (1.D+0/(1.D+0 + (SCHR(5,N)*HDGL)**CN))**CM
        HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
        SLR_F = MAX( (1.D+0-HSCL)*SCHR(7,N),ZERO )
        SLFX = ASL_F*(1.D+0-SLR_F) + SLR_F
        PORD_MX = (1.D+0-POR(4,N))*POR0(2,N)/
     &    ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
        PORD_FX = POR(4,N)/
     &    ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
        SLX = SLFX*PORD_FX + SLMX*PORD_MX
        SGX = 1.D+0-SLX
        IF( SGX.LT.EPSL ) SGX = 0.D+0
        ASLX = ASL_F*PORD_FX + ASL_M*PORD_MX
        ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        ESGTX = 0.D+0
        SGTX = 0.D+0
!
!---  Dual porosity Brooks and Corey saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.4 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        CL = MAX( SCHR(3,N),SMALL )
        IF( HDGL.LE.SCHR(1,N) ) THEN
          ASL_M = 1.D+0
        ELSE
          ASL_M = (SCHR(1,N)/HDGL)**CL
        ENDIF
        REALX = REAL(ISM(N))
        HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
        SLR_M = MAX( (1.D+0-HSCL)*SCHR(4,N),ZERO )
        SLMX = ASL_M*(1.D+0-SLR_M) + SLR_M
        CL = MAX( SCHR(6,N),SMALL )
        IF( HDGL.LE.SCHR(5,N) ) THEN
          ASL_F = 1.D+0
        ELSE
          ASL_F = (SCHR(5,N)/HDGL)**CL
        ENDIF
        HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
        SLR_F = MAX( (1.D+0-HSCL)*SCHR(7,N),ZERO )
        SLFX = ASL_F*(1.D+0-SLR_F) + SLR_F
        PORD_MX = (1.D+0-POR(4,N))*POR0(2,N)/
     &    ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
        PORD_FX = POR(4,N)/
     &    ( POR(4,N) + (1.D+0-POR(4,N))*POR0(2,N) + SMALL )
        SLX = SLFX*PORD_FX + SLMX*PORD_MX
        SGX = 1.D+0-SLX
        IF( SGX.LT.EPSL ) SGX = 0.D+0
        ASLX = ASL_F*PORD_FX + ASL_M*PORD_MX
        ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        ESGTX = 0.D+0
        SGTX = 0.D+0
!
!---  Haverkamp saturation function  ---
!
      ELSEIF( ISCHR(N).EQ.5 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        IF( HDGL.LE.SCHR(1,N) ) THEN
          ASLX = 1.D+0
        ELSE
          ASLX = SCHR(2,N)/(SCHR(2,N)
     &      + (((HDGL-SCHR(1,N))/SCHR(5,N))**SCHR(3,N)))
        ENDIF
        REALX = REAL(ISM(N))
        HSCL = MAX( LOG(HDGL)/LOG(SCHR(12,N)),ZERO )*REALX
        SLRX = MAX( (1.D+0-HSCL)*SCHR(4,N),ZERO )
        SLX = ASLX*(1.D+0-SLRX) + SLRX
        SGX = 1.D+0-SLX
        IF( SGX.LT.EPSL ) SGX = 0.D+0
        ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        ESGTX = 0.D+0
        SGTX = 0.D+0
!
!---  Linear or linear-log interpolation function  ---
!
      ELSEIF( ISCHR(N).EQ.10 .OR. ISCHR(N).EQ.11 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        IF( ISCHR(N).EQ.11 ) HDGL = LOG(HDGL)
        ITBX = 0
        ASLX = FNTBLY( HDGL,ISLTBL(1,N),ISLTBL(2,N),ITBX )
        SLX = ASLX
        SGX = 1.D+0-SLX
        IF( SGX.LT.EPSL ) SGX = 0.D+0
        ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
        ESGTX = 0.D+0
        SGTX = 0.D+0
!
!---  Drainage-imbibition linear or linear-log
!     interpolation function  ---
!
      ELSEIF( ISCHR(N).EQ.12 .OR. ISCHR(N).EQ.13 ) THEN
        HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
        IF( ISCHR(N).EQ.13 ) HDGL = LOG(HDGL)
        ITBX = 0
        SLDX = FNTBLY( HDGL,ISLTBL(1,N),ISLTBL(2,N),ITBX )
        ITBX = 0
        SLIX = FNTBLY( HDGL,ISLTBL(3,N),ISLTBL(4,N),ITBX )
        ASLM = MAX( MIN( SLDX,ASLMINX ),0.D+0 )
        IF( SLDX.GE.SLIX ) THEN
          ASLX = 5.D-1*(SLIX + SQRT((SLIX**2) + 4.D+0*ASLM*SLDX -
     &      4.D+0*SLIX*ASLM))
        ELSE
          ASLX = 5.D-1*(SLIX - SQRT((SLIX**2) + 4.D+0*ASLM*SLDX -
     &      4.D+0*SLIX*ASLM))
        ENDIF
!
!---    Compute trapped gas saturation, using the minimum
!       apparent aqueous saturation and the drainage saturation  ---
!
        IF( INDX.EQ.0 ) THEN
          ESGTX = SLDX-ASLX
          IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
          SGTX = ESGTX*(1.D+0-SLRX)
!
!---    Trapped-gas saturation given, compute the minimum
!       apparent aqueous saturation  ---
!
        ELSEIF( INDX.EQ.1 ) THEN
          IF( (SLDX-SLIX-ESGTX).GT.0.D+0 ) THEN
            ASLM = (SLDX-SLIX-ESGTX)*(ASLX/(SLDX-SLIX))
            ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
          ELSE
            ALSMINX = 0.D+0
          ENDIF
        ENDIF
        SLX = ASLX
        SGX = 1.D+0-SLX
        IF( SGX.LT.EPSL ) SGX = 0.D+0
        ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
!
!---  van Genuchten saturation function w/ gas entrapment,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.101 ) THEN
!
!---    van Genuchten saturation function w/ gas entrapment,
!       w/ Webb extension ASL = SL + SGT  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          HMPX = SCHR(9,N)
          SLRX = SCHR(4,N)
!
!---      Capillary head above the matching point head,
!         use Webb extension  ---
!
          IF( HDGL.GT.HMPX ) THEN
            SMPX = SCHR(8,N)
            HDGL = MIN( HDGL,SCHR(12,N) )
            DMPX = SMPX/(LOG10(SCHR(12,N))-LOG10(HMPX))
            SLX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPX
            ASLX = SLX
!
!---      Capillary head at or below the matching point head,
!         use van Genuchten function
!
          ELSE
            CN = MAX( SCHR(3,N),SMALL )
            IF( SCHR(14,N).LE.ZERO ) THEN
              IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                CM = 1.D+0 - 2.D+0/CN
              ELSE
                CM = 1.D+0 - 1.D+0/CN
              ENDIF
            ELSE
              CM = SCHR(14,N)
            ENDIF
            ASLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGL)**CN))**CM
            SLX = ASLX*(1.D+0-SLRX) + SLRX
            ASLX = SLX
          ENDIF
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              SGTMX = ESGTMX
              R = 1.D+0/SGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX
              SGTMX = ESGTMX
              ASLM = (SGTMX - SGTX)/(SGTMX + SGTMX*SGTX - SGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          SLX = ASLX - ESGTX
          SGTX = ESGTX
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
!
!---    van Genuchten saturation function w/ gas entrapment,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          CN = MAX( SCHR(3,N),SMALL )
          IF( SCHR(14,N).LE.ZERO ) THEN
            IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
              CM = 1.D+0 - 2.D+0/CN
            ELSE
              CM = 1.D+0 - 1.D+0/CN
            ENDIF
          ELSE
            CM = SCHR(14,N)
          ENDIF
          ASLX = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGL)**CN))**CM
          SLRX = SCHR(4,N)
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              R = 1.D+0/ESGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX/(1.D+0-SLRX)
              ASLM = (ESGTMX - ESGTX)/(ESGTMX + ESGTMX*ESGTX - ESGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          ESLX = ASLX - ESGTX
          SLX = ESLX*(1.D+0-SLRX) + SLRX
          SGTX = ESGTX*(1.D+0-SLRX)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
        ENDIF
!
!---  Brooks and Corey saturation function w/ gas entrapment,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.102 ) THEN
!
!---    Brooks and Corey saturation function w/ gas entrapment,
!       w/ Webb extension ASL = SL + SGT  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          HMPX = SCHR(9,N)
          SLRX = SCHR(4,N)
!
!---      Capillary head above the matching point head,
!         use Webb extension  ---
!
          IF( HDGL.GT.HMPX ) THEN
            SMPX = SCHR(8,N)
            HDGL = MIN( HDGL,SCHR(12,N) )
            DMPX = SMPX/(LOG10(SCHR(12,N))-LOG10(HMPX))
            SLX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPX
            ASLX = SLX
!
!---      Capillary head at or below the matching point head,
!         use van Genuchten function
!
          ELSE
            CL = MAX( SCHR(3,N),SMALL )
            IF( HDGL.LE.SCHR(1,N) ) THEN
              ASLX = 1.D+0
            ELSE
              ASLX = (SCHR(1,N)/HDGL)**CL
            ENDIF
            SLRX = SCHR(4,N)
            SLX = ASLX*(1.D+0-SLRX) + SLRX
            ASLX = SLX
          ENDIF
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              SGTMX = ESGTMX
              R = 1.D+0/SGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX
              SGTMX = ESGTMX
              ASLM = (SGTMX - SGTX)/(SGTMX + SGTMX*SGTX - SGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          SLX = ASLX - ESGTX
          SGTX = ESGTX
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
!
!---    Brooks and Corey saturation function w/ gas entrapment,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          CL = MAX( SCHR(3,N),SMALL )
          IF( HDGL.LE.SCHR(1,N) ) THEN
            ASLX = 1.D+0
          ELSE
            ASLX = (SCHR(1,N)/HDGL)**CL
          ENDIF
          SLRX = SCHR(4,N)
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              R = 1.D+0/ESGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX/(1.D+0-SLRX)
              ASLM = (ESGTMX - ESGTX)/(ESGTMX + ESGTMX*ESGTX - ESGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          ESLX = ASLX - ESGTX
          SLX = ESLX*(1.D+0-SLRX) + SLRX
          SGTX = ESGTX*(1.D+0-SLRX)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
        ENDIF
!
!---  van Genuchten drainage-imbibition saturation function,
!     w/ or w/o extensions---
!
      ELSEIF( ISCHR(N).EQ.201 ) THEN
!
!---    van Genuchten saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          HMPDX = SCHR(9,N)
          HMPIX = SCHR(11,N)
          SLRX = SCHR(4,N)
          HDGL = MIN( HDGL,SCHR(12,N) )
!
!---      Capillary head above the drainage matching point head,
!         use Webb extension  ---
!
          IF( HDGL.GT.HMPDX ) THEN
              SMPDX = SCHR(8,N)
              DMPDX = SMPDX/(LOG10(SCHR(12,N))-LOG10(HMPDX))
              SLDX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPDX
              ASLDX = SLDX
              ASLMX = MAX( MIN( ASLDX,ASLMINX ),0.D+0 )
!
!---        Capillary head above the imbibition matching point head,
!           use Webb extension  ---
!
            IF( HDGL.GT.HMPIX ) THEN
              SMPIX = SCHR(10,N)
              DMPIX = SMPIX/(LOG10(SCHR(12,N))-LOG10(HMPIX))
              SLIX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPIX
              ASLIX = SLIX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
!
!---        Capillary head at or below the imbibition matching
!           point head, use van Genuchten function
!
            ELSE
              CNI = MAX( SCHR(5,N),SMALL )
              IF( SCHR(13,N).LE.ZERO ) THEN
                IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                  CMI = 1.D+0 - 2.D+0/CNI
                ELSE
                  CMI = 1.D+0 - 1.D+0/CNI
                ENDIF
              ELSE
                CMI = SCHR(13,N)
              ENDIF
              ASLIX = (1.D+0/(1.D+0 + (SCHR(2,N)*HDGL)**CNI))**CMI
              ASLIX = ASLIX*(1.D+0-SLRX) + SLRX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
            ENDIF
!
!---      Capillary head at or below the drainage matching point head,
!         use van Genuchten function
!
          ELSE
            CND = MAX( SCHR(3,N),SMALL )
            IF( SCHR(14,N).LE.ZERO ) THEN
              IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                CMD = 1.D+0 - 2.D+0/CND
              ELSE
                CMD = 1.D+0 - 1.D+0/CND
              ENDIF
            ELSE
              CMD = SCHR(14,N)
            ENDIF
            ASLDX = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGL)**CND))**CMD
            ASLDX = ASLDX*(1.D+0-SLRX) + SLRX
            ASLMX = MAX( MIN( ASLDX,ASLMINX ),0.D+0 )
!
!---        Capillary head above the imbibition matching point head,
!           use Webb extension  ---
!
            IF( HDGL.GT.HMPIX ) THEN
              SMPIX = SCHR(10,N)
              DMPIX = SMPIX/(LOG10(SCHR(12,N))-LOG10(HMPIX))
              SLIX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPIX
              ASLIX = SLIX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
            ELSE
              CNI = MAX( SCHR(5,N),SMALL )
              IF( SCHR(13,N).LE.ZERO ) THEN
                IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
                  CMI = 1.D+0 - 2.D+0/CNI
                ELSE
                  CMI = 1.D+0 - 1.D+0/CNI
                ENDIF
              ELSE
                CMI = SCHR(13,N)
              ENDIF
              ASLIX = (1.D+0/(1.D+0 + (SCHR(2,N)*HDGL)**CNI))**CMI
              ASLIX = ASLIX*(1.D+0-SLRX) + SLRX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
            ENDIF
          ENDIF
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              SGTMX = ESGTMX
              R = 1.D+0/SGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX
              SGTMX = ESGTMX
              ASLM = (SGTMX - SGTX)/(SGTMX + SGTMX*SGTX - SGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          SLX = ASLX - ESGTX
          SGTX = ESGTX
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
!
!---    van Genuchten saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          CND = MAX( SCHR(3,N),SMALL )
          IF( SCHR(14,N).LE.ZERO ) THEN
            IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
              CMD = 1.D+0 - 2.D+0/CND
            ELSE
              CMD = 1.D+0 - 1.D+0/CND
            ENDIF
          ELSE
            CMD = SCHR(14,N)
          ENDIF
          ASLDX = (1.D+0/(1.D+0 + (SCHR(1,N)*HDGL)**CND))**CMD
          CNI = MAX( SCHR(5,N),SMALL )
          IF( SCHR(13,N).LE.ZERO ) THEN
            IF( MOD( IRPL(N),100 ).EQ.2 ) THEN
              CMI = 1.D+0 - 2.D+0/CNI
            ELSE
              CMI = 1.D+0 - 1.D+0/CNI
            ENDIF
          ELSE
            CMI = SCHR(13,N)
          ENDIF
          ASLIX = (1.D+0/(1.D+0 + (SCHR(2,N)*HDGL)**CNI))**CMI
          ASLMX = MAX( MIN( ASLDX,ASLMINX ),0.D+0 )
          IF( ASLDX.GE.ASLIX ) THEN
            ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &         + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
          ELSE
            ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &         + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
          ENDIF
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              R = 1.D+0/ESGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX/(1.D+0-SLRX)
              ASLM = (ESGTMX - ESGTX)/(ESGTMX + ESGTMX*ESGTX - ESGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          ESLX = ASLX - ESGTX
          SLX = ESLX*(1.D+0-SLRX) + SLRX
          SGTX = ESGTX*(1.D+0-SLRX)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
        ENDIF
!
!---  Brooks and Corey drainage-imbibition saturation function,
!     w/ or w/o Webb extension  ---
!
      ELSEIF( ISCHR(N).EQ.202 ) THEN
!
!---    Brooks and Corey drainage-imbibition saturation function,
!       w/ Webb extension ASL = SL + SGT  ---
!
        IF( ISM(N).EQ.2 ) THEN
          HDGL = MAX( BTGLX*(PGX-PLX)/RHORL/GRAV,1.D-14 )
          HMPDX = SCHR(9,N)
          HMPIX = SCHR(11,N)
          SLRX = SCHR(4,N)
          HDGL = MIN( HDGL,SCHR(12,N) )
!
!---      Capillary head above the drainage matching point head,
!         use Webb extension  ---
!
          IF( HDGL.GT.HMPDX ) THEN
            SMPDX = SCHR(8,N)
            DMPDX = SMPDX/(LOG10(SCHR(12,N))-LOG10(HMPDX))
            SLDX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPDX
            ASLDX = SLDX
            ASLMX = MAX( MIN( ASLDX,ASLMINX ),0.D+0 )
!
!---        Capillary head above the imbibition matching point head,
!           use Webb extension  ---
!
            IF( HDGL.GT.HMPIX ) THEN
              SMPIX = SCHR(10,N)
              DMPIX = SMPIX/(LOG10(SCHR(12,N))-LOG10(HMPIX))
              SLIX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPIX
              ASLIX = SLIX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
!
!---        Capillary head at or below the imbibition matching
!           point head, use Brooks and Corey function
!
            ELSE
              CLI = MAX( SCHR(6,N),SMALL )
              IF( HDGL.LE.SCHR(5,N) ) THEN
                ASLIX = 1.D+0
              ELSE
                ASLIX = (SCHR(5,N)/HDGL)**CLI
              ENDIF
              ASLIX = ASLIX*(1.D+0-SLRX) + SLRX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
            ENDIF
!
!---      Capillary head at or below the drainage matching point head,
!         use Brooks and Corey function
!
          ELSE
            CLD = MAX( SCHR(3,N),SMALL )
            IF( HDGL.LE.SCHR(1,N) ) THEN
              ASLDX = 1.D+0
            ELSE
              ASLDX = (SCHR(1,N)/HDGL)**CLD
            ENDIF
            ASLDX = ASLDX*(1.D+0-SLRX) + SLRX
            ASLMX = MAX( MIN( ASLDX,ASLMINX ),0.D+0 )
!
!---        Capillary head above the imbibition matching point head,
!           use Webb extension  ---
!
            IF( HDGL.GT.HMPIX ) THEN
              SMPIX = SCHR(10,N)
              DMPIX = SMPIX/(LOG10(SCHR(12,N))-LOG10(HMPIX))
              SLIX = -(LOG10(HDGL)-LOG10(SCHR(12,N)))*DMPIX
              ASLIX = SLIX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
!
!---        Capillary head at or below the imbibition matching
!           point head, use Brooks and Corey function
!
            ELSE
              CLI = MAX( SCHR(6,N),SMALL )
              IF( HDGL.LE.SCHR(5,N) ) THEN
                ASLIX = 1.D+0
              ELSE
                ASLIX = (SCHR(5,N)/HDGL)**CLI
              ENDIF
              ASLIX = ASLIX*(1.D+0-SLRX) + SLRX
              IF( ASLDX.GE.ASLIX ) THEN
                ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ELSE
                ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
              ENDIF
            ENDIF
          ENDIF
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              SGTMX = ESGTMX
              R = 1.D+0/SGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX
              SGTMX = ESGTMX
              ASLM = (SGTMX - SGTX)/(SGTMX + SGTMX*SGTX - SGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          SLX = ASLX - ESGTX
          SGTX = ESGTX
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
!
!---    Brooks and Corey drainage-imbibition saturation function,
!       w/o Webb extension ASL = ESL + ESGT  ---
!
        ELSE
          CLD = MAX( SCHR(3,N),SMALL )
          IF( HDGL.LE.SCHR(1,N) ) THEN
            ASLDX = 1.D+0
          ELSE
            ASLDX = (SCHR(1,N)/HDGL)**CLD
          ENDIF
          CLI = MAX( SCHR(6,N),SMALL )
          IF( HDGL.LE.SCHR(5,N) ) THEN
            ASLIX = 1.D+0
          ELSE
            ASLIX = (SCHR(5,N)/HDGL)**CLI
          ENDIF
          ASLMX = MAX( MIN( ASLDX,ASLMINX ),0.D+0 )
          IF( ASLDX.GE.ASLIX ) THEN
            ASLX = 5.D-1*(ASLIX + SQRT((ASLIX**2)
     &         + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
          ELSE
            ASLX = 5.D-1*(ASLIX - SQRT((ASLIX**2)
     &             + 4.D+0*ASLMX*ASLDX - 4.D+0*ASLIX*ASLMX))
          ENDIF
!
!---      Compute trapped gas saturation, using the minimum
!         apparent aqueous saturation  ---
!
          IF( INDX.EQ.0 ) THEN
            ASLM = MAX( MIN( ASLX,ASLMINX ),0.D+0 )
            IF( ESGTMX.GT.EPSL .AND. ASLX.GT.ASLM ) THEN
              R = 1.D+0/ESGTMX - 1.D+0
              ESGTX = (1.D+0-ASLM)/(1.D+0 + R*(1.D+0-ASLM)) -
     &          (1.D+0-ASLX)/(1.D+0 + R*(1.D+0-ASLX))
              IF( ESGTX.LT.EPSL ) ESGTX = 0.D+0
            ELSE
              ESGTX = 0.D+0
            ENDIF
!
!---      Trapped-gas saturation given, compute the minimum
!         apparent aqueous saturation  ---
!
          ELSEIF( INDX.EQ.1 ) THEN
            IF( ESGTMX.GT.EPSL ) THEN
              ESGTX = SGX/(1.D+0-SLRX)
              ASLM = (ESGTMX - ESGTX)/(ESGTMX + ESGTMX*ESGTX - ESGTX)
              ASLMINX = MAX( MIN( ASLM,ASLX ),0.D+0 )
            ELSE
              ESGTX = 0.D+0
              ASLMINX = MAX( ASLX,0.D+0 )
            ENDIF
!
!---      Unrecognized option  ---
!
          ELSE
            PRINT *,'Unrecognized Trapped-Gas Option, ID = ',ID
            ICNV = 4
!
!---        Reset subroutine string sequence  ---
!
            ISUB_LOG = ISUB_LOG-1
            RETURN
          ENDIF
          ESLX = ASLX - ESGTX
          SLX = ESLX*(1.D+0-SLRX) + SLRX
          SGTX = ESGTX*(1.D+0-SLRX)
          ESLX = MIN( MAX( (SLX-SLRX)/(1.D+0-SLRX),0.D+0 ),1.D+0 )
          SGX = 1.D+0-SLX
          IF( SGX.LT.EPSL ) SGX = 0.D+0
        ENDIF
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of SP_GT group  ---
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Update the primary variables on field cells w/o ghost cells.
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 22 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE PROP
      USE OUTPU
      USE JACOB
      USE HYST
      USE GRID
      USE GEOM_FRC
      USE FILES
      USE FDVP_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      REAL*8, DIMENSION(14) :: VARZ
      REAL*8, DIMENSION(14) :: VARX
      INTEGER, DIMENSION(14) :: IVARX
      INTEGER	STATUS(MPI_STATUS_SIZE)	
      INTEGER	(KIND=MPI_OFFSET_KIND) OFFSET
      CHARACTER*64 PH_CND(5)
!
!----------------------Data Statements---------------------------------!
!
      SAVE PH_CND
      DATA PH_CND /'Saturated w/o Entrapped Gas',
     &   'Unsaturated w/ or w/o Entrapped Gas',
     &   'Saturated w/ Trapped Gas',
     &   'Fully Unsaturated',
     &   'Supercritical Water'/
!
!----------------------Executable Lines--------------------------------!
!
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_GT'
      OFFSET = IOFFSET_REF
      IF( ICNV.EQ.1 ) THEN
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ') - 1
          IF( ID.EQ.0 ) PRINT *,'Linear System Solver Failure: ' //
     &      'Time Step  Reduced from ',DTX*CNVTM,UNTM(1:NCH),' to ',
     &      DT*CNVTM,UNTM(1:NCH)
!
!---      Write a linear system solver failure index of -3 in the
!         NSTEP location plus time step reductions to output.bin  ---
!
          NVAR = 1
          IVARX(1) = -3
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
          NVAR = 2
          VARX(1) = DTX*CNVTM
          VARX(2) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            PVA(2,N) = PVA(1,N)
            XMLA(2,N) = XMLA(1,N)
            SL(2,N) = SL(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Fracture flow and transport solution  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) THEN
!
!---        Loop over fracture triangles (without ghost triangles)  ---
!
            DO NTX = 1,NFT(ID+1)
              T_FRC(2,NTX) = T_FRC(1,NTX)
              PL_FRC(2,NTX) = PL_FRC(1,NTX)
              PG_FRC(2,NTX) = PG_FRC(1,NTX)
              PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
              PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
              XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
              SL_FRC(2,NTX) = SL_FRC(1,NTX)
              SG_FRC(2,NTX) = SG_FRC(1,NTX)
              YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
              TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
              NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
            ENDDO
          ENDIF
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
!
!---      Reset principal variables to old time step values
!         on field and ghost cells  ---
!
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            PVA(2,N) = PVA(1,N)
            XMLA(2,N) = XMLA(1,N)
            SL(2,N) = SL(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Fracture flow and transport solution  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) THEN
!
!---        Loop over fracture triangles (without ghost triangles)  ---
!
            DO NTX = 1,NFT(ID+1)
              T_FRC(2,NTX) = T_FRC(1,NTX)
              PL_FRC(2,NTX) = PL_FRC(1,NTX)
              PG_FRC(2,NTX) = PG_FRC(1,NTX)
              PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
              PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
              XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
              SL_FRC(2,NTX) = SL_FRC(1,NTX)
              SG_FRC(2,NTX) = SG_FRC(1,NTX)
              YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
              TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
              NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
            ENDDO
          ENDIF
          IF( ID.EQ.0 )  PRINT *,'          ---  Time Step ' //
     &      'Reduction Limit Exceeded  ---'
          ICNV = 4
          IVARX(1) = -2
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
!
!---    Reset subroutine string sequence  ---
!
        ISUB_LOG = ISUB_LOG-1
        RETURN
      ENDIF
!
!---  Update primary variables on field cells  ---
!
      IERR = 0
      IERRL = NFLD + 1
      IERRG = NFLD + 1
      NMD = 0
      DO N = 1,NFCGC(ID+1)
#ifdef lis
!
!---    Skip for inactive nodes or ghost cells  ---
!
        IF( IXP(N).EQ.0 .OR. IGHC(N).EQ.1 ) CYCLE
#endif
#ifdef petsc
!
!---    Skip for inactive nodes  ---
!
        IF( IXP(N).EQ.0 ) CYCLE
#endif
        IF( IERRL.NE.(NFLD+1) ) CYCLE
        N_DB = ND(N)
        MPW = NMD + IEQW
        DPW = BLU(MPW)
!
!---    Isoair option  ---
!
        IF( ISLC(37).EQ.0 ) THEN
          MPA = NMD + IEQA
          DPA = BLU(MPA)
        ELSE
          DPA = 0.D+0
        ENDIF
!
!---    Isobrine option  ---
!
        IF( ISLC(32).EQ.0 ) THEN
          MPS = NMD + IEQS
          DPS = BLU(MPS)
        ELSE
          DPS = 0.D+0
        ENDIF
!
!---    Nonisothermal simulations  ---
!
        IF( ISLC(30).EQ.0 ) THEN
          MPT = NMD + IEQT
          DPT = BLU(MPT)
          DPX = 2.5D+0
          DPT = SIGN( MIN( DPX,ABS(DPT) ),DPT )
          T(2,N) = T(2,N) + DPT
        ENDIF
!
!---    Increment equation counter for next active node  ---
!
        NMD = NMD + ISVC
!
!---    Saturated system w/o entrapped gas
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas air partial pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        IF( NPHAZ(2,N).EQ.1 ) THEN
          INDX = 0
          CALL REGION_4( T(2,N),PSWX,INDX )
          DPX = 1.D+6
          DPW = SIGN( MIN( ABS(DPW),DPX ),DPW )
          PL(2,N) = PL(2,N) + DPW
!
!---      Zero negative corrections for zero aqueous air  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            PVA(2,N) = MAX( PVA(2,N)+DPA,0.D+0 )
            IF( PVA(2,N).LT.EPSL ) PVA(2,N) = 0.D+0
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Limit salt mass fraction changes to 0.25 of the
!           maximum value if salt mass fraction is less than
!           the maximum   ---
!
            PWX = MAX( PSWX,PL(2,N)+PATM )
            CALL SOL_BRNS( T(2,N),PWX,XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero aqueous salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. BLU(MPS)/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.EPSL ) YLS(2,N) = 0.D+0
            XLS(2,N) = MIN( YLS(2,N),XLSMX )
          ENDIF
!
!---    Unsaturated system w/ or w/o entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - gas pressure
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.2 ) THEN
          INDX = 0
          CALL REGION_4( T(2,N),PSWX,INDX )
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Limit salt mass fraction changes to 0.25 of the
!           maximum value if salt mass fraction is less than
!           the maximum   ---
!
            CALL SOL_BRNS( T(2,N),PSWX,XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero aqueous salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. BLU(MPS)/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.EPSL ) YLS(2,N) = 0.D+0
            XLS(2,N) = MIN( YLS(2,N),XLSMX )
          ENDIF
!
!---      Assign gas-entry pressure for non Brooks-Corey;
!         Brooks-Corey; Brooks-Corey, Dual Porosity; and
!         Brooks-Corey, Entrapment  ---
!
          IF( ISCHR(N).EQ.2 .OR. ISCHR(N).EQ.102 .OR.
     &        ISCHR(N).EQ.202 ) THEN
            ENPR = SCHR(1,N)*RHORL*GRAV
          ELSEIF( ISCHR(N).EQ.4 ) THEN
            ENPR = MIN( SCHR(1,N),SCHR(5,N) )*RHORL*GRAV
          ELSE
            ENPR = 0.D+0
          ENDIF
!
!---      Limit changes in pressure, and trap large changes in
!         gas pressure  ---
!
          DPX = MAX( 1.D+6,2.5D-1*(PG(2,N)-PL(2,N)) )
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          IF( ISLC(37).EQ.0 ) THEN
            DPA = SIGN( MIN(ABS(DPX),ABS(DPA)),DPA )
!
!---       Relax pressure updates when transitioning to unsaturated
!           conditions  ---
!
            IF( (PG(2,N)+DPA)-(PL(2,N)+DPW).LT.ENPR ) THEN
              DPA = 6.D-1*DPA
              DPW = 6.D-1*DPW
            ENDIF
            PG(2,N) = PG(2,N) + DPA
            PG(2,N) = MIN( PG(2,N),5.D+8 )
          ENDIF
          PL(2,N) = PL(2,N) + DPW
          PL(2,N) = MAX( PL(2,N),(PG(2,N)-SCHR(12,N)*RHORL*GRAV) )
!
!---      Maintain the gas pressure above or at the water vapor
!         pressure  ---
!
          CALL P_IAPWS( T(2,N),PSWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
          CALL DENS_B( XLS(2,N),RHOBX,RHOLWX,T(2,N) )
          CALL SP_B( T(2,N),XLS(2,N),PSBX )
          PGX = PG(2,N) + PATM
          PLX = PL(2,N) + PATM
          PCX = PGX - PLX
          CALL VPL_B( T(2,N),PSBX,PCX,RHOBX,PVBX )
          PG(2,N) = MAX( PG(2,N),(PVBX-PATM) )
!
!---    Saturated system w/ entrapped gas
!
!       Energy - temperature
!       Water mass - aqueous pressure
!       Air mass - trapped gas saturation
!       NaCl mass - total NaCl brine mass fraction  ---
!
        ELSEIF( NPHAZ(2,N).EQ.3 ) THEN
!
!---      Limit changes in pressure  ---
!
          DPX = 2.5D-1*MAX(PL(2,N)+PATM,1.D+6)
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          PL(2,N) = PL(2,N) + DPW
          PL(2,N) = MIN( PL(2,N),5.D+8 )
!
!---      Limit changes in trapped gas  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            DPX = 1.D-1*SCHR(15,N)
            DPA = SIGN( MIN(ABS(DPX),ABS(DPA)),DPA )
            SG(2,N) = SG(2,N) + DPA
            IF( SG(2,N).LT.EPSL ) SG(2,N) = 0.D+0
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Limit salt mass fraction changes to 0.25 of the
!           maximum value if salt mass fraction is less than
!           the maximum   ---
!
            INDX = 0
            CALL REGION_4( T(2,N),PWX,INDX )
            CALL P_IAPWS( T(2,N),PWX,RHOGWX,RHOLWX,HGWX,HLWX,UGWX,ULWX )
            CALL SOL_BRNS( T(2,N),PWX,XLSMX )
            IF( YLS(2,N).LT.XLSMX ) THEN
              DPS = SIGN( MIN( ABS(2.5D-1*XLSMX),ABS(DPS) ),DPS )
            ENDIF
!
!---        Zero negative corrections for zero aqueous salt  ---
!
            IF( YLS(2,N)/EPSL.LT.EPSL .AND. BLU(MPS)/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            YLS(2,N) = YLS(2,N)+DPS
            IF( YLS(2,N).LT.EPSL ) YLS(2,N) = 0.D+0
            XLS(2,N) = MIN( YLS(2,N),XLSMX )
          ENDIF
!
!---    Fully unsaturated conditions
!
!       Energy - temperature
!       Water mass - water vapor partial pressure
!       Air mass - gas pressure
!       NaCl mass - salt mass  ---
!
        ELSEIF( NPHAZ(2,N).EQ.4 ) THEN
!
!---      Limit changes in water vapor partial pressure  ---
!
          INDX = 0
          CALL REGION_4( T(2,N),PWX,INDX )
          PWX = MIN( PWX,PCRW )
          DPX = 2.5D-1*PWX
          DPW = SIGN( MIN(ABS(DPX),ABS(DPW)),DPW )
          PVW(2,N) = MAX( PVW(2,N)+DPW,1.D-6 )
!
!---      Limit changes in gas pressure  ---
!
          IF( ISLC(37).EQ.0 ) THEN
            DPX = 2.5D-1*MAX(PVA(2,N),1.D+6)
            DPA = SIGN( MIN(ABS(DPX),ABS(DPA)),DPA )
            PVA(2,N) = MAX( PVA(2,N)+DPA,0.D+0 )
            PG(2,N) = PVW(2,N) + PVA(2,N) - PATM
          ENDIF
!
!---      Isobrine option  ---
!
          IF( ISLC(32).EQ.0 ) THEN
!
!---        Zero negative corrections for salt volumetric conc.  ---
!
            IF( TMS(2,N)/EPSL.LT.EPSL .AND. BLU(MPS)/EPSL.LT.EPSL ) THEN
              BLU(MPS) = 0.D+0
              DPS = 0.D+0
            ENDIF
            TMS(2,N) = TMS(2,N) + DPS
            IF( TMS(2,N).LT.1.D-9 ) TMS(2,N) = 0.D+0
          ENDIF
        ENDIF
#ifdef petsc
!
!---    Skip checks for excessive pressure or temperature for
!       ghost cells   ---
!
        IF( IGHC(N).EQ.1 ) CYCLE
#endif
!
!---    Check for excessive pressure or temperature   ---
!
        PGX = PG(2,N)+PATM
        PLX = PL(2,N)+PATM
        TKX = T(2,N)+TABS
        IF( PGX.GT.100.D+6 .OR. PGX.LT.1.001D-6 ) IERR = 1
        IF( PLX.GT.100.D+6 ) IERR = 1
        IF( TKX.GT.1473.15D+0 .OR. TKX.LT.TABS ) IERR = 1
!
!---    Excess changes in primary variables, skip updates  ---
!
        IF( IERR.EQ.1 .AND. IERRL.EQ.(NFLD+1) ) THEN
          IERRL = ND(N)
          VARZ(1) = REAL( N )
          VARZ(2) = REAL( NPHAZ(2,N) )
          VARZ(3) = DPT
          VARZ(4) = DPW
          VARZ(5) = DPA
          VARZ(6) = DPS
          VARZ(7) = T(2,N)
          VARZ(8) = PL(2,N)+PATM
          VARZ(9) = PG(2,N)+PATM
          VARZ(10) = SG(2,N)
          VARZ(11) = XMLA(2,N)
          VARZ(12) = PVW(2,N)
          VARZ(13) = YLS(2,N)
          VARZ(14) = TMS(2,N)
        ENDIF
      ENDDO
!
!---  Identify minimum global node with errors  ---
!
      CALL MPI_ALLREDUCE( IERRL,IERRG,1,MPI_INTEGER,MPI_MIN,
     &  MPI_COMM_WORLD,IERR )
!
!---  Node identified with an excessive primary variable change  ---
!
      IF( IERRG.NE.(NFLD+1) ) THEN
        ICNV = 1
        ID2X = 0
!
!---    Identify processor with error  ---
!
        DO MP = 1,NP
          IF( IERRL.EQ.IERRG ) ID2X = ID
        ENDDO
        CALL MPI_ALLREDUCE( ID2X,IDX,1,MPI_INTEGER,MPI_MAX,
     &    MPI_COMM_WORLD,IERR )
!
!---    Send node state to P0  ---
!
        IF( ID.EQ.IDX ) THEN
          CALL MPI_SEND( VARZ,29,MPI_REAL8,0,18,MPI_COMM_WORLD,IERR )
        ENDIF
        IF( ID.EQ.0 ) THEN
          CALL MPI_RECV( VARZ,14,MPI_REAL8,IDX,18,MPI_COMM_WORLD,
     &      STATUS,IERR )
          N = INT(VARZ(1))
          NPHZX = MOD(INT(VARZ(2)),100)
          PRINT *,'---  Excessive Primary Variable Change  ---'
          PRINT *,'  Node = ',ND(N)
          PRINT *,'  Phase Condition = ',PH_CND(NPHZX)
          IF( ISLC(30).EQ.0 ) THEN
            PRINT *,'  DPT = ',VARZ(3)
          ENDIF
          PRINT *,'  DPW = ',VARZ(4)
          PRINT *,'  DPA = ',VARZ(5)
          IF( ISLC(32).EQ.0 ) THEN
            PRINT *,'  DPS = ',VARZ(6)
          ENDIF
          PRINT *,'  Temperature, C = ',VARZ(7)
          PRINT *,'  Aqueous Pressure, Pa = ',VARZ(8)
          PRINT *,'  Gas Pressure, Pa = ',VARZ(9)
          PRINT *,'  Gas Saturation = ',VARZ(10)
          PRINT *,'  Aqueous-Air Mass Fraction = ',VARZ(11)
          PRINT *,'  Water Vapor Pressure = ',VARZ(12)
          PRINT *,'  Total-Salt Aqu. Mass Fraction = ',VARZ(13)
          PRINT *,'  Salt Volumetric Concentration = ',VARZ(14)
        ENDIF
!
!---    Reduce time step  ---
!
        IF( NTSR.LT.4 .OR. (DTCF*DT).GT.DTMN ) THEN
          NTSR = NTSR + 1
          DTX = DT
          TM = TM - (1.D+0-DTCF)*DT
          DT = DTCF*DT
          DTO = DT
          DTI = 1.D+0/DT
          NCH = INDEX( UNTM(1:),'  ' ) - 1
          IF( ID.EQ.0 ) PRINT *,'  Time Step Reduced From ',
     &      DTX*CNVTM,UNTM(1:NCH),' to ',DT*CNVTM,UNTM(1:NCH)
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            PVA(2,N) = PVA(1,N)
            XMLA(2,N) = XMLA(1,N)
            SL(2,N) = SL(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Fracture flow and transport solution  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) THEN
!
!---        Loop over fracture triangles (without ghost triangles)  ---
!
            DO NTX = 1,NFT(ID+1)
              T_FRC(2,NTX) = T_FRC(1,NTX)
              PL_FRC(2,NTX) = PL_FRC(1,NTX)
              PG_FRC(2,NTX) = PG_FRC(1,NTX)
              PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
              PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
              XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
              SL_FRC(2,NTX) = SL_FRC(1,NTX)
              SG_FRC(2,NTX) = SG_FRC(1,NTX)
              YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
              TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
              NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
            ENDDO
          ENDIF
!
!---      Write a excessive primary variable index in the NSTEP location
!         plus write the global node numbers and phase condition indices
!         for the location of maximum residuals for the water, air,
!         and salt equations to output.bin  ---
!
          NVAR = 3
          IVARX(1) = -4
          IVARX(2) = ND(IERRG)
          IVARX(3) = NPHZX
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
!
!---      Write maximum residuals for the water, air, and salt
!         equations and time step reductions to output.bin  ---
!
          NVAR = 10
          VARX(1) = VARZ(7)
          VARX(2) = VARZ(8)
          VARX(3) = VARZ(9)
          VARX(4) = VARZ(10)
          VARX(5) = VARZ(11)
          VARX(6) = VARZ(12)
          VARX(7) = VARZ(13)
          VARX(8) = VARZ(14)
          VARX(9) = DTX*CNVTM
          VARX(10) = DT*CNVTM
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,VARX,NVAR,
     &      MPI_REAL8,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTR
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTR
!
!---    Number of time step reductions failure: stop simulation  ---
!
        ELSE
          DO N = 1,NFCGC(ID+1)
            T(2,N) = T(1,N)
            PL(2,N) = PL(1,N)
            PG(2,N) = PG(1,N)
            PVW(2,N) = PVW(1,N)
            PVA(2,N) = PVA(1,N)
            XMLA(2,N) = XMLA(1,N)
            SL(2,N) = SL(1,N)
            SG(2,N) = SG(1,N)
            SGT(2,N) = SGT(1,N)
            ASLMIN(2,N) = ASLMIN(1,N)
            YLS(2,N) = YLS(1,N)
            TMS(2,N) = TMS(1,N)
            NPHAZ(2,N) = NPHAZ(1,N)
          ENDDO
!
!---      Fracture flow and transport solution  ---
!
          IF( ISLC(74).EQ.1 .OR. ISLC(74).EQ.3 ) THEN
!
!---        Loop over fracture triangles (without ghost triangles)  ---
!
            DO NTX = 1,NFT(ID+1)
              T_FRC(2,NTX) = T_FRC(1,NTX)
              PL_FRC(2,NTX) = PL_FRC(1,NTX)
              PG_FRC(2,NTX) = PG_FRC(1,NTX)
              PVW_FRC(2,NTX) = PVW_FRC(1,NTX)
              PVA_FRC(2,NTX) = PVA_FRC(1,NTX)
              XMLA_FRC(2,NTX) = XMLA_FRC(1,NTX)
              SL_FRC(2,NTX) = SL_FRC(1,NTX)
              SG_FRC(2,NTX) = SG_FRC(1,NTX)
              YLS_FRC(2,NTX) = YLS_FRC(1,NTX)
              TMS_FRC(2,NTX) = TMS_FRC(1,NTX)
              NPHAZ_FRC(2,NTX) = NPHAZ_FRC(1,NTX)
            ENDDO
          ENDIF
          IF( ID.EQ.0 ) PRINT *,'          ---  Time Step Reduction ' //
     &        'Limit Exceeded  ---'
          ICNV = 4
!
!---      Write a time-step reduction limit exceeded index in the
!         NSTEP location to output.bin.  ---
!
          IVARX(1) = -2
          NVAR = 1
          IF( ID.EQ.0 ) CALL MPI_FILE_WRITE_AT( IWR,OFFSET,IVARX,NVAR,
     &      MPI_INTEGER,STATUS,IERR)
          OFFSET = OFFSET + NVAR*NBYTI
          IOFFSET_REF = IOFFSET_REF + NVAR*NBYTI
        ENDIF
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_GT group
!
      RETURN
      END

!----------------------Subroutine--------------------------------------!
!
      SUBROUTINE UPDT_GC_GT
!
!-------------------------Disclaimer-----------------------------------!
!
!     This material was prepared as an account of work sponsored by
!     an agency of the United States Government. Neither the
!     United States Government nor the United States Department of
!     Energy, nor Battelle, nor any of their employees, makes any
!     warranty, express or implied, or assumes any legal liability or
!     responsibility for the accuracy, completeness, or usefulness
!     of any information, apparatus, product, software or process
!     disclosed, or represents that its use would not infringe
!     privately owned rights.
!
!----------------------Acknowledgement---------------------------------!
!
!     This software and its documentation were produced with Government
!     support under Contract Number DE-AC06-76RLO-1830 awarded by the
!     United Department of Energy. The Government retains a paid-up
!     non-exclusive, irrevocable worldwide license to reproduce,
!     prepare derivative works, perform publicly and display publicly
!     by or for the Government, including the right to distribute to
!     other Government contractors.
!
!---------------------Copyright Notices--------------------------------!
!
!            Copyright Battelle Memorial Institute, 1996
!                    All Rights Reserved.
!
!----------------------Description-------------------------------------!
!
!     Geothermal Mode (STOMPX-GT)
!
!     Update the primary variables on ghost cells
!
!----------------------Authors-----------------------------------------!
!
!     Written by M.D. White, PNNL, 22 June, 2022
!
!----------------------Fortran 90 Modules------------------------------!
!
      USE MPI
      USE GLB_PAR
      USE SOLTN
      USE OUTPU
      USE JACOB
      USE HYST
      USE GRID
      USE GEOM_FRC
      USE FDVP
      USE CONST
!
!----------------------Implicit Double Precision-----------------------!
!
      IMPLICIT REAL*8 (A-H,O-Z)
      IMPLICIT INTEGER (I-N)
!
!----------------------Type Declarations-------------------------------!
!
      INTEGER	STATUS(MPI_STATUS_SIZE)	
!
!----------------------Executable Lines--------------------------------!
!
      IF( ICNV.EQ.1 .OR. ICNV.EQ.4 ) RETURN
      ISUB_LOG = ISUB_LOG+1
      SUB_LOG(ISUB_LOG) = '/UPDT_GC_GT'
      NPVX = 12
!
!---  Load sending buffer for bottom ghost cells for processors
!     with bottom ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
        MCS = 0
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(1,ID+1)
          SBFB(NCS+1) = PG(2,NLSGC(M+MCS))
          SBFB(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFB(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFB(NCS+4) = PVW(2,NLSGC(M+MCS))
          SBFB(NCS+5) = SG(2,NLSGC(M+MCS))
          SBFB(NCS+6) = SGT(2,NLSGC(M+MCS))
          SBFB(NCS+7) = SL(2,NLSGC(M+MCS))
          SBFB(NCS+8) = T(2,NLSGC(M+MCS))
          SBFB(NCS+9) = TMS(2,NLSGC(M+MCS))
          SBFB(NCS+10) = XMLA(2,NLSGC(M+MCS))
          SBFB(NCS+11) = XLS(2,NLSGC(M+MCS))
          SBFB(NCS+12) = YLS(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(1,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(1,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFB,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Bottom Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending bottom ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(6,ID+1)*NPVX
        IDSNDX = NPGC(6,ID+1) - 1
        NRCVX = NCGC(1,IDSNDX+1)*NPVX
        IDRCVX = NPGC(1,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Bottom Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFB,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Bottom Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,5
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(6,ID+1)
          PG(2,NLRGC(M+MCR)) = RBFB(NCR+1)
          PL(2,NLRGC(M+MCR)) = RBFB(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFB(NCR+3)
          PVW(2,NLRGC(M+MCR)) = RBFB(NCR+4)
          SG(2,NLRGC(M+MCR)) = RBFB(NCR+5)
          SGT(2,NLRGC(M+MCR)) = RBFB(NCR+6)
          SL(2,NLRGC(M+MCR)) = RBFB(NCR+7)
          T(2,NLRGC(M+MCR)) = RBFB(NCR+8)
          TMS(2,NLRGC(M+MCR)) = RBFB(NCR+9)
          XMLA(2,NLRGC(M+MCR)) = RBFB(NCR+10)
          XLS(2,NLRGC(M+MCR)) = RBFB(NCR+11)
          YLS(2,NLRGC(M+MCR)) = RBFB(NCR+12)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for south ghost cells for processors
!     with south ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
        MCS = NCGC(1,ID+1)
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(2,ID+1)
          SBFS(NCS+1) = PG(2,NLSGC(M+MCS))
          SBFS(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFS(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFS(NCS+4) = PVW(2,NLSGC(M+MCS))
          SBFS(NCS+5) = SG(2,NLSGC(M+MCS))
          SBFS(NCS+6) = SGT(2,NLSGC(M+MCS))
          SBFS(NCS+7) = SL(2,NLSGC(M+MCS))
          SBFS(NCS+8) = T(2,NLSGC(M+MCS))
          SBFS(NCS+9) = TMS(2,NLSGC(M+MCS))
          SBFS(NCS+10) = XMLA(2,NLSGC(M+MCS))
          SBFS(NCS+11) = XLS(2,NLSGC(M+MCS))
          SBFS(NCS+12) = YLS(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(2,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(2,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFS,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post South Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending south ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(5,ID+1)*NPVX
        IDSNDX = NPGC(5,ID+1) - 1
        NRCVX = NCGC(2,IDSNDX+1)*NPVX
        IDRCVX = NPGC(2,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'South Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFS,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post South Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,4
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(5,ID+1)
          PG(2,NLRGC(M+MCR)) = RBFS(NCR+1)
          PL(2,NLRGC(M+MCR)) = RBFS(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFS(NCR+3)
          PVW(2,NLRGC(M+MCR)) = RBFS(NCR+4)
          SG(2,NLRGC(M+MCR)) = RBFS(NCR+5)
          SGT(2,NLRGC(M+MCR)) = RBFS(NCR+6)
          SL(2,NLRGC(M+MCR)) = RBFS(NCR+7)
          T(2,NLRGC(M+MCR)) = RBFS(NCR+8)
          TMS(2,NLRGC(M+MCR)) = RBFS(NCR+9)
          XMLA(2,NLRGC(M+MCR)) = RBFS(NCR+10)
          XLS(2,NLRGC(M+MCR)) = RBFS(NCR+11)
          YLS(2,NLRGC(M+MCR)) = RBFS(NCR+12)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for west ghost cells for processors
!     with west ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,2
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(3,ID+1)
!          IF( ID.EQ.2 )
!     &      PRINT *,'S2: ND(',NLSGC(M+MCS),') = ',ND(NLSGC(M+MCS))
          SBFW(NCS+1) = PG(2,NLSGC(M+MCS))
          SBFW(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFW(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFW(NCS+4) = PVW(2,NLSGC(M+MCS))
          SBFW(NCS+5) = SG(2,NLSGC(M+MCS))
          SBFW(NCS+6) = SGT(2,NLSGC(M+MCS))
          SBFW(NCS+7) = SL(2,NLSGC(M+MCS))
          SBFW(NCS+8) = T(2,NLSGC(M+MCS))
          SBFW(NCS+9) = TMS(2,NLSGC(M+MCS))
          SBFW(NCS+10) = XMLA(2,NLSGC(M+MCS))
          SBFW(NCS+11) = XLS(2,NLSGC(M+MCS))
          SBFW(NCS+12) = YLS(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(3,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(3,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFW,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post West Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending west ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(4,ID+1)*NPVX
        IDSNDX = NPGC(4,ID+1) - 1
        NRCVX = NCGC(3,IDSNDX+1)*NPVX
        IDRCVX = NPGC(3,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'West Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFW,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post West Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,3
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(4,ID+1)
!          IF( ID.EQ.1 )
!     &      PRINT *,'R1: ND(',NLSGC(M+MCR),') = ',ND(NLSGC(M+MCR))
          PG(2,NLRGC(M+MCR)) = RBFW(NCR+1)
          PL(2,NLRGC(M+MCR)) = RBFW(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFW(NCR+3)
          PVW(2,NLRGC(M+MCR)) = RBFW(NCR+4)
          SG(2,NLRGC(M+MCR)) = RBFW(NCR+5)
          SGT(2,NLRGC(M+MCR)) = RBFW(NCR+6)
          SL(2,NLRGC(M+MCR)) = RBFW(NCR+7)
          T(2,NLRGC(M+MCR)) = RBFW(NCR+8)
          TMS(2,NLRGC(M+MCR)) = RBFW(NCR+9)
          XMLA(2,NLRGC(M+MCR)) = RBFW(NCR+10)
          XLS(2,NLRGC(M+MCR)) = RBFW(NCR+11)
          YLS(2,NLRGC(M+MCR)) = RBFW(NCR+12)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for east ghost cells for processors
!     with east ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(4,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,3
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(4,ID+1) = ',NCGC(4,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(4,ID+1)
          SBFE(NCS+1) = PG(2,NLSGC(M+MCS))
          SBFE(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFE(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFE(NCS+4) = PVW(2,NLSGC(M+MCS))
          SBFE(NCS+5) = SG(2,NLSGC(M+MCS))
          SBFE(NCS+6) = SGT(2,NLSGC(M+MCS))
          SBFE(NCS+7) = SL(2,NLSGC(M+MCS))
          SBFE(NCS+8) = T(2,NLSGC(M+MCS))
          SBFE(NCS+9) = TMS(2,NLSGC(M+MCS))
          SBFE(NCS+10) = XMLA(2,NLSGC(M+MCS))
          SBFE(NCS+11) = XLS(2,NLSGC(M+MCS))
          SBFE(NCS+12) = YLS(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(4,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(4,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFE,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post East Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending east ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(3,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(3,ID+1)*NPVX
        IDSNDX = NPGC(3,ID+1) - 1
        NRCVX = NCGC(4,IDSNDX+1)*NPVX
        IDRCVX = NPGC(4,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'East Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFE,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post East Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
        DO M = 1,2
          MCR = MCR + NCGC(M,ID+1)
        ENDDO
!        PRINT *,' MCR = ',MCR,' NCGC(3,ID+1) = ',NCGC(3,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(3,ID+1)
          PG(2,NLRGC(M+MCR)) = RBFE(NCR+1)
          PL(2,NLRGC(M+MCR)) = RBFE(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFE(NCR+3)
          PVW(2,NLRGC(M+MCR)) = RBFE(NCR+4)
          SG(2,NLRGC(M+MCR)) = RBFE(NCR+5)
          SGT(2,NLRGC(M+MCR)) = RBFE(NCR+6)
          SL(2,NLRGC(M+MCR)) = RBFE(NCR+7)
          T(2,NLRGC(M+MCR)) = RBFE(NCR+8)
          TMS(2,NLRGC(M+MCR)) = RBFE(NCR+9)
          XMLA(2,NLRGC(M+MCR)) = RBFE(NCR+10)
          XLS(2,NLRGC(M+MCR)) = RBFE(NCR+11)
          YLS(2,NLRGC(M+MCR)) = RBFE(NCR+12)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for north ghost cells for processors
!     with north ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(5,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,4
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(5,ID+1) = ',NCGC(5,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(5,ID+1)
          SBFN(NCS+1) = PG(2,NLSGC(M+MCS))
          SBFN(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFN(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFN(NCS+4) = PVW(2,NLSGC(M+MCS))
          SBFN(NCS+5) = SG(2,NLSGC(M+MCS))
          SBFN(NCS+6) = SGT(2,NLSGC(M+MCS))
          SBFN(NCS+7) = SL(2,NLSGC(M+MCS))
          SBFN(NCS+8) = T(2,NLSGC(M+MCS))
          SBFN(NCS+9) = TMS(2,NLSGC(M+MCS))
          SBFN(NCS+10) = XMLA(2,NLSGC(M+MCS))
          SBFN(NCS+11) = XLS(2,NLSGC(M+MCS))
          SBFN(NCS+12) = YLS(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(5,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(5,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFN,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post North Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending north ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(2,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(2,ID+1)*NPVX
        IDSNDX = NPGC(2,ID+1) - 1
        NRCVX = NCGC(5,IDSNDX+1)*NPVX
        IDRCVX = NPGC(5,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'North Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFN,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post North Receive: IERR = ',IERR,' ID = ',ID
        MCR = NCGC(1,ID+1)
!        PRINT *,' MCR = ',MCR,' NCGC(2,ID+1) = ',NCGC(2,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(2,ID+1)
          PG(2,NLRGC(M+MCR)) = RBFN(NCR+1)
          PL(2,NLRGC(M+MCR)) = RBFN(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFN(NCR+3)
          PVW(2,NLRGC(M+MCR)) = RBFN(NCR+4)
          SG(2,NLRGC(M+MCR)) = RBFN(NCR+5)
          SGT(2,NLRGC(M+MCR)) = RBFN(NCR+6)
          SL(2,NLRGC(M+MCR)) = RBFN(NCR+7)
          T(2,NLRGC(M+MCR)) = RBFN(NCR+8)
          TMS(2,NLRGC(M+MCR)) = RBFN(NCR+9)
          XMLA(2,NLRGC(M+MCR)) = RBFN(NCR+10)
          XLS(2,NLRGC(M+MCR)) = RBFN(NCR+11)
          YLS(2,NLRGC(M+MCR)) = RBFN(NCR+12)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Load sending buffer for top ghost cells for processors
!     with top ghost cells, and send buffer to receiving
!     processors  ---
!
      IF( NCGC(6,ID+1).GT.0 ) THEN
        MCS = 0
        DO M = 1,5
          MCS = MCS + NCGC(M,ID+1)
        ENDDO
        NCS = 0
!        PRINT *,' MCS = ',MCS,' NCGC(6,ID+1) = ',NCGC(6,ID+1),
!     &    ' ID = ',ID
        DO M = 1,NCGC(6,ID+1)
          SBFT(NCS+1) = PG(2,NLSGC(M+MCS))
          SBFT(NCS+2) = PL(2,NLSGC(M+MCS))
          SBFT(NCS+3) = PVA(2,NLSGC(M+MCS))
          SBFT(NCS+4) = PVW(2,NLSGC(M+MCS))
          SBFT(NCS+5) = SG(2,NLSGC(M+MCS))
          SBFT(NCS+6) = SGT(2,NLSGC(M+MCS))
          SBFT(NCS+7) = SL(2,NLSGC(M+MCS))
          SBFT(NCS+8) = T(2,NLSGC(M+MCS))
          SBFT(NCS+9) = TMS(2,NLSGC(M+MCS))
          SBFT(NCS+10) = XMLA(2,NLSGC(M+MCS))
          SBFT(NCS+11) = XLS(2,NLSGC(M+MCS))
          SBFT(NCS+12) = YLS(2,NLSGC(M+MCS))
          NCS = NCS + NPVX
        ENDDO
        NSNDX = NCGC(6,ID+1)*NPVX
        IDSNDX = ID
        IDRCVX = NPGC(6,ID+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Send: NSNDX = ',NSNDX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_SEND( SBFT,NSNDX,MPI_REAL8,IDRCVX,ITAGX,
     &    MPI_COMM_WORLD,IERR )
!        PRINT *,'Post Top Send: IERR = ',IERR,' ID = ',ID
      ENDIF
!
!---  Receive buffer from processors sending top ghost cells,
!     and unload receiving buffer  ---
!
      IF( NCGC(1,ID+1).GT.0 ) THEN
!        NRCVX = NCGC(1,ID+1)*NPVX
        IDSNDX = NPGC(1,ID+1) - 1
        NRCVX = NCGC(6,IDSNDX+1)*NPVX
        IDRCVX = NPGC(6,IDSNDX+1) - 1
        ITAGX = ITAG(IDSNDX+1,IDRCVX+1)
!        PRINT *,'Top Receive: NRCVX = ',NRCVX,' IDRCVX = ',IDRCVX,
!     &    ' IDSNDX = ',IDSNDX,' ITAGX = ',ITAGX,' ID = ',ID
        CALL MPI_RECV( RBFT,NRCVX,MPI_REAL8,IDSNDX,ITAGX,
     &    MPI_COMM_WORLD,STATUS,IERR )
!        PRINT *,'Post Top Receive: IERR = ',IERR,' ID = ',ID
        MCR = 0
!        PRINT *,' MCR = ',MCR,' NCGC(1,ID+1) = ',NCGC(1,ID+1),
!     &    ' ID = ',ID
        NCR = 0
        DO M = 1,NCGC(1,ID+1)
          PG(2,NLRGC(M+MCR)) = RBFT(NCR+1)
          PL(2,NLRGC(M+MCR)) = RBFT(NCR+2)
          PVA(2,NLRGC(M+MCR)) = RBFT(NCR+3)
          PVW(2,NLRGC(M+MCR)) = RBFT(NCR+4)
          SG(2,NLRGC(M+MCR)) = RBFT(NCR+5)
          SGT(2,NLRGC(M+MCR)) = RBFT(NCR+6)
          SL(2,NLRGC(M+MCR)) = RBFT(NCR+7)
          T(2,NLRGC(M+MCR)) = RBFT(NCR+8)
          TMS(2,NLRGC(M+MCR)) = RBFT(NCR+9)
          XMLA(2,NLRGC(M+MCR)) = RBFT(NCR+10)
          XLS(2,NLRGC(M+MCR)) = RBFT(NCR+11)
          YLS(2,NLRGC(M+MCR)) = RBFT(NCR+12)
          NCR = NCR + NPVX
        ENDDO
      ENDIF
!
!---  Reset subroutine string sequence  ---
!
      ISUB_LOG = ISUB_LOG-1
!
!---  End of UPDT_GC_GT group
!
      RETURN
      END


